{"version":3,"sources":["webpack://QHSenseMeetJS/webpack/universalModuleDefinition","webpack://QHSenseMeetJS/webpack/bootstrap","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/xmpp/XMPPEvents.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/strophe.js/strophe.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseConferenceEvents.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/browser/index.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/qhsense-meet-logger/lib/index.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/statistics/statistics.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/SDPUtil.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/RTC/RTCEvents.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/statistics/AnalyticsEvents.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/RTC/MediaType.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/RTC/RTCUtils.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/util/GlobalOnErrorHandler.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseTrackErrors.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/RTC/RTC.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/RTC/VideoType.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseTrackError.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseTrackEvents.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseConferenceErrors.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/SDP.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/js-utils/browser-detection/browsers.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/js-utils/browser-detection/BrowserDetection.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/js-utils/index.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/videosipgw/VideoSIPGWConstants.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseConnectionEvents.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/sdp-transform/lib/index.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/statistics/Events.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/util/Listenable.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/settings/Settings.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/SdpTransformUtil.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/proxyconnection/constants.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/events/events.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/RTC/Resolutions.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/JingleSessionState.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/statistics/CallStats.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/connectivity/ConnectionQualityEvents.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/util/RandomUtil.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/ConnectionPlugin.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/xmpp.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseConnectionErrors.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/RTC/SignalingEvents.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/webrtc-adapter/src/js/utils.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/RTC/CameraFacingMode.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/RTC/ScreenObtainer.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/connectivity/ParticipantConnectionStatus.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/recording/recordingXMLUtils.js","webpack://QHSenseMeetJS/(webpack)/buildin/global.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/JingleSessionPC.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseMediaDevicesEvents.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/bowser/src/bowser.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/SDPDiffer.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/process/browser.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/e2eping/E2ePingEvents.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/statistics/LocalStatsCollector.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/util/ScriptUtil.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseTranscriptionStatus.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/RTC/QHSenseTrack.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/util/MathUtil.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/statistics/SpeakerStats.js","webpack://QHSenseMeetJS/(webpack)/buildin/module.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/authentication/AuthenticationEvents.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/RTC/QHSenseLocalTrack.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/recording/JibriSession.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseMediaDevices.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/qhsense-meet-logger/lib/Logger.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/sdp/sdp.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/sdp-transform/lib/grammar.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/transcription/audioRecorder.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/util/AuthUtil.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseConnection.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseConference.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/lodash.isequal/index.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseConferenceEventManager.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/util/EventEmitterForwarder.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/statistics/AnalyticsAdapter.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/browser/BrowserCapabilities.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/js-md5/src/md5.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/util/UsernameGenerator.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/statistics/RTPStatsCollector.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseParticipant.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/authenticateAndUpgradeRole.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/strophe.emuc.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/ChatRoom.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/moderator.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/strophe.jingle.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/util/StringUtils.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/JingleSession.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/SignalingLayerImpl.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/RTC/SignalingLayer.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/util/AsyncQueue.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/async/lib/async.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/strophe.util.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/strophe.ping.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/strophe.rayo.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/strophe.logger.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/StropheBoshLastSuccess.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/Caps.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/DTMF/QHSenseDTMFManager.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/P2PDominantSpeakerDetection.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/RTC/BridgeChannel.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/RTC/TraceablePeerConnection.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/RTC/QHSenseRemoteTrack.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/RTC/LocalSdpMunger.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/RtxModifier.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/xmpp/SdpConsistency.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/TalkMutedDetection.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/connectivity/ConnectionQuality.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/connectivity/IceFailedNotification.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/e2eping/e2eping.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/event/Jvb121EventGenerator.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/recording/RecordingManager.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/rttmonitor/rttmonitor.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/statistics/AvgRTPStatsReporter.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/statistics/SpeakerStatsCollector.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/transcription/transcriber.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/version/ComponentsVersions.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/videosipgw/VideoSIPGW.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/videosipgw/QHSenseVideoSIPGWSession.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/recording/recordingConstants.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/proxyconnection/ProxyConnectionService.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/proxyconnection/ProxyConnectionPC.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/index.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/QHSenseMeetJS.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/qhsense-meet-logger/lib/LogCollector.js","webpack://QHSenseMeetJS/(webpack)/buildin/amd-define.js","webpack://QHSenseMeetJS/(webpack)/buildin/amd-options.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/current-executing-script/dist/currentExecutingScript.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/service/statistics/constants.js","webpack://QHSenseMeetJS/../src/strophe.disco.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/timers-browserify/main.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/setimmediate/setImmediate.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/webrtc-adapter/src/js/adapter_core.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/webrtc-adapter/src/js/adapter_factory.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/webrtc-adapter/src/js/chrome/getusermedia.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/webrtc-adapter/src/js/edge/edge_shim.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/rtcpeerconnection-shim/rtcpeerconnection.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/webrtc-adapter/src/js/edge/getusermedia.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/webrtc-adapter/src/js/firefox/getusermedia.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/webrtc-adapter/src/js/safari/safari_shim.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/webrtc-adapter/src/js/common_shim.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/sdp-transform/lib/parser.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/sdp-transform/lib/writer.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/@qhsense/sdp-interop/lib/index.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/@qhsense/sdp-interop/lib/interop.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/@qhsense/sdp-interop/lib/transform.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/@qhsense/sdp-interop/lib/array-equals.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/@qhsense/sdp-simulcast/lib/index.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/node_modules/@qhsense/sdp-simulcast/lib/transform-utils.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/transcription/recordingResult.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/transcription/transcriptionServices/SphinxTranscriptionService.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/transcription/transcriptionServices/AbstractTranscriptionService.js","webpack://QHSenseMeetJS/D:/blueshark/qhmeet/libs/lib-qhsense-meet/modules/transcription/word.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ADD_ICE_CANDIDATE_FAILED","AUDIO_MUTED_BY_FOCUS","AUTHENTICATION_REQUIRED","BRIDGE_DOWN","CALL_ACCEPTED","CALL_INCOMING","CALL_ENDED","CHAT_ERROR_RECEIVED","CONFERENCE_PROPERTIES_CHANGED","CONNECTION_ESTABLISHED","CONNECTION_FAILED","CONNECTION_INTERRUPTED","CONNECTION_RESTORED","CONNECTION_ICE_FAILED","CONNECTION_STATUS_CHANGED","DISPLAY_NAME_CHANGED","EMUC_ROOM_ADDED","EMUC_ROOM_REMOVED","ETHERPAD","FOCUS_DISCONNECTED","FOCUS_LEFT","GRACEFUL_SHUTDOWN","ICE_RESTARTING","ICE_RESTART_SUCCESS","KICKED","LOCAL_ROLE_CHANGED","MESSAGE_RECEIVED","PRIVATE_MESSAGE_RECEIVED","MUC_MEMBER_BOT_TYPE_CHANGED","MUC_DESTROYED","MUC_JOINED","MUC_MEMBER_JOINED","MUC_MEMBER_LEFT","MUC_LEFT","MUC_ROLE_CHANGED","MUC_LOCK_CHANGED","PARTICIPANT_AUDIO_MUTED","PARTICIPANT_VIDEO_MUTED","PARTICIPANT_VIDEO_TYPE_CHANGED","PARTCIPANT_FEATURES_CHANGED","PASSWORD_REQUIRED","PEERCONNECTION_READY","PHONE_NUMBER_CHANGED","PRESENCE_RECEIVED","PRESENCE_STATUS","PROMPT_FOR_LOGIN","READY_TO_JOIN","RECORDER_STATE_CHANGED","REMOTE_STATS","RENEGOTIATION_FAILED","RESERVATION_ERROR","ROOM_CONNECT_ERROR","ROOM_CONNECT_NOT_ALLOWED_ERROR","ROOM_JOIN_ERROR","ROOM_MAX_USERS_ERROR","SENDING_CHAT_MESSAGE","SENDING_PRIVATE_CHAT_MESSAGE","SESSION_ACCEPT_TIMEOUT","SPEAKER_STATS_RECEIVED","START_MUTED_FROM_FOCUS","SUBJECT_CHANGED","SUSPEND_DETECTED","TRANSCRIPTION_STATUS_CHANGED","TRANSPORT_INFO","VIDEO_SIP_GW_AVAILABILITY_CHANGED","VIDEO_SIP_GW_SESSION_STATE_CHANGED","ICE_CONNECTION_STATE_CHANGED","JSON_MESSAGE_RECEIVED","requirejs","require","undef","main","req","makeMap","handlers","defined","waiting","config","defining","hasOwn","aps","slice","jsSuffixRegExp","hasProp","obj","prop","normalize","baseName","nameParts","nameSegment","mapValue","foundMap","lastIndex","foundI","foundStarMap","starI","j","part","baseParts","split","map","starMap","length","nodeIdCompat","test","replace","charAt","concat","splice","join","makeRequire","relName","forceSync","args","arguments","push","apply","makeLoad","depName","callDep","Error","splitPrefix","prefix","index","indexOf","substring","makeRelParts","makeConfig","relParts","plugin","parts","relResourceName","f","pr","e","id","uri","deps","callback","cjsModule","ret","usingExports","callbackType","load","undefined","alt","setTimeout","cfg","_defined","jQuery","this","Function","func","_slice","Array","_concat","_args","isArray","arg","toString","elt","len","from","Number","Math","ceil","floor","forEach","thisArg","T","k","TypeError","O","kValue","keyStr","btoa","input","chr1","chr2","chr3","enc1","enc2","enc3","enc4","output","charCodeAt","isNaN","atob","String","fromCharCode","SHA1","core_sha1","x","olda","oldb","oldc","oldd","olde","w","a","b","rol","safe_add","sha1_ft","sha1_kt","core_hmac_sha1","data","bkey","str2binb","ipad","opad","hash","y","lsw","num","cnt","str","bin","binb2str","binb2b64","binarray","triplet","b64_hmac_sha1","b64_sha1","str_hmac_sha1","str_sha1","MD5","str2binl","md5_cmn","q","md5_ff","md5_gg","md5_hh","md5_ii","core_md5","hexdigest","binl2hex","binl2str","stropheUtils","utf16to8","out","addCookies","cookies","cookieName","cookieObj","isObj","cookieValue","expires","domain","path","escape","unescape","document","cookie","Strophe","$build","$iq","$msg","$pres","utils","attrs","Builder","VERSION","NS","HTTPBIND","BOSH","CLIENT","AUTH","ROSTER","PROFILE","DISCO_INFO","DISCO_ITEMS","MUC","SASL","STREAM","FRAMING","BIND","SESSION","STANZAS","XHTML_IM","XHTML","tags","attributes","css","validTag","tag","validAttribute","attribute","validCSS","style","Status","ERROR","CONNECTING","CONNFAIL","AUTHENTICATING","AUTHFAIL","CONNECTED","DISCONNECTED","DISCONNECTING","ATTACHED","REDIRECT","CONNTIMEOUT","ErrorCondition","BAD_FORMAT","CONFLICT","MISSING_JID_NODE","NO_AUTH_MECH","UNKNOWN_REASON","LogLevel","DEBUG","INFO","WARN","FATAL","ElementType","NORMAL","TEXT","CDATA","FRAGMENT","TIMEOUT","SECONDARY_TIMEOUT","addNamespace","forEachChild","elem","elemName","childNode","childNodes","nodeType","isTagEqual","el","tagName","_xmlGenerator","_makeGenerator","doc","implementation","createDocument","documentMode","_getIEXmlDom","appendChild","createElement","xmlGenerator","docStrings","ActiveXObject","xmlElement","node","xmlTextNode","sort","attr","setAttribute","xmlescape","text","xmlunescape","createTextNode","xmlHtmlNode","html","DOMParser","parseFromString","async","loadXML","getText","nodeValue","copyElement","nodeName","createHtml","cssAttrs","cssName","cssValue","toLowerCase","getAttribute","cssText","createDocumentFragment","escapeNode","unescapeNode","getNodeFromJid","jid","getDomainFromJid","bare","getBareJidFromJid","getResourceFromJid","_handleError","stack","fatal","sourceURL","handler","line","message","fileName","lineNumber","log","level","msg","console","error","debug","info","warn","serialize","result","tree","child","_requestId","_connectionPlugins","addConnectionPlugin","ptype","xmlns","nodeTree","up","parentNode","moreattrs","removeAttribute","cnode","impNode","xmlGen","importNode","newElem","h","fragment","innerHTML","xhtml","Handler","type","options","matchBare","matchBareFromJid","user","getNamespace","elNamespace","ignoreNamespaceFragment","namespaceMatch","nsMatch","that","isMatch","elem_type","run","TimedHandler","period","lastCalled","Date","getTime","reset","Connection","service","proto","protocol","_proto","Websocket","Bosh","features","_sasl_data","do_session","do_bind","timedHandlers","removeTimeds","removeHandlers","addTimeds","addHandlers","protocolErrorHandlers","_idleTimeout","_disconnectTimeout","authenticated","connected","disconnecting","do_authentication","paused","restored","_data","_uniqueId","_sasl_success_handler","_sasl_failure_handler","_sasl_challenge_handler","maxRetries","_onIdle","registerSASLMechanisms","mechanisms","F","init","_reset","_requests","pause","resume","getUniqueId","suffix","uuid","random","addProtocolErrorHandler","status_code","connect","pass","wait","hold","route","authcid","authzid","servtype","connect_callback","_changeConnectStatus","_connect","attach","sid","rid","wind","_attach","restore","_sessionCachingSupported","_restore","JSON","sessionStorage","setItem","removeItem","xmlInput","xmlOutput","rawInput","rawOutput","nextValidRid","send","_queueData","_send","flush","clearTimeout","sendPresence","errback","timeout","timeoutHandler","addHandler","stanza","deleteTimedHandler","addTimedHandler","deleteHandler","sendIQ","iqtype","element","_sendRestart","thand","handRef","hand","SASLAnonymous","SASLExternal","SASLMD5","SASLOAuthBearer","SASLXOAuth2","SASLPlain","SASLSHA1","registerSASLMechanism","mechanism","disconnect","reason","pres","_addSysTimedHandler","_onDisconnectTimeout","_disconnect","_abortAllRequests","_doDisconnect","status","condition","statusChanged","err","_dataRecv","raw","_reqToData","strip","pop","_emptyQueue","cond","conflict","getElementsByTagName","UNKOWN_REASON","newList","_connect_cb","_callback","bodyWrap","getElementsByTagNameNS","mech","matched","authenticate","_no_auth_received","sortMechanismsByPriority","higher","swap","priority","_attemptSASLAuth","mechanism_found","_addSysHandler","_sasl_success_cb","_sasl_failure_cb","_sasl_challenge_cb","_sasl_mechanism","onStart","request_auth_exchange","isClientFirst","response","onChallenge","_attemptLegacyAuth","_auth1_cb","challenge","iq","_auth2_cb","serverSignature","matches","match","onSuccess","streamfeature_handlers","wrapper","_sasl_auth1_cb","_sasl_bind_cb","resource","jidNode","_sasl_session_cb","onFailure","now","SASLMechanism","connection","_connection","auth_str","test_cnonce","cnonce","nonce","salt","iter","Hi","U","U_old","clientKey","serverKey","clientSignature","responseText","authMessage","attribMatch","substr","_quote","realm","host","digest_uri","cred","A1","A2","core","Request","sends","xmlData","origFunc","date","NaN","abort","dead","age","timeDead","xhr","_newXHR","getResponse","responseXML","documentElement","querySelector","textContent","XMLHttpRequest","overrideMimeType","onreadystatechange","_conn","errors","inactivity","lastResponseHeaders","_buildBody","keepalive","_cacheSession","body","to","content","ver","_onRequestStateChange","_throttledRequestHandler","session","parse","getItem","stringify","typ","parseInt","_sendTerminate","_callProtocolErrorHandlers","err_callback","reqStatus","_getRequestStatus","HTTP","_hitError","time_elapsed","def","readyState","getAllResponseHeaders","valid_request","too_many_retries","_removeRequest","reqIs0","_restartRequest","_processRequest","self","primaryTimeout","secondaryTimeout","requestCompletedWithServerError","contentType","open","sync","setRequestHeader","withCredentials","e2","sendFunc","customHeaders","headers","header","backoff","min","pow","abs","new_service","location","pathname","_buildStream","_check_streamerror","connectstatus","errorString","_closeSocket","socket","WebSocket","onopen","_onOpen","onerror","_onError","onclose","_onClose","onmessage","_connect_cb_wrapper","_handleStreamStart","streamStart","parsedMessage","see_uri","string","_streamWrap","_onMessage","CLOSED","close","closeString","code","rawStanza","search","firstChild","start","startString","AUTH_STATUS_CHANGED","AVATAR_CHANGED","BEFORE_STATISTICS_DISPOSED","CONFERENCE_ERROR","CONFERENCE_FAILED","CONFERENCE_JOINED","CONFERENCE_LEFT","DATA_CHANNEL_OPENED","DOMINANT_SPEAKER_CHANGED","DTMF_SUPPORT_CHANGED","ENDPOINT_MESSAGE_RECEIVED","JVB121_STATUS","PARTICIPANT_KICKED","LAST_N_ENDPOINTS_CHANGED","LOCK_STATE_CHANGED","SERVER_REGION_CHANGED","PARTICIPANT_CONN_STATUS_CHANGED","PARTICIPANT_PROPERTY_CHANGED","P2P_STATUS","PROPERTIES_CHANGED","START_MUTED_POLICY_CHANGED","STARTED_MUTED","TALK_WHILE_MUTED","TRACK_ADDED","TRACK_AUDIO_LEVEL_CHANGED","TRACK_MUTE_CHANGED","TRACK_REMOVED","USER_JOINED","USER_LEFT","USER_ROLE_CHANGED","USER_STATUS_CHANGED","BOT_TYPE_CHANGED","BrowserCapabilities","Logger","LogCollector","idLoggers","loggers","curLevel","levels","TRACE","addGlobalTransport","transport","removeGlobalTransport","getLogger","transports","format","logger","setLogLevelById","setLevel","setLogLevel","_instances","__filename","isCallstatsLoaded","_initCallStatsBackend","CallStats","isBackendInitialized","userName","Settings","callStatsUserName","initBackend","callStatsID","callStatsSecret","swapUserNameAndAlias","callStatsAliasName","aliasName","applicationName","getWiFiStatsMethod","confID","Statistics","xmpp","rtpStatsMap","Map","eventEmitter","EventEmitter","callStatsIntegrationEnabled","disableThirdPartyRequests","browser","isReactNative","ScriptUtil","loadScript","customScriptUrl","loadCallStatsAPI","callsStatsInstances","instances","add","audioLevelsEnabled","disableAudioLevels","audioLevelsInterval","analytics","Set","startRemoteStats","peerconnection","stopRemoteStats","rtpStats","RTPStats","set","localStats","startLocalStats","stream","LocalStats","addAudioLevelListener","listener","on","StatisticsEvents","removeAudioLevelListener","removeListener","addBeforeDisposedListener","removeBeforeDisposedListener","addConnectionStatsListener","removeConnectionStatsListener","addByteSentStatsListener","removeByteSentStatsListener","dispose","size","emit","values","callStats","stopCallStats","tpc","keys","tpcId","_stopRemoteStats","removeAllListeners","delete","stopLocalStats","stop","startCallStats","remoteUserID","has","newInstance","_getAllCallStatsInstances","csInstances","statistics","cs","callStatsInstance","sendTerminateEvent","isCallstatsEnabled","sendConnectionResumeOrHoldEvent","isResume","instance","sendResumeOrHoldEvent","sendIceConnectionFailedEvent","sendMuteEvent","muted","sendScreenSharingEvent","ssrc","sendDominantSpeakerEvent","roomJid","sendActiveDeviceListEvent","devicesData","globalSet","associateStreamWithVideoTag","isLocal","userId","usageLabel","containerId","sendGetUserMediaFailed","QHSenseTrackError","gum","constraintName","constraints","formatQHSenseTrackErrorForCallStats","sendCreateOfferFailed","sendCreateAnswerFailed","sendSetLocalDescFailed","sendSetRemoteDescFailed","sendAddIceCandidateFailed","sendLog","globalSubSet","stats","next","csPerStats","sendApplicationLog","sendFeedback","overall","comment","sendEvent","FEEDBACK","rating","LOCAL_JID","reportGlobalError","sendAnalyticsAndLog","event","eventToLog","properties","sendAnalytics","eventName","SDPUtil","filterSpecialChars","iceparams","mediadesc","sessiondesc","pwd","ufrag","findLine","parseICEUfrag","parseICEPwd","buildICEUfrag","frag","buildICEPwd","parseMID","parseMLine","media","shift","port","fmt","buildMLine","mline","parseRTPMap","clockrate","channels","parseSCTPMap","buildRTPMap","parseCrypto","parseFingerprint","fingerprint","parseFmtp","parseICECandidate","candidate","elems","foundation","component","ip","generation","tcptype","network","buildICECandidate","cand","hasOwnAttribute","parseSSRC","desc","lines","parseRTCPFB","pt","params","parseExtmap","direction","haystack","needle","sessionpart","findLines","needles","candidateToJingle","candidateFromJingle","isFirefox","parsePrimaryVideoSsrc","videoMLine","numSsrcs","ssrcs","ssrcInfo","filter","array","numGroups","ssrcGroups","primarySsrc","fidGroup","find","group","semantics","simGroup","generateSsrc","RandomUtil","randomInt","getSsrcAttribute","mLine","attributeName","ssrcLine","parseGroupSsrcs","ssrcGroup","ssrcStr","getMedia","sdp","getUfrag","ufragLines","startsWith","preferVideoCodec","codecName","payloadType","rtp","codec","payload","payloadTypes","payloads","payloadIndex","unshift","stripVideoCodec","removePts","rtxApts","item","rtxPts","fmtp","keepPts","rtcpFb","CREATE_ANSWER_FAILED","CREATE_OFFER_FAILED","DATA_CHANNEL_OPEN","ENDPOINT_CONN_STATUS_CHANGED","LASTN_ENDPOINT_CHANGED","GRANTED_PERMISSIONS","IS_SELECTED_CHANGED","LASTN_VALUE_CHANGED","LOCAL_TRACK_SSRC_UPDATED","TRACK_ATTACHED","REMOTE_TRACK_ADDED","REMOTE_TRACK_MUTE","REMOTE_TRACK_REMOVED","REMOTE_TRACK_UNMUTE","SET_LOCAL_DESCRIPTION_FAILED","SET_REMOTE_DESCRIPTION_FAILED","AUDIO_OUTPUT_DEVICE_CHANGED","DEVICE_LIST_CHANGED","DEVICE_LIST_WILL_CHANGE","DEVICE_LIST_AVAILABLE","LOCAL_UFRAG_CHANGED","REMOTE_UFRAG_CHANGED","TYPE_OPERATIONAL","TYPE_PAGE","TYPE_TRACK","TYPE_UI","ACTION_JINGLE_RESTART","ACTION_JINGLE_SA_TIMEOUT","ACTION_JINGLE_SI_RECEIVED","ACTION_JINGLE_SI_TIMEOUT","ACTION_JINGLE_TERMINATE","ACTION_JINGLE_TR_RECEIVED","ACTION_JINGLE_TR_SUCCESS","ACTION_P2P_ESTABLISHED","ACTION_P2P_FAILED","ACTION_P2P_SWITCH_TO_JVB","AVAILABLE_DEVICE","CONNECTION_DISCONNECTED","ICE_DURATION","ICE_ESTABLISHMENT_DURATION_DIFF","ICE_STATE_CHANGED","NO_BYTES_SENT","TRACK_UNMUTED","createBridgeDownEvent","action","actionSubject","createConnectionFailedEvent","errorType","errorMessage","details","createConnectionStageReachedEvent","stage","source","createE2eRttEvent","participantId","region","rtt","createFocusLeftEvent","createGetUserMediaEvent","createParticipantConnectionStatusEvent","createJingleEvent","createNoDataFromSourceEvent","mediaType","createP2PEvent","createRemotelyMutedEvent","createRtpStatsEvent","createRttByRegionEvent","createBridgeChannelClosedEvent","createTtfmEvent","AUDIO","VIDEO","usesAdapter","availableDevices","availableDevicesPollTimer","OLD_GUM_DEFAULT_DEVICES","DEFAULT_CONSTRAINTS","video","aspectRatio","height","ideal","max","SS_DEFAULT_FRAME_RATE","audioOutputDeviceId","audioOutputChanged","disableAP","disableAEC","disableNS","disableAGC","disableHPF","featureDetectionAudioEl","isAudioOutputDeviceChangeAvailable","setSinkId","initEnumerateDevicesWithCallback","navigator","mediaDevices","enumerateDevices","then","getConstraints","um","audio","isNewStyleConstraintsSupported","isSafariWithVP8","isEdge","mandatory","optional","cameraDeviceId","deviceId","sourceId","facingMode","CameraFacingMode","USER","minFps","maxFps","fps","minFrameRate","maxFrameRate","resolution","Resolutions","width","minWidth","minHeight","maxWidth","maxHeight","setResolutionConstraints","micDeviceId","echoCancellation","googEchoCancellation","googAutoGainControl","googNoiseSuppression","googHighpassFilter","googNoiseSuppression2","googEchoCancellation2","googAutoGainControl2","isChrome","getSSConstraints","mozMediaSource","mediaSource","frameRate","errmsg","GlobalOnErrorHandler","callErrorHandler","bandwidth","firefox_fake_device","fake","desktopStream","chromeMediaSource","screen","chromeMediaSourceId","getTrackSSConstraints","desktopSharingFrameRate","updateGrantedPermissions","audioTracksReceived","Boolean","getAudioTracks","videoTracksReceived","getVideoTracks","grantedPermissions","RTCEvents","compareAvailableMediaDevices","newDevices","mediaDeviceInfoToJSON","kind","groupId","label","facing","sendDeviceListToAnalytics","deviceList","audioInputDeviceCount","audioOutputDeviceCount","videoInputDeviceCount","videoOutputDeviceCount","device","onMediaDevicesListChanged","devicesReceived","handleLocalStream","streams","audioStream","videoStream","res","audioVideo","audioTracks","MediaStream","addTrack","videoTracks","desktop","sourceType","track","MediaType","videoType","VideoType","DESKTOP","CAMERA","defaultSetVideoSrc","src","srcObjectPropertyName","qhsenseObjectURL","URL","createObjectURL","rtcUtils","clearInterval","usesNewGumFlow","RTCPeerConnectionType","RTCPeerConnection","attachMediaStream","wrapAttachMediaStream","srcObject","getStreamID","getTrackID","isChromiumBased","_initPCConstraints","screenObtainer","getUserMediaWithConstraints","isDeviceListAvailable","ds","updateKnownDevices","pds","supportsDeviceChangeEvent","addEventListener","setInterval","pcConstraints","googHighStartBitrate","googPayloadPadding","googScreencastMinBitrate","googCpuOveruseDetection","googCpuOveruseEncodeUsage","googCpuUnderuseThreshold","googCpuOveruseThreshold","useIPv6","googIPv6","p2pPcConstraints","disableSuspendVideo","googSuspendBelowMinBitrate","Promise","resolve","reject","getUserMedia","catch","umDevices","isSupported","supportsVideo","obtainStream","_parseDesktopSharingOptions","devices","requestingDesktop","includes","_getAudioAndVideoStreams","avStream","missingTracks","_getMissingTracks","stopMediaStream","desktopSharingSourceDevice","requestedDevices","missingDevices","audioDeviceRequested","videoDeviceRequested","desktopSharingExtensionExternalInstallation","desktopSharingSources","gumOptions","trackOptions","mediaStreamsMetaData","maybeRequestDesktopDevice","matchingDevice","exact","_newGetUserMediaWithConstraints","getTracks","applyConstraints","_newGetDesktopMedia","maybeRequestCaptureDevices","requestedCaptureDevices","newGetConstraints","effects","deviceType","mediaStream","release","url","revokeObjectURL","isDeviceChangeAvailable","deviceData","enable","Listenable","origAttachMediaStream","getAudioOutputDevice","ex","callUnhandledRejectionHandler","promise","oldOnErrorHandler","oldOnUnhandledRejection","onunhandledrejection","errHandler","CHROME_EXTENSION_GENERIC_ERROR","CHROME_EXTENSION_INSTALLATION_ERROR","CHROME_EXTENSION_USER_GESTURE_REQUIRED","CHROME_EXTENSION_USER_CANCELED","CONSTRAINT_FAILED","ELECTRON_DESKTOP_PICKER_ERROR","ELECTRON_DESKTOP_PICKER_NOT_FOUND","FIREFOX_EXTENSION_NEEDED","GENERAL","NOT_FOUND","PERMISSION_DENIED","TRACK_IS_DISPOSED","TRACK_NO_STREAM_FOUND","UNSUPPORTED_RESOLUTION","peerConnectionIdCounter","rtcTrackIdCounter","createLocalTracks","tracksInfo","newTracks","trackInfo","safeCounterIncrement","localTrack","QHSenseLocalTrack","rtcId","_newCreateLocalTracks","metaData","getSettings","RTC","conference","peerConnections","localTracks","_channel","_channelOpen","_lastN","_lastNEndpoints","_maxFrameHeight","_pinnedEndpoint","_selectedEndpoints","_lastNChangeListener","_onLastNChanged","_onDeviceListChanged","_updateAudioOutputForAudioTracks","RTCUtils","addListener","newObtainAudioAndVideoPermissions","obtainAudioAndVideoPermissions","eventType","isP2P","elSelector","getCurrentlyAvailableMediaDevices","getEventDataForActiveDevice","setAudioOutputDevice","isUserStreamById","streamId","isDesktopSharingEnabled","_channelOpenListener","wsUrl","BridgeChannel","sendPinnedEndpointMessage","sendSelectedEndpointsMessage","sendReceiverVideoConstraintMessage","_selectedEndpoint","sendSetLastNMessage","lastNEndpoints","oldLastNEndpoints","leavingLastNEndpoints","enteringLastNEndpoints","isInLastN","QHSenseConferenceEvents","maxFrameHeight","ids","signaling","iceConfig","getPCConstraints","abtestSuspendVideo","setSuspendVideo","addPermanentProperties","supportsSdpSemantics","sdpSemantics","newConnection","TraceablePeerConnection","traceablePeerConnection","localVideo","getLocalTracks","localAudio","tracks","getType","remoteTracks","pcRemoteTracks","getRemoteTracks","mutePromises","audioTrack","mute","unmute","all","pos","owner","removedTracks","pcRemovedTracks","removeRemoteTracks","audioLevel","getTrackBySSRC","isAudioTrack","setAudioLevel","sendMessage","remoteAudioTracks","setAudioOutput","TRACK_ERROR_TO_MESSAGE_MAP","QHSenseTrackErrors","constraint","failedConstraintName","getResolutionFromFailedConstraint","constructor","LOCAL_TRACK_STOPPED","TRACK_AUDIO_OUTPUT_CHANGED","TRACK_VIDEOTYPE_CHANGED","NO_DATA_FROM_SOURCE","CHAT_ERROR","CONFERENCE_DESTROYED","CONFERENCE_MAX_USERS","CONNECTION_ERROR","NOT_ALLOWED_ERROR","INCOMPATIBLE_SERVER_VERSIONS","OFFER_ANSWER_FAILED","PASSWORD_NOT_SUPPORTED","SETUP_FAILED","VIDEOBRIDGE_NOT_AVAILABLE","SDP","mediaI","failICE","removeTcpCandidates","removeUdpCandidates","getMediaSsrcMap","tmp","mediaSSRCs","mediaindex","mid","linessrc","idx","containsSSRC","medias","mangle","newdesc","rtpmap","removeSessionLines","removeMediaLines","toJingle","thecreator","assrcline","creator","amidline","afmtpline","rtcpFbToJingle","crypto","required","ssrcMap","availableSsrc","ssrcParameters","ssrcSdpLine","kv","v","ridLines","rids","ridLine","ridInfo","senders","transportToJingle","sctpmap","sctpAttrs","number","setup","payloadtype","rtcpFbFromJingle","each","$","fromJingle","jingle","groups","contents","_","jingle2media","sctp","streamCount","CHROME","OPERA","FIREFOX","INTERNET_EXPLORER","EDGE","SAFARI","NWJS","ELECTRON","REACT_NATIVE","UNKNOWN","bowserNameToQHSenseName","_detectElectron","userAgent","version","_detectNWJS","_detectReactNative","product","_detect","browserInfo","detectors","bowser","chrome","_detectChromiumBased","BrowserDetection","detectedBrowserInfo","_name","_version","compareVersions","compareVersion","STATUS_AVAILABLE","STATUS_UNDEFINED","STATUS_BUSY","STATE_ON","STATE_OFF","STATE_PENDING","STATE_RETRYING","STATE_FAILED","ERROR_NO_CONNECTION","ERROR_SESSION_EXISTS","WRONG_STATE","parser","writer","write","parseFmtpConfig","parseParams","parsePayloads","parseRemoteCandidates","parseImageAttributes","parseSimulcastStreamList","AUDIO_LEVEL","BEFORE_DISPOSED","BYTE_SENT_STATS","CONNECTION_STATS","removeEventListener","off","_callStatsUserName","_machineId","getLocalStorage","storage","localStorage","_p8","username","UsernameGenerator","generateUsername","qhsenseMeetId","sessionId","parsePrimarySSRC","parseSecondarySSRC","_getSSRCCount","MLineWrap","ssrcNumber","attrName","ssrcObj","ssrcNum","primarySSRC","msid","findGroup","fecGroup","findGroupByPrimarySSRC","videoSSRCs","getSSRCs","ssrcGroupInfo","secondarySsrc","groupInfo","oldSSRC","newSSRC","SdpTransformWrap","rawSDP","parsedSDP","transform","selectedMLine","ACTIONS","ACCEPT","INITIATE","TERMINATE","UNAVAILABLE","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","_events","_eventsCount","_maxListeners","defaultMaxListeners","$getMaxListeners","_addListener","prepend","events","existing","warning","newListener","warned","emitter","count","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","_listeners","unwrap","evlistener","arr","unwrapListeners","arrayClone","listenerCount","copy","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","context","listeners","prependListener","once","prependOnceListener","list","position","originalListener","spliceOne","rawListeners","eventNames","order","PENDING","ACTIVE","ENDED","_fabrics","wrtcFuncNames","fabricEvent","DEFAULT_REMOTE_USER","reportType","hasFabric","fabrics","backendInitialized","_addNewFabric","_emptyReportQueue","backend","atLeastOneFabric","defaultInstance","csInstance","defaultConfID","defaultPC","reportsQueue","report","errorData","_reportError","pc","eventData","sendFabricEvent","associateMstWithUserID","callStatsId","_error","reportError","theBackend","methodName","originalMethod","theArguments","originalReportError","exception","configParams","CallStatsBackend","callstats","_traceAndCatchBackendCalls","userID","applicationVersion","getName","siteID","initialize","_initCallback","attachWifiStatsHandler","addresses","_reportEvent","conferenceID","sendUserFeedback","fabricAttributes","remoteEndpointType","endpointType","peer","server","addNewFabric","fabricUsage","multiplex","_addNewFabricCallback","success","streamEndpointId","fabricTerminated","LOCAL_STATS_UPDATED","REMOTE_STATS_UPDATED","ALPHANUM","randomElement","randomHexDigit","randomHexString","randomAlphanumStr","getConnectionPluginDefinition","ConnectionPluginListenable","DEFAULT_STUN_SERVERS","urls","QHSENSE_MEET_MUC_TYPE","XMPP","token","disconnectInProgress","connectionTimes","authenticatedUser","_initStrophePlugins","bosh","conn","createConnection","_lastSuccessTracker","LastSuccessTracker","startTracking","caps","Caps","clientNode","initFeaturesList","ev","addFeature","disableRtx","supportsRtx","enableLipSync","rayo","_pingSupported","credentials","performance","statusStr","getStatusString","XMPPEvents","useStunTurn","p2p","getStunAndTurnCredentials","pingJid","getFeaturesAndIdentities","identities","PING","ping","startInterval","identity","speakerStatsComponentAddress","_onPrivateMessage","password","QHSenseConnectionEvents","anonymousConnectionFailed","connectionFailed","lastErrorMsg","QHSenseConnectionErrors","stopInterval","wasIntentionalDisconnect","errMsg","_getConnectionFailedReasonDetails","lastErrorStatus","getLastErrorStatus","timeSinceLastSuccess","getTimeSinceLastSuccess","connectionHandler","attaching","hosts","anonymousdomain","configDomain","hostname","roomName","onCreateResource","roomjid","muc","mucNickname","emuc","createRoom","getLog","dial","isPingSupported","moderate","setMute","eject","sessions","disconnectListener","evType","jvb","iceServers","p2pStunServers","stunServers","iceTransportPolicy","initEmuc","initJingle","initStropheUtil","initPing","initRayo","initStropheLogger","deploymentInfo","shard","headersArr","trim","shard_changed","suspend_time","getPingSuspendTime","room","jsonString","json","jsonMessage","parsedJson","tryParseJSONAndVerify","users","CONNECTION_DROPPED_ERROR","OTHER_ERROR","SERVER_ERROR","PEER_MUTED_CHANGED","PEER_VIDEO_TYPE_CHANGED","logDisabled_","deprecationWarnings_","disableLog","bool","disableWarnings","deprecated","oldMethod","newMethod","extractVersion","uastring","expr","detectBrowser","mozGetUserMedia","webkitGetUserMedia","webkitRTCPeerConnection","shimCreateObjectURL","ENVIRONMENT","chromeExtInstalled","chromeExtUpdateRequired","gumFunction","ScreenObtainer","intChromeExtPromise","desktopSharingChromeDisabled","desktopSharingChromeExtId","desktopSharingFirefoxDisabled","_createObtainStreamMethod","isNWJS","QHSenseMeetNW","obtainDesktopStream","qhsenseError","isElectron","obtainScreenOnElectron","isOpera","supportsGetDisplayMedia","obtainScreenFromGetDisplayMedia","append","getWebStoreInstallUrl","initInlineInstalls","checkChromeExtInstalled","installed","updateRequired","initChromeExtension","obtainScreenFromExtension","obtainScreenOnFirefox","errorCallback","streamCallback","failCallback","obtainWebRTCScreen","QHSenseMeetScreenObtainer","openDesktopPicker","desktopSharingChromeSources","streamType","onGetStreamResponse","doGetStreamFromExtensionOptions","runtime","getStream","sources","lastError","doGetStreamFromExtension","alert","handleExternalInstall","webStoreInstallUrl","checkForChromeExtensionOnInterval","checkAgain","waitInterval","retries","currentRetries","interval","waitForExtensionAfterInstall","getDisplayMedia","getVersion","extVersion","minVersion","s1","s2","n1","n2","isUpdateRequired","desktopSharingChromeMinExtVersion","DEFAULT_NOT_IN_LAST_N_TIMEOUT","DEFAULT_RTC_MUTE_TIMEOUT","ParticipantConnectionStatus","INACTIVE","INTERRUPTED","RESTORING","ParticipantConnectionStatusHandler","rtc","trackTimers","connStatusFromJvb","outOfLastNTimeout","rtcMuteTimeout","rtcMutedTimestamp","enteredLastNTimestamp","restoringTimers","peerConnStatusMap","isConnectionActiveByJvb","isRestoringTimedout","isVideoMuted","isVideoTrackFrozen","supportsVideoMuteOnConnInterrupted","_onEndpointConnStatusChanged","onEndpointConnStatusChanged","_onP2PStatus","refreshConnectionStatusForAll","_onTrackRtcMuted","onTrackRtcMuted","_onTrackRtcUnmuted","onTrackRtcUnmuted","_onRemoteTrackAdded","onRemoteTrackAdded","_onRemoteTrackRemoved","onRemoteTrackRemoved","_onSignallingMuteChanged","onSignallingMuteChanged","_onLastNValueChanged","clearRtcMutedTimestamp","endpointId","isActive","myUserId","figureOutConnectionStatus","participant","newStatus","getConnectionStatus","getId","_setConnectionStatus","remoteTrack","getParticipantId","QHSenseTrackEvents","hasAnyVideoRTCMuted","hasAnyVideoTrackWebRTCMuted","_getVideoFrozenTimeout","participants","getParticipants","getParticipantById","inP2PMode","isP2PActive","isRestoringTimedOut","_isRestoringTimedout","audioOnlyMode","getLastN","isConnActiveByJvb","newState","_getNewStateForP2PMode","_getNewStateForJvbMode","_clearRestoringTimer","nowMs","internalState","internalStates","startedMs","_changeConnectionStatus","leavingLastN","enteringLastN","rTimer","isMuted","getFocusRecordingUpdate","presence","jibriStatus","recordingMode","sessionID","getHiddenDomainUpdate","liveStreamViewURLContainer","liveStreamViewURL","modeContainer","sessionIDContainer","getSessionIdFromIq","jibri","getSessionId","sessionIdContainer","isFromFocus","g","JingleSessionPC","localJid","remoteJid","mediaConstraints","isInitiator","_bridgeSessionId","_iceCheckingStartedTimestamp","_gatheringStartedTimestamp","_localVideoActive","_remoteVideoActive","_gatheringReported","lasticecandidate","closed","signalingLayer","SignalingLayerImpl","modificationQueue","AsyncQueue","wasConnected","establishmentDuration","jingleContents","videoContents","JingleSessionState","isReconnect","wasstable","webrtcIceUdpDisable","webrtcIceTcpDisable","pcOptions","gatherStats","maxstats","disableSimulcast","disableH264","preferH264","_abtestSuspendVideoEnabled","enableFirefoxSimulcast","testing","enableLayerSuspension","startSilent","createPeerConnection","onicecandidate","phase","initiator","sendIceCandidate","onsignalingstatechange","signalingState","connectionState","oniceconnectionstatechange","iceConnectionState","reconnect","iceStarted","onnegotiationneeded","setChatRoom","isSelected","setIsSelected","finishedCallback","_renegotiate","localSDP","localDescription","ice","sdpMLineIndex","jcand","usedrip","dripContainer","sendIceCandidates","candidates","_assertNotEnded","initiatorJid","cands","sdpMid","fingerprintLine","newJingleErrorHandler","sessionInfo","iceCandidates","rtcCandidate","RTCIceCandidate","iceCandidate","addIceCandidate","outerHTML","ssrcElement","setSSRCOwner","i3","ssrcInfoElement","generateRecvonlySsrc","jingleOffer","failure","setOfferAnswerCycle","sendSessionAccept","createOffer","offerSdp","setLocalDescription","sendSessionInitiate","jingleAnswer","jingleOfferAnswerIq","newRemoteSdp","_processNewJingleOfferIq","oldLocalSdp","bridgeSessionId","sendContentModify","newLocalSdp","notifyMySSRCUpdate","jingleOfferElem","originalOffer","clone","remove","sendTransportAccept","accept","responder","responderJid","videoTransferActive","newSendersValue","sessionModify","transportAccept","medialines","transportReject","sendSessionTerminate","sessionTerminate","reasonDescription","terminate","reasonCondition","reasonText","sourceAddElem","currentRemoteSdp","addSsrcInfo","i1","i2","_addOrRemoveRemoteStream","isAdd","logPrefix","readSsrcInfo","remoteDescription","addOrRemoveSsrcInfo","_parseSsrcInfoFromSourceAdd","_parseSsrcInfoFromSourceRemove","_processRemoteAddSource","_processRemoteRemoveSource","offerIq","remoteSdp","removeSsrcInfo","optionalRemoteSdp","RTCSessionDescription","_initiatorRenegotiate","_responderRenegotiate","setRemoteDescription","createAnswer","answer","offer","oldTrack","newTrack","workFunction","isVideoTrack","clearRecvonlySsrc","replaceTrack","shouldRenegotiate","newLocalSDP","sourceRemoveElem","ssrcLines","operationName","oldSDP","currentLocalSDP","sdpDiff","SDPDiffer","addedMedia","getNewMedia","removedMedia","_addRemoveTrackAsMuteUnmute","isMute","oldLocalSDP","removeTrackMute","addTrackUnmute","_verifyNoSSRCChanged","audioActive","videoActive","logAudioStr","logVideoStr","isSessionActive","audioActiveChanged","setAudioTransferActive","pcVideoActiveChanged","setVideoTransferActive","newVideoSenders","parseVideoSenders","_modifyRemoteVideoActive","remoteVideoSenders","isRemoteVideoActive","newSDP","sdpDiffer","request","failureCb","errResponse","errorElSel","errorReasonSel","errorMsgSel","clear","finishCallback","shutdown","abTesting","enableSuspendVideoTest","_getInitiatorJid","integerHash","JingleSession","PERMISSION_PROMPT_IS_SHOWN","definition","detect","ua","getFirstMatch","regex","getSecondMatch","iosdevice","android","nexusMobile","nexusTablet","chromeos","silk","sailfish","tizen","webos","windowsphone","windows","mac","linux","edgeVersion","versionIdentifier","tablet","mobile","xbox","opera","samsungBrowser","coast","yandexbrowser","ucbrowser","maxthon","epiphany","puffin","sleipnir","kMeleon","osname","msedge","msie","chromeBook","vivaldi","seamonkey","firefox","firefoxos","phantom","slimer","blackberry","touchpad","bada","qupzilla","chromium","safari","googlebot","blink","webkit","gecko","ios","osVersion","getWindowsVersion","osversion","osMajorVersion","getVersionPrecision","iterator","versions","precision","chunks","delta","chunk","reverse","isUnsupportedBrowser","minVersions","strictMode","_bowser","browserList","browserItem","check","arrayEquals","array1","array2","equals","mySDP","otherSDP","myMedias","othersMedias","newMedia","othersMediaIdx","myMedia","othersMedia","otherSsrcGroup","mySsrcGroup","modify","sdpMediaSsrcs","modified","mediaSsrc","nv","cachedSetTimeout","cachedClearTimeout","process","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","marker","runClearTimeout","Item","noop","nextTick","title","env","argv","binding","cwd","chdir","dir","umask","E2E_RTT_CHANGED","AudioContext","webkitAudioContext","LocalStatsCollector","intervalId","intervalMilis","suspend","isLocalStatsSupported","analyser","createAnalyser","smoothingTimeConstant","fftSize","createMediaStreamSource","Uint8Array","frequencyBinCount","getByteTimeDomainData","newLevel","lastLevel","diff","samples","maxVolume","parseFloat","toFixed","timeDomainDataToAudioLevel","currentExecutingScript","relativeURL","loadCallback","script","referenceNode","scriptEl","scriptSrc","baseScriptSrc","lastIndexOf","onload","insertBefore","ON","OFF","trackHandler2Prop","addMediaStreamInactiveHandler","oninactive","QHSenseTrack","streamInactiveHandler","trackMediaType","containers","disposed","_streamInactiveHandler","_setStream","_setHandler","container","_onTrackAttach","_maybeFireTrackAttached","_attachTTFMTracker","active","getStreamId","trackId","getTrackId","nextValue","MAX_SAFE_INTEGER","SpeakerStats","displayName","isLocalStats","_userId","setDisplayName","_isLocalStats","setDominantSpeaker","totalDominantSpeakerTime","_dominantSpeakerStart","_hasLeft","newName","isNowDominantSpeaker","isDominantSpeaker","timeElapsed","total","webpackPolyfill","deprecate","paths","children","IDENTITY_UPDATED","_setEffectInProgress","effect","isEnabled","_startStreamEffect","_constraints","_prevSetMuted","_facingMode","_trackEnded","_hasSentData","_testDataSent","_realDeviceId","_trackMutedTS","_onDeviceListWillChange","oldRealDeviceId","_setRealDeviceIdFromDeviceList","getTrack","_onAudioOutputDeviceChanged","_initNoDataFromSourceHandlers","_isNoDataFromSourceEventsEnabled","_fireNoDataFromSourceEvent","isReceivingData","storedMSID","getMSID","_streamEffect","_originalStream","startEffect","stopEffect","_stopStreamEffect","removeTrack","_switchStreamEffect","cont","_queueSetMuted","setMuted","_setMuted","logMuteInfo","doesVideoMuteByStreamRemove","enabled","_removeStreamFromConferenceAsMute","_unregisterHandlers","stopStream","streamOptions","getDeviceId","getCameraFacingMode","assign","streamsInfo","streamInfo","_addStreamToConferenceAsUnmute","_sendMuteStatus","_addLocalTrackAsUnmute","successCallback","_removeLocalTrackAsMute","detach","bytesSent","getConnectionState","trackSettings","_stopStreamInProgress","_switchCamera","_effectEnabled","some","JibriSession","_mode","_setSessionID","setStatus","_sessionID","_liveStreamViewURL","_status","appData","broadcastId","focusMucJid","_createIQ","recordingXMLUtils","_setErrorFromIq","errorIq","setError","VIDEO_PERMISSION_NAME","QHSenseMediaDevices","_eventEmitter","_grantedPermissions","QHSenseMediaDevicesEvents","_logOutputDevice","_handleGrantedPermissions","_permissionsApiSupported","permissions","query","deviceID","supported","promises","results","every","permissionStatus","consoleTransport","globalTransports","callerInfo","fileLocation","column","getCallerInfo","methods","transportIdx","LOG","SDPUtils","localCName","generateIdentifier","splitLines","blob","splitSections","getDescription","sections","getMediaSections","matchPrefix","parseCandidate","address","relatedAddress","relatedPort","tcpType","usernameFragment","writeCandidate","toUpperCase","parseIceOptions","parseRtpMap","parsed","clockRate","numChannels","writeRtpMap","preferredPayloadType","writeExtmap","headerExtension","preferredId","writeFmtp","parameters","param","parseRtcpFb","parameter","writeRtcpFb","rtcpFeedback","fb","parseSsrcMedia","sp","colon","parseSsrcGroup","getMid","mediaSection","algorithm","getDtlsParameters","role","fingerprints","writeDtlsParameters","setupType","fp","parseCryptoLine","cryptoSuite","keyParams","sessionParams","writeCryptoLine","writeCryptoKeyParams","parseCryptoKeyParams","keyMethod","keySalt","lifeTime","mkiValue","mkiLength","getCryptoParameters","getIceParameters","writeIceParameters","parseRtpParameters","description","codecs","headerExtensions","fecMechanisms","rtcp","rtpmapline","fmtps","writeRtpDescription","maxptime","extension","parseRtpEncodingParameters","encodingParameters","hasRed","hasUlpfec","flows","apt","encParam","codecPayloadType","rtx","fec","maxBitrate","parseRtcpParameters","rtcpParameters","remoteSsrc","cname","rsize","reducedSize","compound","mux","parseMsid","spec","planB","msidParts","parseSctpDescription","maxMessageSize","maxSizeLine","sctpPort","writeSctpDescription","generateSessionId","writeSessionBoilerplate","sessId","sessVer","sessUser","writeMediaSection","transceiver","iceGatherer","getLocalParameters","dtlsTransport","rtpSender","rtpReceiver","sendEncodingParameters","getDirection","getKind","isRejected","parseOLine","sessionVersion","netType","addressType","isValidSDP","grammar","reg","names","u","z","encoding","rate","subtype","sessionConfig","raddr","RegExp","dir2","RecordingResult","AUDIO_WEBM","AUDIO_OGG","TrackRecorder","recorder","startTime","startRecorder","trackRecorder","stopRecorder","determineCorrectFileType","MediaRecorder","isTypeSupported","AudioRecorder","qhsenseConference","recorders","fileType","isRecording","instantiateTrackRecorder","updateNames","originalStream","getOriginalStream","createEmptyStream","mimeType","ondataavailable","dataEvent","recorderToRemove","getDisplayName","download","Blob","href","click","getRecordingResults","getFileType","getTokenAuthUrl","urlPattern","roleUpgrade","QHSenseConnection","appID","errType","ANALYTICS_CONNECTION_DISCONNECTED","getJid","setToken","initQHSenseConference","QHSenseConference","getConnectionTimes","feature","submit","removeFeature","eventManager","QHSenseConferenceEventManager","_init","componentsVersions","ComponentsVersions","jvbJingleSession","lastDominantSpeaker","dtmfManager","somebodySupportsDTMF","authEnabled","startAudioMuted","startVideoMuted","startMutedPolicy","isMutedByFocus","mutedByFocusActor","wasStopped","connectionQuality","ConnectionQuality","avgRtpStatsReporter","AvgRTPStatsReporter","avgRtpStatsN","isJvbConnectionInterrupted","speakerStatsCollector","SpeakerStatsCollector","deferredStartP2PTask","delay","backToP2PDelay","isP2PConnectionInterrupted","p2pJingleSession","videoSIPGWHandler","VideoSIPGW","recordingManager","RecordingManager","resourceCreator","isAuthenticatedUser","setupXMPPListeners","_onIceConnectionInterrupted","_onIceConnectionRestored","_onIceConnectionEstablished","_updateProperties","rttMonitor","RttMonitor","e2eping","E2ePing","setupRTCListeners","participantConnectionStatus","_peerConnStatusRtcMuteTimeout","_peerConnStatusOutOfLastNTimeout","enableDisplayNameInStats","callStatsCustomScriptUrl","enableStatsID","setupChatRoomListeners","setupStatisticsListeners","enableTalkWhileMuted","TalkMutedDetection","setLastN","channelLastN","jvb121Status","Jvb121EventGenerator","p2pDominantSpeakerDetection","P2PDominantSpeakerDetection","userRegion","setLocalParticipantProperty","_maybeSetSITimeout","authenticateAndUpgradeRole","isJoined","joined","isP2PEnabled","isP2PTestModeEnabled","p2pTestMode","leave","onLocalTrackRemoved","closeBridgeChannel","_delayedIceFailed","cancel","removeXMPPListeners","destroy","onMemberLeft","getConnection","isAuthEnabled","isLoggedIn","authIdentity","getAuthLogin","isExternalAuthEnabled","moderator","getExternalAuthUrl","urlForPopup","getPopupLoginUrl","getLoginUrl","getLocalAudioTrack","getLocalVideoTrack","eventId","addCommandListener","command","addPresenceListener","removeCommandListener","removePresenceListener","sendTextMessage","elementName","sendPrivateTextMessage","sendPrivateMessage","sendCommand","addToPresence","sendCommandOnce","removeCommand","removeFromPresence","setSubject","subject","isModerator","getTranscriber","transcriber","Transcriber","localAudioTracks","getTranscriptionStatus","transcriptionStatus","localVideoTrack","_fireAudioLevelChangeEvent","activeTpc","getActivePeerConnection","_fireMuteChangeEvent","actorParticipant","muteParticipant","myroomjid","actorId","_setConference","removeLocalTrack","muteHandler","audioLevelHandler","_doReplaceTrack","_setupNewTrack","replaceTrackPromises","addLocalTrack","setAudioMute","setVideoMute","addAsUnmutePromises","addTrackAsUnmute","removeAsMutePromises","removeTrackAsMute","getRole","isHidden","hiddenDomain","lock","lockRoom","QHSenseConferenceErrors","unlock","selectParticipant","selectParticipants","participantIds","selectEndpoints","pinParticipant","pinEndpoint","lastN","isInteger","isVideoActive","setMediaTransferActive","getParticipantCount","countHidden","kickParticipant","kick","_maybeClearSITimeout","_sessionInitiateTimeout","onMemberJoined","nick","statsID","botType","QHSenseParticipant","_role","_botType","_updateFeatures","_maybeStartOrStopP2P","getFeatures","_supportsDTMF","updateDTMFSupport","setProperty","_onMemberBotTypeChanged","botParticipant","onMemberKicked","isSelfPresence","kickedParticipantId","kickedParticipant","onLocalRoleChanged","onUserRoleChanged","onDisplayNameChanged","_displayName","_tracks","onCallAccepted","setAnswer","onTransportInfo","transportInfo","addIceCandidates","removedTrack","_onIncomingCallP2P","jingleSession","rejectReason","supportsP2P","errorMsg","_rejectIncomingCall","_acceptP2PIncomingCall","onIncomingCall","isFocus","_acceptJvbIncomingCall","serverRegion","_setBridgeChannel","acceptOffer","_suspendMediaTransferForJvbConnection","bridgeChannelType","webSocket","first","openBridgeChannel","supportsDataChannels","initializeBridgeChannel","onCallEnded","forceJvb121","p2pFailed","_stopP2PSession","onSuspendDetected","supportsDTMF","isDTMFSupported","sendTones","tones","duration","peerConnection","QHSenseDTMFManager","startRecording","stopRecording","isSIPCallingSupported","hangup","startTranscriber","stopTranscriber","getPhoneNumber","getPhonePin","setStartMutedPolicy","policy","getStartMutedPolicy","isStartAudioMuted","isStartVideoMuted","getLogs","getJingleLog","metadata","time","getXmppLog","removeLocalParticipantProperty","getLocalParticipantProperty","presMap","nodes","overallFeedback","detailedFeedback","remoteUserId","getLocalSSRC","getSSRC","getUsageLabel","_isFocus","mucJid","_fireIncompatibleVersionsEvent","sendEndpointMessage","sendChannelMessage","broadcastEndpointMessage","sendThroughVideobridge","messageType","messageToSend","isConnectionInterrupted","_onIceConnectionFailed","IceFailedNotification","sendIceFailedNotification","remoteID","getStatsID","_addRemoteJVBTracks","_addRemoteTracks","_addRemoteP2PTracks","logName","p2pEstablishmentDuration","jvbEstablishmentDuration","done","forceJVB121Ratio","establishmentDurationDiff","_setP2PStatus","_removeRemoteJVBTracks","changed","isEqual","analyticsKeys","getProperty","_maybeClearDeferredStartP2P","_removeRemoteTracks","_removeRemoteP2PTracks","sessionNickname","_resumeMediaTransferForJvbConnection","_startP2PSession","newP2PJingleSession","invite","userLeftEvent","peers","peerCount","hasBotPeer","shouldBeInP2P","myId","peersId","wasP2PEstablished","getP2PConnectionState","startP2PSession","peerJid","stopP2PSession","getSpeakerStats","getStats","setReceiverVideoConstraint","createVideoSIPGWSession","sipAddress","VideoSIPGWConstants","LARGE_ARRAY_SIZE","HASH_UNDEFINED","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","argsTag","arrayTag","asyncTag","boolTag","dateTag","errorTag","funcTag","genTag","mapTag","numberTag","nullTag","objectTag","proxyTag","regexpTag","setTag","stringTag","symbolTag","undefinedTag","arrayBufferTag","dataViewTag","reIsHostCtor","reIsUint","typedArrayTags","freeGlobal","global","freeSelf","freeExports","freeModule","moduleExports","freeProcess","nodeUtil","nodeIsTypedArray","isTypedArray","arraySome","predicate","mapToArray","setToArray","uid","arrayProto","funcProto","objectProto","coreJsData","funcToString","maskSrcKey","exec","IE_PROTO","nativeObjectToString","reIsNative","Buffer","propertyIsEnumerable","symToStringTag","nativeGetSymbols","nativeIsBuffer","isBuffer","nativeKeys","DataView","getNative","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","valueOf","Hash","entries","entry","ListCache","MapCache","SetCache","__data__","Stack","arrayLikeKeys","inherited","isArr","isArg","isArguments","isBuff","isType","skipIndexes","iteratee","baseTimes","isIndex","assocIndexOf","eq","baseGetTag","isOwn","unmasked","getRawTag","objectToString","baseIsArguments","isObjectLike","baseIsEqual","other","bitmask","customizer","equalFunc","objIsArr","othIsArr","objTag","getTag","othTag","objIsObj","othIsObj","isSameTag","equalArrays","byteLength","byteOffset","buffer","convert","isPartial","stacked","equalByTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","objProps","getAllKeys","objLength","othLength","skipCtor","objValue","othValue","compared","objCtor","othCtor","equalObjects","baseIsEqualDeep","baseIsNative","isObject","isMasked","isFunction","baseKeys","Ctor","arrLength","seen","arrValue","othIndex","keysFunc","symbolsFunc","offset","arrayPush","baseGetAllKeys","getSymbols","getMapData","getValue","pairs","resIndex","arrayFilter","symbol","ArrayBuffer","ctorString","isLength","baseUnary","xmppListeners","chatRoom","chatRoomForwarder","EventEmitterForwarder","actor","forward","setParticipantPropertyListener","recorderSession","logObject","getError","getStatus","AuthenticationEvents","txt","myJid","ts","updated","featuresChangedListener","_addConferenceXMPPListener","audioMuted","videoMuted","ignoreStartMuted","_onByteSentStatsReceived","dest","srcEvent","AnalyticsAdapter","analyticsHandlers","cache","permanentProperties","conferenceName","setAnalyticsHandlers","_setUserProperties","_sendEvent","setUserProperties","_verifyRequiredFields","objectType","containerType","objectId","_maybeCacheEvent","isSafariWithWebrtc","isSafari","isVersionLessThan","ondevicechange","usesUnifiedPlan","usesPlanB","RTCRtpTransceiver","_getChromiumBasedVersion","WINDOW","JS_MD5_NO_WINDOW","WEB_WORKER","NODE_JS","JS_MD5_NO_NODE_JS","COMMON_JS","JS_MD5_NO_COMMON_JS","AMD","ARRAY_BUFFER","JS_MD5_NO_ARRAY_BUFFER","HEX_CHARS","EXTRA","SHIFT","OUTPUT_TYPES","BASE64_ENCODE_CHAR","blocks","buffer8","Uint32Array","JS_MD5_NO_ARRAY_BUFFER_IS_VIEW","isView","createOutputMethod","outputType","Md5","update","createMethod","method","nodeWrap","eval","nodeMethod","createHash","digest","sharedMemory","h0","h1","h2","h3","bytes","hBytes","finalized","hashed","notString","lastByteIndex","finalize","bc","da","hex","arrayBuffer","base64","v1","v2","v3","base64Str","md5","KEYS_BY_BROWSER_TYPE","calculatePacketLoss","lostPackets","totalPackets","round","SsrcStats","loss","bitrate","upload","framerate","ConferenceStats","packetLoss","StatsCollector","statsInterval","_browserType","_usesPromiseGetStats","_getStatValue","_defineNewGetStatValueMethod","_defineGetStatValueMethod","baselineAudioLevelsReport","currentAudioLevelsReport","currentStatsReport","previousStatsReport","audioLevelsIntervalId","conferenceStats","audioLevelsIntervalMilis","statsIntervalId","statsIntervalMilis","ssrc2stats","browsers","setLoss","setResolution","addBitrate","resetBitrate","setFramerate","startAudioLevelStats","processNewAudioLevelReport","processAudioLevelReport","supportsRtpStatistics","processNewStatsReport","processStatsReport","itemStatByKey","stat","pair","keyFromName","getNonNegativeStat","getStatValue","byteSentStats","receiveBandwidth","sendBandwidth","localCandidateType","localip","remoteCandidateType","conferenceStatsTransport","selected","local","localCandidateId","remote","remoteCandidateId","ipAddress","portNumber","candidateType","msType","remoteAddress","localAddress","before","ssrcIds","isRemote","remoteSource","ssrcStats","isDownloadStream","packetsNow","packetsBefore","packetsDiff","packetsLostNow","packetsLostBefore","packetsLostDiff","packetsTotal","packetsLost","bytesReceivedNow","bytesReceivedBefore","bytesReceived","nowBytesTransmitted","timeMs","timestamp","bitrateReceivedKbps","bitrateSentKbps","_processAndEmitReport","bitrateDownload","bitrateUpload","resolutions","framerates","audioBitrateDownload","audioBitrateUpload","videoBitrateDownload","videoBitrateUpload","userResolutions","userFramerates","getNonNegativeValue","_calculateBitrate","fieldName","bytesNow","bytesBefore","bytesProcessed","bitrateKbps","nominated","availableIncomingBitrate","availableOutgoingBitrate","remoteUsedCandidate","localUsedCandidate","remoteIpAddress","remotePort","localIpAddress","localPort","localIp","networkType","currentRoundTripTime","framerateMean","frameHeight","frameWidth","framesPerSecond","framesSent","trackIdentifier","getSsrcByTrackId","hidden","_jid","_id","_conference","_hidden","_statsID","_connectionStatus","_properties","_identity","isWebRTCTrackMuted","oldValue","_isMediaTypeMuted","reduce","rejectPromise","onLoginSuccessful","roomPassword","canceled","authenticationError","connectionError","MucConnectionPlugin","rooms","onPresence","onPresenceUnavailable","onPresenceError","onMessage","onMute","ChatRoom","createNonAnonymousRoom","packet2JSON","json2packet","packet","filterNodeFromPresenceJSON","members","presHandlers","noBridgeAvailable","Moderator","initPresenceMap","lastPresences","phoneNumber","phonePin","participantPropertyListener","locked","QHSenseTranscriptionStatus","xns","addVideoInfoToPresence","disableFocus","allocateConferenceFocus","fromJoin","getInfo","getForm","form","formSubmit","member","statusEl","hasStatusUpdate","xElement","mucUserItem","affiliation","getFocusUserJid","isHiddenDomain","fromHiddenDomain","xEl","extractIdentityInformation","userInfo","newRole","_initFocus","memberOfThis","displayJids","att","phone","pin","processNode","tagHandlers","nickname","skipEvents","onMucMemberLeft","reasonSelect","doLeave","isKick","membersKeys","actorNick","actorSelect","onParticipantLeft","subjectText","stamp","dateParts","discoRoomInfo","kickIQ","onError","onNotSupported","formsubmit","handlerIdx","sendVideoInfoPresence","sendAudioInfoPresence","addAudioInfoToPresence","mutedNode","videoTypeNode","isSipGatewayEnabled","iqToFocus","onMucLeft","doReject","createExpBackoffTimer","step","origin","xmppService","getNextTimeout","getNextErrorTimeout","externalAuthEnabled","sipGatewayEnabled","call_control","attachEvent","setFocusUserJid","focusJid","focusUserJid","getFocusComponent","focusComponent","focus","createConferenceIq","openSctp","machineUID","machineId","enforcedBridge","enableTcc","enableRemb","minParticipants","audioPacketDelay","startBitrate","minBitrate","octo","probability","stereo","useRoomAsSharedDocumentName","parseSessionId","resultIq","parseConfigOptions","authenticationEnabled","_allocateConferenceFocusSuccess","_allocateConferenceFocusError","invalidSession","reservationErr","errorCode","errorTextNode","waitMs","retrySec","urlCallback","failureCallback","_getLoginUrl","popup","urlCb","decodeURIComponent","logout","logoutUrl","JingleConnectionPlugin","jvbIceConfig","p2pIceConfig","offerToReceiveAudio","offerToReceiveVideo","onJingle","fromJid","ack","sess","startMuted","modifyContents","replaceTransport","successTime","sendTransportReject","addRemoteStream","removeRemoteStream","me","onTerminated","iceservers","dict","credential","updateLog","ConnectionPlugin","doInitialize","ssrcOwners","oldChatRoom","_audioMuteHandler","_videoMuteHandler","_videoTypeHandler","SignalingEvents","getMediaPresenceInfo","SignalingLayer","_queue","_processQueueTasks","_stopped","kill","task","previous_async","only_once","fn","called","noConflict","_toString","_isArray","_each","_map","_keys","setImmediate","completed","eachSeries","iterate","forEachSeries","eachLimit","limit","_eachLimit","forEachLimit","started","running","replenish","doParallel","doSeries","_asyncMap","eachfn","mapSeries","mapLimit","_mapLimit","doParallelLimit","memo","inject","foldl","reduceRight","reversed","foldr","_filter","filterSeries","select","selectSeries","_reject","rejectSeries","main_callback","detectSeries","any","sortBy","criteria","left","right","auto","tasks","remainingTasks","taskComplete","theCallback","taskCallback","safeResults","rkey","requires","ready","retry","times","attempts","wrappedTask","wrappedCallback","wrappedResults","retryAttempt","finalAttempt","seriesCallback","series","waterfall","wrapIterator","_parallel","parallel","parallelLimit","makeCallback","cb","concatSeries","whilst","doWhilst","until","doUntil","worker","concurrency","_insert","drain","saturated","workers","empty","idle","priorityQueue","_compareTasks","sequence","compare","beg","end","_binarySearch","cargo","working","drained","_console_fn","memoize","hasher","queues","memoized","unmemoized","unmemoize","counter","timesSeries","seq","fns","newargs","nextargs","compose","_applyEach","go","applyEach","applyEachSeries","forever","resetLastErrorStatusRegExpr","lastErrorStatusRegExpr","trace","errStatusCapture","PING_TIMESTAMPS_TO_KEEP","PingConnectionPlugin","failedPings","pingExecIntervals","_addPingExecutionTimestamp","pingIntervals","maxInterval","previousTS","currentInterval","RayoConnectionPlugin","onRayo","roomPass","callResource","StropheLogger","logIncoming","logOutgoing","LastRequestTracker","_nextValidRid","_lastSuccess","stropheConnection","IDENTITY_PROPERTIES","IDENTITY_PROPERTIES_FOR_COMPARE","compareIdentities","generateSha","sortedIdentities","accumulatedValue","sortedFeatures","disco","versionToCapabilities","jidToVersion","_addChatRoom","_removeChatRoom","CAPS","_handleCaps","_onMucMemberLeft","_removeJidToVersionEntry","_generateVersion","_getDiscoInfo","sha","receivedNode","category","_fixChatRoomPresenceMap","_identities","_features","_notifyVersionChanged","oldVersion","dtmfSender","createDTMFSender","insertDTMF","_audioLevel","myUserID","_areRetriesEnabled","_closedFromClient","datachannel","createDataChannel","_handleChannel","_wsUrl","_initWebSocket","ws","timeoutS","_retryTimeout","reload","isOpen","closeEvent","_stopConnectionRetries","_startConnectionRetries","OPEN","colibriClass","msgPayload","jsonObject","pinnedEndpoint","endpointIds","selectedEndpoints","maxFrameHeightPixels","channel","dominantSpeakerEndpoint","endpoint","_retryWebSocketConnection","SIMULCAST_LAYERS","SIM_LAYER_RIDS","audioTransferActive","_addedStreams","localSSRCs","localUfrag","remoteUfrag","_peerVideoTypeChanged","_peerMutedChanged","statsinterval","Interop","interop","Simulcast","simulcast","numOfLayers","explodeRemoteSimulcast","sdpConsistency","SdpConsistency","localSdpMunger","LocalSdpMunger","rtxModifier","RtxModifier","what","onaddstream","_remoteStreamAdded","onremovestream","_remoteStreamRemoved","ondatachannel","_processStat","statValue","endTime","dumpSDP","_getDesiredMediaDirection","mediaTransferActive","hasAnyTracksOfType","isSimulcastOn","supportsSimulcast","videoTrack","_setVideoType","endpoints","endpointTrackMap","mediaTrack","findTrackById","onaddtrack","_remoteTrackAdded","onremovetrack","_remoteTrackRemoved","streamAudioTracks","streamVideoTracks","mediaLines","mls","trackSsrc","ownerEndpointId","getSSRCOwner","peerMediaInfo","getPeerMediaInfo","_createRemoteTrack","remoteTracksMap","existingTrack","QHSenseRemoteTrack","isUserStream","_removeRemoteTrackById","_getRemoteTrackById","removedAudioTrack","removedVideoTrack","_removeRemoteTrack","toBeRemoved","normalizePlanB","firstSsrcs","newSsrcLines","isVersionGreaterThan","filteredLines","ssrcId","cnameLine","replaceDefaultUnifiedPlanMsid","resStr","_getSSRC","_injectSsrcGroupForUnifiedSimulcast","simulcast_03","getters","toPlanB","maybeAddMutedLocalVideoTracksToSDP","transformer","audioMedia","selectMedia","videoMedia","toRawSDP","enforceSendRecv","transformStreamIdentifiers","webrtcStream","_addStream","generateNewStreamSSRCInfo","setPrimarySsrc","setSsrcCache","fidGroups","rtxSsrcMapping","rtxSsrc","_assertTrackBelongs","webRtcStream","addStream","_removeStream","supportsRtpSender","_handleSenderRemoveStream","removeStream","doesBelong","isMediaStreamInPc","findSenderByStream","getSenders","sender","extractPrimarySSRC","opts","_ensureSimulcastGroupIsLast","localSdp","sdpStr","videoStartIndex","simStartIndex","otherStartIndex","simEndIndex","simStr","otherEndIndex","sdpHead","simStrTrimmed","sdpTail","_adjustLocalMediaDirection","modifiedDirection","desiredAudioDirection","desiredVideoDirection","parsedSdp","toUnifiedPlan","_insertUnifiedPlanSimulcastReceive","mungeRemoteDescription","stripRtx","_injectH264IfNotPresent","dummyPayloadType","payloadsArray","clearVideoSsrcCache","peerTracks","_removePeerConnection","simParams","encodings","scaleResolutionDownBy","setParameters","_createOfferOrAnswer","isOffer","handleSuccess","resultSdp","resolveFn","rejectFn","hasPrimarySsrcCached","makeVideoPrimarySsrcsConsistent","mungeLocalDescription","modifyRtxSsrcs","groupsMap","groupSSRCs","extractSSRCMap","_processLocalSSRCsMap","handleFailure","trackMSID","newSSRCNum","oldSSRCNum","currNumSsrcs","videoSender","getParameters","simIndex","handleLayerSuspension","ttfmTrackerAudioAttached","ttfmTrackerVideoAttached","hasBeenMuted","_bindMuteHandlers","_onTrackMute","_onTrackUnmute","gumStart","gumEnd","gumDuration","ttfm","_playCallback","localVideos","isInPeerConnection","shouldFakeSdp","requiredSSRCs","ssrcCache","cachedPrimarySsrc","primaryCname","removeSSRC","addSSRCAttribute","addSSRCGroup","modifyRtxSsrcs2","pcId","streamAndTrackIDs","_addMutedLocalVideoTracksToSDP","sessionDesc","audioMLine","_transformMediaIdentifiers","updateAssociatedRtxStream","primarySsrcInfo","primarySsrcMsid","primarySsrcCname","previousRtxSSRC","getRtxSSRC","dumpSSRCGroups","removeGroupsWithSSRC","correspondingRtxSsrcs","ssrcMapping","sdpTransformer","getSSRCCount","primaryVideoSsrcs","getPrimaryVideoSSRCs","getSSRCAttrValue","correspondingRtxSsrc","previousAssociatedRtxStream","containsAnySSRCGroups","findGroups","removeGroupsBySemantics","injectRecvOnly","newPrimarySsrc","getPrimaryVideoSsrc","replaceSSRC","_eventFired","_trackMuteChanged","_trackAdded","_isLocalAudioTrack","STATS_MESSAGE_TYPE","kSimulcastFormats","layers","videoBitrateCap","getTarget","millisSinceStart","simulcastFormat","targetHeight","pixels","rampUp","_localStats","jvbRTT","_lastConnectionQualityUpdate","_remoteStats","_timeIceConnected","_timeVideoUnmuted","_timeLastBwCapRemoved","ConferenceEvents","_updateLocalConnectionQuality","ConnectionQualityEvents","_broadcastLocalStats","_updateRemoteStats","_updateLocalStats","_maybeUpdateUnmuteTime","bridgeCount","resolutionName","quality","activeTPC","newVideoBitrateCap","bandwidthLimiter","getBandwidthLimit","prevConnectionQuality","diffSeconds","updateLocalConnectionQuality","_calculateConnectionQuality","_canceled","_iceFailedTimeout","ParticipantWrapper","requests","lastRequestId","clearIntervals","sendRequest","handleResponse","maybeSendAnalytics","isDataChannelOpen","pingInterval","pingIntervalMs","analyticsInterval","analyticsIntervalMs","requestId","requestMessage","timeSent","E2ePingEvents","Infinity","participantJoined","participantLeft","messageReceived","dataChannelOpened","participantWrapper","handleRequest","_jvb121","evaluateStatus","oldStatus","_sessions","_chatRoom","_handleFocusPresence","_handleJibriPresence","getSession","getID","_addSession","_emitSessionUpdate","_createSession","setLiveStreamViewURL","offerOptions","PCMonitor","getStatsIntervalMs","getStatsInterval","rtts","stopped","startStatsInterval","handleCandidateRtt","rttTotal","candidateKey","responsesReceived","requestsSent","rttTotalDiff","responsesReceivedDiff","requestsResponsesDiff","supportsLocalCandidateRttStatistics","pcMonitors","startPCMonitors","initialDelay","AverageStatReport","sum","calculate","ConnectionAvgStats","_n","_sampleIdx","_avgRTT","_avgRemoteRTTMap","_avgRtpStatsReporter","_avgEnd2EndRTT","_onConnectionStats","_calculateAvgStats","_onUserLeft","_onRemoteStatsUpdated","_processRemoteStats","supportsRTTStatistics","addNext","batchReport","appendReport","jvbEnd2EndRTT","jvbStatsMonitor","avgRemoteRTT","_calculateAvgRemoteRTT","avgLocalRTT","_resetAvgStats","remoteAvg","avg","validData","rttAvg","_avgAudioBitrateUp","_avgAudioBitrateDown","_avgVideoBitrateUp","_avgVideoBitrateDown","_avgBandwidthUp","_avgBandwidthDown","_avgPacketLossTotal","_avgPacketLossUp","_avgPacketLossDown","_avgRemoteFPS","_avgRemoteScreenFPS","_avgLocalFPS","_avgLocalScreenFPS","_avgRemoteCameraPixels","_avgRemoteScreenPixels","_avgLocalCameraPixels","_avgLocalScreenPixels","_avgCQ","_onLocalStatsUpdated","_onP2PStatusChanged","p2pStatsMonitor","_onJvb121StatusChanged","_resetAvgJvbStats","confSize","supportsBandwidthStatistics","_calculateAvgVideoFps","_calculateAvgVideoPixels","peerResolutions","peerPixelsSum","myID","peerID","videosResolution","peerAvgPixels","_calculatePeerAvgVideoPixels","videos","getTracksByMediaType","peerSsrcCount","peerSsrcPixels","peerFpsSum","videosFps","peerAvgFPS","_calculatePeerAvgVideoFps","peerSsrcFps","dominantSpeakerId","_onDominantSpeaker","_onUserJoin","_onUserLeave","_onDisplayNameChange","_updateStats","oldDominantSpeaker","newDominantSpeaker","savedUser","markAsHasLeft","newStats","speakerStatsToUpdate","SphinxService","BEFORE_STATE","audioRecorder","transcriptionService","transcription","lineLength","blobCallBack","wordArray","getUTCMilliseconds","wordObject","begin","word","maybeMerge","hasPopulatedArrays","twoDimensionalArray","callBack","recordingResult","merge","arrays","potentialWords","pushWordToSortedArray","lowestWordArray","wordToAdd","updateTranscription","foundSmaller","wordToCompare","getTranscription","getState","processPresence","FOCUS_COMPONENT","VIDEOBRIDGE_COMPONENT","XMPP_SERVER_COMPONENT","mucResource","componentName","getComponentVersion","sessionStateChangeListener","sessionStateChanged","handleJibriSIPState","Constants","sipaddress","setState","failure_reason","QHSenseVideoSIPGWSession","addStateListener","removeStateListener","_sendJibriIQ","failureReason","oldState","displayname","BUSY","RESOURCE_CONSTRAINT","SERVICE_UNAVAILABLE","FILE","ProxyConnectionService","qhsenseConnection","otherOptions","_options","_peerConnection","_onFatalError","_onSendMessage","_onRemoteStream","getPeerJid","_convertStringToXML","$jingle","_createPeerConnection","receiveVideo","processMessage","_selfCloseConnection","xml","xmlDom","onRemoteStream","onSendMessage","ProxyConnectionPC","qhsenseRemoteTrack","isVideo","convertVideoToDesktop","qhsenseLocalTracks","newCreateLocalTracks","stringifiedIq","XMLSerializer","serializeToString","onConnectionClosed","receiveAudio","_onSessionAccept","_onSessionInitiate","_onSessionTerminate","_onTransportInfo","connectionStub","iceConfigStub","roomStub","_rtc","default","getLowerResolution","resName","getAnalyticsAttributesFromOptions","video_requested","_mergeNamespaceAndModule","QHSenseMeetJS","constants","recording","recordingConstants","sipVideoGW","errorTypes","logLevels","enableAnalyticsLogging","enableWindowOnErrorHandler","getGlobalOnErrorHandler","aprops","isWebRtcSupported","addGlobalLogTransport","globalTransport","removeGlobalLogTransport","firePermissionPromptIsShownEvent","originalOptions","promiseFulfilled","emitEvent","mStream","currentlyAvailableMediaDevices","oldResolution","newResolution","isMultipleAudioInputSupported","isCollectingLocalStats","lineno","colno","util","AuthUtil","logStorage","stringifyObjects","storeInterval","maxEntryLength","logLevel","_log","storeLogsIntervalID","totalLen","outputCache","someObject","formatLogMessage","prevMessage","prevMessageText","_flush","_reschedulePublishInterval","force","reschedule","isReady","cachedQueue","storeLogs","__webpack_amd_options__","scriptReadyRegex","fullPageUrl","pageUrl","scripts","supportsScriptReadyState","isNotOpera","hasNativeCurrentScriptAccessor","stackTraceLimit","hasStackBeforeThrowing","hasStackAfterThrowing","_nearestExecutingScript","eligibleScripts","skipStackDepth","getScriptFromUrl","getScriptUrlFromStack","ignoreMessage","hasAttribute","getSoleInlineScript","currentScript","thrownErr","near","far","_items","_onDiscoInfo","_onDiscoItems","addIdentity","lang","var_name","addItem","call_back","items","_buildIQResult","query_attrs","iqresult","scope","Timeout","clearFn","_clearFn","unref","ref","enroll","msecs","_idleTimeoutId","unenroll","_unrefActive","_onTimeout","clearImmediate","registerImmediate","messagePrefix","onGlobalMessage","nextHandle","tasksByHandle","currentlyRunningATask","attachTo","handle","runIfPresent","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","canUsePostMessage","MessageChannel","port1","port2","removeChild","adapterFactory","dependencies","shimChrome","shimFirefox","shimEdge","shimSafari","logging","browserDetails","adapter","chromeShim","edgeShim","firefoxShim","safariShim","commonShim","shimPeerConnection","browserShim","shimGetUserMedia","shimMediaStream","shimSourceObject","shimOnTrack","shimAddTrackRemoveTrack","shimGetSendersWithDtmf","shimRTCIceCandidate","shimReplaceTrack","shimRTCIceServerUrls","shimCallbacksAPI","shimLocalStreamsAPI","shimRemoteStreamsAPI","shimTrackEventTransceiver","shimCreateOfferLegacy","webkitMediaStream","_ontrack","origSetRemoteDescription","_ontrackpoly","te","getReceivers","Event","dispatchEvent","shimSenderWithDtmf","_dtmf","_pc","_senders","origAddTrack","origRemoveTrack","origAddStream","origRemoveStream","RTCRtpSender","origGetSenders","HTMLMediaElement","_srcObject","origGetLocalStreams","getLocalStreams","nativeStreams","_reverseStreams","_streams","DOMException","newStream","alreadyExists","oldStream","nativeMethod","isLegacyCall","replaceInternalStreamId","origSetLocalDescription","replaceExternalStreamId","origLocalDescription","getOwnPropertyDescriptor","streamid","internalId","externalStream","internalStream","OrigPeerConnection","pcConfig","newIceServers","generateCertificate","iceTransports","origGetStats","selector","fixChromeStats_","standardReport","standardStats","localcandidate","remotecandidate","makeMapStats","successCallbackWrapper_","nativeAddIceCandidate","constraintsToChrome_","cc","oldname_","oc","mix","advanced","shimConstraints_","remap","face","getSupportedFacingModeLies","getSupportedConstraints","dev","shimError_","PermissionDeniedError","InvalidStateError","DevicesNotFoundError","ConstraintNotSatisfiedError","TrackStartError","MediaDeviceFailedDueToShutdown","MediaDeviceKillSwitchOn","getUserMediaPromise_","kinds","MediaStreamTrack","getSources","origGetUserMedia","shimRTCPeerConnection","RTCIceGatherer","origMSTEnabled","RTCDtmfSender","setTrack","dtlsRole","_initialTrackId","getCommonCapabilities","localCapabilities","remoteCapabilities","commonCapabilities","findCodecByPayloadType","rtxCapabilityMatches","lRtx","rRtx","lCodecs","rCodecs","lCodec","rCodec","lHeaderExtension","rHeaderExtension","isActionAllowedInSignalingState","maybeAddCandidate","iceTransport","alreadyAdded","getRemoteCandidates","remoteCandidate","addRemoteCandidate","makeError","NotSupportedError","InvalidAccessError","OperationError","addTrackToStreamAndFireEvent","MediaStreamTrackEvent","fireAddTrack","trackEvent","_dispatchEvent","_eventTarget","canTrickleIceCandidates","needNegotiation","localStreams","remoteStreams","_localDescription","_remoteDescription","iceGatheringState","usingBundle","bundlePolicy","rtcpMuxPolicy","hasTurn","isString","filterIceServers","_iceGatherers","iceCandidatePoolSize","gatherPolicy","_config","transceivers","_sdpSessionId","_sdpSessionVersion","_dtlsRole","_isClosed","configurable","ontrack","onconnectionstatechange","onicegatheringstatechange","_emitGatheringStateChange","getConfiguration","getRemoteStreams","_createTransceiver","doNotAdd","hasBundleTransport","recvEncodingParameters","associatedRemoteMediaStreams","wantReceive","_createIceAndDtlsTransports","_maybeFireNegotiationNeeded","clonedStream","clonedTrack","_createIceGatherer","writable","bufferedCandidateEvents","bufferCandidates","_gather","onlocalcandidate","evt","serializedCandidate","toJSON","complete","RTCIceTransport","onicestatechange","_updateIceConnectionState","_updateConnectionState","RTCDtlsTransport","ondtlsstatechange","_disposeIceAndDtlsTransports","_transceive","recv","receive","isIceLite","rejected","remoteIceParameters","remoteDtlsParameters","_updateSignalingState","receiverList","iceOptions","remoteMsid","isComplete","setTransport","setRemoteCandidates","RTCRtpReceiver","getCapabilities","isNewTrack","nativeTrack","removeTrackFromStreamAndFireEvent","states","checking","disconnected","failed","new","connecting","numAudioTracks","numVideoTracks","remoteCodec","hdrExt","rHdrExt","getLocalCandidates","mediaSectionsInOffer","candidateString","senderOrReceiver","allStats","ortcObjectName","nativeGetstats","nativeStats","mapStats","inboundrtp","outboundrtp","candidatepair","RTCTrackEvent","mozSrcObject","mozRTCPeerConnection","newServer","mozRTCSessionDescription","mozRTCIceCandidate","modernStatsTypes","nativeGetStats","onSucc","onErr","InternalError","SecurityError","getUserMedia_","constraintsToFF37_","orgEnumerateDevices","nativeGetUserMedia","nativeGetSettings","nativeApplyConstraints","_localStreams","getStreamById","_remoteStreams","_addTrack","_onaddstream","_onaddstreampoly","withCallback","errcb","RTCTransceiver","origCreateOffer","audioTransceiver","getTransceivers","setDirection","addTransceiver","videoTransceiver","NativeRTCIceCandidate","nativeCandidate","parsedCandidate","augmentedCandidate","eventNameToWrap","nativeAddEventListener","nativeEventName","_eventMap","nativeRemoveEventListener","unwrappedCb","wrapPeerConnectionEvent","nativeCreateObjectURL","nativeRevokeObjectURL","newId","dsc","nativeSetAttribute","toIntIfInt","parseReg","needsBlank","keyLocation","rawName","attachProperties","validLine","paramReducer","acc","scid","formatRegExp","formatStr","makeLine","defaultOuterOrder","defaultInnerOrder","outerOrder","innerOrder","midToString","mlB2UMap","mlU2BMap","candidateToUnifiedPlan","candidateToPlanB","getFirstSendingIndexFromAnswer","rewrite","type2bl","types","directionResult","uLine","rtcpMux","directionMasks","bundleOnly","mids","msidSemantic","semantic","cached","hasBundle","recvonlySsrcs","mid2ul","bIdx","uIdx","bLine","uLineData","iceUfrag","icePwd","ssrc2group","ssrc2ml","related","transformUtils","parseSsrcs","writeSsrcs","DEFAULT_NUM_OF_LAYERS","processVideo","validateDescription","clearSsrcCache","_parseSimLayers","_buildNewToOldSsrcMap","newSsrcList","oldSsrcList","newSsrc","oldSsrc","_fillInSourceDataFromCache","newSimSsrcs","newMsid","newCname","ssrcsToReplace","ssrcsToAdd","_generateSourceData","addAssociatedStream","simSsrcs","simSsrc","_restoreSimulcast","simulcastSsrcs","relatedGroup","relatedSsrcs","relatedSSRC","simulcastGroup","nuke","implodeRemoteSimulcast","invalid","removeGoogConference","assertGoogConference","TranscriptionService","Word","sphinxURL","toReturn","getURL","audioFileBlob","DONE","formatResponse","objects","filler","verify","audioBlob","getWord","getBeginTime","getEndTime"],"mappings":"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","file":"lib-qhsense-meet.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"QHSenseMeetJS\"] = factory();\n\telse\n\t\troot[\"QHSenseMeetJS\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 118);\n","const XMPPEvents = {\r\n    /**\r\n     * Indicates error while adding ice candidate.\r\n     */\r\n    ADD_ICE_CANDIDATE_FAILED: 'xmpp.add_ice_candidate_failed',\r\n\r\n    // Designates an event indicating that the focus has asked us to mute our\r\n    // audio.\r\n    AUDIO_MUTED_BY_FOCUS: 'xmpp.audio_muted_by_focus',\r\n    AUTHENTICATION_REQUIRED: 'xmpp.authentication_required',\r\n    BRIDGE_DOWN: 'xmpp.bridge_down',\r\n\r\n    /**\r\n     * Triggered when 'session-accept' is received from the responder.\r\n     */\r\n    CALL_ACCEPTED: 'xmpp.callaccepted.jingle',\r\n\r\n    // Designates an event indicating that an offer (e.g. Jingle\r\n    // session-initiate) was received.\r\n    CALL_INCOMING: 'xmpp.callincoming.jingle',\r\n\r\n    // Triggered when Jicofo kills our media session, this can happen while\r\n    // we're still in the MUC, when it decides to terminate the media session.\r\n    // For example when the session is idle for too long, because we're the only\r\n    // person in the conference room.\r\n    CALL_ENDED: 'xmpp.callended.jingle',\r\n    CHAT_ERROR_RECEIVED: 'xmpp.chat_error_received',\r\n\r\n    // The conference properties (as advertised by jicofo) have changed\r\n    CONFERENCE_PROPERTIES_CHANGED: 'xmpp.conference_properties_changed',\r\n\r\n    /**\r\n     * This event is triggered when the ICE connects for the first time.\r\n     */\r\n    CONNECTION_ESTABLISHED: 'xmpp.connection.connected',\r\n\r\n    // Designates an event indicating that the connection to the XMPP server\r\n    // failed.\r\n    CONNECTION_FAILED: 'xmpp.connection.failed',\r\n\r\n    // Designates an event indicating that the media (ICE) connection was\r\n    // interrupted. This should go to the RTC module.\r\n    CONNECTION_INTERRUPTED: 'xmpp.connection.interrupted',\r\n\r\n    // Designates an event indicating that the media (ICE) connection was\r\n    // restored. This should go to the RTC module.\r\n    CONNECTION_RESTORED: 'xmpp.connection.restored',\r\n\r\n    // Designates an event indicating that the media (ICE) connection failed.\r\n    // This should go to the RTC module.\r\n    CONNECTION_ICE_FAILED: 'xmpp.connection.ice.failed',\r\n\r\n    /**\r\n     * Designates an event indicating connection status changes.\r\n     */\r\n    CONNECTION_STATUS_CHANGED: 'xmpp.connection.status.changed',\r\n\r\n    // Designates an event indicating that the display name of a participant\r\n    // has changed.\r\n    DISPLAY_NAME_CHANGED: 'xmpp.display_name_changed',\r\n\r\n    /**\r\n     * Chat room instance have been added to Strophe.emuc plugin.\r\n     */\r\n    EMUC_ROOM_ADDED: 'xmpp.emuc_room_added',\r\n\r\n    /**\r\n     * Chat room instance have been removed from Strophe.emuc plugin.\r\n     */\r\n    EMUC_ROOM_REMOVED: 'xmpp.emuc_room_removed',\r\n    ETHERPAD: 'xmpp.etherpad',\r\n    FOCUS_DISCONNECTED: 'xmpp.focus_disconnected',\r\n    FOCUS_LEFT: 'xmpp.focus_left',\r\n    GRACEFUL_SHUTDOWN: 'xmpp.graceful_shutdown',\r\n\r\n    /**\r\n     * Event fired when 'transport-replace' Jingle message has been received,\r\n     * before the new offer is set on the PeerConnection.\r\n     */\r\n    ICE_RESTARTING: 'rtc.ice_restarting',\r\n\r\n    /**\r\n     * Event fired after the 'transport-replace' message has been processed\r\n     * and the new offer has been set successfully.\r\n     */\r\n    ICE_RESTART_SUCCESS: 'rtc.ice_restart_success',\r\n\r\n    /**\r\n     * Designates an event indicating that we were kicked from the XMPP MUC.\r\n     * @param {boolean} isSelfPresence - whether it is for local participant\r\n     * or another participant.\r\n     * @param {string} actorJid - the jid of the participant who was initator\r\n     * of the kick.\r\n     * @param {?string} participantJid - when it is not a kick for local participant,\r\n     * this is the jid of the participant which was kicked.\r\n     */\r\n    KICKED: 'xmpp.kicked',\r\n\r\n    // Designates an event indicating that our role in the XMPP MUC has changed.\r\n    LOCAL_ROLE_CHANGED: 'xmpp.localrole_changed',\r\n\r\n    // Designates an event indicating that an XMPP message in the MUC was\r\n    // received.\r\n    MESSAGE_RECEIVED: 'xmpp.message_received',\r\n\r\n    // Designates an event indicating that a private XMPP message in the MUC was\r\n    // received.\r\n    PRIVATE_MESSAGE_RECEIVED: 'xmpp.private_message_received',\r\n\r\n    // Designates an event indicating that a bot participant type had changed\r\n    MUC_MEMBER_BOT_TYPE_CHANGED: 'xmpp.muc_member_bot_type_changed',\r\n\r\n    // Designates an event indicating that the XMPP MUC was destroyed.\r\n    MUC_DESTROYED: 'xmpp.muc_destroyed',\r\n\r\n    // Designates an event indicating that we have joined the XMPP MUC.\r\n    MUC_JOINED: 'xmpp.muc_joined',\r\n\r\n    // Designates an event indicating that a participant joined the XMPP MUC.\r\n    MUC_MEMBER_JOINED: 'xmpp.muc_member_joined',\r\n\r\n    // Designates an event indicating that a participant left the XMPP MUC.\r\n    MUC_MEMBER_LEFT: 'xmpp.muc_member_left',\r\n\r\n    // Designates an event indicating that local participant left the muc\r\n    MUC_LEFT: 'xmpp.muc_left',\r\n\r\n    // Designates an event indicating that the MUC role of a participant has\r\n    // changed.\r\n    MUC_ROLE_CHANGED: 'xmpp.muc_role_changed',\r\n\r\n    // Designates an event indicating that the MUC has been locked or unlocked.\r\n    MUC_LOCK_CHANGED: 'xmpp.muc_lock_changed',\r\n\r\n    // Designates an event indicating that a participant in the XMPP MUC has\r\n    // advertised that they have audio muted (or unmuted).\r\n    PARTICIPANT_AUDIO_MUTED: 'xmpp.audio_muted',\r\n\r\n    // Designates an event indicating that a participant in the XMPP MUC has\r\n    // advertised that they have video muted (or unmuted).\r\n    PARTICIPANT_VIDEO_MUTED: 'xmpp.video_muted',\r\n\r\n    // Designates an event indicating that the video type (e.g. 'camera' or\r\n    // 'screen') for a participant has changed.\r\n    // Note: currently this event fires every time we receive presence from\r\n    // someone (regardless of whether or not the \"video type\" changed).\r\n    PARTICIPANT_VIDEO_TYPE_CHANGED: 'xmpp.video_type',\r\n\r\n    /**\r\n     * Indicates that the features of the participant has been changed.\r\n     */\r\n    PARTCIPANT_FEATURES_CHANGED: 'xmpp.partcipant_features_changed',\r\n    PASSWORD_REQUIRED: 'xmpp.password_required',\r\n    PEERCONNECTION_READY: 'xmpp.peerconnection_ready',\r\n\r\n    /**\r\n     * Indicates that phone number changed.\r\n     */\r\n    PHONE_NUMBER_CHANGED: 'conference.phoneNumberChanged',\r\n    PRESENCE_RECEIVED: 'xmpp.presence_received',\r\n    PRESENCE_STATUS: 'xmpp.presence_status',\r\n    PROMPT_FOR_LOGIN: 'xmpp.prompt_for_login',\r\n\r\n    // xmpp is connected and obtained user media\r\n    READY_TO_JOIN: 'xmpp.ready_to_join',\r\n\r\n    /**\r\n     * Indicates that recording state changed.\r\n     */\r\n    RECORDER_STATE_CHANGED: 'xmpp.recorderStateChanged',\r\n\r\n    // Designates an event indicating that we received statistics from a\r\n    // participant in the MUC.\r\n    REMOTE_STATS: 'xmpp.remote_stats',\r\n\r\n    /**\r\n     * Indicates that the offer / answer renegotiation has failed.\r\n     */\r\n    RENEGOTIATION_FAILED: 'xmpp.renegotiation_failed',\r\n    RESERVATION_ERROR: 'xmpp.room_reservation_error',\r\n    ROOM_CONNECT_ERROR: 'xmpp.room_connect_error',\r\n    ROOM_CONNECT_NOT_ALLOWED_ERROR: 'xmpp.room_connect_error.not_allowed',\r\n    ROOM_JOIN_ERROR: 'xmpp.room_join_error',\r\n\r\n    /**\r\n     * Indicates that max users limit has been reached.\r\n     */\r\n    ROOM_MAX_USERS_ERROR: 'xmpp.room_max_users_error',\r\n\r\n    // Designates an event indicating that we sent an XMPP message to the MUC.\r\n    SENDING_CHAT_MESSAGE: 'xmpp.sending_chat_message',\r\n\r\n    // Designates an event indicating that we sent a private XMPP message to\r\n    // a specific user of the muc.\r\n    SENDING_PRIVATE_CHAT_MESSAGE: 'xmpp.sending_private_chat_message',\r\n\r\n    /**\r\n     * Event fired when we do not get our 'session-accept' acknowledged by\r\n     * Jicofo. It most likely means that there is serious problem with our\r\n     * connection or XMPP server and we should reload the conference.\r\n     *\r\n     * We have seen that to happen in BOSH requests race condition when the BOSH\r\n     * request table containing the 'session-accept' was discarded by Prosody.\r\n     * Jicofo does send the RESULT immediately without any condition, so missing\r\n     * packets means that most likely it has never seen our IQ.\r\n     */\r\n    SESSION_ACCEPT_TIMEOUT: 'xmpp.session_accept_timeout',\r\n\r\n    /**\r\n     * Event fired when speaker stats update message is received.\r\n     */\r\n    SPEAKER_STATS_RECEIVED: 'xmpp.speaker_stats_received',\r\n\r\n    // Designates an event indicating that we should join the conference with\r\n    // audio and/or video muted.\r\n    START_MUTED_FROM_FOCUS: 'xmpp.start_muted_from_focus',\r\n\r\n    // Designates an event indicating that the subject of the XMPP MUC has\r\n    // changed.\r\n    SUBJECT_CHANGED: 'xmpp.subject_changed',\r\n\r\n    // FIXME: how does it belong to XMPP ? - it's detected by the PeerConnection\r\n    // suspending detected\r\n    SUSPEND_DETECTED: 'xmpp.suspend_detected',\r\n\r\n    /**\r\n     * Notifies for transcription status changes. The event provides the\r\n     * following parameters to its listeners:\r\n     *\r\n     * @param {String} status - The new status.\r\n     */\r\n    TRANSCRIPTION_STATUS_CHANGED: 'xmpp.transcription_status_changed',\r\n\r\n    /**\r\n     * Event fired when 'transport-info' with new ICE candidates is received.\r\n     */\r\n    TRANSPORT_INFO: 'xmpp.transportinfo.jingle',\r\n\r\n    /**\r\n     * Indicates that video SIP GW state changed.\r\n     *\r\n     * @param {VideoSIPGWConstants} status - Any of the following statuses:\r\n     * STATUS_BUSY, STATUS_AVAILABLE or STATUS_UNDEFINED.\r\n     */\r\n    VIDEO_SIP_GW_AVAILABILITY_CHANGED: 'xmpp.videoSIPGWAvailabilityChanged',\r\n\r\n    /**\r\n     * Indicates that video SIP GW Session state changed.\r\n     * The statuses are any of the following statuses:\r\n     * STATE_ON, STATE_OFF, STATE_PENDING, STATE_RETRYING, STATE_FAILED.\r\n     * {@see VideoSIPGWConstants}\r\n     *\r\n     * @param {options} event - {address, oldState, newState, displayName}.\r\n     */\r\n    VIDEO_SIP_GW_SESSION_STATE_CHANGED:\r\n        'xmpp.videoSIPGWSessionStateChanged',\r\n\r\n    // Designates an event indicating that the local ICE connection state has\r\n    // changed.\r\n    ICE_CONNECTION_STATE_CHANGED: 'xmpp.ice_connection_state_changed',\r\n\r\n    /**\r\n     * Event which is emitted when the body in an XMPP message in the MUC\r\n     * contains JSON\r\n     */\r\n    JSON_MESSAGE_RECEIVED: 'xmmp.json_message_received'\r\n};\r\n\r\nmodule.exports = XMPPEvents;\r\n","/** File: strophe.js\n *  A JavaScript library for writing XMPP clients.\n *\n *  This library uses either Bidirectional-streams Over Synchronous HTTP (BOSH)\n *  to emulate a persistent, stateful, two-way connection to an XMPP server or\n *  alternatively WebSockets.\n *\n *  More information on BOSH can be found in XEP 124.\n *  For more information on XMPP-over WebSocket see this RFC:\n *  http://tools.ietf.org/html/rfc7395\n */\n\n/* All of the Strophe globals are defined in this special function below so\n * that references to the globals become closures.  This will ensure that\n * on page reload, these references will still be available to callbacks\n * that are still executing.\n */\n\n/* jshint ignore:start */\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        //Allow using this built library as an AMD module\n        //in another project. That other project will only\n        //see this AMD call, not the internal modules in\n        //the closure below.\n        define([], factory);\n    } else {\n        //Browser globals case.\n        var wrapper = factory();\n        root.Strophe        = wrapper.Strophe;\n        root.$build         = wrapper.$build;\n        root.$iq            = wrapper.$iq;\n        root.$msg           = wrapper.$msg;\n        root.$pres          = wrapper.$pres;\n        root.SHA1           = wrapper.SHA1;\n        root.MD5            = wrapper.MD5;\n        root.b64_hmac_sha1  = wrapper.b64_hmac_sha1;\n        root.b64_sha1       = wrapper.b64_sha1;\n        root.str_hmac_sha1  = wrapper.str_hmac_sha1;\n        root.str_sha1       = wrapper.str_sha1;\n    }\n}(this, function () {\n    //almond, and your modules will be inlined here\n/* jshint ignore:end */\n/**\n * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.\n * Released under MIT license, http://github.com/requirejs/almond/LICENSE\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name) {\n            name = name.split('/');\n            lastIndex = name.length - 1;\n\n            // If wanting node ID compatibility, strip .js from end\n            // of IDs. Have to do this here, and not in nameToUrl\n            // because node allows either .js or non .js to map\n            // to same file.\n            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n            }\n\n            // Starts with a '.' so need the baseName\n            if (name[0].charAt(0) === '.' && baseParts) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that 'directory' and not name of the baseName's\n                //module. For instance, baseName of 'one/two/three', maps to\n                //'one/two/three.js', but we want the directory, 'one/two' for\n                //this normalization.\n                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\n                name = normalizedBaseParts.concat(name);\n            }\n\n            //start trimDots\n            for (i = 0; i < name.length; i++) {\n                part = name[i];\n                if (part === '.') {\n                    name.splice(i, 1);\n                    i -= 1;\n                } else if (part === '..') {\n                    // If at the start, or previous value is still ..,\n                    // keep them so that when converted to a path it may\n                    // still work when converted to a path, even though\n                    // as an ID it is less than ideal. In larger point\n                    // releases, may be better to just kick out an error.\n                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {\n                        continue;\n                    } else if (i > 0) {\n                        name.splice(i - 1, 2);\n                        i -= 2;\n                    }\n                }\n            }\n            //end trimDots\n\n            name = name.join('/');\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            var args = aps.call(arguments, 0);\n\n            //If first arg is not require('string'), and there is only\n            //one arg, it is the array form without a callback. Insert\n            //a null so that the following concat is correct.\n            if (typeof args[0] !== 'string' && args.length === 1) {\n                args.push(null);\n            }\n            return req.apply(undef, args.concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    //Creates a parts array for a relName where first part is plugin ID,\n    //second part is resource ID. Assumes relName has already been normalized.\n    function makeRelParts(relName) {\n        return relName ? splitPrefix(relName) : [];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relParts) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0],\n            relResourceName = relParts[1];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relResourceName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relResourceName));\n            } else {\n                name = normalize(name, relResourceName);\n            }\n        } else {\n            name = normalize(name, relResourceName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i, relParts,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n        relParts = makeRelParts(relName);\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relParts);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, makeRelParts(callback)).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n        if (typeof name !== 'string') {\n            throw new Error('See almond README: incorrect module build, no module name');\n        }\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"node_modules/almond/almond.js\", function(){});\n\n/*\n    This program is distributed under the terms of the MIT license.\n    Please see the LICENSE file for details.\n\n    Copyright 2006-2008, OGG, LLC\n*/\n/* jshint undef: true, unused: true:, noarg: true, latedef: true */\n/* global define */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-polyfill',[], function () {\n            return factory(root);\n        });\n    } else {\n        // Browser globals\n        return factory(root);\n    }\n}(this, function (root) {\n\n/** Function: Function.prototype.bind\n *  Bind a function to an instance.\n *\n *  This Function object extension method creates a bound method similar\n *  to those in Python.  This means that the 'this' object will point\n *  to the instance you want.  See <MDC's bind() documentation at https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind>\n *  and <Bound Functions and Function Imports in JavaScript at http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/>\n *  for a complete explanation.\n *\n *  This extension already exists in some browsers (namely, Firefox 3), but\n *  we provide it to support those that don't.\n *\n *  Parameters:\n *    (Object) obj - The object that will become 'this' in the bound function.\n *    (Object) argN - An option argument that will be prepended to the\n *      arguments given for the function call\n *\n *  Returns:\n *    The bound function.\n */\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function (obj /*, arg1, arg2, ... */) {\n        var func = this;\n        var _slice = Array.prototype.slice;\n        var _concat = Array.prototype.concat;\n        var _args = _slice.call(arguments, 1);\n        return function () {\n            return func.apply(obj ? obj : this, _concat.call(_args, _slice.call(arguments, 0)));\n        };\n    };\n}\n\n/** Function: Array.isArray\n *  This is a polyfill for the ES5 Array.isArray method.\n */\nif (!Array.isArray) {\n    Array.isArray = function(arg) {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n}\n\n/** Function: Array.prototype.indexOf\n *  Return the index of an object in an array.\n *\n *  This function is not supplied by some JavaScript implementations, so\n *  we provide it if it is missing.  This code is from:\n *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf\n *\n *  Parameters:\n *    (Object) elt - The object to look for.\n *    (Integer) from - The index from which to start looking. (optional).\n *\n *  Returns:\n *    The index of elt in the array or -1 if not found.\n */\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function(elt /*, from*/) {\n        var len = this.length;\n        var from = Number(arguments[1]) || 0;\n        from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n        if (from < 0) {\n            from += len;\n        }\n\n        for (; from < len; from++) {\n            if (from in this && this[from] === elt) {\n                return from;\n            }\n        }\n        return -1;\n    };\n}\n\n/** Function: Array.prototype.forEach\n *\n *  This function is not available in IE < 9\n *\n *  See <forEach on developer.mozilla.org at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach>\n */\nif (!Array.prototype.forEach) {\n    Array.prototype.forEach = function(callback, thisArg) {\n        var T, k;\n        if (this === null) {\n            throw new TypeError(' this is null or not defined');\n        }\n        // 1. Let O be the result of calling toObject() passing the\n        // |this| value as the argument.\n        var O = Object(this);\n        // 2. Let lenValue be the result of calling the Get() internal\n        // method of O with the argument \"length\".\n        // 3. Let len be toUint32(lenValue).\n        var len = O.length >>> 0;\n        // 4. If isCallable(callback) is false, throw a TypeError exception.\n        // See: http://es5.github.com/#x9.11\n        if (typeof callback !== \"function\") {\n            throw new TypeError(callback + ' is not a function');\n        }\n        // 5. If thisArg was supplied, let T be thisArg; else let\n        // T be undefined.\n        if (arguments.length > 1) {\n            T = thisArg;\n        }\n        // 6. Let k be 0\n        k = 0;\n        // 7. Repeat, while k < len\n        while (k < len) {\n            var kValue;\n            // a. Let Pk be ToString(k).\n            //        This is implicit for LHS operands of the in operator\n            // b. Let kPresent be the result of calling the HasProperty\n            //        internal method of O with argument Pk.\n            //        This step can be combined with c\n            // c. If kPresent is true, then\n            if (k in O) {\n                // i. Let kValue be the result of calling the Get internal\n                // method of O with argument Pk.\n                kValue = O[k];\n                // ii. Call the Call internal method of callback with T as\n                // the this value and argument list containing kValue, k, and O.\n                callback.call(T, kValue, k, O);\n            }\n            // d. Increase k by 1.\n            k++;\n        }\n        // 8. return undefined\n    };\n}\n\n// This code was written by Tyler Akins and has been placed in the\n// public domain.  It would be nice if you left this header intact.\n// Base64 code from Tyler Akins -- http://rumkin.com\nvar keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nif (!root.btoa) {\n    root.btoa = function (input) {\n        /**\n         * Encodes a string in base64\n         * @param {String} input The string to encode in base64.\n         */\n        var output = \"\";\n        var chr1, chr2, chr3;\n        var enc1, enc2, enc3, enc4;\n        var i = 0;\n        do {\n            chr1 = input.charCodeAt(i++);\n            chr2 = input.charCodeAt(i++);\n            chr3 = input.charCodeAt(i++);\n\n            enc1 = chr1 >> 2;\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n            enc4 = chr3 & 63;\n\n            if (isNaN(chr2)) {\n                enc2 = ((chr1 & 3) << 4);\n                enc3 = enc4 = 64;\n            } else if (isNaN(chr3)) {\n                enc4 = 64;\n            }\n            output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +\n                keyStr.charAt(enc3) + keyStr.charAt(enc4);\n        } while (i < input.length);\n        return output;\n    };\n}\n\nif (!root.atob) {\n    root.atob = function (input) {\n        /**\n         * Decodes a base64 string.\n         * @param {String} input The string to decode.\n         */\n        var output = \"\";\n        var chr1, chr2, chr3;\n        var enc1, enc2, enc3, enc4;\n        var i = 0;\n        // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n        do {\n            enc1 = keyStr.indexOf(input.charAt(i++));\n            enc2 = keyStr.indexOf(input.charAt(i++));\n            enc3 = keyStr.indexOf(input.charAt(i++));\n            enc4 = keyStr.indexOf(input.charAt(i++));\n\n            chr1 = (enc1 << 2) | (enc2 >> 4);\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n            chr3 = ((enc3 & 3) << 6) | enc4;\n\n            output = output + String.fromCharCode(chr1);\n\n            if (enc3 !== 64) {\n                output = output + String.fromCharCode(chr2);\n            }\n            if (enc4 !== 64) {\n                output = output + String.fromCharCode(chr3);\n            }\n        } while (i < input.length);\n        return output;\n    };\n}\n}));\n\n/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\n/* jshint undef: true, unused: true:, noarg: true, latedef: false */\n/* global define */\n\n/* Some functions and variables have been stripped for use with Strophe */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-sha1', [],function () {\n            return factory();\n        });\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        // Browser globals\n        root.SHA1 = factory();\n    }\n}(this, function () {\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = new Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  var i, j, t, olda, oldb, oldc, oldd, olde;\n  for (i = 0; i < x.length; i += 16)\n  {\n    olda = a;\n    oldb = b;\n    oldc = c;\n    oldd = d;\n    olde = e;\n\n    for (j = 0; j < 80; j++)\n    {\n      if (j < 16) { w[j] = x[i + j]; }\n      else { w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1); }\n      t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return [a, b, c, d, e];\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if (t < 20) { return (b & c) | ((~b) & d); }\n  if (t < 40) { return b ^ c ^ d; }\n  if (t < 60) { return (b & c) | (b & d) | (c & d); }\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Calculate the HMAC-SHA1 of a key and some data\n */\nfunction core_hmac_sha1(key, data)\n{\n  var bkey = str2binb(key);\n  if (bkey.length > 16) { bkey = core_sha1(bkey, key.length * 8); }\n\n  var ipad = new Array(16), opad = new Array(16);\n  for (var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);\n  return core_sha1(opad.concat(hash), 512 + 160);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert an 8-bit or 16-bit string to an array of big-endian words\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\n */\nfunction str2binb(str)\n{\n  var bin = [];\n  var mask = 255;\n  for (var i = 0; i < str.length * 8; i += 8)\n  {\n    bin[i>>5] |= (str.charCodeAt(i / 8) & mask) << (24 - i%32);\n  }\n  return bin;\n}\n\n/*\n * Convert an array of big-endian words to a string\n */\nfunction binb2str(bin)\n{\n  var str = \"\";\n  var mask = 255;\n  for (var i = 0; i < bin.length * 32; i += 8)\n  {\n    str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);\n  }\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a base-64 string\n */\nfunction binb2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  var triplet, j;\n  for (var i = 0; i < binarray.length * 4; i += 3)\n  {\n    triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |\n              (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |\n               ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\n    for (j = 0; j < 4; j++)\n    {\n      if (i * 8 + j * 6 > binarray.length * 32) { str += \"=\"; }\n      else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }\n    }\n  }\n  return str;\n}\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nreturn {\n    b64_hmac_sha1:  function (key, data){ return binb2b64(core_hmac_sha1(key, data)); },\n    b64_sha1:       function (s) { return binb2b64(core_sha1(str2binb(s),s.length * 8)); },\n    binb2str:       binb2str,\n    core_hmac_sha1: core_hmac_sha1,\n    str_hmac_sha1:  function (key, data){ return binb2str(core_hmac_sha1(key, data)); },\n    str_sha1:       function (s) { return binb2str(core_sha1(str2binb(s),s.length * 8)); },\n};\n}));\n\n/*\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n/*\n * Everything that isn't used by Strophe has been stripped here!\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-md5',[], function () {\n            return factory();\n        });\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        // Browser globals\n        root.MD5 = factory();\n    }\n}(this, function () {\n    /*\n     * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n     * to work around bugs in some JS interpreters.\n     */\n    var safe_add = function (x, y) {\n        var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n        return (msw << 16) | (lsw & 0xFFFF);\n    };\n\n    /*\n     * Bitwise rotate a 32-bit number to the left.\n     */\n    var bit_rol = function (num, cnt) {\n        return (num << cnt) | (num >>> (32 - cnt));\n    };\n\n    /*\n     * Convert a string to an array of little-endian words\n     */\n    var str2binl = function (str) {\n        var bin = [];\n        for(var i = 0; i < str.length * 8; i += 8)\n        {\n            bin[i>>5] |= (str.charCodeAt(i / 8) & 255) << (i%32);\n        }\n        return bin;\n    };\n\n    /*\n     * Convert an array of little-endian words to a string\n     */\n    var binl2str = function (bin) {\n        var str = \"\";\n        for(var i = 0; i < bin.length * 32; i += 8)\n        {\n            str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & 255);\n        }\n        return str;\n    };\n\n    /*\n     * Convert an array of little-endian words to a hex string.\n     */\n    var binl2hex = function (binarray) {\n        var hex_tab = \"0123456789abcdef\";\n        var str = \"\";\n        for(var i = 0; i < binarray.length * 4; i++)\n        {\n            str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +\n                hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);\n        }\n        return str;\n    };\n\n    /*\n     * These functions implement the four basic operations the algorithm uses.\n     */\n    var md5_cmn = function (q, a, b, x, s, t) {\n        return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);\n    };\n\n    var md5_ff = function (a, b, c, d, x, s, t) {\n        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n    };\n\n    var md5_gg = function (a, b, c, d, x, s, t) {\n        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n    };\n\n    var md5_hh = function (a, b, c, d, x, s, t) {\n        return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n    };\n\n    var md5_ii = function (a, b, c, d, x, s, t) {\n        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n    };\n\n    /*\n     * Calculate the MD5 of an array of little-endian words, and a bit length\n     */\n    var core_md5 = function (x, len) {\n        /* append padding */\n        x[len >> 5] |= 0x80 << ((len) % 32);\n        x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n        var a =  1732584193;\n        var b = -271733879;\n        var c = -1732584194;\n        var d =  271733878;\n\n        var olda, oldb, oldc, oldd;\n        for (var i = 0; i < x.length; i += 16)\n        {\n            olda = a;\n            oldb = b;\n            oldc = c;\n            oldd = d;\n\n            a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\n            d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\n            c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\n            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n            a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\n            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n            b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\n            a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\n            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n            c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\n            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\n            a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\n            d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\n            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\n            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\n\n            a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\n            d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\n            c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\n            b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\n            a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\n            d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\n            c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\n            b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\n            a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\n            d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\n            c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\n            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n            a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\n            d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\n            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\n\n            a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\n            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\n            b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\n            a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\n            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n            c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\n            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\n            a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\n            d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\n            c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\n            b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\n            a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\n            d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\n            c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\n            b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\n\n            a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\n            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\n            b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\n            a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\n            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n            c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\n            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n            a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\n            d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\n            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\n            a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\n            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\n            c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\n            b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\n\n            a = safe_add(a, olda);\n            b = safe_add(b, oldb);\n            c = safe_add(c, oldc);\n            d = safe_add(d, oldd);\n        }\n        return [a, b, c, d];\n    };\n\n    var obj = {\n        /*\n         * These are the functions you'll usually want to call.\n         * They take string arguments and return either hex or base-64 encoded\n         * strings.\n         */\n        hexdigest: function (s) {\n            return binl2hex(core_md5(str2binl(s), s.length * 8));\n        },\n\n        hash: function (s) {\n            return binl2str(core_md5(str2binl(s), s.length * 8));\n        }\n    };\n    return obj;\n}));\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-utils',[], function () {\n            return factory();\n        });\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        // Browser globals\n        root.stropheUtils = factory();\n    }\n}(this, function () {\n\n    var utils = {\n\n        utf16to8: function (str) {\n            var i, c;\n            var out = \"\";\n            var len = str.length;\n            for (i = 0; i < len; i++) {\n                c = str.charCodeAt(i);\n                if ((c >= 0x0000) && (c <= 0x007F)) {\n                    out += str.charAt(i);\n                } else if (c > 0x07FF) {\n                    out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));\n                    out += String.fromCharCode(0x80 | ((c >>  6) & 0x3F));\n                    out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));\n                } else {\n                    out += String.fromCharCode(0xC0 | ((c >>  6) & 0x1F));\n                    out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));\n                }\n            }\n            return out;\n        },\n\n        addCookies: function (cookies) {\n            /* Parameters:\n             *  (Object) cookies - either a map of cookie names\n             *    to string values or to maps of cookie values.\n             *\n             * For example:\n             * { \"myCookie\": \"1234\" }\n             *\n             * or:\n             * { \"myCookie\": {\n             *      \"value\": \"1234\",\n             *      \"domain\": \".example.org\",\n             *      \"path\": \"/\",\n             *      \"expires\": expirationDate\n             *      }\n             *  }\n             *\n             *  These values get passed to Strophe.Connection via\n             *   options.cookies\n             */\n            var cookieName, cookieObj, isObj, cookieValue, expires, domain, path;\n            for (cookieName in (cookies || {})) {\n                expires = '';\n                domain = '';\n                path = '';\n                cookieObj = cookies[cookieName];\n                isObj = typeof cookieObj === \"object\";\n                cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));\n                if (isObj) {\n                    expires = cookieObj.expires ? \";expires=\"+cookieObj.expires : '';\n                    domain = cookieObj.domain ? \";domain=\"+cookieObj.domain : '';\n                    path = cookieObj.path ? \";path=\"+cookieObj.path : '';\n                }\n                document.cookie =\n                    cookieName+'='+cookieValue + expires + domain + path;\n            }\n        }\n    };\n    return utils;\n}));\n\n/*\n    This program is distributed under the terms of the MIT license.\n    Please see the LICENSE file for details.\n\n    Copyright 2006-2008, OGG, LLC\n*/\n\n/* jshint undef: true, unused: true:, noarg: true, latedef: true */\n/*global define, document, sessionStorage, setTimeout, clearTimeout, ActiveXObject, DOMParser, btoa, atob */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-core',[\n            'strophe-sha1',\n            'strophe-md5',\n            'strophe-utils'\n        ], function () {\n            return factory.apply(this, arguments);\n        });\n    }  else if (typeof exports === 'object') {\n        module.exports = factory(\n            require('./sha1'),\n            require('./md5'),\n            require('./utils')\n        );\n    } else {\n        // Browser globals\n        var o = factory(root.SHA1, root.MD5, root.stropheUtils);\n        root.Strophe =        o.Strophe;\n        root.$build =         o.$build;\n        root.$iq =            o.$iq;\n        root.$msg =           o.$msg;\n        root.$pres =          o.$pres;\n        root.SHA1 =           o.SHA1;\n        root.MD5 =            o.MD5;\n        root.b64_hmac_sha1 =  o.SHA1.b64_hmac_sha1;\n        root.b64_sha1 =       o.SHA1.b64_sha1;\n        root.str_hmac_sha1 =  o.SHA1.str_hmac_sha1;\n        root.str_sha1 =       o.SHA1.str_sha1;\n    }\n}(this, function (SHA1, MD5, utils) {\n\nvar Strophe;\n\n/** Function: $build\n *  Create a Strophe.Builder.\n *  This is an alias for 'new Strophe.Builder(name, attrs)'.\n *\n *  Parameters:\n *    (String) name - The root element name.\n *    (Object) attrs - The attributes for the root element in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder object.\n */\nfunction $build(name, attrs) { return new Strophe.Builder(name, attrs); }\n\n/** Function: $msg\n *  Create a Strophe.Builder with a <message/> element as the root.\n *\n *  Parameters:\n *    (Object) attrs - The <message/> element attributes in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder object.\n */\nfunction $msg(attrs) { return new Strophe.Builder(\"message\", attrs); }\n\n/** Function: $iq\n *  Create a Strophe.Builder with an <iq/> element as the root.\n *\n *  Parameters:\n *    (Object) attrs - The <iq/> element attributes in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder object.\n */\nfunction $iq(attrs) { return new Strophe.Builder(\"iq\", attrs); }\n\n/** Function: $pres\n *  Create a Strophe.Builder with a <presence/> element as the root.\n *\n *  Parameters:\n *    (Object) attrs - The <presence/> element attributes in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder object.\n */\nfunction $pres(attrs) { return new Strophe.Builder(\"presence\", attrs); }\n\n/** Class: Strophe\n *  An object container for all Strophe library functions.\n *\n *  This class is just a container for all the objects and constants\n *  used in the library.  It is not meant to be instantiated, but to\n *  provide a namespace for library objects, constants, and functions.\n */\nStrophe = {\n    /** Constant: VERSION */\n    VERSION: \"1.2.16\",\n\n    /** Constants: XMPP Namespace Constants\n     *  Common namespace constants from the XMPP RFCs and XEPs.\n     *\n     *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.\n     *  NS.BOSH - BOSH namespace from XEP 206.\n     *  NS.CLIENT - Main XMPP client namespace.\n     *  NS.AUTH - Legacy authentication namespace.\n     *  NS.ROSTER - Roster operations namespace.\n     *  NS.PROFILE - Profile namespace.\n     *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.\n     *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.\n     *  NS.MUC - Multi-User Chat namespace from XEP 45.\n     *  NS.SASL - XMPP SASL namespace from RFC 3920.\n     *  NS.STREAM - XMPP Streams namespace from RFC 3920.\n     *  NS.BIND - XMPP Binding namespace from RFC 3920.\n     *  NS.SESSION - XMPP Session namespace from RFC 3920.\n     *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.\n     *  NS.XHTML - XHTML body namespace from XEP 71.\n     */\n    NS: {\n        HTTPBIND: \"http://jabber.org/protocol/httpbind\",\n        BOSH: \"urn:xmpp:xbosh\",\n        CLIENT: \"jabber:client\",\n        AUTH: \"jabber:iq:auth\",\n        ROSTER: \"jabber:iq:roster\",\n        PROFILE: \"jabber:iq:profile\",\n        DISCO_INFO: \"http://jabber.org/protocol/disco#info\",\n        DISCO_ITEMS: \"http://jabber.org/protocol/disco#items\",\n        MUC: \"http://jabber.org/protocol/muc\",\n        SASL: \"urn:ietf:params:xml:ns:xmpp-sasl\",\n        STREAM: \"http://etherx.jabber.org/streams\",\n        FRAMING: \"urn:ietf:params:xml:ns:xmpp-framing\",\n        BIND: \"urn:ietf:params:xml:ns:xmpp-bind\",\n        SESSION: \"urn:ietf:params:xml:ns:xmpp-session\",\n        VERSION: \"jabber:iq:version\",\n        STANZAS: \"urn:ietf:params:xml:ns:xmpp-stanzas\",\n        XHTML_IM: \"http://jabber.org/protocol/xhtml-im\",\n        XHTML: \"http://www.w3.org/1999/xhtml\"\n    },\n\n    /** Constants: XHTML_IM Namespace\n     *  contains allowed tags, tag attributes, and css properties.\n     *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.\n     *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended\n     *  allowed tags and their attributes.\n     */\n    XHTML: {\n        tags: ['a','blockquote','br','cite','em','img','li','ol','p','span','strong','ul','body'],\n        attributes: {\n            'a':          ['href'],\n            'blockquote': ['style'],\n            'br':         [],\n            'cite':       ['style'],\n            'em':         [],\n            'img':        ['src', 'alt', 'style', 'height', 'width'],\n            'li':         ['style'],\n            'ol':         ['style'],\n            'p':          ['style'],\n            'span':       ['style'],\n            'strong':     [],\n            'ul':         ['style'],\n            'body':       []\n        },\n        css: ['background-color','color','font-family','font-size','font-style','font-weight','margin-left','margin-right','text-align','text-decoration'],\n        /** Function: XHTML.validTag\n         *\n         * Utility method to determine whether a tag is allowed\n         * in the XHTML_IM namespace.\n         *\n         * XHTML tag names are case sensitive and must be lower case.\n         */\n        validTag: function(tag) {\n            for (var i = 0; i < Strophe.XHTML.tags.length; i++) {\n                if (tag === Strophe.XHTML.tags[i]) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /** Function: XHTML.validAttribute\n         *\n         * Utility method to determine whether an attribute is allowed\n         * as recommended per XEP-0071\n         *\n         * XHTML attribute names are case sensitive and must be lower case.\n         */\n        validAttribute: function(tag, attribute) {\n            if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {\n                for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {\n                    if (attribute === Strophe.XHTML.attributes[tag][i]) {\n                        return true;\n                    }\n                }\n            }\n        return false;\n        },\n        validCSS: function(style) {\n            for (var i = 0; i < Strophe.XHTML.css.length; i++) {\n                if (style === Strophe.XHTML.css[i]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    },\n\n    /** Constants: Connection Status Constants\n     *  Connection status constants for use by the connection handler\n     *  callback.\n     *\n     *  Status.ERROR - An error has occurred\n     *  Status.CONNECTING - The connection is currently being made\n     *  Status.CONNFAIL - The connection attempt failed\n     *  Status.AUTHENTICATING - The connection is authenticating\n     *  Status.AUTHFAIL - The authentication attempt failed\n     *  Status.CONNECTED - The connection has succeeded\n     *  Status.DISCONNECTED - The connection has been terminated\n     *  Status.DISCONNECTING - The connection is currently being terminated\n     *  Status.ATTACHED - The connection has been attached\n     *  Status.REDIRECT - The connection has been redirected\n     *  Status.CONNTIMEOUT - The connection has timed out\n     */\n    Status: {\n        ERROR: 0,\n        CONNECTING: 1,\n        CONNFAIL: 2,\n        AUTHENTICATING: 3,\n        AUTHFAIL: 4,\n        CONNECTED: 5,\n        DISCONNECTED: 6,\n        DISCONNECTING: 7,\n        ATTACHED: 8,\n        REDIRECT: 9,\n        CONNTIMEOUT: 10\n    },\n\n    ErrorCondition: {\n        BAD_FORMAT: \"bad-format\",\n        CONFLICT: \"conflict\",\n        MISSING_JID_NODE: \"x-strophe-bad-non-anon-jid\",\n        NO_AUTH_MECH: \"no-auth-mech\",\n        UNKNOWN_REASON: \"unknown\",\n    },\n\n    /** Constants: Log Level Constants\n     *  Logging level indicators.\n     *\n     *  LogLevel.DEBUG - Debug output\n     *  LogLevel.INFO - Informational output\n     *  LogLevel.WARN - Warnings\n     *  LogLevel.ERROR - Errors\n     *  LogLevel.FATAL - Fatal errors\n     */\n    LogLevel: {\n        DEBUG: 0,\n        INFO: 1,\n        WARN: 2,\n        ERROR: 3,\n        FATAL: 4\n    },\n\n    /** PrivateConstants: DOM Element Type Constants\n     *  DOM element types.\n     *\n     *  ElementType.NORMAL - Normal element.\n     *  ElementType.TEXT - Text data element.\n     *  ElementType.FRAGMENT - XHTML fragment element.\n     */\n    ElementType: {\n        NORMAL: 1,\n        TEXT: 3,\n        CDATA: 4,\n        FRAGMENT: 11\n    },\n\n    /** PrivateConstants: Timeout Values\n     *  Timeout values for error states.  These values are in seconds.\n     *  These should not be changed unless you know exactly what you are\n     *  doing.\n     *\n     *  TIMEOUT - Timeout multiplier. A waiting request will be considered\n     *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.\n     *      This defaults to 1.1, and with default wait, 66 seconds.\n     *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where\n     *      Strophe can detect early failure, it will consider the request\n     *      failed if it doesn't return after\n     *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.\n     *      This defaults to 0.1, and with default wait, 6 seconds.\n     */\n    TIMEOUT: 1.1,\n    SECONDARY_TIMEOUT: 0.1,\n\n    /** Function: addNamespace\n     *  This function is used to extend the current namespaces in\n     *  Strophe.NS.  It takes a key and a value with the key being the\n     *  name of the new namespace, with its actual value.\n     *  For example:\n     *  Strophe.addNamespace('PUBSUB', \"http://jabber.org/protocol/pubsub\");\n     *\n     *  Parameters:\n     *    (String) name - The name under which the namespace will be\n     *      referenced under Strophe.NS\n     *    (String) value - The actual namespace.\n     */\n    addNamespace: function (name, value) {\n        Strophe.NS[name] = value;\n    },\n\n    /** Function: forEachChild\n     *  Map a function over some or all child elements of a given element.\n     *\n     *  This is a small convenience function for mapping a function over\n     *  some or all of the children of an element.  If elemName is null, all\n     *  children will be passed to the function, otherwise only children\n     *  whose tag names match elemName will be passed.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The element to operate on.\n     *    (String) elemName - The child element tag name filter.\n     *    (Function) func - The function to apply to each child.  This\n     *      function should take a single argument, a DOM element.\n     */\n    forEachChild: function (elem, elemName, func) {\n        var i, childNode;\n        for (i = 0; i < elem.childNodes.length; i++) {\n            childNode = elem.childNodes[i];\n            if (childNode.nodeType === Strophe.ElementType.NORMAL &&\n                (!elemName || this.isTagEqual(childNode, elemName))) {\n                func(childNode);\n            }\n        }\n    },\n\n    /** Function: isTagEqual\n     *  Compare an element's tag name with a string.\n     *\n     *  This function is case sensitive.\n     *\n     *  Parameters:\n     *    (XMLElement) el - A DOM element.\n     *    (String) name - The element name.\n     *\n     *  Returns:\n     *    true if the element's tag name matches _el_, and false\n     *    otherwise.\n     */\n    isTagEqual: function (el, name) {\n        return el.tagName === name;\n    },\n\n    /** PrivateVariable: _xmlGenerator\n     *  _Private_ variable that caches a DOM document to\n     *  generate elements.\n     */\n    _xmlGenerator: null,\n\n    /** PrivateFunction: _makeGenerator\n     *  _Private_ function that creates a dummy XML DOM document to serve as\n     *  an element and text node generator.\n     */\n    _makeGenerator: function () {\n        var doc;\n        // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.\n        // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be\n                // less than 10 in the case of IE9 and below.\n        if (document.implementation.createDocument === undefined ||\n                        document.implementation.createDocument && document.documentMode && document.documentMode < 10) {\n            doc = this._getIEXmlDom();\n            doc.appendChild(doc.createElement('strophe'));\n        } else {\n            doc = document.implementation\n                .createDocument('jabber:client', 'strophe', null);\n        }\n        return doc;\n    },\n\n    /** Function: xmlGenerator\n     *  Get the DOM document to generate elements.\n     *\n     *  Returns:\n     *    The currently used DOM document.\n     */\n    xmlGenerator: function () {\n        if (!Strophe._xmlGenerator) {\n            Strophe._xmlGenerator = Strophe._makeGenerator();\n        }\n        return Strophe._xmlGenerator;\n    },\n\n    /** PrivateFunction: _getIEXmlDom\n     *  Gets IE xml doc object\n     *\n     *  Returns:\n     *    A Microsoft XML DOM Object\n     *  See Also:\n     *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx\n     */\n    _getIEXmlDom : function() {\n        var doc = null;\n        var docStrings = [\n            \"Msxml2.DOMDocument.6.0\",\n            \"Msxml2.DOMDocument.5.0\",\n            \"Msxml2.DOMDocument.4.0\",\n            \"MSXML2.DOMDocument.3.0\",\n            \"MSXML2.DOMDocument\",\n            \"MSXML.DOMDocument\",\n            \"Microsoft.XMLDOM\"\n        ];\n\n        for (var d = 0; d < docStrings.length; d++) {\n            if (doc === null) {\n                try {\n                    doc = new ActiveXObject(docStrings[d]);\n                } catch (e) {\n                    doc = null;\n                }\n            } else {\n                break;\n            }\n        }\n        return doc;\n    },\n\n    /** Function: xmlElement\n     *  Create an XML DOM element.\n     *\n     *  This function creates an XML DOM element correctly across all\n     *  implementations. Note that these are not HTML DOM elements, which\n     *  aren't appropriate for XMPP stanzas.\n     *\n     *  Parameters:\n     *    (String) name - The name for the element.\n     *    (Array|Object) attrs - An optional array or object containing\n     *      key/value pairs to use as element attributes. The object should\n     *      be in the format {'key': 'value'} or {key: 'value'}. The array\n     *      should have the format [['key1', 'value1'], ['key2', 'value2']].\n     *    (String) text - The text child data for the element.\n     *\n     *  Returns:\n     *    A new XML DOM element.\n     */\n    xmlElement: function (name) {\n        if (!name) { return null; }\n\n        var node = Strophe.xmlGenerator().createElement(name);\n        // FIXME: this should throw errors if args are the wrong type or\n        // there are more than two optional args\n        var a, i, k;\n        for (a = 1; a < arguments.length; a++) {\n            var arg = arguments[a];\n            if (!arg) { continue; }\n            if (typeof(arg) === \"string\" ||\n                typeof(arg) === \"number\") {\n                node.appendChild(Strophe.xmlTextNode(arg));\n            } else if (typeof(arg) === \"object\" &&\n                       typeof(arg.sort) === \"function\") {\n                for (i = 0; i < arg.length; i++) {\n                    var attr = arg[i];\n                    if (typeof(attr) === \"object\" &&\n                        typeof(attr.sort) === \"function\" &&\n                        attr[1] !== undefined &&\n                        attr[1] !== null) {\n                        node.setAttribute(attr[0], attr[1]);\n                    }\n                }\n            } else if (typeof(arg) === \"object\") {\n                for (k in arg) {\n                    if (arg.hasOwnProperty(k)) {\n                        if (arg[k] !== undefined &&\n                            arg[k] !== null) {\n                            node.setAttribute(k, arg[k]);\n                        }\n                    }\n                }\n            }\n        }\n\n        return node;\n    },\n\n    /*  Function: xmlescape\n     *  Excapes invalid xml characters.\n     *\n     *  Parameters:\n     *     (String) text - text to escape.\n     *\n     *  Returns:\n     *      Escaped text.\n     */\n    xmlescape: function(text) {\n        text = text.replace(/\\&/g, \"&amp;\");\n        text = text.replace(/</g,  \"&lt;\");\n        text = text.replace(/>/g,  \"&gt;\");\n        text = text.replace(/'/g,  \"&apos;\");\n        text = text.replace(/\"/g,  \"&quot;\");\n        return text;\n    },\n\n    /*  Function: xmlunescape\n    *  Unexcapes invalid xml characters.\n    *\n    *  Parameters:\n    *     (String) text - text to unescape.\n    *\n    *  Returns:\n    *      Unescaped text.\n    */\n    xmlunescape: function(text) {\n        text = text.replace(/\\&amp;/g, \"&\");\n        text = text.replace(/&lt;/g,  \"<\");\n        text = text.replace(/&gt;/g,  \">\");\n        text = text.replace(/&apos;/g,  \"'\");\n        text = text.replace(/&quot;/g,  \"\\\"\");\n        return text;\n    },\n\n    /** Function: xmlTextNode\n     *  Creates an XML DOM text node.\n     *\n     *  Provides a cross implementation version of document.createTextNode.\n     *\n     *  Parameters:\n     *    (String) text - The content of the text node.\n     *\n     *  Returns:\n     *    A new XML DOM text node.\n     */\n    xmlTextNode: function (text) {\n        return Strophe.xmlGenerator().createTextNode(text);\n    },\n\n    /** Function: xmlHtmlNode\n     *  Creates an XML DOM html node.\n     *\n     *  Parameters:\n     *    (String) html - The content of the html node.\n     *\n     *  Returns:\n     *    A new XML DOM text node.\n     */\n    xmlHtmlNode: function (html) {\n        var node;\n        //ensure text is escaped\n        if (DOMParser) {\n            var parser = new DOMParser();\n            node = parser.parseFromString(html, \"text/xml\");\n        } else {\n            node = new ActiveXObject(\"Microsoft.XMLDOM\");\n            node.async=\"false\";\n            node.loadXML(html);\n        }\n        return node;\n    },\n\n    /** Function: getText\n     *  Get the concatenation of all text children of an element.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    A String with the concatenated text of all text element children.\n     */\n    getText: function (elem) {\n        if (!elem) { return null; }\n\n        var str = \"\";\n        if (elem.childNodes.length === 0 && elem.nodeType === Strophe.ElementType.TEXT) {\n            str += elem.nodeValue;\n        }\n\n        for (var i = 0; i < elem.childNodes.length; i++) {\n            if (elem.childNodes[i].nodeType === Strophe.ElementType.TEXT) {\n                str += elem.childNodes[i].nodeValue;\n            }\n        }\n\n        return Strophe.xmlescape(str);\n    },\n\n    /** Function: copyElement\n     *  Copy an XML DOM element.\n     *\n     *  This function copies a DOM element and all its descendants and returns\n     *  the new copy.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    A new, copied DOM element tree.\n     */\n    copyElement: function (elem) {\n        var i, el;\n        if (elem.nodeType === Strophe.ElementType.NORMAL) {\n            el = Strophe.xmlElement(elem.tagName);\n\n            for (i = 0; i < elem.attributes.length; i++) {\n                el.setAttribute(elem.attributes[i].nodeName,\n                                elem.attributes[i].value);\n            }\n\n            for (i = 0; i < elem.childNodes.length; i++) {\n                el.appendChild(Strophe.copyElement(elem.childNodes[i]));\n            }\n        } else if (elem.nodeType === Strophe.ElementType.TEXT) {\n            el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);\n        }\n        return el;\n    },\n\n\n    /** Function: createHtml\n     *  Copy an HTML DOM element into an XML DOM.\n     *\n     *  This function copies a DOM element and all its descendants and returns\n     *  the new copy.\n     *\n     *  Parameters:\n     *    (HTMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    A new, copied DOM element tree.\n     */\n    createHtml: function (elem) {\n        var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;\n        if (elem.nodeType === Strophe.ElementType.NORMAL) {\n            tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.\n            if(Strophe.XHTML.validTag(tag)) {\n                try {\n                    el = Strophe.xmlElement(tag);\n                    for(i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {\n                        attribute = Strophe.XHTML.attributes[tag][i];\n                        value = elem.getAttribute(attribute);\n                        if(typeof value === 'undefined' || value === null || value === '' || value === false || value === 0) {\n                            continue;\n                        }\n                        if(attribute === 'style' && typeof value === 'object') {\n                            if(typeof value.cssText !== 'undefined') {\n                                value = value.cssText; // we're dealing with IE, need to get CSS out\n                            }\n                        }\n                        // filter out invalid css styles\n                        if(attribute === 'style') {\n                            css = [];\n                            cssAttrs = value.split(';');\n                            for(j = 0; j < cssAttrs.length; j++) {\n                                attr = cssAttrs[j].split(':');\n                                cssName = attr[0].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\").toLowerCase();\n                                if(Strophe.XHTML.validCSS(cssName)) {\n                                    cssValue = attr[1].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n                                    css.push(cssName + ': ' + cssValue);\n                                }\n                            }\n                            if(css.length > 0) {\n                                value = css.join('; ');\n                                el.setAttribute(attribute, value);\n                            }\n                        } else {\n                            el.setAttribute(attribute, value);\n                        }\n                    }\n\n                    for (i = 0; i < elem.childNodes.length; i++) {\n                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n                    }\n                } catch(e) { // invalid elements\n                  el = Strophe.xmlTextNode('');\n                }\n            } else {\n                el = Strophe.xmlGenerator().createDocumentFragment();\n                for (i = 0; i < elem.childNodes.length; i++) {\n                    el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n                }\n            }\n        } else if (elem.nodeType === Strophe.ElementType.FRAGMENT) {\n            el = Strophe.xmlGenerator().createDocumentFragment();\n            for (i = 0; i < elem.childNodes.length; i++) {\n                el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n            }\n        } else if (elem.nodeType === Strophe.ElementType.TEXT) {\n            el = Strophe.xmlTextNode(elem.nodeValue);\n        }\n        return el;\n    },\n\n    /** Function: escapeNode\n     *  Escape the node part (also called local part) of a JID.\n     *\n     *  Parameters:\n     *    (String) node - A node (or local part).\n     *\n     *  Returns:\n     *    An escaped node (or local part).\n     */\n    escapeNode: function (node) {\n        if (typeof node !== \"string\") { return node; }\n        return node.replace(/^\\s+|\\s+$/g, '')\n            .replace(/\\\\/g,  \"\\\\5c\")\n            .replace(/ /g,   \"\\\\20\")\n            .replace(/\\\"/g,  \"\\\\22\")\n            .replace(/\\&/g,  \"\\\\26\")\n            .replace(/\\'/g,  \"\\\\27\")\n            .replace(/\\//g,  \"\\\\2f\")\n            .replace(/:/g,   \"\\\\3a\")\n            .replace(/</g,   \"\\\\3c\")\n            .replace(/>/g,   \"\\\\3e\")\n            .replace(/@/g,   \"\\\\40\");\n    },\n\n    /** Function: unescapeNode\n     *  Unescape a node part (also called local part) of a JID.\n     *\n     *  Parameters:\n     *    (String) node - A node (or local part).\n     *\n     *  Returns:\n     *    An unescaped node (or local part).\n     */\n    unescapeNode: function (node) {\n        if (typeof node !== \"string\") { return node; }\n        return node.replace(/\\\\20/g, \" \")\n            .replace(/\\\\22/g, '\"')\n            .replace(/\\\\26/g, \"&\")\n            .replace(/\\\\27/g, \"'\")\n            .replace(/\\\\2f/g, \"/\")\n            .replace(/\\\\3a/g, \":\")\n            .replace(/\\\\3c/g, \"<\")\n            .replace(/\\\\3e/g, \">\")\n            .replace(/\\\\40/g, \"@\")\n            .replace(/\\\\5c/g, \"\\\\\");\n    },\n\n    /** Function: getNodeFromJid\n     *  Get the node portion of a JID String.\n     *\n     *  Parameters:\n     *    (String) jid - A JID.\n     *\n     *  Returns:\n     *    A String containing the node.\n     */\n    getNodeFromJid: function (jid) {\n        if (jid.indexOf(\"@\") < 0) { return null; }\n        return jid.split(\"@\")[0];\n    },\n\n    /** Function: getDomainFromJid\n     *  Get the domain portion of a JID String.\n     *\n     *  Parameters:\n     *    (String) jid - A JID.\n     *\n     *  Returns:\n     *    A String containing the domain.\n     */\n    getDomainFromJid: function (jid) {\n        var bare = Strophe.getBareJidFromJid(jid);\n        if (bare.indexOf(\"@\") < 0) {\n            return bare;\n        } else {\n            var parts = bare.split(\"@\");\n            parts.splice(0, 1);\n            return parts.join('@');\n        }\n    },\n\n    /** Function: getResourceFromJid\n     *  Get the resource portion of a JID String.\n     *\n     *  Parameters:\n     *    (String) jid - A JID.\n     *\n     *  Returns:\n     *    A String containing the resource.\n     */\n    getResourceFromJid: function (jid) {\n        var s = jid.split(\"/\");\n        if (s.length < 2) { return null; }\n        s.splice(0, 1);\n        return s.join('/');\n    },\n\n    /** Function: getBareJidFromJid\n     *  Get the bare JID from a JID String.\n     *\n     *  Parameters:\n     *    (String) jid - A JID.\n     *\n     *  Returns:\n     *    A String containing the bare JID.\n     */\n    getBareJidFromJid: function (jid) {\n        return jid ? jid.split(\"/\")[0] : null;\n    },\n\n    /** PrivateFunction: _handleError\n     *  _Private_ function that properly logs an error to the console\n     */\n    _handleError: function (e) {\n        if (typeof e.stack !== \"undefined\") {\n            Strophe.fatal(e.stack);\n        }\n        if (e.sourceURL) {\n            Strophe.fatal(\"error: \" + this.handler + \" \" + e.sourceURL + \":\" +\n                          e.line + \" - \" + e.name + \": \" + e.message);\n        } else if (e.fileName) {\n            Strophe.fatal(\"error: \" + this.handler + \" \" +\n                          e.fileName + \":\" + e.lineNumber + \" - \" +\n                          e.name + \": \" + e.message);\n        } else {\n            Strophe.fatal(\"error: \" + e.message);\n        }\n    },\n\n    /** Function: log\n     *  User overrideable logging function.\n     *\n     *  This function is called whenever the Strophe library calls any\n     *  of the logging functions.  The default implementation of this\n     *  function logs only fatal errors.  If client code wishes to handle the logging\n     *  messages, it should override this with\n     *  > Strophe.log = function (level, msg) {\n     *  >   (user code here)\n     *  > };\n     *\n     *  Please note that data sent and received over the wire is logged\n     *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().\n     *\n     *  The different levels and their meanings are\n     *\n     *    DEBUG - Messages useful for debugging purposes.\n     *    INFO - Informational messages.  This is mostly information like\n     *      'disconnect was called' or 'SASL auth succeeded'.\n     *    WARN - Warnings about potential problems.  This is mostly used\n     *      to report transient connection errors like request timeouts.\n     *    ERROR - Some error occurred.\n     *    FATAL - A non-recoverable fatal error occurred.\n     *\n     *  Parameters:\n     *    (Integer) level - The log level of the log message.  This will\n     *      be one of the values in Strophe.LogLevel.\n     *    (String) msg - The log message.\n     */\n    log: function (level, msg) {\n        if (level === this.LogLevel.FATAL &&\n            typeof window.console === 'object' &&\n            typeof window.console.error === 'function') {\n            window.console.error(msg);\n        }\n    },\n\n    /** Function: debug\n     *  Log a message at the Strophe.LogLevel.DEBUG level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    debug: function(msg) {\n        this.log(this.LogLevel.DEBUG, msg);\n    },\n\n    /** Function: info\n     *  Log a message at the Strophe.LogLevel.INFO level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    info: function (msg) {\n        this.log(this.LogLevel.INFO, msg);\n    },\n\n    /** Function: warn\n     *  Log a message at the Strophe.LogLevel.WARN level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    warn: function (msg) {\n        this.log(this.LogLevel.WARN, msg);\n    },\n\n    /** Function: error\n     *  Log a message at the Strophe.LogLevel.ERROR level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    error: function (msg) {\n        this.log(this.LogLevel.ERROR, msg);\n    },\n\n    /** Function: fatal\n     *  Log a message at the Strophe.LogLevel.FATAL level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    fatal: function (msg) {\n        this.log(this.LogLevel.FATAL, msg);\n    },\n\n    /** Function: serialize\n     *  Render a DOM element and all descendants to a String.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    The serialized element tree as a String.\n     */\n    serialize: function (elem) {\n        var result;\n\n        if (!elem) { return null; }\n\n        if (typeof(elem.tree) === \"function\") {\n            elem = elem.tree();\n        }\n\n        var nodeName = elem.nodeName;\n        var i, child;\n\n        if (elem.getAttribute(\"_realname\")) {\n            nodeName = elem.getAttribute(\"_realname\");\n        }\n\n        result = \"<\" + nodeName;\n        for (i = 0; i < elem.attributes.length; i++) {\n             if(elem.attributes[i].nodeName !== \"_realname\") {\n               result += \" \" + elem.attributes[i].nodeName +\n                   \"='\" + Strophe.xmlescape(elem.attributes[i].value) + \"'\";\n             }\n        }\n\n        if (elem.childNodes.length > 0) {\n            result += \">\";\n            for (i = 0; i < elem.childNodes.length; i++) {\n                child = elem.childNodes[i];\n                switch( child.nodeType ){\n                  case Strophe.ElementType.NORMAL:\n                    // normal element, so recurse\n                    result += Strophe.serialize(child);\n                    break;\n                  case Strophe.ElementType.TEXT:\n                    // text element to escape values\n                    result += Strophe.xmlescape(child.nodeValue);\n                    break;\n                  case Strophe.ElementType.CDATA:\n                    // cdata section so don't escape values\n                    result += \"<![CDATA[\"+child.nodeValue+\"]]>\";\n                }\n            }\n            result += \"</\" + nodeName + \">\";\n        } else {\n            result += \"/>\";\n        }\n\n        return result;\n    },\n\n    /** PrivateVariable: _requestId\n     *  _Private_ variable that keeps track of the request ids for\n     *  connections.\n     */\n    _requestId: 0,\n\n    /** PrivateVariable: Strophe.connectionPlugins\n     *  _Private_ variable Used to store plugin names that need\n     *  initialization on Strophe.Connection construction.\n     */\n    _connectionPlugins: {},\n\n    /** Function: addConnectionPlugin\n     *  Extends the Strophe.Connection object with the given plugin.\n     *\n     *  Parameters:\n     *    (String) name - The name of the extension.\n     *    (Object) ptype - The plugin's prototype.\n     */\n    addConnectionPlugin: function (name, ptype) {\n        Strophe._connectionPlugins[name] = ptype;\n    }\n};\n\n/** Class: Strophe.Builder\n *  XML DOM builder.\n *\n *  This object provides an interface similar to JQuery but for building\n *  DOM elements easily and rapidly.  All the functions except for toString()\n *  and tree() return the object, so calls can be chained.  Here's an\n *  example using the $iq() builder helper.\n *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})\n *  >     .c('query', {xmlns: 'strophe:example'})\n *  >     .c('example')\n *  >     .toString()\n *\n *  The above generates this XML fragment\n *  > <iq to='you' from='me' type='get' id='1'>\n *  >   <query xmlns='strophe:example'>\n *  >     <example/>\n *  >   </query>\n *  > </iq>\n *  The corresponding DOM manipulations to get a similar fragment would be\n *  a lot more tedious and probably involve several helper variables.\n *\n *  Since adding children makes new operations operate on the child, up()\n *  is provided to traverse up the tree.  To add two children, do\n *  > builder.c('child1', ...).up().c('child2', ...)\n *  The next operation on the Builder will be relative to the second child.\n */\n\n/** Constructor: Strophe.Builder\n *  Create a Strophe.Builder object.\n *\n *  The attributes should be passed in object notation.  For example\n *  > var b = new Builder('message', {to: 'you', from: 'me'});\n *  or\n *  > var b = new Builder('messsage', {'xml:lang': 'en'});\n *\n *  Parameters:\n *    (String) name - The name of the root element.\n *    (Object) attrs - The attributes for the root element in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder.\n */\nStrophe.Builder = function (name, attrs) {\n    // Set correct namespace for jabber:client elements\n    if (name === \"presence\" || name === \"message\" || name === \"iq\") {\n        if (attrs && !attrs.xmlns) {\n            attrs.xmlns = Strophe.NS.CLIENT;\n        } else if (!attrs) {\n            attrs = {xmlns: Strophe.NS.CLIENT};\n        }\n    }\n\n    // Holds the tree being built.\n    this.nodeTree = Strophe.xmlElement(name, attrs);\n\n    // Points to the current operation node.\n    this.node = this.nodeTree;\n};\n\nStrophe.Builder.prototype = {\n    /** Function: tree\n     *  Return the DOM tree.\n     *\n     *  This function returns the current DOM tree as an element object.  This\n     *  is suitable for passing to functions like Strophe.Connection.send().\n     *\n     *  Returns:\n     *    The DOM tree as a element object.\n     */\n    tree: function () {\n        return this.nodeTree;\n    },\n\n    /** Function: toString\n     *  Serialize the DOM tree to a String.\n     *\n     *  This function returns a string serialization of the current DOM\n     *  tree.  It is often used internally to pass data to a\n     *  Strophe.Request object.\n     *\n     *  Returns:\n     *    The serialized DOM tree in a String.\n     */\n    toString: function () {\n        return Strophe.serialize(this.nodeTree);\n    },\n\n    /** Function: up\n     *  Make the current parent element the new current element.\n     *\n     *  This function is often used after c() to traverse back up the tree.\n     *  For example, to add two children to the same element\n     *  > builder.c('child1', {}).up().c('child2', {});\n     *\n     *  Returns:\n     *    The Stophe.Builder object.\n     */\n    up: function () {\n        this.node = this.node.parentNode;\n        return this;\n    },\n\n    /** Function: root\n     *  Make the root element the new current element.\n     *\n     *  When at a deeply nested element in the tree, this function can be used\n     *  to jump back to the root of the tree, instead of having to repeatedly\n     *  call up().\n     *\n     *  Returns:\n     *    The Stophe.Builder object.\n     */\n    root: function () {\n        this.node = this.nodeTree;\n        return this;\n    },\n\n    /** Function: attrs\n     *  Add or modify attributes of the current element.\n     *\n     *  The attributes should be passed in object notation.  This function\n     *  does not move the current element pointer.\n     *\n     *  Parameters:\n     *    (Object) moreattrs - The attributes to add/modify in object notation.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    attrs: function (moreattrs) {\n        for (var k in moreattrs) {\n            if (moreattrs.hasOwnProperty(k)) {\n                if (moreattrs[k] === undefined) {\n                    this.node.removeAttribute(k);\n                } else {\n                    this.node.setAttribute(k, moreattrs[k]);\n                }\n            }\n        }\n        return this;\n    },\n\n    /** Function: c\n     *  Add a child to the current element and make it the new current\n     *  element.\n     *\n     *  This function moves the current element pointer to the child,\n     *  unless text is provided.  If you need to add another child, it\n     *  is necessary to use up() to go back to the parent in the tree.\n     *\n     *  Parameters:\n     *    (String) name - The name of the child.\n     *    (Object) attrs - The attributes of the child in object notation.\n     *    (String) text - The text to add to the child.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    c: function (name, attrs, text) {\n        var child = Strophe.xmlElement(name, attrs, text);\n        this.node.appendChild(child);\n        if (typeof text !== \"string\" && typeof text !==\"number\") {\n            this.node = child;\n        }\n        return this;\n    },\n\n    /** Function: cnode\n     *  Add a child to the current element and make it the new current\n     *  element.\n     *\n     *  This function is the same as c() except that instead of using a\n     *  name and an attributes object to create the child it uses an\n     *  existing DOM element object.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    cnode: function (elem) {\n        var impNode;\n        var xmlGen = Strophe.xmlGenerator();\n        try {\n            impNode = (xmlGen.importNode !== undefined);\n        } catch (e) {\n            impNode = false;\n        }\n        var newElem = impNode ?\n                      xmlGen.importNode(elem, true) :\n                      Strophe.copyElement(elem);\n        this.node.appendChild(newElem);\n        this.node = newElem;\n        return this;\n    },\n\n    /** Function: t\n     *  Add a child text element.\n     *\n     *  This *does not* make the child the new current element since there\n     *  are no children of text elements.\n     *\n     *  Parameters:\n     *    (String) text - The text data to append to the current element.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    t: function (text) {\n        var child = Strophe.xmlTextNode(text);\n        this.node.appendChild(child);\n        return this;\n    },\n\n    /** Function: h\n     *  Replace current element contents with the HTML passed in.\n     *\n     *  This *does not* make the child the new current element\n     *\n     *  Parameters:\n     *    (String) html - The html to insert as contents of current element.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    h: function (html) {\n        var fragment = document.createElement('body');\n\n        // force the browser to try and fix any invalid HTML tags\n        fragment.innerHTML = html;\n\n        // copy cleaned html into an xml dom\n        var xhtml = Strophe.createHtml(fragment);\n\n        while(xhtml.childNodes.length > 0) {\n            this.node.appendChild(xhtml.childNodes[0]);\n        }\n        return this;\n    }\n};\n\n/** PrivateClass: Strophe.Handler\n *  _Private_ helper class for managing stanza handlers.\n *\n *  A Strophe.Handler encapsulates a user provided callback function to be\n *  executed when matching stanzas are received by the connection.\n *  Handlers can be either one-off or persistant depending on their\n *  return value. Returning true will cause a Handler to remain active, and\n *  returning false will remove the Handler.\n *\n *  Users will not use Strophe.Handler objects directly, but instead they\n *  will use Strophe.Connection.addHandler() and\n *  Strophe.Connection.deleteHandler().\n */\n\n/** PrivateConstructor: Strophe.Handler\n *  Create and initialize a new Strophe.Handler.\n *\n *  Parameters:\n *    (Function) handler - A function to be executed when the handler is run.\n *    (String) ns - The namespace to match.\n *    (String) name - The element name to match.\n *    (String) type - The element type to match.\n *    (String) id - The element id attribute to match.\n *    (String) from - The element from attribute to match.\n *    (Object) options - Handler options\n *\n *  Returns:\n *    A new Strophe.Handler object.\n */\nStrophe.Handler = function (handler, ns, name, type, id, from, options) {\n    this.handler = handler;\n    this.ns = ns;\n    this.name = name;\n    this.type = type;\n    this.id = id;\n    this.options = options || {'matchBareFromJid': false, 'ignoreNamespaceFragment': false};\n    // BBB: Maintain backward compatibility with old `matchBare` option\n    if (this.options.matchBare) {\n        Strophe.warn('The \"matchBare\" option is deprecated, use \"matchBareFromJid\" instead.');\n        this.options.matchBareFromJid = this.options.matchBare;\n        delete this.options.matchBare;\n    }\n\n    if (this.options.matchBareFromJid) {\n        this.from = from ? Strophe.getBareJidFromJid(from) : null;\n    } else {\n        this.from = from;\n    }\n    // whether the handler is a user handler or a system handler\n    this.user = true;\n};\n\nStrophe.Handler.prototype = {\n    /** PrivateFunction: getNamespace\n     *  Returns the XML namespace attribute on an element.\n     *  If `ignoreNamespaceFragment` was passed in for this handler, then the\n     *  URL fragment will be stripped.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XML element with the namespace.\n     *\n     *  Returns:\n     *    The namespace, with optionally the fragment stripped.\n     */\n    getNamespace: function (elem) {\n        var elNamespace = elem.getAttribute(\"xmlns\");\n        if (elNamespace && this.options.ignoreNamespaceFragment) {\n            elNamespace = elNamespace.split('#')[0];\n        }\n        return elNamespace;\n    },\n\n    /** PrivateFunction: namespaceMatch\n     *  Tests if a stanza matches the namespace set for this Strophe.Handler.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XML element to test.\n     *\n     *  Returns:\n     *    true if the stanza matches and false otherwise.\n     */\n    namespaceMatch: function (elem) {\n        var nsMatch = false;\n        if (!this.ns) {\n            return true;\n        } else {\n            var that = this;\n            Strophe.forEachChild(elem, null, function (elem) {\n                if (that.getNamespace(elem) === that.ns) {\n                    nsMatch = true;\n                }\n            });\n            nsMatch = nsMatch || this.getNamespace(elem) === this.ns;\n        }\n        return nsMatch;\n    },\n\n    /** PrivateFunction: isMatch\n     *  Tests if a stanza matches the Strophe.Handler.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XML element to test.\n     *\n     *  Returns:\n     *    true if the stanza matches and false otherwise.\n     */\n    isMatch: function (elem) {\n        var from = elem.getAttribute('from');\n        if (this.options.matchBareFromJid) {\n            from = Strophe.getBareJidFromJid(from);\n        }\n        var elem_type = elem.getAttribute(\"type\");\n        if (this.namespaceMatch(elem) &&\n            (!this.name || Strophe.isTagEqual(elem, this.name)) &&\n            (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) !== -1 : elem_type === this.type)) &&\n            (!this.id || elem.getAttribute(\"id\") === this.id) &&\n            (!this.from || from === this.from)) {\n                return true;\n        }\n        return false;\n    },\n\n    /** PrivateFunction: run\n     *  Run the callback on a matching stanza.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The DOM element that triggered the\n     *      Strophe.Handler.\n     *\n     *  Returns:\n     *    A boolean indicating if the handler should remain active.\n     */\n    run: function (elem) {\n        var result = null;\n        try {\n            result = this.handler(elem);\n        } catch (e) {\n            Strophe._handleError(e);\n            throw e;\n        }\n        return result;\n    },\n\n    /** PrivateFunction: toString\n     *  Get a String representation of the Strophe.Handler object.\n     *\n     *  Returns:\n     *    A String.\n     */\n    toString: function () {\n        return \"{Handler: \" + this.handler + \"(\" + this.name + \",\" +\n            this.id + \",\" + this.ns + \")}\";\n    }\n};\n\n/** PrivateClass: Strophe.TimedHandler\n *  _Private_ helper class for managing timed handlers.\n *\n *  A Strophe.TimedHandler encapsulates a user provided callback that\n *  should be called after a certain period of time or at regular\n *  intervals.  The return value of the callback determines whether the\n *  Strophe.TimedHandler will continue to fire.\n *\n *  Users will not use Strophe.TimedHandler objects directly, but instead\n *  they will use Strophe.Connection.addTimedHandler() and\n *  Strophe.Connection.deleteTimedHandler().\n */\n\n/** PrivateConstructor: Strophe.TimedHandler\n *  Create and initialize a new Strophe.TimedHandler object.\n *\n *  Parameters:\n *    (Integer) period - The number of milliseconds to wait before the\n *      handler is called.\n *    (Function) handler - The callback to run when the handler fires.  This\n *      function should take no arguments.\n *\n *  Returns:\n *    A new Strophe.TimedHandler object.\n */\nStrophe.TimedHandler = function (period, handler) {\n    this.period = period;\n    this.handler = handler;\n    this.lastCalled = new Date().getTime();\n    this.user = true;\n};\n\nStrophe.TimedHandler.prototype = {\n    /** PrivateFunction: run\n     *  Run the callback for the Strophe.TimedHandler.\n     *\n     *  Returns:\n     *    true if the Strophe.TimedHandler should be called again, and false\n     *      otherwise.\n     */\n    run: function () {\n        this.lastCalled = new Date().getTime();\n        return this.handler();\n    },\n\n    /** PrivateFunction: reset\n     *  Reset the last called time for the Strophe.TimedHandler.\n     */\n    reset: function () {\n        this.lastCalled = new Date().getTime();\n    },\n\n    /** PrivateFunction: toString\n     *  Get a string representation of the Strophe.TimedHandler object.\n     *\n     *  Returns:\n     *    The string representation.\n     */\n    toString: function () {\n        return \"{TimedHandler: \" + this.handler + \"(\" + this.period +\")}\";\n    }\n};\n\n/** Class: Strophe.Connection\n *  XMPP Connection manager.\n *\n *  This class is the main part of Strophe.  It manages a BOSH or websocket\n *  connection to an XMPP server and dispatches events to the user callbacks\n *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1\n *  and legacy authentication.\n *\n *  After creating a Strophe.Connection object, the user will typically\n *  call connect() with a user supplied callback to handle connection level\n *  events like authentication failure, disconnection, or connection\n *  complete.\n *\n *  The user will also have several event handlers defined by using\n *  addHandler() and addTimedHandler().  These will allow the user code to\n *  respond to interesting stanzas or do something periodically with the\n *  connection. These handlers will be active once authentication is\n *  finished.\n *\n *  To send data to the connection, use send().\n */\n\n/** Constructor: Strophe.Connection\n *  Create and initialize a Strophe.Connection object.\n *\n *  The transport-protocol for this connection will be chosen automatically\n *  based on the given service parameter. URLs starting with \"ws://\" or\n *  \"wss://\" will use WebSockets, URLs starting with \"http://\", \"https://\"\n *  or without a protocol will use BOSH.\n *\n *  To make Strophe connect to the current host you can leave out the protocol\n *  and host part and just pass the path, e.g.\n *\n *  > var conn = new Strophe.Connection(\"/http-bind/\");\n *\n *  Options common to both Websocket and BOSH:\n *  ------------------------------------------\n *\n *  cookies:\n *\n *  The *cookies* option allows you to pass in cookies to be added to the\n *  document. These cookies will then be included in the BOSH XMLHttpRequest\n *  or in the websocket connection.\n *\n *  The passed in value must be a map of cookie names and string values.\n *\n *  > { \"myCookie\": {\n *  >     \"value\": \"1234\",\n *  >     \"domain\": \".example.org\",\n *  >     \"path\": \"/\",\n *  >     \"expires\": expirationDate\n *  >     }\n *  > }\n *\n *  Note that cookies can't be set in this way for other domains (i.e. cross-domain).\n *  Those cookies need to be set under those domains, for example they can be\n *  set server-side by making a XHR call to that domain to ask it to set any\n *  necessary cookies.\n *\n *  mechanisms:\n *\n *  The *mechanisms* option allows you to specify the SASL mechanisms that this\n *  instance of Strophe.Connection (and therefore your XMPP client) will\n *  support.\n *\n *  The value must be an array of objects with Strophe.SASLMechanism\n *  prototypes.\n *\n *  If nothing is specified, then the following mechanisms (and their\n *  priorities) are registered:\n *\n *      SCRAM-SHA1 - 70\n *      DIGEST-MD5 - 60\n *      PLAIN - 50\n *      OAUTH-BEARER - 40\n *      OAUTH-2 - 30\n *      ANONYMOUS - 20\n *      EXTERNAL - 10\n *\n *  WebSocket options:\n *  ------------------\n *\n *  If you want to connect to the current host with a WebSocket connection you\n *  can tell Strophe to use WebSockets through a \"protocol\" attribute in the\n *  optional options parameter. Valid values are \"ws\" for WebSocket and \"wss\"\n *  for Secure WebSocket.\n *  So to connect to \"wss://CURRENT_HOSTNAME/xmpp-websocket\" you would call\n *\n *  > var conn = new Strophe.Connection(\"/xmpp-websocket/\", {protocol: \"wss\"});\n *\n *  Note that relative URLs _NOT_ starting with a \"/\" will also include the path\n *  of the current site.\n *\n *  Also because downgrading security is not permitted by browsers, when using\n *  relative URLs both BOSH and WebSocket connections will use their secure\n *  variants if the current connection to the site is also secure (https).\n *\n *  BOSH options:\n *  -------------\n *\n *  By adding \"sync\" to the options, you can control if requests will\n *  be made synchronously or not. The default behaviour is asynchronous.\n *  If you want to make requests synchronous, make \"sync\" evaluate to true.\n *  > var conn = new Strophe.Connection(\"/http-bind/\", {sync: true});\n *\n *  You can also toggle this on an already established connection.\n *  > conn.options.sync = true;\n *\n *  The *customHeaders* option can be used to provide custom HTTP headers to be\n *  included in the XMLHttpRequests made.\n *\n *  The *keepalive* option can be used to instruct Strophe to maintain the\n *  current BOSH session across interruptions such as webpage reloads.\n *\n *  It will do this by caching the sessions tokens in sessionStorage, and when\n *  \"restore\" is called it will check whether there are cached tokens with\n *  which it can resume an existing session.\n *\n *  The *withCredentials* option should receive a Boolean value and is used to\n *  indicate wether cookies should be included in ajax requests (by default\n *  they're not).\n *  Set this value to true if you are connecting to a BOSH service\n *  and for some reason need to send cookies to it.\n *  In order for this to work cross-domain, the server must also enable\n *  credentials by setting the Access-Control-Allow-Credentials response header\n *  to \"true\". For most usecases however this setting should be false (which\n *  is the default).\n *  Additionally, when using Access-Control-Allow-Credentials, the\n *  Access-Control-Allow-Origin header can't be set to the wildcard \"*\", but\n *  instead must be restricted to actual domains.\n *\n *  The *contentType* option can be set to change the default Content-Type\n *  of \"text/xml; charset=utf-8\", which can be useful to reduce the amount of\n *  CORS preflight requests that are sent to the server.\n *\n *  Parameters:\n *    (String) service - The BOSH or WebSocket service URL.\n *    (Object) options - A hash of configuration options\n *\n *  Returns:\n *    A new Strophe.Connection object.\n */\nStrophe.Connection = function (service, options) {\n    // The service URL\n    this.service = service;\n    // Configuration options\n    this.options = options || {};\n    var proto = this.options.protocol || \"\";\n\n    // Select protocal based on service or options\n    if (service.indexOf(\"ws:\") === 0 || service.indexOf(\"wss:\") === 0 ||\n            proto.indexOf(\"ws\") === 0) {\n        this._proto = new Strophe.Websocket(this);\n    } else {\n        this._proto = new Strophe.Bosh(this);\n    }\n\n    /* The connected JID. */\n    this.jid = \"\";\n    /* the JIDs domain */\n    this.domain = null;\n    /* stream:features */\n    this.features = null;\n\n    // SASL\n    this._sasl_data = {};\n    this.do_session = false;\n    this.do_bind = false;\n\n    // handler lists\n    this.timedHandlers = [];\n    this.handlers = [];\n    this.removeTimeds = [];\n    this.removeHandlers = [];\n    this.addTimeds = [];\n    this.addHandlers = [];\n    this.protocolErrorHandlers = {\n        'HTTP': {},\n        'websocket': {}\n    };\n\n    this._idleTimeout = null;\n    this._disconnectTimeout = null;\n\n    this.authenticated = false;\n    this.connected = false;\n    this.disconnecting = false;\n    this.do_authentication = true;\n    this.paused = false;\n    this.restored = false;\n\n    this._data = [];\n    this._uniqueId = 0;\n\n    this._sasl_success_handler = null;\n    this._sasl_failure_handler = null;\n    this._sasl_challenge_handler = null;\n\n    // Max retries before disconnecting\n    this.maxRetries = 5;\n\n    // Call onIdle callback every 1/10th of a second\n    // XXX: setTimeout should be called only with function expressions (23974bc1)\n    this._idleTimeout = setTimeout(function() {\n        this._onIdle();\n    }.bind(this), 100);\n\n    utils.addCookies(this.options.cookies);\n    this.registerSASLMechanisms(this.options.mechanisms);\n\n    // initialize plugins\n    for (var k in Strophe._connectionPlugins) {\n        if (Strophe._connectionPlugins.hasOwnProperty(k)) {\n            var ptype = Strophe._connectionPlugins[k];\n            // jslint complaints about the below line, but this is fine\n            var F = function () {}; // jshint ignore:line\n            F.prototype = ptype;\n            this[k] = new F();\n            this[k].init(this);\n        }\n    }\n};\n\nStrophe.Connection.prototype = {\n    /** Function: reset\n     *  Reset the connection.\n     *\n     *  This function should be called after a connection is disconnected\n     *  before that connection is reused.\n     */\n    reset: function () {\n        this._proto._reset();\n\n        // SASL\n        this.do_session = false;\n        this.do_bind = false;\n\n        // handler lists\n        this.timedHandlers = [];\n        this.handlers = [];\n        this.removeTimeds = [];\n        this.removeHandlers = [];\n        this.addTimeds = [];\n        this.addHandlers = [];\n\n        this.authenticated = false;\n        this.connected = false;\n        this.disconnecting = false;\n        this.restored = false;\n\n        this._data = [];\n        this._requests = [];\n        this._uniqueId = 0;\n    },\n\n    /** Function: pause\n     *  Pause the request manager.\n     *\n     *  This will prevent Strophe from sending any more requests to the\n     *  server.  This is very useful for temporarily pausing\n     *  BOSH-Connections while a lot of send() calls are happening quickly.\n     *  This causes Strophe to send the data in a single request, saving\n     *  many request trips.\n     */\n    pause: function () {\n        this.paused = true;\n    },\n\n    /** Function: resume\n     *  Resume the request manager.\n     *\n     *  This resumes after pause() has been called.\n     */\n    resume: function () {\n        this.paused = false;\n    },\n\n    /** Function: getUniqueId\n     *  Generate a unique ID for use in <iq/> elements.\n     *\n     *  All <iq/> stanzas are required to have unique id attributes.  This\n     *  function makes creating these easy.  Each connection instance has\n     *  a counter which starts from zero, and the value of this counter\n     *  plus a colon followed by the suffix becomes the unique id. If no\n     *  suffix is supplied, the counter is used as the unique id.\n     *\n     *  Suffixes are used to make debugging easier when reading the stream\n     *  data, and their use is recommended.  The counter resets to 0 for\n     *  every new connection for the same reason.  For connections to the\n     *  same server that authenticate the same way, all the ids should be\n     *  the same, which makes it easy to see changes.  This is useful for\n     *  automated testing as well.\n     *\n     *  Parameters:\n     *    (String) suffix - A optional suffix to append to the id.\n     *\n     *  Returns:\n     *    A unique string to be used for the id attribute.\n     */\n    getUniqueId: function(suffix) {\n        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n            var r = Math.random() * 16 | 0,\n                v = c === 'x' ? r : r & 0x3 | 0x8;\n            return v.toString(16);\n        });\n        if (typeof(suffix) === \"string\" || typeof(suffix) === \"number\") {\n            return uuid + \":\" + suffix;\n        } else {\n            return uuid + \"\";\n        }\n    },\n\n    /** Function: addProtocolErrorHandler\n     *  Register a handler function for when a protocol (websocker or HTTP)\n     *  error occurs.\n     *\n     *  NOTE: Currently only HTTP errors for BOSH requests are handled.\n     *  Patches that handle websocket errors would be very welcome.\n     *\n     *  Parameters:\n     *    (String) protocol - 'HTTP' or 'websocket'\n     *    (Integer) status_code - Error status code (e.g 500, 400 or 404)\n     *    (Function) callback - Function that will fire on Http error\n     *\n     *  Example:\n     *  function onError(err_code){\n     *    //do stuff\n     *  }\n     *\n     *  var conn = Strophe.connect('http://example.com/http-bind');\n     *  conn.addProtocolErrorHandler('HTTP', 500, onError);\n     *  // Triggers HTTP 500 error and onError handler will be called\n     *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);\n     */\n    addProtocolErrorHandler: function(protocol, status_code, callback){\n        this.protocolErrorHandlers[protocol][status_code] = callback;\n    },\n\n\n    /** Function: connect\n     *  Starts the connection process.\n     *\n     *  As the connection process proceeds, the user supplied callback will\n     *  be triggered multiple times with status updates.  The callback\n     *  should take two arguments - the status code and the error condition.\n     *\n     *  The status code will be one of the values in the Strophe.Status\n     *  constants.  The error condition will be one of the conditions\n     *  defined in RFC 3920 or the condition 'strophe-parsererror'.\n     *\n     *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant\n     *  for BOSH connections. Please see XEP 124 for a more detailed explanation\n     *  of the optional parameters.\n     *\n     *  Parameters:\n     *    (String) jid - The user's JID.  This may be a bare JID,\n     *      or a full JID.  If a node is not supplied, SASL OAUTHBEARER or\n     *      SASL ANONYMOUS authentication will be attempted (OAUTHBEARER will\n     *      process the provided password value as an access token).\n     *    (String) pass - The user's password.\n     *    (Function) callback - The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (String) route - The optional route value.\n     *    (String) authcid - The optional alternative authentication identity\n     *      (username) if intending to impersonate another user.\n     *      When using the SASL-EXTERNAL authentication mechanism, for example\n     *      with client certificates, then the authcid value is used to\n     *      determine whether an authorization JID (authzid) should be sent to\n     *      the server. The authzid should not be sent to the server if the\n     *      authzid and authcid are the same. So to prevent it from being sent\n     *      (for example when the JID is already contained in the client\n     *      certificate), set authcid to that same JID. See XEP-178 for more\n     *      details.\n     */\n    connect: function (jid, pass, callback, wait, hold, route, authcid) {\n        this.jid = jid;\n        /** Variable: authzid\n         *  Authorization identity.\n         */\n        this.authzid = Strophe.getBareJidFromJid(this.jid);\n\n        /** Variable: authcid\n         *  Authentication identity (User name).\n         */\n        this.authcid = authcid || Strophe.getNodeFromJid(this.jid);\n\n        /** Variable: pass\n         *  Authentication identity (User password).\n         */\n        this.pass = pass;\n\n        /** Variable: servtype\n         *  Digest MD5 compatibility.\n         */\n        this.servtype = \"xmpp\";\n\n        this.connect_callback = callback;\n        this.disconnecting = false;\n        this.connected = false;\n        this.authenticated = false;\n        this.restored = false;\n\n        // parse jid for domain\n        this.domain = Strophe.getDomainFromJid(this.jid);\n\n        this._changeConnectStatus(Strophe.Status.CONNECTING, null);\n\n        this._proto._connect(wait, hold, route);\n    },\n\n    /** Function: attach\n     *  Attach to an already created and authenticated BOSH session.\n     *\n     *  This function is provided to allow Strophe to attach to BOSH\n     *  sessions which have been created externally, perhaps by a Web\n     *  application.  This is often used to support auto-login type features\n     *  without putting user credentials into the page.\n     *\n     *  Parameters:\n     *    (String) jid - The full JID that is bound by the session.\n     *    (String) sid - The SID of the BOSH session.\n     *    (String) rid - The current RID of the BOSH session.  This RID\n     *      will be used by the next request.\n     *    (Function) callback The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\n     *      allowed range of request ids that are valid.  The default is 5.\n     */\n    attach: function (jid, sid, rid, callback, wait, hold, wind) {\n        if (this._proto instanceof Strophe.Bosh) {\n            this._proto._attach(jid, sid, rid, callback, wait, hold, wind);\n        } else {\n            throw {\n                name: 'StropheSessionError',\n                message: 'The \"attach\" method can only be used with a BOSH connection.'\n            };\n        }\n    },\n\n    /** Function: restore\n     *  Attempt to restore a cached BOSH session.\n     *\n     *  This function is only useful in conjunction with providing the\n     *  \"keepalive\":true option when instantiating a new Strophe.Connection.\n     *\n     *  When \"keepalive\" is set to true, Strophe will cache the BOSH tokens\n     *  RID (Request ID) and SID (Session ID) and then when this function is\n     *  called, it will attempt to restore the session from those cached\n     *  tokens.\n     *\n     *  This function must therefore be called instead of connect or attach.\n     *\n     *  For an example on how to use it, please see examples/restore.js\n     *\n     *  Parameters:\n     *    (String) jid - The user's JID.  This may be a bare JID or a full JID.\n     *    (Function) callback - The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\n     *      allowed range of request ids that are valid.  The default is 5.\n     */\n    restore: function (jid, callback, wait, hold, wind) {\n        if (this._sessionCachingSupported()) {\n            this._proto._restore(jid, callback, wait, hold, wind);\n        } else {\n            throw {\n                name: 'StropheSessionError',\n                message: 'The \"restore\" method can only be used with a BOSH connection.'\n            };\n        }\n    },\n\n    /** PrivateFunction: _sessionCachingSupported\n     * Checks whether sessionStorage and JSON are supported and whether we're\n     * using BOSH.\n     */\n    _sessionCachingSupported: function () {\n        if (this._proto instanceof Strophe.Bosh) {\n            if (!JSON) { return false; }\n            try {\n                sessionStorage.setItem('_strophe_', '_strophe_');\n                sessionStorage.removeItem('_strophe_');\n            } catch (e) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    },\n\n    /** Function: xmlInput\n     *  User overrideable function that receives XML data coming into the\n     *  connection.\n     *\n     *  The default function does nothing.  User code can override this with\n     *  > Strophe.Connection.xmlInput = function (elem) {\n     *  >   (user code)\n     *  > };\n     *\n     *  Due to limitations of current Browsers' XML-Parsers the opening and closing\n     *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\n     *\n     *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\n     *  <Strophe.Bosh.strip> if you want to strip this tag.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XML data received by the connection.\n     */\n    /* jshint unused:false */\n    xmlInput: function (elem) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: xmlOutput\n     *  User overrideable function that receives XML data sent to the\n     *  connection.\n     *\n     *  The default function does nothing.  User code can override this with\n     *  > Strophe.Connection.xmlOutput = function (elem) {\n     *  >   (user code)\n     *  > };\n     *\n     *  Due to limitations of current Browsers' XML-Parsers the opening and closing\n     *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\n     *\n     *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\n     *  <Strophe.Bosh.strip> if you want to strip this tag.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XMLdata sent by the connection.\n     */\n    /* jshint unused:false */\n    xmlOutput: function (elem) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: rawInput\n     *  User overrideable function that receives raw data coming into the\n     *  connection.\n     *\n     *  The default function does nothing.  User code can override this with\n     *  > Strophe.Connection.rawInput = function (data) {\n     *  >   (user code)\n     *  > };\n     *\n     *  Parameters:\n     *    (String) data - The data received by the connection.\n     */\n    /* jshint unused:false */\n    rawInput: function (data) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: rawOutput\n     *  User overrideable function that receives raw data sent to the\n     *  connection.\n     *\n     *  The default function does nothing.  User code can override this with\n     *  > Strophe.Connection.rawOutput = function (data) {\n     *  >   (user code)\n     *  > };\n     *\n     *  Parameters:\n     *    (String) data - The data sent by the connection.\n     */\n    /* jshint unused:false */\n    rawOutput: function (data) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: nextValidRid\n     *  User overrideable function that receives the new valid rid.\n     *\n     *  The default function does nothing. User code can override this with\n     *  > Strophe.Connection.nextValidRid = function (rid) {\n     *  >    (user code)\n     *  > };\n     *\n     *  Parameters:\n     *    (Number) rid - The next valid rid\n     */\n    /* jshint unused:false */\n    nextValidRid: function (rid) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: send\n     *  Send a stanza.\n     *\n     *  This function is called to push data onto the send queue to\n     *  go out over the wire.  Whenever a request is sent to the BOSH\n     *  server, all pending data is sent and the queue is flushed.\n     *\n     *  Parameters:\n     *    (XMLElement |\n     *     [XMLElement] |\n     *     Strophe.Builder) elem - The stanza to send.\n     */\n    send: function (elem) {\n        if (elem === null) { return ; }\n        if (typeof(elem.sort) === \"function\") {\n            for (var i = 0; i < elem.length; i++) {\n                this._queueData(elem[i]);\n            }\n        } else if (typeof(elem.tree) === \"function\") {\n            this._queueData(elem.tree());\n        } else {\n            this._queueData(elem);\n        }\n\n        this._proto._send();\n    },\n\n    /** Function: flush\n     *  Immediately send any pending outgoing data.\n     *\n     *  Normally send() queues outgoing data until the next idle period\n     *  (100ms), which optimizes network use in the common cases when\n     *  several send()s are called in succession. flush() can be used to\n     *  immediately send all pending data.\n     */\n    flush: function () {\n        // cancel the pending idle period and run the idle function\n        // immediately\n        clearTimeout(this._idleTimeout);\n        this._onIdle();\n    },\n\n    /** Function: sendPresence\n     *  Helper function to send presence stanzas. The main benefit is for\n     *  sending presence stanzas for which you expect a responding presence\n     *  stanza with the same id (for example when leaving a chat room).\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The stanza to send.\n     *    (Function) callback - The callback function for a successful request.\n     *    (Function) errback - The callback function for a failed or timed\n     *      out request.  On timeout, the stanza will be null.\n     *    (Integer) timeout - The time specified in milliseconds for a\n     *      timeout to occur.\n     *\n     *  Returns:\n     *    The id used to send the presence.\n     */\n    sendPresence: function(elem, callback, errback, timeout) {\n        var timeoutHandler = null;\n        var that = this;\n        if (typeof(elem.tree) === \"function\") {\n            elem = elem.tree();\n        }\n        var id = elem.getAttribute('id');\n        if (!id) { // inject id if not found\n            id = this.getUniqueId(\"sendPresence\");\n            elem.setAttribute(\"id\", id);\n        }\n\n        if (typeof callback === \"function\" || typeof errback === \"function\") {\n            var handler = this.addHandler(function (stanza) {\n                // remove timeout handler if there is one\n                if (timeoutHandler) {\n                    that.deleteTimedHandler(timeoutHandler);\n                }\n                var type = stanza.getAttribute('type');\n                if (type === 'error') {\n                    if (errback) {\n                        errback(stanza);\n                    }\n                } else if (callback) {\n                    callback(stanza);\n                }\n            }, null, 'presence', null, id);\n\n            // if timeout specified, set up a timeout handler.\n            if (timeout) {\n                timeoutHandler = this.addTimedHandler(timeout, function () {\n                    // get rid of normal handler\n                    that.deleteHandler(handler);\n                    // call errback on timeout with null stanza\n                    if (errback) {\n                        errback(null);\n                    }\n                    return false;\n                });\n            }\n        }\n        this.send(elem);\n        return id;\n    },\n\n    /** Function: sendIQ\n     *  Helper function to send IQ stanzas.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The stanza to send.\n     *    (Function) callback - The callback function for a successful request.\n     *    (Function) errback - The callback function for a failed or timed\n     *      out request.  On timeout, the stanza will be null.\n     *    (Integer) timeout - The time specified in milliseconds for a\n     *      timeout to occur.\n     *\n     *  Returns:\n     *    The id used to send the IQ.\n    */\n    sendIQ: function(elem, callback, errback, timeout) {\n        var timeoutHandler = null;\n        var that = this;\n        if (typeof(elem.tree) === \"function\") {\n            elem = elem.tree();\n        }\n        var id = elem.getAttribute('id');\n        if (!id) { // inject id if not found\n            id = this.getUniqueId(\"sendIQ\");\n            elem.setAttribute(\"id\", id);\n        }\n\n        if (typeof callback === \"function\" || typeof errback === \"function\") {\n            var handler = this.addHandler(function (stanza) {\n                // remove timeout handler if there is one\n                if (timeoutHandler) {\n                    that.deleteTimedHandler(timeoutHandler);\n                }\n                var iqtype = stanza.getAttribute('type');\n                if (iqtype === 'result') {\n                    if (callback) {\n                        callback(stanza);\n                    }\n                } else if (iqtype === 'error') {\n                    if (errback) {\n                        errback(stanza);\n                    }\n                } else {\n                    throw {\n                        name: \"StropheError\",\n                        message: \"Got bad IQ type of \" + iqtype\n                    };\n                }\n            }, null, 'iq', ['error', 'result'], id);\n\n            // if timeout specified, set up a timeout handler.\n            if (timeout) {\n                timeoutHandler = this.addTimedHandler(timeout, function () {\n                    // get rid of normal handler\n                    that.deleteHandler(handler);\n                    // call errback on timeout with null stanza\n                    if (errback) {\n                        errback(null);\n                    }\n                    return false;\n                });\n            }\n        }\n        this.send(elem);\n        return id;\n    },\n\n    /** PrivateFunction: _queueData\n     *  Queue outgoing data for later sending.  Also ensures that the data\n     *  is a DOMElement.\n     */\n    _queueData: function (element) {\n        if (element === null ||\n            !element.tagName ||\n            !element.childNodes) {\n            throw {\n                name: \"StropheError\",\n                message: \"Cannot queue non-DOMElement.\"\n            };\n        }\n        this._data.push(element);\n    },\n\n    /** PrivateFunction: _sendRestart\n     *  Send an xmpp:restart stanza.\n     */\n    _sendRestart: function () {\n        this._data.push(\"restart\");\n        this._proto._sendRestart();\n        // XXX: setTimeout should be called only with function expressions (23974bc1)\n        this._idleTimeout = setTimeout(function() {\n            this._onIdle();\n        }.bind(this), 100);\n    },\n\n    /** Function: addTimedHandler\n     *  Add a timed handler to the connection.\n     *\n     *  This function adds a timed handler.  The provided handler will\n     *  be called every period milliseconds until it returns false,\n     *  the connection is terminated, or the handler is removed.  Handlers\n     *  that wish to continue being invoked should return true.\n     *\n     *  Because of method binding it is necessary to save the result of\n     *  this function if you wish to remove a handler with\n     *  deleteTimedHandler().\n     *\n     *  Note that user handlers are not active until authentication is\n     *  successful.\n     *\n     *  Parameters:\n     *    (Integer) period - The period of the handler.\n     *    (Function) handler - The callback function.\n     *\n     *  Returns:\n     *    A reference to the handler that can be used to remove it.\n     */\n    addTimedHandler: function (period, handler) {\n        var thand = new Strophe.TimedHandler(period, handler);\n        this.addTimeds.push(thand);\n        return thand;\n    },\n\n    /** Function: deleteTimedHandler\n     *  Delete a timed handler for a connection.\n     *\n     *  This function removes a timed handler from the connection.  The\n     *  handRef parameter is *not* the function passed to addTimedHandler(),\n     *  but is the reference returned from addTimedHandler().\n     *\n     *  Parameters:\n     *    (Strophe.TimedHandler) handRef - The handler reference.\n     */\n    deleteTimedHandler: function (handRef) {\n        // this must be done in the Idle loop so that we don't change\n        // the handlers during iteration\n        this.removeTimeds.push(handRef);\n    },\n\n    /** Function: addHandler\n     *  Add a stanza handler for the connection.\n     *\n     *  This function adds a stanza handler to the connection.  The\n     *  handler callback will be called for any stanza that matches\n     *  the parameters.  Note that if multiple parameters are supplied,\n     *  they must all match for the handler to be invoked.\n     *\n     *  The handler will receive the stanza that triggered it as its argument.\n     *  *The handler should return true if it is to be invoked again;\n     *  returning false will remove the handler after it returns.*\n     *\n     *  As a convenience, the ns parameters applies to the top level element\n     *  and also any of its immediate children.  This is primarily to make\n     *  matching /iq/query elements easy.\n     *\n     *  Options\n     *  ~~~~~~~\n     *  With the options argument, you can specify boolean flags that affect how\n     *  matches are being done.\n     *\n     *  Currently two flags exist:\n     *\n     *  - matchBareFromJid:\n     *      When set to true, the from parameter and the\n     *      from attribute on the stanza will be matched as bare JIDs instead\n     *      of full JIDs. To use this, pass {matchBareFromJid: true} as the\n     *      value of options. The default value for matchBareFromJid is false.\n     *\n     *  - ignoreNamespaceFragment:\n     *      When set to true, a fragment specified on the stanza's namespace\n     *      URL will be ignored when it's matched with the one configured for\n     *      the handler.\n     *\n     *      This means that if you register like this:\n     *      >   connection.addHandler(\n     *      >       handler,\n     *      >       'http://jabber.org/protocol/muc',\n     *      >       null, null, null, null,\n     *      >       {'ignoreNamespaceFragment': true}\n     *      >   );\n     *\n     *      Then a stanza with XML namespace of\n     *      'http://jabber.org/protocol/muc#user' will also be matched. If\n     *      'ignoreNamespaceFragment' is false, then only stanzas with\n     *      'http://jabber.org/protocol/muc' will be matched.\n     *\n     *  Deleting the handler\n     *  ~~~~~~~~~~~~~~~~~~~~\n     *  The return value should be saved if you wish to remove the handler\n     *  with deleteHandler().\n     *\n     *  Parameters:\n     *    (Function) handler - The user callback.\n     *    (String) ns - The namespace to match.\n     *    (String) name - The stanza name to match.\n     *    (String|Array) type - The stanza type (or types if an array) to match.\n     *    (String) id - The stanza id attribute to match.\n     *    (String) from - The stanza from attribute to match.\n     *    (String) options - The handler options\n     *\n     *  Returns:\n     *    A reference to the handler that can be used to remove it.\n     */\n    addHandler: function (handler, ns, name, type, id, from, options) {\n        var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);\n        this.addHandlers.push(hand);\n        return hand;\n    },\n\n    /** Function: deleteHandler\n     *  Delete a stanza handler for a connection.\n     *\n     *  This function removes a stanza handler from the connection.  The\n     *  handRef parameter is *not* the function passed to addHandler(),\n     *  but is the reference returned from addHandler().\n     *\n     *  Parameters:\n     *    (Strophe.Handler) handRef - The handler reference.\n     */\n    deleteHandler: function (handRef) {\n        // this must be done in the Idle loop so that we don't change\n        // the handlers during iteration\n        this.removeHandlers.push(handRef);\n        // If a handler is being deleted while it is being added,\n        // prevent it from getting added\n        var i = this.addHandlers.indexOf(handRef);\n        if (i >= 0) {\n            this.addHandlers.splice(i, 1);\n        }\n    },\n\n    /** Function: registerSASLMechanisms\n     *\n     * Register the SASL mechanisms which will be supported by this instance of\n     * Strophe.Connection (i.e. which this XMPP client will support).\n     *\n     *  Parameters:\n     *    (Array) mechanisms - Array of objects with Strophe.SASLMechanism prototypes\n     *\n     */\n    registerSASLMechanisms: function (mechanisms) {\n        this.mechanisms = {};\n        mechanisms = mechanisms || [\n            Strophe.SASLAnonymous,\n            Strophe.SASLExternal,\n            Strophe.SASLMD5,\n            Strophe.SASLOAuthBearer,\n            Strophe.SASLXOAuth2,\n            Strophe.SASLPlain,\n            Strophe.SASLSHA1\n        ];\n        mechanisms.forEach(this.registerSASLMechanism.bind(this));\n    },\n\n    /** Function: registerSASLMechanism\n     *\n     * Register a single SASL mechanism, to be supported by this client.\n     *\n     *  Parameters:\n     *    (Object) mechanism - Object with a Strophe.SASLMechanism prototype\n     *\n     */\n    registerSASLMechanism: function (mechanism) {\n        this.mechanisms[mechanism.prototype.name] = mechanism;\n    },\n\n    /** Function: disconnect\n     *  Start the graceful disconnection process.\n     *\n     *  This function starts the disconnection process.  This process starts\n     *  by sending unavailable presence and sending BOSH body of type\n     *  terminate.  A timeout handler makes sure that disconnection happens\n     *  even if the BOSH server does not respond.\n     *  If the Connection object isn't connected, at least tries to abort all pending requests\n     *  so the connection object won't generate successful requests (which were already opened).\n     *\n     *  The user supplied connection callback will be notified of the\n     *  progress as this process happens.\n     *\n     *  Parameters:\n     *    (String) reason - The reason the disconnect is occuring.\n     */\n    disconnect: function (reason) {\n        this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);\n\n        Strophe.info(\"Disconnect was called because: \" + reason);\n        if (this.connected) {\n            var pres = false;\n            this.disconnecting = true;\n            if (this.authenticated) {\n                pres = $pres({\n                    xmlns: Strophe.NS.CLIENT,\n                    type: 'unavailable'\n                });\n            }\n            // setup timeout handler\n            this._disconnectTimeout = this._addSysTimedHandler(\n                3000, this._onDisconnectTimeout.bind(this));\n            this._proto._disconnect(pres);\n        } else {\n            Strophe.info(\"Disconnect was called before Strophe connected to the server\");\n            this._proto._abortAllRequests();\n            this._doDisconnect();\n        }\n    },\n\n    /** PrivateFunction: _changeConnectStatus\n     *  _Private_ helper function that makes sure plugins and the user's\n     *  callback are notified of connection status changes.\n     *\n     *  Parameters:\n     *    (Integer) status - the new connection status, one of the values\n     *      in Strophe.Status\n     *    (String) condition - the error condition or null\n     *    (XMLElement) elem - The triggering stanza.\n     */\n    _changeConnectStatus: function (status, condition, elem) {\n        // notify all plugins listening for status changes\n        for (var k in Strophe._connectionPlugins) {\n            if (Strophe._connectionPlugins.hasOwnProperty(k)) {\n                var plugin = this[k];\n                if (plugin.statusChanged) {\n                    try {\n                        plugin.statusChanged(status, condition);\n                    } catch (err) {\n                        Strophe.error(\"\" + k + \" plugin caused an exception \" +\n                                      \"changing status: \" + err);\n                    }\n                }\n            }\n        }\n\n        // notify the user's callback\n        if (this.connect_callback) {\n            try {\n                this.connect_callback(status, condition, elem);\n            } catch (e) {\n                Strophe._handleError(e);\n                Strophe.error(\n                    \"User connection callback caused an \"+\"exception: \"+e);\n            }\n        }\n    },\n\n    /** PrivateFunction: _doDisconnect\n     *  _Private_ function to disconnect.\n     *\n     *  This is the last piece of the disconnection logic.  This resets the\n     *  connection and alerts the user's connection callback.\n     */\n    _doDisconnect: function (condition) {\n        if (typeof this._idleTimeout === \"number\") {\n            clearTimeout(this._idleTimeout);\n        }\n\n        // Cancel Disconnect Timeout\n        if (this._disconnectTimeout !== null) {\n            this.deleteTimedHandler(this._disconnectTimeout);\n            this._disconnectTimeout = null;\n        }\n\n        Strophe.info(\"_doDisconnect was called\");\n        this._proto._doDisconnect();\n\n        this.authenticated = false;\n        this.disconnecting = false;\n        this.restored = false;\n\n        // delete handlers\n        this.handlers = [];\n        this.timedHandlers = [];\n        this.removeTimeds = [];\n        this.removeHandlers = [];\n        this.addTimeds = [];\n        this.addHandlers = [];\n\n        // tell the parent we disconnected\n        this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);\n        this.connected = false;\n    },\n\n    /** PrivateFunction: _dataRecv\n     *  _Private_ handler to processes incoming data from the the connection.\n     *\n     *  Except for _connect_cb handling the initial connection request,\n     *  this function handles the incoming data for all requests.  This\n     *  function also fires stanza handlers that match each incoming\n     *  stanza.\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The request that has data ready.\n     *    (string) req - The stanza a raw string (optiona).\n     */\n    _dataRecv: function (req, raw) {\n        Strophe.info(\"_dataRecv called\");\n        var elem = this._proto._reqToData(req);\n        if (elem === null) { return; }\n\n        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\n            if (elem.nodeName === this._proto.strip && elem.childNodes.length) {\n                this.xmlInput(elem.childNodes[0]);\n            } else {\n                this.xmlInput(elem);\n            }\n        }\n        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\n            if (raw) {\n                this.rawInput(raw);\n            } else {\n                this.rawInput(Strophe.serialize(elem));\n            }\n        }\n\n        // remove handlers scheduled for deletion\n        var i, hand;\n        while (this.removeHandlers.length > 0) {\n            hand = this.removeHandlers.pop();\n            i = this.handlers.indexOf(hand);\n            if (i >= 0) {\n                this.handlers.splice(i, 1);\n            }\n        }\n\n        // add handlers scheduled for addition\n        while (this.addHandlers.length > 0) {\n            this.handlers.push(this.addHandlers.pop());\n        }\n\n        // handle graceful disconnect\n        if (this.disconnecting && this._proto._emptyQueue()) {\n            this._doDisconnect();\n            return;\n        }\n\n        var type = elem.getAttribute(\"type\");\n        var cond, conflict;\n        if (type !== null && type === \"terminate\") {\n            // Don't process stanzas that come in after disconnect\n            if (this.disconnecting) {\n                return;\n            }\n\n            // an error occurred\n            cond = elem.getAttribute(\"condition\");\n            conflict = elem.getElementsByTagName(\"conflict\");\n            if (cond !== null) {\n                if (cond === \"remote-stream-error\" && conflict.length > 0) {\n                    cond = \"conflict\";\n                }\n                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\n            } else {\n                this._changeConnectStatus(\n                    Strophe.Status.CONNFAIL,\n                    Strophe.ErrorCondition.UNKOWN_REASON\n                );\n            }\n            this._doDisconnect(cond);\n            return;\n        }\n\n        // send each incoming stanza through the handler chain\n        var that = this;\n        Strophe.forEachChild(elem, null, function (child) {\n            var i, newList;\n            // process handlers\n            newList = that.handlers;\n            that.handlers = [];\n            for (i = 0; i < newList.length; i++) {\n                var hand = newList[i];\n                // encapsulate 'handler.run' not to lose the whole handler list if\n                // one of the handlers throws an exception\n                try {\n                    if (hand.isMatch(child) &&\n                        (that.authenticated || !hand.user)) {\n                        if (hand.run(child)) {\n                            that.handlers.push(hand);\n                        }\n                    } else {\n                        that.handlers.push(hand);\n                    }\n                } catch(e) {\n                    // if the handler throws an exception, we consider it as false\n                    Strophe.warn('Removing Strophe handlers due to uncaught exception: '+e.message);\n                }\n            }\n        });\n    },\n\n\n    /** Attribute: mechanisms\n     *  SASL Mechanisms available for Connection.\n     */\n    mechanisms: {},\n\n    /** PrivateFunction: _connect_cb\n     *  _Private_ handler for initial connection request.\n     *\n     *  This handler is used to process the initial connection request\n     *  response from the BOSH server. It is used to set up authentication\n     *  handlers and start the authentication process.\n     *\n     *  SASL authentication will be attempted if available, otherwise\n     *  the code will fall back to legacy authentication.\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The current request.\n     *    (Function) _callback - low level (xmpp) connect callback function.\n     *      Useful for plugins with their own xmpp connect callback (when they\n     *      want to do something special).\n     */\n    _connect_cb: function (req, _callback, raw) {\n        Strophe.info(\"_connect_cb was called\");\n        this.connected = true;\n\n        var bodyWrap;\n        try {\n            bodyWrap = this._proto._reqToData(req);\n        } catch (e) {\n            if (e !== \"badformat\") { throw e; }\n            this._changeConnectStatus(\n                Strophe.Status.CONNFAIL,\n                Strophe.ErrorCondition.BAD_FORMAT\n            );\n            this._doDisconnect(Strophe.ErrorCondition.BAD_FORMAT);\n        }\n        if (!bodyWrap) { return; }\n\n        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\n            if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {\n                this.xmlInput(bodyWrap.childNodes[0]);\n            } else {\n                this.xmlInput(bodyWrap);\n            }\n        }\n        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\n            if (raw) {\n                this.rawInput(raw);\n            } else {\n                this.rawInput(Strophe.serialize(bodyWrap));\n            }\n        }\n\n        var conncheck = this._proto._connect_cb(bodyWrap);\n        if (conncheck === Strophe.Status.CONNFAIL) {\n            return;\n        }\n\n        // Check for the stream:features tag\n        var hasFeatures;\n        if (bodyWrap.getElementsByTagNameNS) {\n            hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \"features\").length > 0;\n        } else {\n            hasFeatures = bodyWrap.getElementsByTagName(\"stream:features\").length > 0 ||\n                            bodyWrap.getElementsByTagName(\"features\").length > 0;\n        }\n        if (!hasFeatures) {\n            this._proto._no_auth_received(_callback);\n            return;\n        }\n\n        var matched = [], i, mech;\n        var mechanisms = bodyWrap.getElementsByTagName(\"mechanism\");\n        if (mechanisms.length > 0) {\n            for (i = 0; i < mechanisms.length; i++) {\n                mech = Strophe.getText(mechanisms[i]);\n                if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);\n            }\n        }\n        if (matched.length === 0) {\n            if (bodyWrap.getElementsByTagName(\"auth\").length === 0) {\n                // There are no matching SASL mechanisms and also no legacy\n                // auth available.\n                this._proto._no_auth_received(_callback);\n                return;\n            }\n        }\n        if (this.do_authentication !== false) {\n            this.authenticate(matched);\n        }\n    },\n\n    /** Function: sortMechanismsByPriority\n     *\n     *  Sorts an array of objects with prototype SASLMechanism according to\n     *  their priorities.\n     *\n     *  Parameters:\n     *    (Array) mechanisms - Array of SASL mechanisms.\n     *\n     */\n    sortMechanismsByPriority: function (mechanisms) {\n        // Sorting mechanisms according to priority.\n        var i, j, higher, swap;\n        for (i = 0; i < mechanisms.length - 1; ++i) {\n            higher = i;\n            for (j = i + 1; j < mechanisms.length; ++j) {\n                if (mechanisms[j].prototype.priority > mechanisms[higher].prototype.priority) {\n                    higher = j;\n                }\n            }\n            if (higher !== i) {\n                swap = mechanisms[i];\n                mechanisms[i] = mechanisms[higher];\n                mechanisms[higher] = swap;\n            }\n        }\n        return mechanisms;\n    },\n\n    /** PrivateFunction: _attemptSASLAuth\n     *\n     *  Iterate through an array of SASL mechanisms and attempt authentication\n     *  with the highest priority (enabled) mechanism.\n     *\n     *  Parameters:\n     *    (Array) mechanisms - Array of SASL mechanisms.\n     *\n     *  Returns:\n     *    (Boolean) mechanism_found - true or false, depending on whether a\n     *          valid SASL mechanism was found with which authentication could be\n     *          started.\n     */\n    _attemptSASLAuth: function (mechanisms) {\n        mechanisms = this.sortMechanismsByPriority(mechanisms || []);\n        var i = 0, mechanism_found = false;\n        for (i = 0; i < mechanisms.length; ++i) {\n            if (!mechanisms[i].prototype.test(this)) {\n                continue;\n            }\n            this._sasl_success_handler = this._addSysHandler(\n                this._sasl_success_cb.bind(this), null,\n                \"success\", null, null);\n            this._sasl_failure_handler = this._addSysHandler(\n                this._sasl_failure_cb.bind(this), null,\n                \"failure\", null, null);\n            this._sasl_challenge_handler = this._addSysHandler(\n                this._sasl_challenge_cb.bind(this), null,\n                \"challenge\", null, null);\n\n            this._sasl_mechanism = new mechanisms[i]();\n            this._sasl_mechanism.onStart(this);\n\n            var request_auth_exchange = $build(\"auth\", {\n                xmlns: Strophe.NS.SASL,\n                mechanism: this._sasl_mechanism.name\n            });\n            if (this._sasl_mechanism.isClientFirst) {\n                var response = this._sasl_mechanism.onChallenge(this, null);\n                request_auth_exchange.t(btoa(response));\n            }\n            this.send(request_auth_exchange.tree());\n            mechanism_found = true;\n            break;\n        }\n        return mechanism_found;\n    },\n\n    /** PrivateFunction: _attemptLegacyAuth\n     *\n     *  Attempt legacy (i.e. non-SASL) authentication.\n     *\n     */\n    _attemptLegacyAuth: function () {\n        if (Strophe.getNodeFromJid(this.jid) === null) {\n            // we don't have a node, which is required for non-anonymous\n            // client connections\n            this._changeConnectStatus(\n                Strophe.Status.CONNFAIL,\n                Strophe.ErrorCondition.MISSING_JID_NODE\n            );\n            this.disconnect(Strophe.ErrorCondition.MISSING_JID_NODE);\n        } else {\n            // Fall back to legacy authentication\n            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);\n            this._addSysHandler(\n                this._auth1_cb.bind(this),\n                null, null, null, \"_auth_1\"\n            );\n            this.send($iq({\n                    'type': \"get\",\n                    'to': this.domain,\n                    'id': \"_auth_1\"\n                }).c(\"query\", {xmlns: Strophe.NS.AUTH})\n                .c(\"username\", {}).t(Strophe.getNodeFromJid(this.jid))\n                .tree());\n        }\n    },\n\n    /** Function: authenticate\n     * Set up authentication\n     *\n     *  Continues the initial connection request by setting up authentication\n     *  handlers and starting the authentication process.\n     *\n     *  SASL authentication will be attempted if available, otherwise\n     *  the code will fall back to legacy authentication.\n     *\n     *  Parameters:\n     *    (Array) matched - Array of SASL mechanisms supported.\n     *\n     */\n    authenticate: function (matched) {\n        if (!this._attemptSASLAuth(matched)) {\n            this._attemptLegacyAuth();\n        }\n    },\n\n    /** PrivateFunction: _sasl_challenge_cb\n     *  _Private_ handler for the SASL challenge\n     *\n     */\n    _sasl_challenge_cb: function(elem) {\n      var challenge = atob(Strophe.getText(elem));\n      var response = this._sasl_mechanism.onChallenge(this, challenge);\n      var stanza = $build('response', {\n          'xmlns': Strophe.NS.SASL\n      });\n      if (response !== \"\") {\n        stanza.t(btoa(response));\n      }\n      this.send(stanza.tree());\n      return true;\n    },\n\n    /** PrivateFunction: _auth1_cb\n     *  _Private_ handler for legacy authentication.\n     *\n     *  This handler is called in response to the initial <iq type='get'/>\n     *  for legacy authentication.  It builds an authentication <iq/> and\n     *  sends it, creating a handler (calling back to _auth2_cb()) to\n     *  handle the result\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The stanza that triggered the callback.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    /* jshint unused:false */\n    _auth1_cb: function (elem) {\n        // build plaintext auth iq\n        var iq = $iq({type: \"set\", id: \"_auth_2\"})\n            .c('query', {xmlns: Strophe.NS.AUTH})\n            .c('username', {}).t(Strophe.getNodeFromJid(this.jid))\n            .up()\n            .c('password').t(this.pass);\n\n        if (!Strophe.getResourceFromJid(this.jid)) {\n            // since the user has not supplied a resource, we pick\n            // a default one here.  unlike other auth methods, the server\n            // cannot do this for us.\n            this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';\n        }\n        iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));\n\n        this._addSysHandler(this._auth2_cb.bind(this), null,\n                            null, null, \"_auth_2\");\n        this.send(iq.tree());\n        return false;\n    },\n    /* jshint unused:true */\n\n    /** PrivateFunction: _sasl_success_cb\n     *  _Private_ handler for succesful SASL authentication.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _sasl_success_cb: function (elem) {\n        if (this._sasl_data[\"server-signature\"]) {\n            var serverSignature;\n            var success = atob(Strophe.getText(elem));\n            var attribMatch = /([a-z]+)=([^,]+)(,|$)/;\n            var matches = success.match(attribMatch);\n            if (matches[1] === \"v\") {\n                serverSignature = matches[2];\n            }\n\n            if (serverSignature !== this._sasl_data[\"server-signature\"]) {\n              // remove old handlers\n              this.deleteHandler(this._sasl_failure_handler);\n              this._sasl_failure_handler = null;\n              if (this._sasl_challenge_handler) {\n                this.deleteHandler(this._sasl_challenge_handler);\n                this._sasl_challenge_handler = null;\n              }\n\n              this._sasl_data = {};\n              return this._sasl_failure_cb(null);\n            }\n        }\n        Strophe.info(\"SASL authentication succeeded.\");\n\n        if (this._sasl_mechanism) {\n          this._sasl_mechanism.onSuccess();\n        }\n\n        // remove old handlers\n        this.deleteHandler(this._sasl_failure_handler);\n        this._sasl_failure_handler = null;\n        if (this._sasl_challenge_handler) {\n            this.deleteHandler(this._sasl_challenge_handler);\n            this._sasl_challenge_handler = null;\n        }\n\n        var streamfeature_handlers = [];\n        var wrapper = function(handlers, elem) {\n            while (handlers.length) {\n                this.deleteHandler(handlers.pop());\n            }\n            this._sasl_auth1_cb.bind(this)(elem);\n            return false;\n        };\n        streamfeature_handlers.push(this._addSysHandler(function(elem) {\n            wrapper.bind(this)(streamfeature_handlers, elem);\n        }.bind(this), null, \"stream:features\", null, null));\n        streamfeature_handlers.push(this._addSysHandler(function(elem) {\n            wrapper.bind(this)(streamfeature_handlers, elem);\n        }.bind(this), Strophe.NS.STREAM, \"features\", null, null));\n\n        // we must send an xmpp:restart now\n        this._sendRestart();\n\n        return false;\n    },\n\n    /** PrivateFunction: _sasl_auth1_cb\n     *  _Private_ handler to start stream binding.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _sasl_auth1_cb: function (elem) {\n        // save stream:features for future usage\n        this.features = elem;\n        var i, child;\n        for (i = 0; i < elem.childNodes.length; i++) {\n            child = elem.childNodes[i];\n            if (child.nodeName === 'bind') {\n                this.do_bind = true;\n            }\n\n            if (child.nodeName === 'session') {\n                this.do_session = true;\n            }\n        }\n\n        if (!this.do_bind) {\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n            return false;\n        } else {\n            this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,\n                                null, \"_bind_auth_2\");\n\n            var resource = Strophe.getResourceFromJid(this.jid);\n            if (resource) {\n                this.send($iq({type: \"set\", id: \"_bind_auth_2\"})\n                          .c('bind', {xmlns: Strophe.NS.BIND})\n                          .c('resource', {}).t(resource).tree());\n            } else {\n                this.send($iq({type: \"set\", id: \"_bind_auth_2\"})\n                          .c('bind', {xmlns: Strophe.NS.BIND})\n                          .tree());\n            }\n        }\n        return false;\n    },\n\n    /** PrivateFunction: _sasl_bind_cb\n     *  _Private_ handler for binding result and session start.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _sasl_bind_cb: function (elem) {\n        if (elem.getAttribute(\"type\") === \"error\") {\n            Strophe.info(\"SASL binding failed.\");\n            var conflict = elem.getElementsByTagName(\"conflict\"), condition;\n            if (conflict.length > 0) {\n                condition = Strophe.ErrorCondition.CONFLICT;\n            }\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition, elem);\n            return false;\n        }\n\n        // TODO - need to grab errors\n        var bind = elem.getElementsByTagName(\"bind\");\n        var jidNode;\n        if (bind.length > 0) {\n            // Grab jid\n            jidNode = bind[0].getElementsByTagName(\"jid\");\n            if (jidNode.length > 0) {\n                this.jid = Strophe.getText(jidNode[0]);\n\n                if (this.do_session) {\n                    this._addSysHandler(this._sasl_session_cb.bind(this),\n                                        null, null, null, \"_session_auth_2\");\n\n                    this.send($iq({type: \"set\", id: \"_session_auth_2\"})\n                                  .c('session', {xmlns: Strophe.NS.SESSION})\n                                  .tree());\n                } else {\n                    this.authenticated = true;\n                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n                }\n            }\n        } else {\n            Strophe.info(\"SASL binding failed.\");\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);\n            return false;\n        }\n    },\n\n    /** PrivateFunction: _sasl_session_cb\n     *  _Private_ handler to finish successful SASL connection.\n     *\n     *  This sets Connection.authenticated to true on success, which\n     *  starts the processing of user handlers.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _sasl_session_cb: function (elem) {\n        if (elem.getAttribute(\"type\") === \"result\") {\n            this.authenticated = true;\n            this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n        } else if (elem.getAttribute(\"type\") === \"error\") {\n            Strophe.info(\"Session creation failed.\");\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);\n            return false;\n        }\n        return false;\n    },\n\n    /** PrivateFunction: _sasl_failure_cb\n     *  _Private_ handler for SASL authentication failure.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    /* jshint unused:false */\n    _sasl_failure_cb: function (elem) {\n        // delete unneeded handlers\n        if (this._sasl_success_handler) {\n            this.deleteHandler(this._sasl_success_handler);\n            this._sasl_success_handler = null;\n        }\n        if (this._sasl_challenge_handler) {\n            this.deleteHandler(this._sasl_challenge_handler);\n            this._sasl_challenge_handler = null;\n        }\n\n        if(this._sasl_mechanism)\n          this._sasl_mechanism.onFailure();\n        this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);\n        return false;\n    },\n    /* jshint unused:true */\n\n    /** PrivateFunction: _auth2_cb\n     *  _Private_ handler to finish legacy authentication.\n     *\n     *  This handler is called when the result from the jabber:iq:auth\n     *  <iq/> stanza is returned.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The stanza that triggered the callback.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _auth2_cb: function (elem) {\n        if (elem.getAttribute(\"type\") === \"result\") {\n            this.authenticated = true;\n            this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n        } else if (elem.getAttribute(\"type\") === \"error\") {\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);\n            this.disconnect('authentication failed');\n        }\n        return false;\n    },\n\n    /** PrivateFunction: _addSysTimedHandler\n     *  _Private_ function to add a system level timed handler.\n     *\n     *  This function is used to add a Strophe.TimedHandler for the\n     *  library code.  System timed handlers are allowed to run before\n     *  authentication is complete.\n     *\n     *  Parameters:\n     *    (Integer) period - The period of the handler.\n     *    (Function) handler - The callback function.\n     */\n    _addSysTimedHandler: function (period, handler) {\n        var thand = new Strophe.TimedHandler(period, handler);\n        thand.user = false;\n        this.addTimeds.push(thand);\n        return thand;\n    },\n\n    /** PrivateFunction: _addSysHandler\n     *  _Private_ function to add a system level stanza handler.\n     *\n     *  This function is used to add a Strophe.Handler for the\n     *  library code.  System stanza handlers are allowed to run before\n     *  authentication is complete.\n     *\n     *  Parameters:\n     *    (Function) handler - The callback function.\n     *    (String) ns - The namespace to match.\n     *    (String) name - The stanza name to match.\n     *    (String) type - The stanza type attribute to match.\n     *    (String) id - The stanza id attribute to match.\n     */\n    _addSysHandler: function (handler, ns, name, type, id) {\n        var hand = new Strophe.Handler(handler, ns, name, type, id);\n        hand.user = false;\n        this.addHandlers.push(hand);\n        return hand;\n    },\n\n    /** PrivateFunction: _onDisconnectTimeout\n     *  _Private_ timeout handler for handling non-graceful disconnection.\n     *\n     *  If the graceful disconnect process does not complete within the\n     *  time allotted, this handler finishes the disconnect anyway.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _onDisconnectTimeout: function () {\n        Strophe.info(\"_onDisconnectTimeout was called\");\n        this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);\n        this._proto._onDisconnectTimeout();\n        // actually disconnect\n        this._doDisconnect();\n        return false;\n    },\n\n    /** PrivateFunction: _onIdle\n     *  _Private_ handler to process events during idle cycle.\n     *\n     *  This handler is called every 100ms to fire timed handlers that\n     *  are ready and keep poll requests going.\n     */\n    _onIdle: function () {\n        var i, thand, since, newList;\n\n        // add timed handlers scheduled for addition\n        // NOTE: we add before remove in the case a timed handler is\n        // added and then deleted before the next _onIdle() call.\n        while (this.addTimeds.length > 0) {\n            this.timedHandlers.push(this.addTimeds.pop());\n        }\n\n        // remove timed handlers that have been scheduled for deletion\n        while (this.removeTimeds.length > 0) {\n            thand = this.removeTimeds.pop();\n            i = this.timedHandlers.indexOf(thand);\n            if (i >= 0) {\n                this.timedHandlers.splice(i, 1);\n            }\n        }\n\n        // call ready timed handlers\n        var now = new Date().getTime();\n        newList = [];\n        for (i = 0; i < this.timedHandlers.length; i++) {\n            thand = this.timedHandlers[i];\n            if (this.authenticated || !thand.user) {\n                since = thand.lastCalled + thand.period;\n                if (since - now <= 0) {\n                    if (thand.run()) {\n                        newList.push(thand);\n                    }\n                } else {\n                    newList.push(thand);\n                }\n            }\n        }\n        this.timedHandlers = newList;\n\n        clearTimeout(this._idleTimeout);\n\n        this._proto._onIdle();\n\n        // reactivate the timer only if connected\n        if (this.connected) {\n            // XXX: setTimeout should be called only with function expressions (23974bc1)\n            this._idleTimeout = setTimeout(function() {\n                this._onIdle();\n            }.bind(this), 100);\n        }\n    }\n};\n\n/** Class: Strophe.SASLMechanism\n *\n *  encapsulates SASL authentication mechanisms.\n *\n *  User code may override the priority for each mechanism or disable it completely.\n *  See <priority> for information about changing priority and <test> for informatian on\n *  how to disable a mechanism.\n *\n *  By default, all mechanisms are enabled and the priorities are\n *\n *      OAUTHBEARER - 60\n *      SCRAM-SHA1 - 50\n *      DIGEST-MD5 - 40\n *      PLAIN - 30\n *      ANONYMOUS - 20\n *      EXTERNAL - 10\n *\n *  See: Strophe.Connection.addSupportedSASLMechanisms\n */\n\n/**\n * PrivateConstructor: Strophe.SASLMechanism\n * SASL auth mechanism abstraction.\n *\n *  Parameters:\n *    (String) name - SASL Mechanism name.\n *    (Boolean) isClientFirst - If client should send response first without challenge.\n *    (Number) priority - Priority.\n *\n *  Returns:\n *    A new Strophe.SASLMechanism object.\n */\nStrophe.SASLMechanism = function(name, isClientFirst, priority) {\n  /** PrivateVariable: name\n   *  Mechanism name.\n   */\n  this.name = name;\n  /** PrivateVariable: isClientFirst\n   *  If client sends response without initial server challenge.\n   */\n  this.isClientFirst = isClientFirst;\n  /** Variable: priority\n   *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).\n   *  Users may override this to prioritize mechanisms differently.\n   *\n   *  In the default configuration the priorities are\n   *\n   *  SCRAM-SHA1 - 40\n   *  DIGEST-MD5 - 30\n   *  Plain - 20\n   *\n   *  Example: (This will cause Strophe to choose the mechanism that the server sent first)\n   *\n   *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;\n   *\n   *  See <SASL mechanisms> for a list of available mechanisms.\n   *\n   */\n  this.priority = priority;\n};\n\nStrophe.SASLMechanism.prototype = {\n  /**\n   *  Function: test\n   *  Checks if mechanism able to run.\n   *  To disable a mechanism, make this return false;\n   *\n   *  To disable plain authentication run\n   *  > Strophe.SASLPlain.test = function() {\n   *  >   return false;\n   *  > }\n   *\n   *  See <SASL mechanisms> for a list of available mechanisms.\n   *\n   *  Parameters:\n   *    (Strophe.Connection) connection - Target Connection.\n   *\n   *  Returns:\n   *    (Boolean) If mechanism was able to run.\n   */\n  /* jshint unused:false */\n  test: function(connection) {\n    return true;\n  },\n  /* jshint unused:true */\n\n  /** PrivateFunction: onStart\n   *  Called before starting mechanism on some connection.\n   *\n   *  Parameters:\n   *    (Strophe.Connection) connection - Target Connection.\n   */\n  onStart: function(connection) {\n    this._connection = connection;\n  },\n\n  /** PrivateFunction: onChallenge\n   *  Called by protocol implementation on incoming challenge. If client is\n   *  first (isClientFirst === true) challenge will be null on the first call.\n   *\n   *  Parameters:\n   *    (Strophe.Connection) connection - Target Connection.\n   *    (String) challenge - current challenge to handle.\n   *\n   *  Returns:\n   *    (String) Mechanism response.\n   */\n  /* jshint unused:false */\n  onChallenge: function(connection, challenge) {\n    throw new Error(\"You should implement challenge handling!\");\n  },\n  /* jshint unused:true */\n\n  /** PrivateFunction: onFailure\n   *  Protocol informs mechanism implementation about SASL failure.\n   */\n  onFailure: function() {\n    this._connection = null;\n  },\n\n  /** PrivateFunction: onSuccess\n   *  Protocol informs mechanism implementation about SASL success.\n   */\n  onSuccess: function() {\n    this._connection = null;\n  }\n};\n\n  /** Constants: SASL mechanisms\n   *  Available authentication mechanisms\n   *\n   *  Strophe.SASLAnonymous - SASL ANONYMOUS authentication.\n   *  Strophe.SASLPlain - SASL PLAIN authentication.\n   *  Strophe.SASLMD5 - SASL DIGEST-MD5 authentication\n   *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication\n   *  Strophe.SASLOAuthBearer - SASL OAuth Bearer authentication\n   *  Strophe.SASLExternal - SASL EXTERNAL authentication\n   *  Strophe.SASLXOAuth2 - SASL X-OAuth2 authentication\n   */\n\n// Building SASL callbacks\n\n/** PrivateConstructor: SASLAnonymous\n *  SASL ANONYMOUS authentication.\n */\nStrophe.SASLAnonymous = function() {};\nStrophe.SASLAnonymous.prototype = new Strophe.SASLMechanism(\"ANONYMOUS\", false, 20);\n\nStrophe.SASLAnonymous.prototype.test = function(connection) {\n    return connection.authcid === null;\n};\n\n\n/** PrivateConstructor: SASLPlain\n *  SASL PLAIN authentication.\n */\nStrophe.SASLPlain = function() {};\nStrophe.SASLPlain.prototype = new Strophe.SASLMechanism(\"PLAIN\", true, 50);\n\nStrophe.SASLPlain.prototype.test = function(connection) {\n    return connection.authcid !== null;\n};\n\nStrophe.SASLPlain.prototype.onChallenge = function(connection) {\n    var auth_str = connection.authzid;\n    auth_str = auth_str + \"\\u0000\";\n    auth_str = auth_str + connection.authcid;\n    auth_str = auth_str + \"\\u0000\";\n    auth_str = auth_str + connection.pass;\n    return utils.utf16to8(auth_str);\n};\n\n\n/** PrivateConstructor: SASLSHA1\n *  SASL SCRAM SHA 1 authentication.\n */\nStrophe.SASLSHA1 = function() {};\nStrophe.SASLSHA1.prototype = new Strophe.SASLMechanism(\"SCRAM-SHA-1\", true, 70);\n\nStrophe.SASLSHA1.prototype.test = function(connection) {\n    return connection.authcid !== null;\n};\n\nStrophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {\n  var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);\n  var auth_str = \"n=\" + utils.utf16to8(connection.authcid);\n  auth_str += \",r=\";\n  auth_str += cnonce;\n  connection._sasl_data.cnonce = cnonce;\n  connection._sasl_data[\"client-first-message-bare\"] = auth_str;\n\n  auth_str = \"n,,\" + auth_str;\n\n  this.onChallenge = function (connection, challenge) {\n    var nonce, salt, iter, Hi, U, U_old, i, k, pass;\n    var clientKey, serverKey, clientSignature;\n    var responseText = \"c=biws,\";\n    var authMessage = connection._sasl_data[\"client-first-message-bare\"] + \",\" +\n      challenge + \",\";\n    var cnonce = connection._sasl_data.cnonce;\n    var attribMatch = /([a-z]+)=([^,]+)(,|$)/;\n\n    while (challenge.match(attribMatch)) {\n      var matches = challenge.match(attribMatch);\n      challenge = challenge.replace(matches[0], \"\");\n      switch (matches[1]) {\n      case \"r\":\n        nonce = matches[2];\n        break;\n      case \"s\":\n        salt = matches[2];\n        break;\n      case \"i\":\n        iter = matches[2];\n        break;\n      }\n    }\n\n    if (nonce.substr(0, cnonce.length) !== cnonce) {\n      connection._sasl_data = {};\n      return connection._sasl_failure_cb();\n    }\n\n    responseText += \"r=\" + nonce;\n    authMessage += responseText;\n\n    salt = atob(salt);\n    salt += \"\\x00\\x00\\x00\\x01\";\n\n    pass = utils.utf16to8(connection.pass);\n    Hi = U_old = SHA1.core_hmac_sha1(pass, salt);\n    for (i = 1; i < iter; i++) {\n      U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));\n      for (k = 0; k < 5; k++) {\n        Hi[k] ^= U[k];\n      }\n      U_old = U;\n    }\n    Hi = SHA1.binb2str(Hi);\n\n    clientKey = SHA1.core_hmac_sha1(Hi, \"Client Key\");\n    serverKey = SHA1.str_hmac_sha1(Hi, \"Server Key\");\n    clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);\n    connection._sasl_data[\"server-signature\"] = SHA1.b64_hmac_sha1(serverKey, authMessage);\n\n    for (k = 0; k < 5; k++) {\n      clientKey[k] ^= clientSignature[k];\n    }\n\n    responseText += \",p=\" + btoa(SHA1.binb2str(clientKey));\n    return responseText;\n  }.bind(this);\n\n  return auth_str;\n};\n\n\n/** PrivateConstructor: SASLMD5\n *  SASL DIGEST MD5 authentication.\n */\nStrophe.SASLMD5 = function() {};\nStrophe.SASLMD5.prototype = new Strophe.SASLMechanism(\"DIGEST-MD5\", false, 60);\n\nStrophe.SASLMD5.prototype.test = function(connection) {\n    return connection.authcid !== null;\n};\n\n/** PrivateFunction: _quote\n *  _Private_ utility function to backslash escape and quote strings.\n *\n *  Parameters:\n *    (String) str - The string to be quoted.\n *\n *  Returns:\n *    quoted string\n */\nStrophe.SASLMD5.prototype._quote = function (str) {\n    return '\"' + str.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"') + '\"';\n    //\" end string workaround for emacs\n};\n\nStrophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {\n  var attribMatch = /([a-z]+)=(\"[^\"]+\"|[^,\"]+)(?:,|$)/;\n  var cnonce = test_cnonce || MD5.hexdigest(\"\" + (Math.random() * 1234567890));\n  var realm = \"\";\n  var host = null;\n  var nonce = \"\";\n  var qop = \"\";\n  var matches;\n\n  while (challenge.match(attribMatch)) {\n    matches = challenge.match(attribMatch);\n    challenge = challenge.replace(matches[0], \"\");\n    matches[2] = matches[2].replace(/^\"(.+)\"$/, \"$1\");\n    switch (matches[1]) {\n    case \"realm\":\n      realm = matches[2];\n      break;\n    case \"nonce\":\n      nonce = matches[2];\n      break;\n    case \"qop\":\n      qop = matches[2];\n      break;\n    case \"host\":\n      host = matches[2];\n      break;\n    }\n  }\n\n  var digest_uri = connection.servtype + \"/\" + connection.domain;\n  if (host !== null) {\n    digest_uri = digest_uri + \"/\" + host;\n  }\n\n  var cred = utils.utf16to8(connection.authcid + \":\" + realm + \":\" + this._connection.pass);\n  var A1 = MD5.hash(cred) + \":\" + nonce + \":\" + cnonce;\n  var A2 = 'AUTHENTICATE:' + digest_uri;\n\n  var responseText = \"\";\n  responseText += 'charset=utf-8,';\n  responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';\n  responseText += 'realm=' + this._quote(realm) + ',';\n  responseText += 'nonce=' + this._quote(nonce) + ',';\n  responseText += 'nc=00000001,';\n  responseText += 'cnonce=' + this._quote(cnonce) + ',';\n  responseText += 'digest-uri=' + this._quote(digest_uri) + ',';\n  responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + \":\" +\n                                              nonce + \":00000001:\" +\n                                              cnonce + \":auth:\" +\n                                              MD5.hexdigest(A2)) + \",\";\n  responseText += 'qop=auth';\n\n  this.onChallenge = function () {\n      return \"\";\n  };\n  return responseText;\n};\n\n\n/** PrivateConstructor: SASLOAuthBearer\n *  SASL OAuth Bearer authentication.\n */\nStrophe.SASLOAuthBearer = function() {};\nStrophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism(\"OAUTHBEARER\", true, 40);\n\nStrophe.SASLOAuthBearer.prototype.test = function(connection) {\n    return connection.pass !== null;\n};\n\nStrophe.SASLOAuthBearer.prototype.onChallenge = function(connection) {\n    var auth_str = 'n,';\n    if (connection.authcid !== null) {\n      auth_str = auth_str + 'a=' + connection.authzid;\n    }\n    auth_str = auth_str + ',';\n    auth_str = auth_str + \"\\u0001\";\n    auth_str = auth_str + 'auth=Bearer ';\n    auth_str = auth_str + connection.pass;\n    auth_str = auth_str + \"\\u0001\";\n    auth_str = auth_str + \"\\u0001\";\n\n    return utils.utf16to8(auth_str);\n};\n\n\n/** PrivateConstructor: SASLExternal\n *  SASL EXTERNAL authentication.\n *\n *  The EXTERNAL mechanism allows a client to request the server to use\n *  credentials established by means external to the mechanism to\n *  authenticate the client. The external means may be, for instance,\n *  TLS services.\n */\nStrophe.SASLExternal = function() {};\nStrophe.SASLExternal.prototype = new Strophe.SASLMechanism(\"EXTERNAL\", true, 10);\n\nStrophe.SASLExternal.prototype.onChallenge = function(connection) {\n    /** According to XEP-178, an authzid SHOULD NOT be presented when the\n     * authcid contained or implied in the client certificate is the JID (i.e.\n     * authzid) with which the user wants to log in as.\n     *\n     * To NOT send the authzid, the user should therefore set the authcid equal\n     * to the JID when instantiating a new Strophe.Connection object.\n     */\n    return connection.authcid === connection.authzid ? '' : connection.authzid;\n};\n\n\n/** PrivateConstructor: SASLXOAuth2\n *  SASL X-OAuth2 authentication.\n */\nStrophe.SASLXOAuth2 = function () { };\nStrophe.SASLXOAuth2.prototype = new Strophe.SASLMechanism(\"X-OAUTH2\", true, 30);\n\nStrophe.SASLXOAuth2.prototype.test = function (connection) {\n    return connection.pass !== null;\n};\n\nStrophe.SASLXOAuth2.prototype.onChallenge = function (connection) {\n    var auth_str = '\\u0000';\n    if (connection.authcid !== null) {\n        auth_str = auth_str + connection.authzid;\n    }\n    auth_str = auth_str + \"\\u0000\";\n    auth_str = auth_str + connection.pass;\n\n    return utils.utf16to8(auth_str);\n};\n\n\nreturn {\n    'Strophe':         Strophe,\n    '$build':          $build,\n    '$iq':             $iq,\n    '$msg':            $msg,\n    '$pres':           $pres,\n    'SHA1':            SHA1,\n    'MD5':             MD5,\n    'b64_hmac_sha1':   SHA1.b64_hmac_sha1,\n    'b64_sha1':        SHA1.b64_sha1,\n    'str_hmac_sha1':   SHA1.str_hmac_sha1,\n    'str_sha1':        SHA1.str_sha1\n};\n}));\n\n/*\n    This program is distributed under the terms of the MIT license.\n    Please see the LICENSE file for details.\n\n    Copyright 2006-2008, OGG, LLC\n*/\n\n/* jshint undef: true, unused: true:, noarg: true, latedef: true */\n/* global define, window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject, Strophe, $build */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-bosh',['strophe-core'], function (core) {\n            return factory(\n                core.Strophe,\n                core.$build\n            );\n        });\n    } else if (typeof exports === 'object') {\n        var core = require('./core');\n\n        module.exports = factory(core.Strophe, core.$build);\n    } else {\n        // Browser globals\n        return factory(Strophe, $build);\n    }\n}(this, function (Strophe, $build) {\n\n/** PrivateClass: Strophe.Request\n *  _Private_ helper class that provides a cross implementation abstraction\n *  for a BOSH related XMLHttpRequest.\n *\n *  The Strophe.Request class is used internally to encapsulate BOSH request\n *  information.  It is not meant to be used from user's code.\n */\n\n/** PrivateConstructor: Strophe.Request\n *  Create and initialize a new Strophe.Request object.\n *\n *  Parameters:\n *    (XMLElement) elem - The XML data to be sent in the request.\n *    (Function) func - The function that will be called when the\n *      XMLHttpRequest readyState changes.\n *    (Integer) rid - The BOSH rid attribute associated with this request.\n *    (Integer) sends - The number of times this same request has been sent.\n */\nStrophe.Request = function (elem, func, rid, sends) {\n    this.id = ++Strophe._requestId;\n    this.xmlData = elem;\n    this.data = Strophe.serialize(elem);\n    // save original function in case we need to make a new request\n    // from this one.\n    this.origFunc = func;\n    this.func = func;\n    this.rid = rid;\n    this.date = NaN;\n    this.sends = sends || 0;\n    this.abort = false;\n    this.dead = null;\n\n    this.age = function () {\n        if (!this.date) { return 0; }\n        var now = new Date();\n        return (now - this.date) / 1000;\n    };\n    this.timeDead = function () {\n        if (!this.dead) { return 0; }\n        var now = new Date();\n        return (now - this.dead) / 1000;\n    };\n    this.xhr = this._newXHR();\n};\n\nStrophe.Request.prototype = {\n    /** PrivateFunction: getResponse\n     *  Get a response from the underlying XMLHttpRequest.\n     *\n     *  This function attempts to get a response from the request and checks\n     *  for errors.\n     *\n     *  Throws:\n     *    \"parsererror\" - A parser error occured.\n     *    \"badformat\" - The entity has sent XML that cannot be processed.\n     *\n     *  Returns:\n     *    The DOM element tree of the response.\n     */\n    getResponse: function () {\n        var node = null;\n        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {\n            node = this.xhr.responseXML.documentElement;\n            if (node.tagName === \"parsererror\") {\n                Strophe.error(\"invalid response received\");\n                Strophe.error(\"responseText: \" + this.xhr.responseText);\n                Strophe.error(\"responseXML: \" +\n                              Strophe.serialize(this.xhr.responseXML));\n                throw \"parsererror\";\n            }\n        } else if (this.xhr.responseText) {\n            // In React Native, we may get responseText but no responseXML.  We can try to parse it manually.\n            Strophe.debug(\"Got responseText but no responseXML; attempting to parse it with DOMParser...\");\n            node = new DOMParser().parseFromString(this.xhr.responseText, 'application/xml').documentElement;\n            if (!node) {\n                throw new Error('Parsing produced null node');\n            } else if (node.querySelector('parsererror')) {\n                Strophe.error(\"invalid response received: \" + node.querySelector('parsererror').textContent);\n                Strophe.error(\"responseText: \" + this.xhr.responseText);\n                throw \"badformat\";\n            }\n        }\n        return node;\n    },\n\n    /** PrivateFunction: _newXHR\n     *  _Private_ helper function to create XMLHttpRequests.\n     *\n     *  This function creates XMLHttpRequests across all implementations.\n     *\n     *  Returns:\n     *    A new XMLHttpRequest.\n     */\n    _newXHR: function () {\n        var xhr = null;\n        if (window.XMLHttpRequest) {\n            xhr = new XMLHttpRequest();\n            if (xhr.overrideMimeType) {\n                xhr.overrideMimeType(\"text/xml; charset=utf-8\");\n            }\n        } else if (window.ActiveXObject) {\n            xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n        }\n        // use Function.bind() to prepend ourselves as an argument\n        xhr.onreadystatechange = this.func.bind(null, this);\n        return xhr;\n    }\n};\n\n/** Class: Strophe.Bosh\n *  _Private_ helper class that handles BOSH Connections\n *\n *  The Strophe.Bosh class is used internally by Strophe.Connection\n *  to encapsulate BOSH sessions. It is not meant to be used from user's code.\n */\n\n/** File: bosh.js\n *  A JavaScript library to enable BOSH in Strophejs.\n *\n *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)\n *  to emulate a persistent, stateful, two-way connection to an XMPP server.\n *  More information on BOSH can be found in XEP 124.\n */\n\n/** PrivateConstructor: Strophe.Bosh\n *  Create and initialize a Strophe.Bosh object.\n *\n *  Parameters:\n *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.\n *\n *  Returns:\n *    A new Strophe.Bosh object.\n */\nStrophe.Bosh = function(connection) {\n    this._conn = connection;\n    /* request id for body tags */\n    this.rid = Math.floor(Math.random() * 4294967295);\n    /* The current session ID. */\n    this.sid = null;\n\n    // default BOSH values\n    this.hold = 1;\n    this.wait = 60;\n    this.window = 5;\n    this.errors = 0;\n    this.inactivity = null;\n\n    this.lastResponseHeaders = null;\n\n    this._requests = [];\n};\n\nStrophe.Bosh.prototype = {\n    /** Variable: strip\n     *\n     *  BOSH-Connections will have all stanzas wrapped in a <body> tag when\n     *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.\n     *  To strip this tag, User code can set <Strophe.Bosh.strip> to \"body\":\n     *\n     *  > Strophe.Bosh.prototype.strip = \"body\";\n     *\n     *  This will enable stripping of the body tag in both\n     *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.\n     */\n    strip: null,\n\n    /** PrivateFunction: _buildBody\n     *  _Private_ helper function to generate the <body/> wrapper for BOSH.\n     *\n     *  Returns:\n     *    A Strophe.Builder with a <body/> element.\n     */\n    _buildBody: function () {\n        var bodyWrap = $build('body', {\n            rid: this.rid++,\n            xmlns: Strophe.NS.HTTPBIND\n        });\n        if (this.sid !== null) {\n            bodyWrap.attrs({sid: this.sid});\n        }\n        if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {\n            this._cacheSession();\n        }\n        return bodyWrap;\n    },\n\n    /** PrivateFunction: _reset\n     *  Reset the connection.\n     *\n     *  This function is called by the reset function of the Strophe Connection\n     */\n    _reset: function () {\n        this.rid = Math.floor(Math.random() * 4294967295);\n        this.sid = null;\n        this.errors = 0;\n        if (this._conn._sessionCachingSupported()) {\n            window.sessionStorage.removeItem('strophe-bosh-session');\n        }\n\n        this._conn.nextValidRid(this.rid);\n    },\n\n    /** PrivateFunction: _connect\n     *  _Private_ function that initializes the BOSH connection.\n     *\n     *  Creates and sends the Request that initializes the BOSH connection.\n     */\n    _connect: function (wait, hold, route) {\n        this.wait = wait || this.wait;\n        this.hold = hold || this.hold;\n        this.errors = 0;\n\n        // build the body tag\n        var body = this._buildBody().attrs({\n            to: this._conn.domain,\n            \"xml:lang\": \"en\",\n            wait: this.wait,\n            hold: this.hold,\n            content: \"text/xml; charset=utf-8\",\n            ver: \"1.6\",\n            \"xmpp:version\": \"1.0\",\n            \"xmlns:xmpp\": Strophe.NS.BOSH\n        });\n\n        if(route){\n            body.attrs({\n                route: route\n            });\n        }\n\n        var _connect_cb = this._conn._connect_cb;\n\n        this._requests.push(\n            new Strophe.Request(body.tree(),\n                                this._onRequestStateChange.bind(\n                                    this, _connect_cb.bind(this._conn)),\n                                body.tree().getAttribute(\"rid\")));\n        this._throttledRequestHandler();\n    },\n\n    /** PrivateFunction: _attach\n     *  Attach to an already created and authenticated BOSH session.\n     *\n     *  This function is provided to allow Strophe to attach to BOSH\n     *  sessions which have been created externally, perhaps by a Web\n     *  application.  This is often used to support auto-login type features\n     *  without putting user credentials into the page.\n     *\n     *  Parameters:\n     *    (String) jid - The full JID that is bound by the session.\n     *    (String) sid - The SID of the BOSH session.\n     *    (String) rid - The current RID of the BOSH session.  This RID\n     *      will be used by the next request.\n     *    (Function) callback The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\n     *      allowed range of request ids that are valid.  The default is 5.\n     */\n    _attach: function (jid, sid, rid, callback, wait, hold, wind) {\n        this._conn.jid = jid;\n        this.sid = sid;\n        this.rid = rid;\n\n        this._conn.connect_callback = callback;\n\n        this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);\n\n        this._conn.authenticated = true;\n        this._conn.connected = true;\n\n        this.wait = wait || this.wait;\n        this.hold = hold || this.hold;\n        this.window = wind || this.window;\n\n        this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);\n    },\n\n    /** PrivateFunction: _restore\n     *  Attempt to restore a cached BOSH session\n     *\n     *  Parameters:\n     *    (String) jid - The full JID that is bound by the session.\n     *      This parameter is optional but recommended, specifically in cases\n     *      where prebinded BOSH sessions are used where it's important to know\n     *      that the right session is being restored.\n     *    (Function) callback The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\n     *      allowed range of request ids that are valid.  The default is 5.\n     */\n    _restore: function (jid, callback, wait, hold, wind) {\n        var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));\n        if (typeof session !== \"undefined\" &&\n                   session !== null &&\n                   session.rid &&\n                   session.sid &&\n                   session.jid &&\n                   (    typeof jid === \"undefined\" ||\n                        jid === null ||\n                        Strophe.getBareJidFromJid(session.jid) === Strophe.getBareJidFromJid(jid) ||\n                        // If authcid is null, then it's an anonymous login, so\n                        // we compare only the domains:\n                        ((Strophe.getNodeFromJid(jid) === null) && (Strophe.getDomainFromJid(session.jid) === jid))\n                    )\n        ) {\n            this._conn.restored = true;\n            this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);\n        } else {\n            throw { name: \"StropheSessionError\", message: \"_restore: no restoreable session.\" };\n        }\n    },\n\n    /** PrivateFunction: _cacheSession\n     *  _Private_ handler for the beforeunload event.\n     *\n     *  This handler is used to process the Bosh-part of the initial request.\n     *  Parameters:\n     *    (Strophe.Request) bodyWrap - The received stanza.\n     */\n    _cacheSession: function () {\n        if (this._conn.authenticated) {\n            if (this._conn.jid && this.rid && this.sid) {\n                window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({\n                    'jid': this._conn.jid,\n                    'rid': this.rid,\n                    'sid': this.sid\n                }));\n            }\n        } else {\n            window.sessionStorage.removeItem('strophe-bosh-session');\n        }\n    },\n\n    /** PrivateFunction: _connect_cb\n     *  _Private_ handler for initial connection request.\n     *\n     *  This handler is used to process the Bosh-part of the initial request.\n     *  Parameters:\n     *    (Strophe.Request) bodyWrap - The received stanza.\n     */\n    _connect_cb: function (bodyWrap) {\n        var typ = bodyWrap.getAttribute(\"type\");\n        var cond, conflict;\n        if (typ !== null && typ === \"terminate\") {\n            // an error occurred\n            cond = bodyWrap.getAttribute(\"condition\");\n            Strophe.error(\"BOSH-Connection failed: \" + cond);\n            conflict = bodyWrap.getElementsByTagName(\"conflict\");\n            if (cond !== null) {\n                if (cond === \"remote-stream-error\" && conflict.length > 0) {\n                    cond = \"conflict\";\n                }\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\n            } else {\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"unknown\");\n            }\n            this._conn._doDisconnect(cond);\n            return Strophe.Status.CONNFAIL;\n        }\n\n        // check to make sure we don't overwrite these if _connect_cb is\n        // called multiple times in the case of missing stream:features\n        if (!this.sid) {\n            this.sid = bodyWrap.getAttribute(\"sid\");\n        }\n        var wind = bodyWrap.getAttribute('requests');\n        if (wind) { this.window = parseInt(wind, 10); }\n        var hold = bodyWrap.getAttribute('hold');\n        if (hold) { this.hold = parseInt(hold, 10); }\n        var wait = bodyWrap.getAttribute('wait');\n        if (wait) { this.wait = parseInt(wait, 10); }\n        var inactivity = bodyWrap.getAttribute('inactivity');\n        if (inactivity) { this.inactivity = parseInt(inactivity, 10); }\n    },\n\n    /** PrivateFunction: _disconnect\n     *  _Private_ part of Connection.disconnect for Bosh\n     *\n     *  Parameters:\n     *    (Request) pres - This stanza will be sent before disconnecting.\n     */\n    _disconnect: function (pres) {\n        this._sendTerminate(pres);\n    },\n\n    /** PrivateFunction: _doDisconnect\n     *  _Private_ function to disconnect.\n     *\n     *  Resets the SID and RID.\n     */\n    _doDisconnect: function () {\n        this.sid = null;\n        this.rid = Math.floor(Math.random() * 4294967295);\n        if (this._conn._sessionCachingSupported()) {\n            window.sessionStorage.removeItem('strophe-bosh-session');\n        }\n\n        this._conn.nextValidRid(this.rid);\n    },\n\n    /** PrivateFunction: _emptyQueue\n     * _Private_ function to check if the Request queue is empty.\n     *\n     *  Returns:\n     *    True, if there are no Requests queued, False otherwise.\n     */\n    _emptyQueue: function () {\n        return this._requests.length === 0;\n    },\n\n    /** PrivateFunction: _callProtocolErrorHandlers\n     *  _Private_ function to call error handlers registered for HTTP errors.\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The request that is changing readyState.\n     */\n    _callProtocolErrorHandlers: function (req) {\n        var reqStatus = this._getRequestStatus(req),\n            err_callback;\n        err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];\n        if (err_callback) {\n            err_callback.call(this, reqStatus);\n        }\n    },\n\n    /** PrivateFunction: _hitError\n     *  _Private_ function to handle the error count.\n     *\n     *  Requests are resent automatically until their error count reaches\n     *  5.  Each time an error is encountered, this function is called to\n     *  increment the count and disconnect if the count is too high.\n     *\n     *  Parameters:\n     *    (Integer) reqStatus - The request status.\n     */\n    _hitError: function (reqStatus) {\n        this.errors++;\n        Strophe.warn(\"request errored, status: \" + reqStatus +\n                     \", number of errors: \" + this.errors);\n        if (this.errors > 4) {\n            this._conn._onDisconnectTimeout();\n        }\n    },\n\n    /** PrivateFunction: _no_auth_received\n     *\n     * Called on stream start/restart when no stream:features\n     * has been received and sends a blank poll request.\n     */\n    _no_auth_received: function (callback) {\n        Strophe.warn(\"Server did not yet offer a supported authentication \"+\n                     \"mechanism. Sending a blank poll request.\");\n        if (callback) {\n            callback = callback.bind(this._conn);\n        } else {\n            callback = this._conn._connect_cb.bind(this._conn);\n        }\n        var body = this._buildBody();\n        this._requests.push(\n            new Strophe.Request(\n                body.tree(),\n                this._onRequestStateChange.bind(this, callback),\n                body.tree().getAttribute(\"rid\")\n            )\n        );\n        this._throttledRequestHandler();\n    },\n\n    /** PrivateFunction: _onDisconnectTimeout\n     *  _Private_ timeout handler for handling non-graceful disconnection.\n     *\n     *  Cancels all remaining Requests and clears the queue.\n     */\n    _onDisconnectTimeout: function () {\n        this._abortAllRequests();\n    },\n\n    /** PrivateFunction: _abortAllRequests\n     *  _Private_ helper function that makes sure all pending requests are aborted.\n     */\n    _abortAllRequests: function _abortAllRequests() {\n        var req;\n        while (this._requests.length > 0) {\n            req = this._requests.pop();\n            req.abort = true;\n            req.xhr.abort();\n            // jslint complains, but this is fine. setting to empty func\n            // is necessary for IE6\n            req.xhr.onreadystatechange = function () {}; // jshint ignore:line\n        }\n    },\n\n    /** PrivateFunction: _onIdle\n     *  _Private_ handler called by Strophe.Connection._onIdle\n     *\n     *  Sends all queued Requests or polls with empty Request if there are none.\n     */\n    _onIdle: function () {\n        var data = this._conn._data;\n        // if no requests are in progress, poll\n        if (this._conn.authenticated && this._requests.length === 0 &&\n            data.length === 0 && !this._conn.disconnecting) {\n            Strophe.info(\"no requests during idle cycle, sending \" +\n                         \"blank request\");\n            data.push(null);\n        }\n\n        if (this._conn.paused) {\n            return;\n        }\n\n        if (this._requests.length < 2 && data.length > 0) {\n            var body = this._buildBody();\n            for (var i = 0; i < data.length; i++) {\n                if (data[i] !== null) {\n                    if (data[i] === \"restart\") {\n                        body.attrs({\n                            to: this._conn.domain,\n                            \"xml:lang\": \"en\",\n                            \"xmpp:restart\": \"true\",\n                            \"xmlns:xmpp\": Strophe.NS.BOSH\n                        });\n                    } else {\n                        body.cnode(data[i]).up();\n                    }\n                }\n            }\n            delete this._conn._data;\n            this._conn._data = [];\n            this._requests.push(\n                new Strophe.Request(body.tree(),\n                                    this._onRequestStateChange.bind(\n                                        this, this._conn._dataRecv.bind(this._conn)),\n                                    body.tree().getAttribute(\"rid\")));\n            this._throttledRequestHandler();\n        }\n\n        if (this._requests.length > 0) {\n            var time_elapsed = this._requests[0].age();\n            if (this._requests[0].dead !== null) {\n                if (this._requests[0].timeDead() >\n                    Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {\n                    this._throttledRequestHandler();\n                }\n            }\n\n            if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {\n                Strophe.warn(\"Request \" +\n                             this._requests[0].id +\n                             \" timed out, over \" + Math.floor(Strophe.TIMEOUT * this.wait) +\n                             \" seconds since last activity\");\n                this._throttledRequestHandler();\n            }\n        }\n    },\n\n    /** PrivateFunction: _getRequestStatus\n     *\n     *  Returns the HTTP status code from a Strophe.Request\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The Strophe.Request instance.\n     *    (Integer) def - The default value that should be returned if no\n     *          status value was found.\n     */\n    _getRequestStatus: function (req, def) {\n        var reqStatus;\n        if (req.xhr.readyState === 4) {\n            try {\n                reqStatus = req.xhr.status;\n            } catch (e) {\n                // ignore errors from undefined status attribute. Works\n                // around a browser bug\n                Strophe.error(\n                    \"Caught an error while retrieving a request's status, \" +\n                    \"reqStatus: \" + reqStatus);\n            }\n        }\n        if (typeof(reqStatus) === \"undefined\") {\n            reqStatus = typeof def === 'number' ? def : 0;\n        }\n        return reqStatus;\n    },\n\n    /** PrivateFunction: _onRequestStateChange\n     *  _Private_ handler for Strophe.Request state changes.\n     *\n     *  This function is called when the XMLHttpRequest readyState changes.\n     *  It contains a lot of error handling logic for the many ways that\n     *  requests can fail, and calls the request callback when requests\n     *  succeed.\n     *\n     *  Parameters:\n     *    (Function) func - The handler for the request.\n     *    (Strophe.Request) req - The request that is changing readyState.\n     */\n    _onRequestStateChange: function (func, req) {\n        Strophe.debug(\"request id \"+req.id+\".\"+req.sends+\n                      \" state changed to \"+req.xhr.readyState);\n        if (req.abort) {\n            req.abort = false;\n            return;\n        }\n        if (req.xhr.readyState !== 4) {\n            // The request is not yet complete\n            return;\n        }\n        var reqStatus = this._getRequestStatus(req);\n        this.lastResponseHeaders = req.xhr.getAllResponseHeaders();\n        if (this.disconnecting && reqStatus >= 400) {\n            this._hitError(reqStatus);\n            this._callProtocolErrorHandlers(req);\n            return;\n        }\n\n        var valid_request = reqStatus > 0 && reqStatus < 500;\n        var too_many_retries = req.sends > this._conn.maxRetries;\n        if (valid_request || too_many_retries) {\n            // remove from internal queue\n            this._removeRequest(req);\n            Strophe.debug(\"request id \"+req.id+\" should now be removed\");\n        }\n\n        if (reqStatus === 200) {\n            // request succeeded\n            var reqIs0 = (this._requests[0] === req);\n            var reqIs1 = (this._requests[1] === req);\n            // if request 1 finished, or request 0 finished and request\n            // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to\n            // restart the other - both will be in the first spot, as the\n            // completed request has been removed from the queue already\n            if (reqIs1 ||\n                (reqIs0 && this._requests.length > 0 &&\n                    this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {\n                this._restartRequest(0);\n            }\n            this._conn.nextValidRid(Number(req.rid) + 1);\n            Strophe.debug(\"request id \"+req.id+\".\"+req.sends+\" got 200\");\n            func(req); // call handler\n            this.errors = 0;\n        } else if (reqStatus === 0 ||\n                   (reqStatus >= 400 && reqStatus < 600) ||\n                   reqStatus >= 12000) {\n            // request failed\n            Strophe.error(\"request id \"+req.id+\".\"+req.sends+\" error \"+reqStatus+\" happened\");\n            this._hitError(reqStatus);\n            this._callProtocolErrorHandlers(req);\n            if (reqStatus >= 400 && reqStatus < 500) {\n                this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);\n                this._conn._doDisconnect();\n            }\n        } else {\n            Strophe.error(\"request id \"+req.id+\".\"+req.sends+\" error \"+reqStatus+\" happened\");\n        }\n\n        if (!valid_request && !too_many_retries) {\n            this._throttledRequestHandler();\n        } else if (too_many_retries && !this._conn.connected) {\n            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"giving-up\");\n        }\n    },\n\n    /** PrivateFunction: _processRequest\n     *  _Private_ function to process a request in the queue.\n     *\n     *  This function takes requests off the queue and sends them and\n     *  restarts dead requests.\n     *\n     *  Parameters:\n     *    (Integer) i - The index of the request in the queue.\n     */\n    _processRequest: function (i) {\n        var self = this;\n        var req = this._requests[i];\n        var reqStatus = this._getRequestStatus(req, -1);\n\n        // make sure we limit the number of retries\n        if (req.sends > this._conn.maxRetries) {\n            this._conn._onDisconnectTimeout();\n            return;\n        }\n\n        var time_elapsed = req.age();\n        var primaryTimeout = (!isNaN(time_elapsed) &&\n                              time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));\n        var secondaryTimeout = (req.dead !== null &&\n                                req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));\n        var requestCompletedWithServerError = (req.xhr.readyState === 4 &&\n                                               (reqStatus < 1 || reqStatus >= 500));\n        if (primaryTimeout || secondaryTimeout ||\n            requestCompletedWithServerError) {\n            if (secondaryTimeout) {\n                Strophe.error(\"Request \" + this._requests[i].id +\n                              \" timed out (secondary), restarting\");\n            }\n            req.abort = true;\n            req.xhr.abort();\n            // setting to null fails on IE6, so set to empty function\n            req.xhr.onreadystatechange = function () {};\n            this._requests[i] = new Strophe.Request(req.xmlData,\n                                                    req.origFunc,\n                                                    req.rid,\n                                                    req.sends);\n            req = this._requests[i];\n        }\n\n        if (req.xhr.readyState === 0) {\n            Strophe.debug(\"request id \"+req.id+\".\"+req.sends+\" posting\");\n\n            try {\n                var contentType = this._conn.options.contentType || \"text/xml; charset=utf-8\";\n                req.xhr.open(\"POST\", this._conn.service, this._conn.options.sync ? false : true);\n                if (typeof req.xhr.setRequestHeader !== 'undefined') {\n                    // IE9 doesn't have setRequestHeader\n                    req.xhr.setRequestHeader(\"Content-Type\", contentType);\n                }\n                if (this._conn.options.withCredentials) {\n                    req.xhr.withCredentials = true;\n                }\n            } catch (e2) {\n                Strophe.error(\"XHR open failed: \" + e2.toString());\n                if (!this._conn.connected) {\n                    this._conn._changeConnectStatus(\n                            Strophe.Status.CONNFAIL, \"bad-service\");\n                }\n                this._conn.disconnect();\n                return;\n            }\n\n            // Fires the XHR request -- may be invoked immediately\n            // or on a gradually expanding retry window for reconnects\n            var sendFunc = function () {\n                req.date = new Date();\n                if (self._conn.options.customHeaders){\n                    var headers = self._conn.options.customHeaders;\n                    for (var header in headers) {\n                        if (headers.hasOwnProperty(header)) {\n                            req.xhr.setRequestHeader(header, headers[header]);\n                        }\n                    }\n                }\n                req.xhr.send(req.data);\n            };\n\n            // Implement progressive backoff for reconnects --\n            // First retry (send === 1) should also be instantaneous\n            if (req.sends > 1) {\n                // Using a cube of the retry number creates a nicely\n                // expanding retry window\n                var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),\n                                       Math.pow(req.sends, 3)) * 1000;\n                setTimeout(function() {\n                    // XXX: setTimeout should be called only with function expressions (23974bc1)\n                    sendFunc();\n                }, backoff);\n            } else {\n                sendFunc();\n            }\n\n            req.sends++;\n\n            if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {\n                if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {\n                    this._conn.xmlOutput(req.xmlData.childNodes[0]);\n                } else {\n                    this._conn.xmlOutput(req.xmlData);\n                }\n            }\n            if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {\n                this._conn.rawOutput(req.data);\n            }\n        } else {\n            Strophe.debug(\"_processRequest: \" +\n                          (i === 0 ? \"first\" : \"second\") +\n                          \" request has readyState of \" +\n                          req.xhr.readyState);\n        }\n    },\n\n    /** PrivateFunction: _removeRequest\n     *  _Private_ function to remove a request from the queue.\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The request to remove.\n     */\n    _removeRequest: function (req) {\n        Strophe.debug(\"removing request\");\n        var i;\n        for (i = this._requests.length - 1; i >= 0; i--) {\n            if (req === this._requests[i]) {\n                this._requests.splice(i, 1);\n            }\n        }\n        // IE6 fails on setting to null, so set to empty function\n        req.xhr.onreadystatechange = function () {};\n        this._throttledRequestHandler();\n    },\n\n    /** PrivateFunction: _restartRequest\n     *  _Private_ function to restart a request that is presumed dead.\n     *\n     *  Parameters:\n     *    (Integer) i - The index of the request in the queue.\n     */\n    _restartRequest: function (i) {\n        var req = this._requests[i];\n        if (req.dead === null) {\n            req.dead = new Date();\n        }\n\n        this._processRequest(i);\n    },\n\n    /** PrivateFunction: _reqToData\n     * _Private_ function to get a stanza out of a request.\n     *\n     * Tries to extract a stanza out of a Request Object.\n     * When this fails the current connection will be disconnected.\n     *\n     *  Parameters:\n     *    (Object) req - The Request.\n     *\n     *  Returns:\n     *    The stanza that was passed.\n     */\n    _reqToData: function (req) {\n        try {\n            return req.getResponse();\n        } catch (e) {\n            if (e !== \"parsererror\") { throw e; }\n            this._conn.disconnect(\"strophe-parsererror\");\n        }\n    },\n\n    /** PrivateFunction: _sendTerminate\n     *  _Private_ function to send initial disconnect sequence.\n     *\n     *  This is the first step in a graceful disconnect.  It sends\n     *  the BOSH server a terminate body and includes an unavailable\n     *  presence if authentication has completed.\n     */\n    _sendTerminate: function (pres) {\n        Strophe.info(\"_sendTerminate was called\");\n        var body = this._buildBody().attrs({type: \"terminate\"});\n        if (pres) {\n            body.cnode(pres.tree());\n        }\n        var req = new Strophe.Request(\n            body.tree(),\n            this._onRequestStateChange.bind(\n            this, this._conn._dataRecv.bind(this._conn)),\n            body.tree().getAttribute(\"rid\")\n        );\n        this._requests.push(req);\n        this._throttledRequestHandler();\n    },\n\n    /** PrivateFunction: _send\n     *  _Private_ part of the Connection.send function for BOSH\n     *\n     * Just triggers the RequestHandler to send the messages that are in the queue\n     */\n    _send: function () {\n        clearTimeout(this._conn._idleTimeout);\n        this._throttledRequestHandler();\n\n        // XXX: setTimeout should be called only with function expressions (23974bc1)\n        this._conn._idleTimeout = setTimeout(function() {\n            this._onIdle();\n        }.bind(this._conn), 100);\n    },\n\n    /** PrivateFunction: _sendRestart\n     *\n     *  Send an xmpp:restart stanza.\n     */\n    _sendRestart: function () {\n        this._throttledRequestHandler();\n        clearTimeout(this._conn._idleTimeout);\n    },\n\n    /** PrivateFunction: _throttledRequestHandler\n     *  _Private_ function to throttle requests to the connection window.\n     *\n     *  This function makes sure we don't send requests so fast that the\n     *  request ids overflow the connection window in the case that one\n     *  request died.\n     */\n    _throttledRequestHandler: function () {\n        if (!this._requests) {\n            Strophe.debug(\"_throttledRequestHandler called with \" +\n                          \"undefined requests\");\n        } else {\n            Strophe.debug(\"_throttledRequestHandler called with \" +\n                          this._requests.length + \" requests\");\n        }\n\n        if (!this._requests || this._requests.length === 0) {\n            return;\n        }\n\n        if (this._requests.length > 0) {\n            this._processRequest(0);\n        }\n\n        if (this._requests.length > 1 &&\n            Math.abs(this._requests[0].rid -\n                     this._requests[1].rid) < this.window) {\n            this._processRequest(1);\n        }\n    }\n};\nreturn Strophe;\n}));\n\n/*\n    This program is distributed under the terms of the MIT license.\n    Please see the LICENSE file for details.\n\n    Copyright 2006-2008, OGG, LLC\n*/\n\n/* jshint undef: true, unused: true:, noarg: true, latedef: true */\n/* global define, window, clearTimeout, WebSocket, DOMParser, Strophe, $build */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-websocket',['strophe-core'], function (core) {\n            return factory(\n                core.Strophe,\n                core.$build\n            );\n        });\n    } else if (typeof exports === 'object') {\n        var core = require('./core');\n\n        module.exports = factory(core.Strophe, core.$build);\n    } else {\n        // Browser globals\n        return factory(Strophe, $build);\n    }\n}(this, function (Strophe, $build) {\n\n/** Class: Strophe.WebSocket\n *  _Private_ helper class that handles WebSocket Connections\n *\n *  The Strophe.WebSocket class is used internally by Strophe.Connection\n *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.\n */\n\n/** File: websocket.js\n *  A JavaScript library to enable XMPP over Websocket in Strophejs.\n *\n *  This file implements XMPP over WebSockets for Strophejs.\n *  If a Connection is established with a Websocket url (ws://...)\n *  Strophe will use WebSockets.\n *  For more information on XMPP-over-WebSocket see RFC 7395:\n *  http://tools.ietf.org/html/rfc7395\n *\n *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)\n */\n\n/** PrivateConstructor: Strophe.Websocket\n *  Create and initialize a Strophe.WebSocket object.\n *  Currently only sets the connection Object.\n *\n *  Parameters:\n *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.\n *\n *  Returns:\n *    A new Strophe.WebSocket object.\n */\nStrophe.Websocket = function(connection) {\n    this._conn = connection;\n    this.strip = \"wrapper\";\n\n    var service = connection.service;\n    if (service.indexOf(\"ws:\") !== 0 && service.indexOf(\"wss:\") !== 0) {\n        // If the service is not an absolute URL, assume it is a path and put the absolute\n        // URL together from options, current URL and the path.\n        var new_service = \"\";\n\n        if (connection.options.protocol === \"ws\" && window.location.protocol !== \"https:\") {\n            new_service += \"ws\";\n        } else {\n            new_service += \"wss\";\n        }\n\n        new_service += \"://\" + window.location.host;\n\n        if (service.indexOf(\"/\") !== 0) {\n            new_service += window.location.pathname + service;\n        } else {\n            new_service += service;\n        }\n\n        connection.service = new_service;\n    }\n};\n\nStrophe.Websocket.prototype = {\n    /** PrivateFunction: _buildStream\n     *  _Private_ helper function to generate the <stream> start tag for WebSockets\n     *\n     *  Returns:\n     *    A Strophe.Builder with a <stream> element.\n     */\n    _buildStream: function () {\n        return $build(\"open\", {\n            \"xmlns\": Strophe.NS.FRAMING,\n            \"to\": this._conn.domain,\n            \"version\": '1.0'\n        });\n    },\n\n    /** PrivateFunction: _check_streamerror\n     * _Private_ checks a message for stream:error\n     *\n     *  Parameters:\n     *    (Strophe.Request) bodyWrap - The received stanza.\n     *    connectstatus - The ConnectStatus that will be set on error.\n     *  Returns:\n     *     true if there was a streamerror, false otherwise.\n     */\n    _check_streamerror: function (bodyWrap, connectstatus) {\n        var errors;\n        if (bodyWrap.getElementsByTagNameNS) {\n            errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \"error\");\n        } else {\n            errors = bodyWrap.getElementsByTagName(\"stream:error\");\n        }\n        if (errors.length === 0) {\n            return false;\n        }\n        var error = errors[0];\n\n        var condition = \"\";\n        var text = \"\";\n\n        var ns = \"urn:ietf:params:xml:ns:xmpp-streams\";\n        for (var i = 0; i < error.childNodes.length; i++) {\n            var e = error.childNodes[i];\n            if (e.getAttribute(\"xmlns\") !== ns) {\n                break;\n            } if (e.nodeName === \"text\") {\n                text = e.textContent;\n            } else {\n                condition = e.nodeName;\n            }\n        }\n\n        var errorString = \"WebSocket stream error: \";\n\n        if (condition) {\n            errorString += condition;\n        } else {\n            errorString += \"unknown\";\n        }\n\n        if (text) {\n            errorString += \" - \" + text;\n        }\n\n        Strophe.error(errorString);\n\n        // close the connection on stream_error\n        this._conn._changeConnectStatus(connectstatus, condition);\n        this._conn._doDisconnect();\n        return true;\n    },\n\n    /** PrivateFunction: _reset\n     *  Reset the connection.\n     *\n     *  This function is called by the reset function of the Strophe Connection.\n     *  Is not needed by WebSockets.\n     */\n    _reset: function () {\n        return;\n    },\n\n    /** PrivateFunction: _connect\n     *  _Private_ function called by Strophe.Connection.connect\n     *\n     *  Creates a WebSocket for a connection and assigns Callbacks to it.\n     *  Does nothing if there already is a WebSocket.\n     */\n    _connect: function () {\n        // Ensure that there is no open WebSocket from a previous Connection.\n        this._closeSocket();\n\n        // Create the new WobSocket\n        this.socket = new WebSocket(this._conn.service, \"xmpp\");\n        this.socket.onopen = this._onOpen.bind(this);\n        this.socket.onerror = this._onError.bind(this);\n        this.socket.onclose = this._onClose.bind(this);\n        this.socket.onmessage = this._connect_cb_wrapper.bind(this);\n    },\n\n    /** PrivateFunction: _connect_cb\n     *  _Private_ function called by Strophe.Connection._connect_cb\n     *\n     * checks for stream:error\n     *\n     *  Parameters:\n     *    (Strophe.Request) bodyWrap - The received stanza.\n     */\n    _connect_cb: function(bodyWrap) {\n        var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);\n        if (error) {\n            return Strophe.Status.CONNFAIL;\n        }\n    },\n\n    /** PrivateFunction: _handleStreamStart\n     * _Private_ function that checks the opening <open /> tag for errors.\n     *\n     * Disconnects if there is an error and returns false, true otherwise.\n     *\n     *  Parameters:\n     *    (Node) message - Stanza containing the <open /> tag.\n     */\n    _handleStreamStart: function(message) {\n        var error = false;\n\n        // Check for errors in the <open /> tag\n        var ns = message.getAttribute(\"xmlns\");\n        if (typeof ns !== \"string\") {\n            error = \"Missing xmlns in <open />\";\n        } else if (ns !== Strophe.NS.FRAMING) {\n            error = \"Wrong xmlns in <open />: \" + ns;\n        }\n\n        var ver = message.getAttribute(\"version\");\n        if (typeof ver !== \"string\") {\n            error = \"Missing version in <open />\";\n        } else if (ver !== \"1.0\") {\n            error = \"Wrong version in <open />: \" + ver;\n        }\n\n        if (error) {\n            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);\n            this._conn._doDisconnect();\n            return false;\n        }\n\n        return true;\n    },\n\n    /** PrivateFunction: _connect_cb_wrapper\n     * _Private_ function that handles the first connection messages.\n     *\n     * On receiving an opening stream tag this callback replaces itself with the real\n     * message handler. On receiving a stream error the connection is terminated.\n     */\n    _connect_cb_wrapper: function(message) {\n        if (message.data.indexOf(\"<open \") === 0 || message.data.indexOf(\"<?xml\") === 0) {\n            // Strip the XML Declaration, if there is one\n            var data = message.data.replace(/^(<\\?.*?\\?>\\s*)*/, \"\");\n            if (data === '') return;\n\n            var streamStart = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n            this._conn.xmlInput(streamStart);\n            this._conn.rawInput(message.data);\n\n            //_handleStreamSteart will check for XML errors and disconnect on error\n            if (this._handleStreamStart(streamStart)) {\n                //_connect_cb will check for stream:error and disconnect on error\n                this._connect_cb(streamStart);\n            }\n        } else if (message.data.indexOf(\"<close \") === 0) { // <close xmlns=\"urn:ietf:params:xml:ns:xmpp-framing />\n            // Parse the raw string to an XML element\n            var parsedMessage = new DOMParser().parseFromString(message.data, \"text/xml\").documentElement;\n            // Report this input to the raw and xml handlers\n            this._conn.xmlInput(parsedMessage);\n            this._conn.rawInput(message.data);\n            var see_uri = parsedMessage.getAttribute(\"see-other-uri\");\n            if (see_uri) {\n                var service = this._conn.service;\n                // Valid scenarios: WSS->WSS, WS->ANY\n                var isSecureRedirect = (service.indexOf(\"wss:\") >= 0 && see_uri.indexOf(\"wss:\") >= 0) || (service.indexOf(\"ws:\") >= 0);\n                if(isSecureRedirect) {\n                    this._conn._changeConnectStatus(\n                        Strophe.Status.REDIRECT,\n                        \"Received see-other-uri, resetting connection\"\n                    );\n                    this._conn.reset();\n                    this._conn.service = see_uri;\n                    this._connect();\n                }\n            } else {\n                this._conn._changeConnectStatus(\n                    Strophe.Status.CONNFAIL,\n                    \"Received closing stream\"\n                );\n                this._conn._doDisconnect();\n            }\n        } else {\n            var string = this._streamWrap(message.data);\n            var elem = new DOMParser().parseFromString(string, \"text/xml\").documentElement;\n            this.socket.onmessage = this._onMessage.bind(this);\n            this._conn._connect_cb(elem, null, message.data);\n        }\n    },\n\n    /** PrivateFunction: _disconnect\n     *  _Private_ function called by Strophe.Connection.disconnect\n     *\n     *  Disconnects and sends a last stanza if one is given\n     *\n     *  Parameters:\n     *    (Request) pres - This stanza will be sent before disconnecting.\n     */\n    _disconnect: function (pres) {\n        if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {\n            if (pres) {\n                this._conn.send(pres);\n            }\n            var close = $build(\"close\", { \"xmlns\": Strophe.NS.FRAMING });\n            this._conn.xmlOutput(close.tree());\n            var closeString = Strophe.serialize(close);\n            this._conn.rawOutput(closeString);\n            try {\n                this.socket.send(closeString);\n            } catch (e) {\n                Strophe.info(\"Couldn't send <close /> tag.\");\n            }\n        }\n        this._conn._doDisconnect();\n    },\n\n    /** PrivateFunction: _doDisconnect\n     *  _Private_ function to disconnect.\n     *\n     *  Just closes the Socket for WebSockets\n     */\n    _doDisconnect: function () {\n        Strophe.info(\"WebSockets _doDisconnect was called\");\n        this._closeSocket();\n    },\n\n    /** PrivateFunction _streamWrap\n     *  _Private_ helper function to wrap a stanza in a <stream> tag.\n     *  This is used so Strophe can process stanzas from WebSockets like BOSH\n     */\n    _streamWrap: function (stanza) {\n        return \"<wrapper>\" + stanza + '</wrapper>';\n    },\n\n\n    /** PrivateFunction: _closeSocket\n     *  _Private_ function to close the WebSocket.\n     *\n     *  Closes the socket if it is still open and deletes it\n     */\n    _closeSocket: function () {\n        if (this.socket) { try {\n            this.socket.onerror = null;\n            this.socket.close();\n        } catch (e) {} }\n        this.socket = null;\n    },\n\n    /** PrivateFunction: _emptyQueue\n     * _Private_ function to check if the message queue is empty.\n     *\n     *  Returns:\n     *    True, because WebSocket messages are send immediately after queueing.\n     */\n    _emptyQueue: function () {\n        return true;\n    },\n\n    /** PrivateFunction: _onClose\n     * _Private_ function to handle websockets closing.\n     *\n     * Nothing to do here for WebSockets\n     */\n    _onClose: function(e) {\n        if(this._conn.connected && !this._conn.disconnecting) {\n            Strophe.error(\"Websocket closed unexpectedly\");\n            this._conn._doDisconnect();\n        } else if (e && e.code === 1006 && !this._conn.connected && this.socket) {\n            // in case the onError callback was not called (Safari 10 does not\n            // call onerror when the initial connection fails) we need to\n            // dispatch a CONNFAIL status update to be consistent with the\n            // behavior on other browsers.\n            Strophe.error(\"Websocket closed unexcectedly\");\n            this._conn._changeConnectStatus(\n                Strophe.Status.CONNFAIL,\n                \"The WebSocket connection could not be established or was disconnected.\"\n            );\n            this._conn._doDisconnect();\n        } else {\n            Strophe.info(\"Websocket closed\");\n        }\n    },\n\n    /** PrivateFunction: _no_auth_received\n     *\n     * Called on stream start/restart when no stream:features\n     * has been received.\n     */\n    _no_auth_received: function (callback) {\n        Strophe.error(\"Server did not offer a supported authentication mechanism\");\n        this._changeConnectStatus(\n            Strophe.Status.CONNFAIL,\n            Strophe.ErrorCondition.NO_AUTH_MECH\n        );\n        if (callback) {\n            callback.call(this._conn);\n        }\n        this._conn._doDisconnect();\n    },\n\n    /** PrivateFunction: _onDisconnectTimeout\n     *  _Private_ timeout handler for handling non-graceful disconnection.\n     *\n     *  This does nothing for WebSockets\n     */\n    _onDisconnectTimeout: function () {},\n\n    /** PrivateFunction: _abortAllRequests\n     *  _Private_ helper function that makes sure all pending requests are aborted.\n     */\n    _abortAllRequests: function () {},\n\n    /** PrivateFunction: _onError\n     * _Private_ function to handle websockets errors.\n     *\n     * Parameters:\n     * (Object) error - The websocket error.\n     */\n    _onError: function(error) {\n        Strophe.error(\"Websocket error \" + error);\n        this._conn._changeConnectStatus(\n            Strophe.Status.CONNFAIL,\n            \"The WebSocket connection could not be established or was disconnected.\"\n        );\n        this._disconnect();\n    },\n\n    /** PrivateFunction: _onIdle\n     *  _Private_ function called by Strophe.Connection._onIdle\n     *\n     *  sends all queued stanzas\n     */\n    _onIdle: function () {\n        var data = this._conn._data;\n        if (data.length > 0 && !this._conn.paused) {\n            for (var i = 0; i < data.length; i++) {\n                if (data[i] !== null) {\n                    var stanza, rawStanza;\n                    if (data[i] === \"restart\") {\n                        stanza = this._buildStream().tree();\n                    } else {\n                        stanza = data[i];\n                    }\n                    rawStanza = Strophe.serialize(stanza);\n                    this._conn.xmlOutput(stanza);\n                    this._conn.rawOutput(rawStanza);\n                    this.socket.send(rawStanza);\n                }\n            }\n            this._conn._data = [];\n        }\n    },\n\n    /** PrivateFunction: _onMessage\n     * _Private_ function to handle websockets messages.\n     *\n     * This function parses each of the messages as if they are full documents.\n     * [TODO : We may actually want to use a SAX Push parser].\n     *\n     * Since all XMPP traffic starts with\n     *  <stream:stream version='1.0'\n     *                 xml:lang='en'\n     *                 xmlns='jabber:client'\n     *                 xmlns:stream='http://etherx.jabber.org/streams'\n     *                 id='3697395463'\n     *                 from='SERVER'>\n     *\n     * The first stanza will always fail to be parsed.\n     *\n     * Additionally, the seconds stanza will always be <stream:features> with\n     * the stream NS defined in the previous stanza, so we need to 'force'\n     * the inclusion of the NS in this stanza.\n     *\n     * Parameters:\n     * (string) message - The websocket message.\n     */\n    _onMessage: function(message) {\n        var elem, data;\n        // check for closing stream\n        var close = '<close xmlns=\"urn:ietf:params:xml:ns:xmpp-framing\" />';\n        if (message.data === close) {\n            this._conn.rawInput(close);\n            this._conn.xmlInput(message);\n            if (!this._conn.disconnecting) {\n                this._conn._doDisconnect();\n            }\n            return;\n        } else if (message.data.search(\"<open \") === 0) {\n            // This handles stream restarts\n            elem = new DOMParser().parseFromString(message.data, \"text/xml\").documentElement;\n            if (!this._handleStreamStart(elem)) {\n                return;\n            }\n        } else {\n            data = this._streamWrap(message.data);\n            elem = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n        }\n\n        if (this._check_streamerror(elem, Strophe.Status.ERROR)) {\n            return;\n        }\n\n        //handle unavailable presence stanza before disconnecting\n        if (this._conn.disconnecting &&\n                elem.firstChild.nodeName === \"presence\" &&\n                elem.firstChild.getAttribute(\"type\") === \"unavailable\") {\n            this._conn.xmlInput(elem);\n            this._conn.rawInput(Strophe.serialize(elem));\n            // if we are already disconnecting we will ignore the unavailable stanza and\n            // wait for the </stream:stream> tag before we close the connection\n            return;\n        }\n        this._conn._dataRecv(elem, message.data);\n    },\n\n    /** PrivateFunction: _onOpen\n     * _Private_ function to handle websockets connection setup.\n     *\n     * The opening stream tag is sent here.\n     */\n    _onOpen: function() {\n        Strophe.info(\"Websocket open\");\n        var start = this._buildStream();\n        this._conn.xmlOutput(start.tree());\n\n        var startString = Strophe.serialize(start);\n        this._conn.rawOutput(startString);\n        this.socket.send(startString);\n    },\n\n    /** PrivateFunction: _reqToData\n     * _Private_ function to get a stanza out of a request.\n     *\n     * WebSockets don't use requests, so the passed argument is just returned.\n     *\n     *  Parameters:\n     *    (Object) stanza - The stanza.\n     *\n     *  Returns:\n     *    The stanza that was passed.\n     */\n    _reqToData: function (stanza) {\n        return stanza;\n    },\n\n    /** PrivateFunction: _send\n     *  _Private_ part of the Connection.send function for WebSocket\n     *\n     * Just flushes the messages that are in the queue\n     */\n    _send: function () {\n        this._conn.flush();\n    },\n\n    /** PrivateFunction: _sendRestart\n     *\n     *  Send an xmpp:restart stanza.\n     */\n    _sendRestart: function () {\n        clearTimeout(this._conn._idleTimeout);\n        this._conn._onIdle.bind(this._conn)();\n    }\n};\nreturn Strophe;\n}));\n\n(function(root){\n    if(typeof define === 'function' && define.amd){\n        define('strophe',[\n            \"strophe-core\",\n            \"strophe-bosh\",\n            \"strophe-websocket\"\n        ], function (wrapper) {\n            return wrapper;\n        });\n    } else if (typeof exports === 'object') {\n        var core = require('./core');\n        require('./bosh');\n        require('./websocket');\n        module.exports = core;\n    }\n})(this);\n\n\nrequire([\"strophe-polyfill\"]);\n/* jshint ignore:start */\n    //The modules for your project will be inlined above\n    //this snippet. Ask almond to synchronously require the\n    //module value for 'main' here and return it as the\n    //value to use for the public API for the built file.\n    return require('strophe');\n}));\n/* jshint ignore:end */\n","/**\r\n * The events for the conference.\r\n */\r\n\r\n/**\r\n * Indicates that authentication status changed.\r\n */\r\nexport const AUTH_STATUS_CHANGED = 'conference.auth_status_changed';\r\n\r\n/**\r\n * A participant avatar has changed.\r\n */\r\nexport const AVATAR_CHANGED = 'conference.avatarChanged';\r\n\r\n/**\r\n * Fired just before the statistics module is disposed and it's the last chance\r\n * to submit some logs to the statistics service (ex. CallStats if enabled),\r\n * before it's disconnected.\r\n */\r\nexport const BEFORE_STATISTICS_DISPOSED = 'conference.beforeStatisticsDisposed';\r\n\r\n/**\r\n * Indicates that an error occured.\r\n */\r\nexport const CONFERENCE_ERROR = 'conference.error';\r\n\r\n/**\r\n * Indicates that conference failed.\r\n */\r\nexport const CONFERENCE_FAILED = 'conference.failed';\r\n\r\n/**\r\n * Indicates that conference has been joined. The event does NOT provide any\r\n * parameters to its listeners.\r\n */\r\nexport const CONFERENCE_JOINED = 'conference.joined';\r\n\r\n/**\r\n * Indicates that conference has been left.\r\n */\r\nexport const CONFERENCE_LEFT = 'conference.left';\r\n\r\n/**\r\n * Indicates that the connection to the conference has been established\r\n * XXX This is currently fired whenVthe *ICE* connection enters 'connected'\r\n * state for the first time.\r\n */\r\nexport const CONNECTION_ESTABLISHED = 'conference.connectionEstablished';\r\n\r\n/**\r\n * Indicates that the connection to the conference has been interrupted for some\r\n * reason.\r\n * XXX This is currently fired when the *ICE* connection is interrupted.\r\n */\r\nexport const CONNECTION_INTERRUPTED = 'conference.connectionInterrupted';\r\n\r\n/**\r\n * Indicates that the connection to the conference has been restored.\r\n * XXX This is currently fired when the *ICE* connection is restored.\r\n */\r\nexport const CONNECTION_RESTORED = 'conference.connectionRestored';\r\n\r\n/**\r\n * A connection to the video bridge's data channel has been established.\r\n */\r\nexport const DATA_CHANNEL_OPENED = 'conference.dataChannelOpened';\r\n\r\n/**\r\n * A user has changed it display name\r\n */\r\nexport const DISPLAY_NAME_CHANGED = 'conference.displayNameChanged';\r\n\r\n/**\r\n * The dominant speaker was changed.\r\n */\r\nexport const DOMINANT_SPEAKER_CHANGED = 'conference.dominantSpeaker';\r\n\r\n/**\r\n * Indicates that DTMF support changed.\r\n */\r\nexport const DTMF_SUPPORT_CHANGED = 'conference.dtmfSupportChanged';\r\n\r\n/**\r\n * Indicates that a message from another participant is received on data\r\n * channel.\r\n */\r\nexport const ENDPOINT_MESSAGE_RECEIVED = 'conference.endpoint_message_received';\r\n\r\n/**\r\n * NOTE This is lib-qhsense-meet internal event and can be removed at any time !\r\n *\r\n * Event emitted when conference transits, between one to one and multiparty JVB\r\n * conference. If the conference switches to P2P it's neither one to one nor\r\n * a multiparty JVB conference, but P2P (the status argument of this event will\r\n * be <tt>false</tt>).\r\n *\r\n * The first argument is a boolean which carries the previous value and\r\n * the seconds argument is a boolean with the new status. The event is emitted\r\n * only if the previous and the new values are different.\r\n *\r\n * @type {string}\r\n */\r\nexport const JVB121_STATUS = 'conference.jvb121Status';\r\n\r\n/**\r\n * You are kicked from the conference.\r\n * @param {QHSenseParticipant} the participant that initiated the kick.\r\n */\r\nexport const KICKED = 'conference.kicked';\r\n\r\n/**\r\n * Participant was kicked from the conference.\r\n * @param {QHSenseParticipant} the participant that initiated the kick.\r\n * @param {QHSenseParticipant} the participant that was kicked.\r\n */\r\nexport const PARTICIPANT_KICKED = 'conference.participant_kicked';\r\n\r\n/**\r\n * The Last N set is changed.\r\n *\r\n * @param {Array<string>|null} leavingEndpointIds the ids of all the endpoints\r\n * which are leaving Last N\r\n * @param {Array<string>|null} enteringEndpointIds the ids of all the endpoints\r\n * which are entering Last N\r\n */\r\nexport const LAST_N_ENDPOINTS_CHANGED = 'conference.lastNEndpointsChanged';\r\n\r\n/**\r\n * Indicates that the room has been locked or unlocked.\r\n */\r\nexport const LOCK_STATE_CHANGED = 'conference.lock_state_changed';\r\n\r\n/**\r\n * Indicates that the region of the media server (QHSense-videobridge) that we\r\n * are connected to changed (or was initially set).\r\n * @type {string} the region.\r\n */\r\nexport const SERVER_REGION_CHANGED = 'conference.server_region_changed';\r\n\r\n/**\r\n * New text message was received.\r\n */\r\nexport const MESSAGE_RECEIVED = 'conference.messageReceived';\r\n\r\n/**\r\n * New private text message was received.\r\n */\r\nexport const PRIVATE_MESSAGE_RECEIVED = 'conference.privateMessageReceived';\r\n\r\n/**\r\n * Event fired when JVB sends notification about interrupted/restored user's\r\n * ICE connection status or we detect local problem with the video track.\r\n * First argument is the ID of the participant and\r\n * the seconds is a string indicating if the connection is currently\r\n * - active - the connection is active\r\n * - inactive - the connection is inactive, was intentionally interrupted by\r\n * the bridge\r\n * - interrupted - a network problem occurred\r\n * - restoring - the connection was inactive and is restoring now\r\n *\r\n * The current status value can be obtained by calling\r\n * QHSenseParticipant.getConnectionStatus().\r\n */\r\nexport const PARTICIPANT_CONN_STATUS_CHANGED\r\n    = 'conference.participant_conn_status_changed';\r\n\r\n/**\r\n * Indicates that the features of the participant has been changed.\r\n */\r\nexport const PARTCIPANT_FEATURES_CHANGED\r\n    = 'conference.partcipant_features_changed';\r\n\r\n/**\r\n * Indicates that a the value of a specific property of a specific participant\r\n * has changed.\r\n */\r\nexport const PARTICIPANT_PROPERTY_CHANGED\r\n    = 'conference.participant_property_changed';\r\n\r\n/**\r\n * Indicates that the conference has switched between JVB and P2P connections.\r\n * The first argument of this event is a <tt>boolean</tt> which when set to\r\n * <tt>true</tt> means that the conference is running on the P2P connection.\r\n */\r\nexport const P2P_STATUS = 'conference.p2pStatus';\r\n\r\n/**\r\n * Indicates that phone number changed.\r\n */\r\nexport const PHONE_NUMBER_CHANGED = 'conference.phoneNumberChanged';\r\n\r\n/**\r\n * The conference properties changed.\r\n * @type {string}\r\n */\r\nexport const PROPERTIES_CHANGED = 'conference.propertiesChanged';\r\n\r\n/**\r\n * Indicates that recording state changed.\r\n */\r\nexport const RECORDER_STATE_CHANGED = 'conference.recorderStateChanged';\r\n\r\n/**\r\n * Indicates that video SIP GW state changed.\r\n * @param {VideoSIPGWConstants} status.\r\n */\r\nexport const VIDEO_SIP_GW_AVAILABILITY_CHANGED\r\n    = 'conference.videoSIPGWAvailabilityChanged';\r\n\r\n/**\r\n * Indicates that video SIP GW Session state changed.\r\n * @param {options} event - {\r\n *     {string} address,\r\n *     {VideoSIPGWConstants} oldState,\r\n *     {VideoSIPGWConstants} newState,\r\n *     {string} displayName}\r\n * }.\r\n */\r\nexport const VIDEO_SIP_GW_SESSION_STATE_CHANGED\r\n    = 'conference.videoSIPGWSessionStateChanged';\r\n\r\n/**\r\n * Indicates that start muted settings changed.\r\n */\r\nexport const START_MUTED_POLICY_CHANGED\r\n    = 'conference.start_muted_policy_changed';\r\n\r\n/**\r\n * Indicates that the local user has started muted.\r\n */\r\nexport const STARTED_MUTED = 'conference.started_muted';\r\n\r\n/**\r\n * Indicates that subject of the conference has changed.\r\n */\r\nexport const SUBJECT_CHANGED = 'conference.subjectChanged';\r\n\r\n/**\r\n * Indicates that DTMF support changed.\r\n */\r\nexport const SUSPEND_DETECTED = 'conference.suspendDetected';\r\n\r\n/**\r\n * Event indicates that local user is talking while he muted himself\r\n */\r\nexport const TALK_WHILE_MUTED = 'conference.talk_while_muted';\r\n\r\n/**\r\n * A new media track was added to the conference. The event provides the\r\n * following parameters to its listeners:\r\n *\r\n * @param {QHSenseTrack} track the added QHSenseTrack\r\n */\r\nexport const TRACK_ADDED = 'conference.trackAdded';\r\n\r\n/**\r\n * Audio levels of a media track ( attached to the conference) was changed.\r\n */\r\nexport const TRACK_AUDIO_LEVEL_CHANGED = 'conference.audioLevelsChanged';\r\n\r\n/**\r\n * A media track ( attached to the conference) mute status was changed.\r\n * @param {QHSenseParticipant|null} the participant that initiated the mute\r\n * if it is a remote mute.\r\n */\r\nexport const TRACK_MUTE_CHANGED = 'conference.trackMuteChanged';\r\n\r\n/**\r\n * The media track was removed from the conference. The event provides the\r\n * following parameters to its listeners:\r\n *\r\n * @param {QHSenseTrack} track the removed QHSenseTrack\r\n */\r\nexport const TRACK_REMOVED = 'conference.trackRemoved';\r\n\r\n/**\r\n * Notifies for transcription status changes. The event provides the\r\n * following parameters to its listeners:\r\n *\r\n * @param {String} status - The new status.\r\n */\r\nexport const TRANSCRIPTION_STATUS_CHANGED\r\n    = 'conference.transcriptionStatusChanged';\r\n\r\n\r\n/**\r\n * A new user joined the conference.\r\n */\r\nexport const USER_JOINED = 'conference.userJoined';\r\n\r\n/**\r\n * A user has left the conference.\r\n */\r\nexport const USER_LEFT = 'conference.userLeft';\r\n\r\n/**\r\n * User role changed.\r\n */\r\nexport const USER_ROLE_CHANGED = 'conference.roleChanged';\r\n\r\n/**\r\n * User status changed.\r\n */\r\nexport const USER_STATUS_CHANGED = 'conference.statusChanged';\r\n\r\n/**\r\n * Event indicates that the bot participant type changed.\r\n */\r\nexport const BOT_TYPE_CHANGED = 'conference.bot_type_changed';\r\n","import BrowserCapabilities from './BrowserCapabilities';\r\n\r\nexport default new BrowserCapabilities();\r\n","/* Copyright @ 2015 Atlassian Pty Ltd\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar Logger = require(\"./Logger\");\r\nvar LogCollector = require(\"./LogCollector\");\r\n\r\n/**\r\n * Definition of the log method\r\n * @name log_method\r\n * @function\r\n * @param {...*} log_args the arguments to be logged\r\n */\r\n/**\r\n * The logger's transport type definition.\r\n *\r\n * @typedef {object} LoggerTransport\r\n *\r\n * @property {log_method} trace method called to log on {@link Logger.levels.TRACE} logging level\r\n * @property {log_method} debug method called to log on {@link Logger.levels.DEBUG} logging level\r\n * @property {log_method} info method called to log on {@link Logger.levels.INFO} logging level\r\n * @property {log_method} log method called to log on {@link Logger.levels.LOG} logging level\r\n * @property {log_method} warn method called to log on {@link Logger.levels.WARN} logging level\r\n * @property {log_method} error method called to log on {@link Logger.levels.ERROR} logging level\r\n */\r\n\r\n/**\r\n * Map with the created loggers with ID.\r\n */\r\nvar idLoggers = {};\r\n\r\n/**\r\n * Array with the loggers without id.\r\n */\r\nvar loggers = [];\r\n\r\n/**\r\n * Log level for the lbrary.\r\n */\r\nvar curLevel = Logger.levels.TRACE;\r\n\r\n\r\nmodule.exports = {\r\n    /**\r\n     * Adds given {@link LoggerTransport} instance to the list of global\r\n     * transports which means that it'll be used by all {@link Logger}s\r\n     * @param {LoggerTransport} transport\r\n     */\r\n    addGlobalTransport: function(transport) {\r\n        Logger.addGlobalTransport(transport);\r\n    },\r\n    /**\r\n     * Removes given {@link LoggerTransport} instance from the list of global\r\n     * transports\r\n     * @param {LoggerTransport} transport\r\n     */\r\n    removeGlobalTransport: function(transport) {\r\n        Logger.removeGlobalTransport(transport);\r\n    },\r\n    /**\r\n     * Creates new logger.\r\n     * @arguments the same as Logger constructor\r\n     */\r\n    getLogger: function(id, transports, format) {\r\n        var logger = new Logger(curLevel, id, transports, format);\r\n        if(id) {\r\n            idLoggers[id] = idLoggers[id] || [];\r\n            idLoggers[id].push(logger);\r\n        } else {\r\n            loggers.push(logger);\r\n        }\r\n        return logger;\r\n    },\r\n    /**\r\n     * Changes the log level for the existing loggers by id.\r\n     * @param level the new log level.\r\n     * @param id if specified the level will be changed only for loggers with the\r\n     * same id. Otherwise the operation will affect all loggers that don't\r\n     * have id.\r\n     */\r\n    setLogLevelById: function(level, id) {\r\n        var l = id? (idLoggers[id] || []) : loggers;\r\n        for(var i = 0; i < l.length; i++) {\r\n            l[i].setLevel(level);\r\n        }\r\n    },\r\n    /**\r\n     * Changes the log level for all existing loggers.\r\n     * @param level the new log level.\r\n     */\r\n    setLogLevel: function (level) {\r\n        curLevel = level;\r\n        var i = 0;\r\n        for(; i < loggers.length; i++) {\r\n            loggers[i].setLevel(level);\r\n        }\r\n\r\n        for(var id in idLoggers) {\r\n            var l = idLoggers[id] || [];\r\n            for(i = 0; i < l.length; i++) {\r\n                l[i].setLevel(level);\r\n            }\r\n        }\r\n    },\r\n    /**\r\n     * The supported log levels.\r\n     */\r\n    levels: Logger.levels,\r\n    /**\r\n     * Exports the <tt>LogCollector</tt>.\r\n     */\r\n    LogCollector: LogCollector\r\n};\r\n","import EventEmitter from 'events';\r\n\r\nimport { FEEDBACK } from '../../service/statistics/AnalyticsEvents';\r\nimport analytics from './AnalyticsAdapter';\r\nimport CallStats from './CallStats';\r\nimport LocalStats from './LocalStatsCollector';\r\nimport RTPStats from './RTPStatsCollector';\r\n\r\nimport browser from '../browser';\r\nimport Settings from '../settings/Settings';\r\nimport ScriptUtil from '../util/ScriptUtil';\r\nimport QHSenseTrackError from '../../QHSenseTrackError';\r\nimport * as StatisticsEvents from '../../service/statistics/Events';\r\n\r\nconst logger = require('qhsense-meet-logger').getLogger(__filename);\r\n\r\n/**\r\n * Stores all active {@link Statistics} instances.\r\n * @type {Set<Statistics>}\r\n */\r\nlet _instances;\r\n\r\n/**\r\n * True if callstats API is loaded\r\n */\r\nlet isCallstatsLoaded = false;\r\n\r\n/**\r\n * Since callstats.io is a third party, we cannot guarantee the quality of their\r\n * service. More specifically, their server may take noticeably long time to\r\n * respond. Consequently, it is in our best interest (in the sense that the\r\n * intergration of callstats.io is pretty important to us but not enough to\r\n * allow it to prevent people from joining a conference) to (1) start\r\n * downloading their API as soon as possible and (2) do the downloading\r\n * asynchronously.\r\n *\r\n * @param {StatisticsOptions} options - Options to use for downloading and\r\n * initializing callstats backend.\r\n */\r\nfunction loadCallStatsAPI(options) {\r\n    if (!isCallstatsLoaded) {\r\n        ScriptUtil.loadScript(\r\n            options.customScriptUrl\r\n                || 'https://api.callstats.io/static/callstats-ws.min.js',\r\n            /* async */ true,\r\n            /* prepend */ true,\r\n            /* relativeURL */ undefined,\r\n            /* loadCallback */ () => _initCallStatsBackend(options)\r\n        );\r\n        isCallstatsLoaded = true;\r\n    }\r\n}\r\n\r\n/**\r\n * Initializes Callstats backend.\r\n *\r\n * @param {StatisticsOptions} options - The options to use for initializing\r\n * callstats backend.\r\n * @private\r\n */\r\nfunction _initCallStatsBackend(options) {\r\n    if (CallStats.isBackendInitialized()) {\r\n        return;\r\n    }\r\n\r\n    const userName = Settings.callStatsUserName;\r\n\r\n    if (!CallStats.initBackend({\r\n        callStatsID: options.callStatsID,\r\n        callStatsSecret: options.callStatsSecret,\r\n        userName: options.swapUserNameAndAlias\r\n            ? options.callStatsAliasName : userName,\r\n        aliasName: options.swapUserNameAndAlias\r\n            ? userName : options.callStatsAliasName,\r\n        applicationName: options.applicationName,\r\n        getWiFiStatsMethod: options.getWiFiStatsMethod,\r\n        confID: options.confID\r\n    })) {\r\n        logger.error('CallStats Backend initialization failed bad');\r\n    }\r\n}\r\n\r\n/**\r\n * callstats strips any additional fields from Error except for \"name\", \"stack\",\r\n * \"message\" and \"constraintName\". So we need to bundle additional information\r\n * from QHSenseTrackError into error passed to callstats to preserve valuable\r\n * information about error.\r\n * @param {QHSenseTrackError} error\r\n */\r\nfunction formatQHSenseTrackErrorForCallStats(error) {\r\n    const err = new Error();\r\n\r\n    // Just copy original stack from error\r\n    err.stack = error.stack;\r\n\r\n    // Combine name from error's name plus (possibly) name of original GUM error\r\n    err.name = (error.name || 'Unknown error') + (error.gum && error.gum.error\r\n        && error.gum.error.name ? ` - ${error.gum.error.name}` : '');\r\n\r\n    // Put all constraints into this field. For constraint failed errors we will\r\n    // still know which exactly constraint failed as it will be a part of\r\n    // message.\r\n    err.constraintName = error.gum && error.gum.constraints\r\n        ? JSON.stringify(error.gum.constraints) : '';\r\n\r\n    // Just copy error's message.\r\n    err.message = error.message;\r\n\r\n    return err;\r\n}\r\n\r\n/**\r\n * Init statistic options\r\n * @param options\r\n */\r\nStatistics.init = function(options) {\r\n    Statistics.audioLevelsEnabled = !options.disableAudioLevels;\r\n\r\n    if (typeof options.audioLevelsInterval === 'number') {\r\n        Statistics.audioLevelsInterval = options.audioLevelsInterval;\r\n    }\r\n\r\n    Statistics.disableThirdPartyRequests = options.disableThirdPartyRequests;\r\n};\r\n\r\n/**\r\n * The options to configure Statistics.\r\n * @typedef {Object} StatisticsOptions\r\n * @property {string} applicationName - The application name to pass to\r\n * callstats.\r\n * @property {string} callStatsAliasName - The alias name to use when\r\n * initializing callstats.\r\n * @property {string} confID - The callstats conference ID to use.\r\n * @property {string} callStatsID - Callstats credentials - the id.\r\n * @property {string} callStatsSecret - Callstats credentials - the secret.\r\n * @property {string} customScriptUrl - A custom lib url to use when downloading\r\n * callstats library.\r\n * @property {boolean} swapUserNameAndAlias - Whether to swap the places of\r\n * username and alias when initiating callstats.\r\n */\r\n/**\r\n *\r\n * @param xmpp\r\n * @param {StatisticsOptions} options - The options to use creating the\r\n * Statistics.\r\n */\r\nexport default function Statistics(xmpp, options) {\r\n    /**\r\n     * {@link RTPStats} mapped by {@link TraceablePeerConnection.id} which\r\n     * collect RTP statistics for each peerconnection.\r\n     * @type {Map<string, RTPStats}\r\n     */\r\n    this.rtpStatsMap = new Map();\r\n    this.eventEmitter = new EventEmitter();\r\n    this.xmpp = xmpp;\r\n    this.options = options || {};\r\n\r\n    this.callStatsIntegrationEnabled\r\n        = this.options.callStatsID && this.options.callStatsSecret\r\n\r\n            // Even though AppID and AppSecret may be specified, the integration\r\n            // of callstats.io may be disabled because of globally-disallowed\r\n            // requests to any third parties.\r\n            && (Statistics.disableThirdPartyRequests !== true);\r\n    if (this.callStatsIntegrationEnabled) {\r\n        if (browser.isReactNative()) {\r\n            _initCallStatsBackend(this.options);\r\n        } else {\r\n            loadCallStatsAPI(this.options);\r\n        }\r\n\r\n        if (!this.options.confID) {\r\n            logger.warn('\"confID\" is not defined');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores {@link CallStats} instances for each\r\n     * {@link TraceablePeerConnection} (one {@link CallStats} instance serves\r\n     * one TPC). The instances are mapped by {@link TraceablePeerConnection.id}.\r\n     * @type {Map<number, CallStats>}\r\n     */\r\n    this.callsStatsInstances = new Map();\r\n\r\n    Statistics.instances.add(this);\r\n}\r\nStatistics.audioLevelsEnabled = false;\r\nStatistics.audioLevelsInterval = 200;\r\nStatistics.disableThirdPartyRequests = false;\r\nStatistics.analytics = analytics;\r\n\r\nObject.defineProperty(Statistics, 'instances', {\r\n    /**\r\n     * Returns the Set holding all active {@link Statistics} instances. Lazily\r\n     * initializes the Set to allow any Set polyfills to be applied.\r\n     * @type {Set<Statistics>}\r\n     */\r\n    get() {\r\n        if (!_instances) {\r\n            _instances = new Set();\r\n        }\r\n\r\n        return _instances;\r\n    }\r\n});\r\n\r\n/**\r\n * Starts collecting RTP stats for given peerconnection.\r\n * @param {TraceablePeerConnection} peerconnection\r\n */\r\nStatistics.prototype.startRemoteStats = function(peerconnection) {\r\n    this.stopRemoteStats(peerconnection);\r\n\r\n    try {\r\n        const rtpStats\r\n            = new RTPStats(\r\n                peerconnection,\r\n                Statistics.audioLevelsInterval,\r\n                2000,\r\n                this.eventEmitter);\r\n\r\n        rtpStats.start(Statistics.audioLevelsEnabled);\r\n        this.rtpStatsMap.set(peerconnection.id, rtpStats);\r\n    } catch (e) {\r\n        logger.error(`Failed to start collecting remote statistics: ${e}`);\r\n    }\r\n};\r\n\r\nStatistics.localStats = [];\r\n\r\nStatistics.startLocalStats = function(stream, callback) {\r\n    if (!Statistics.audioLevelsEnabled) {\r\n        return;\r\n    }\r\n    const localStats = new LocalStats(stream, Statistics.audioLevelsInterval,\r\n        callback);\r\n\r\n    this.localStats.push(localStats);\r\n    localStats.start();\r\n};\r\n\r\nStatistics.prototype.addAudioLevelListener = function(listener) {\r\n    if (!Statistics.audioLevelsEnabled) {\r\n        return;\r\n    }\r\n    this.eventEmitter.on(StatisticsEvents.AUDIO_LEVEL, listener);\r\n};\r\n\r\nStatistics.prototype.removeAudioLevelListener = function(listener) {\r\n    if (!Statistics.audioLevelsEnabled) {\r\n        return;\r\n    }\r\n    this.eventEmitter.removeListener(StatisticsEvents.AUDIO_LEVEL, listener);\r\n};\r\n\r\nStatistics.prototype.addBeforeDisposedListener = function(listener) {\r\n    this.eventEmitter.on(StatisticsEvents.BEFORE_DISPOSED, listener);\r\n};\r\n\r\nStatistics.prototype.removeBeforeDisposedListener = function(listener) {\r\n    this.eventEmitter.removeListener(\r\n        StatisticsEvents.BEFORE_DISPOSED, listener);\r\n};\r\n\r\nStatistics.prototype.addConnectionStatsListener = function(listener) {\r\n    this.eventEmitter.on(StatisticsEvents.CONNECTION_STATS, listener);\r\n};\r\n\r\nStatistics.prototype.removeConnectionStatsListener = function(listener) {\r\n    this.eventEmitter.removeListener(\r\n        StatisticsEvents.CONNECTION_STATS,\r\n        listener);\r\n};\r\n\r\nStatistics.prototype.addByteSentStatsListener = function(listener) {\r\n    this.eventEmitter.on(StatisticsEvents.BYTE_SENT_STATS, listener);\r\n};\r\n\r\nStatistics.prototype.removeByteSentStatsListener = function(listener) {\r\n    this.eventEmitter.removeListener(StatisticsEvents.BYTE_SENT_STATS,\r\n        listener);\r\n};\r\n\r\nStatistics.prototype.dispose = function() {\r\n    try {\r\n        // NOTE Before reading this please see the comment in stopCallStats...\r\n        //\r\n        // Here we prevent from emitting the event twice in case it will be\r\n        // triggered from stopCallStats.\r\n        // If the event is triggered from here it means that the logs will not\r\n        // be submitted anyway (because there is no CallStats instance), but\r\n        // we're doing that for the sake of some kind of consistency.\r\n        if (!this.callsStatsInstances.size) {\r\n            this.eventEmitter.emit(StatisticsEvents.BEFORE_DISPOSED);\r\n        }\r\n        for (const callStats of this.callsStatsInstances.values()) {\r\n            this.stopCallStats(callStats.tpc);\r\n        }\r\n        for (const tpcId of this.rtpStatsMap.keys()) {\r\n            this._stopRemoteStats(tpcId);\r\n        }\r\n        if (this.eventEmitter) {\r\n            this.eventEmitter.removeAllListeners();\r\n        }\r\n    } finally {\r\n        Statistics.instances.delete(this);\r\n    }\r\n};\r\n\r\nStatistics.stopLocalStats = function(stream) {\r\n    if (!Statistics.audioLevelsEnabled) {\r\n        return;\r\n    }\r\n\r\n    for (let i = 0; i < Statistics.localStats.length; i++) {\r\n        if (Statistics.localStats[i].stream === stream) {\r\n            const localStats = Statistics.localStats.splice(i, 1);\r\n\r\n            localStats[0].stop();\r\n            break;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Stops remote RTP stats for given peerconnection ID.\r\n * @param {string} tpcId {@link TraceablePeerConnection.id}\r\n * @private\r\n */\r\nStatistics.prototype._stopRemoteStats = function(tpcId) {\r\n    const rtpStats = this.rtpStatsMap.get(tpcId);\r\n\r\n    if (rtpStats) {\r\n        rtpStats.stop();\r\n        this.rtpStatsMap.delete(tpcId);\r\n    }\r\n};\r\n\r\n/**\r\n * Stops collecting RTP stats for given peerconnection\r\n * @param {TraceablePeerConnection} tpc\r\n */\r\nStatistics.prototype.stopRemoteStats = function(tpc) {\r\n    this._stopRemoteStats(tpc.id);\r\n};\r\n\r\n// CALSTATS METHODS\r\n\r\n/**\r\n * Initializes the callstats.io API.\r\n * @param {TraceablePeerConnection} tpc the {@link TraceablePeerConnection}\r\n * instance for which CalStats will be started.\r\n * @param {string} remoteUserID\r\n */\r\nStatistics.prototype.startCallStats = function(tpc, remoteUserID) {\r\n    if (!this.callStatsIntegrationEnabled) {\r\n        return;\r\n    } else if (this.callsStatsInstances.has(tpc.id)) {\r\n        logger.error('CallStats instance for ${tpc} exists already');\r\n\r\n        return;\r\n    }\r\n\r\n    logger.info(`Starting CallStats for ${tpc}...`);\r\n\r\n    const newInstance\r\n        = new CallStats(\r\n            tpc,\r\n            {\r\n                confID: this.options.confID,\r\n                remoteUserID\r\n            });\r\n\r\n    this.callsStatsInstances.set(tpc.id, newInstance);\r\n};\r\n\r\n/**\r\n * Obtains the list of *all* {@link CallStats} instances collected from every\r\n * valid {@link Statistics} instance.\r\n * @return {Set<CallStats>}\r\n * @private\r\n */\r\nStatistics._getAllCallStatsInstances = function() {\r\n    const csInstances = new Set();\r\n\r\n    for (const statistics of Statistics.instances) {\r\n        for (const cs of statistics.callsStatsInstances.values()) {\r\n            csInstances.add(cs);\r\n        }\r\n    }\r\n\r\n    return csInstances;\r\n};\r\n\r\n/**\r\n * Removes the callstats.io instances.\r\n */\r\nStatistics.prototype.stopCallStats = function(tpc) {\r\n    const callStatsInstance = this.callsStatsInstances.get(tpc.id);\r\n\r\n    if (callStatsInstance) {\r\n        // FIXME the original purpose of adding BEFORE_DISPOSED event was to be\r\n        // able to submit the last log batch from qhsense-meet to CallStats. After\r\n        // recent changes we dispose the CallStats earlier\r\n        // (before Statistics.dispose), so we need to emit this event here to\r\n        // give this last chance for final log batch submission.\r\n        //\r\n        // Eventually there should be a separate module called \"log storage\"\r\n        // which should emit proper events when it's underlying\r\n        // CallStats instance is going away.\r\n        if (this.callsStatsInstances.size === 1) {\r\n            this.eventEmitter.emit(StatisticsEvents.BEFORE_DISPOSED);\r\n        }\r\n        this.callsStatsInstances.delete(tpc.id);\r\n\r\n        // The fabric needs to be terminated when being stopped\r\n        callStatsInstance.sendTerminateEvent();\r\n    }\r\n};\r\n\r\n/**\r\n * Returns true if the callstats integration is enabled, otherwise returns\r\n * false.\r\n *\r\n * @returns true if the callstats integration is enabled, otherwise returns\r\n * false.\r\n */\r\nStatistics.prototype.isCallstatsEnabled = function() {\r\n    return this.callStatsIntegrationEnabled;\r\n};\r\n\r\n/**\r\n * Logs either resume or hold event for the given peer connection.\r\n * @param {TraceablePeerConnection} tpc the connection for which event will be\r\n * reported\r\n * @param {boolean} isResume true for resume or false for hold\r\n */\r\nStatistics.prototype.sendConnectionResumeOrHoldEvent = function(tpc, isResume) {\r\n    const instance = this.callsStatsInstances.get(tpc.id);\r\n\r\n    if (instance) {\r\n        instance.sendResumeOrHoldEvent(isResume);\r\n    }\r\n};\r\n\r\n/**\r\n * Notifies CallStats and analytics (if present) for ice connection failed\r\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\r\n */\r\nStatistics.prototype.sendIceConnectionFailedEvent = function(tpc) {\r\n    const instance = this.callsStatsInstances.get(tpc.id);\r\n\r\n    if (instance) {\r\n        instance.sendIceConnectionFailedEvent();\r\n    }\r\n};\r\n\r\n/**\r\n * Notifies CallStats for mute events\r\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\r\n * @param {boolean} muted true for muted and false for not muted\r\n * @param {String} type \"audio\"/\"video\"\r\n */\r\nStatistics.prototype.sendMuteEvent = function(tpc, muted, type) {\r\n    const instance = tpc && this.callsStatsInstances.get(tpc.id);\r\n\r\n    CallStats.sendMuteEvent(muted, type, instance);\r\n};\r\n\r\n/**\r\n * Notifies CallStats for screen sharing events\r\n * @param start {boolean} true for starting screen sharing and\r\n * false for not stopping\r\n * @param {string|null} ssrc - optional ssrc value, used only when\r\n * starting screen sharing.\r\n */\r\nStatistics.prototype.sendScreenSharingEvent\r\n    = function(start, ssrc) {\r\n        for (const cs of this.callsStatsInstances.values()) {\r\n            cs.sendScreenSharingEvent(start, ssrc);\r\n        }\r\n    };\r\n\r\n/**\r\n * Notifies the statistics module that we are now the dominant speaker of the\r\n * conference.\r\n * @param {String} roomJid - The room jid where the speaker event occurred.\r\n */\r\nStatistics.prototype.sendDominantSpeakerEvent = function(roomJid) {\r\n    for (const cs of this.callsStatsInstances.values()) {\r\n        cs.sendDominantSpeakerEvent();\r\n    }\r\n\r\n    // xmpp send dominant speaker event\r\n    this.xmpp.sendDominantSpeakerEvent(roomJid);\r\n};\r\n\r\n/**\r\n * Notifies about active device.\r\n * @param {{deviceList: {String:String}}} devicesData - list of devices with\r\n *      their data\r\n */\r\nStatistics.sendActiveDeviceListEvent = function(devicesData) {\r\n    const globalSet = Statistics._getAllCallStatsInstances();\r\n\r\n    if (globalSet.size) {\r\n        for (const cs of globalSet) {\r\n            CallStats.sendActiveDeviceListEvent(devicesData, cs);\r\n        }\r\n    } else {\r\n        CallStats.sendActiveDeviceListEvent(devicesData, null);\r\n    }\r\n};\r\n\r\n/* eslint-disable max-params */\r\n\r\n/**\r\n * Lets the underlying statistics module know where is given SSRC rendered by\r\n * providing renderer tag ID.\r\n * @param {TraceablePeerConnection} tpc the connection to which the stream\r\n * belongs to\r\n * @param {number} ssrc the SSRC of the stream\r\n * @param {boolean} isLocal\r\n * @param {string} userId\r\n * @param {string} usageLabel  meaningful usage label of this stream like\r\n *        'microphone', 'camera' or 'screen'.\r\n * @param {string} containerId the id of media 'audio' or 'video' tag which\r\n *        renders the stream.\r\n */\r\nStatistics.prototype.associateStreamWithVideoTag = function(\r\n        tpc,\r\n        ssrc,\r\n        isLocal,\r\n        userId,\r\n        usageLabel,\r\n        containerId) {\r\n    const instance = this.callsStatsInstances.get(tpc.id);\r\n\r\n    if (instance) {\r\n        instance.associateStreamWithVideoTag(\r\n            ssrc,\r\n            isLocal,\r\n            userId,\r\n            usageLabel,\r\n            containerId);\r\n    }\r\n};\r\n\r\n/* eslint-enable max-params */\r\n\r\n/**\r\n * Notifies CallStats that getUserMedia failed.\r\n *\r\n * @param {Error} e error to send\r\n */\r\nStatistics.sendGetUserMediaFailed = function(e) {\r\n    const error\r\n        = e instanceof QHSenseTrackError\r\n            ? formatQHSenseTrackErrorForCallStats(e) : e;\r\n    const globalSet = Statistics._getAllCallStatsInstances();\r\n\r\n    if (globalSet.size) {\r\n        for (const cs of globalSet) {\r\n            CallStats.sendGetUserMediaFailed(error, cs);\r\n        }\r\n    } else {\r\n        CallStats.sendGetUserMediaFailed(error, null);\r\n    }\r\n};\r\n\r\n/**\r\n * Notifies CallStats that peer connection failed to create offer.\r\n *\r\n * @param {Error} e error to send\r\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\r\n */\r\nStatistics.prototype.sendCreateOfferFailed = function(e, tpc) {\r\n    const instance = this.callsStatsInstances.get(tpc.id);\r\n\r\n    if (instance) {\r\n        instance.sendCreateOfferFailed(e);\r\n    }\r\n};\r\n\r\n/**\r\n * Notifies CallStats that peer connection failed to create answer.\r\n *\r\n * @param {Error} e error to send\r\n * @param {TraceablePeerConnection} tpc connection on which failure occured.\r\n */\r\nStatistics.prototype.sendCreateAnswerFailed = function(e, tpc) {\r\n    const instance = this.callsStatsInstances.get(tpc.id);\r\n\r\n    if (instance) {\r\n        instance.sendCreateAnswerFailed(e);\r\n    }\r\n};\r\n\r\n/**\r\n * Notifies CallStats that peer connection failed to set local description.\r\n *\r\n * @param {Error} e error to send\r\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\r\n */\r\nStatistics.prototype.sendSetLocalDescFailed = function(e, tpc) {\r\n    const instance = this.callsStatsInstances.get(tpc.id);\r\n\r\n    if (instance) {\r\n        instance.sendSetLocalDescFailed(e);\r\n    }\r\n};\r\n\r\n/**\r\n * Notifies CallStats that peer connection failed to set remote description.\r\n *\r\n * @param {Error} e error to send\r\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\r\n */\r\nStatistics.prototype.sendSetRemoteDescFailed = function(e, tpc) {\r\n    const instance = this.callsStatsInstances.get(tpc.id);\r\n\r\n    if (instance) {\r\n        instance.sendSetRemoteDescFailed(e);\r\n    }\r\n};\r\n\r\n/**\r\n * Notifies CallStats that peer connection failed to add ICE candidate.\r\n *\r\n * @param {Error} e error to send\r\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\r\n */\r\nStatistics.prototype.sendAddIceCandidateFailed = function(e, tpc) {\r\n    const instance = this.callsStatsInstances.get(tpc.id);\r\n\r\n    if (instance) {\r\n        instance.sendAddIceCandidateFailed(e);\r\n    }\r\n};\r\n\r\n/**\r\n * Adds to CallStats an application log.\r\n *\r\n * @param {String} m a log message to send or an {Error} object to be reported\r\n */\r\nStatistics.sendLog = function(m) {\r\n    const globalSubSet = new Set();\r\n\r\n    // FIXME we don't want to duplicate logs over P2P instance, but\r\n    // here we should go over instances and call this method for each\r\n    // unique conference ID rather than selecting the first one.\r\n    // We don't have such use case though, so leaving as is for now.\r\n    for (const stats of Statistics.instances) {\r\n        if (stats.callsStatsInstances.size) {\r\n            globalSubSet.add(stats.callsStatsInstances.values().next().value);\r\n        }\r\n    }\r\n\r\n    if (globalSubSet.size) {\r\n        for (const csPerStats of globalSubSet) {\r\n            CallStats.sendApplicationLog(m, csPerStats);\r\n        }\r\n    } else {\r\n        CallStats.sendApplicationLog(m, null);\r\n    }\r\n};\r\n\r\n/**\r\n * Sends the given feedback through CallStats.\r\n *\r\n * @param overall an integer between 1 and 5 indicating the user's rating.\r\n * @param comment the comment from the user.\r\n */\r\nStatistics.prototype.sendFeedback = function(overall, comment) {\r\n    CallStats.sendFeedback(this.options.confID, overall, comment);\r\n    Statistics.analytics.sendEvent(\r\n        FEEDBACK,\r\n        {\r\n            rating: overall,\r\n            comment\r\n        });\r\n};\r\n\r\nStatistics.LOCAL_JID = require('../../service/statistics/constants').LOCAL_JID;\r\n\r\n/**\r\n * Reports global error to CallStats.\r\n *\r\n * @param {Error} error\r\n */\r\nStatistics.reportGlobalError = function(error) {\r\n    if (error instanceof QHSenseTrackError && error.gum) {\r\n        Statistics.sendGetUserMediaFailed(error);\r\n    } else {\r\n        Statistics.sendLog(error);\r\n    }\r\n};\r\n\r\n/**\r\n * Sends event to analytics and logs a message to the logger/console. Console\r\n * messages might also be logged to callstats automatically.\r\n *\r\n * @param {string | Object} event the event name, or an object which\r\n * represents the entire event.\r\n * @param {Object} properties properties to attach to the event (if an event\r\n * name as opposed to an event object is provided).\r\n */\r\nStatistics.sendAnalyticsAndLog = function(event, properties = {}) {\r\n    if (!event) {\r\n        logger.warn('No event or event name given.');\r\n\r\n        return;\r\n    }\r\n\r\n    let eventToLog;\r\n\r\n    // Also support an API with a single object as an event.\r\n    if (typeof event === 'object') {\r\n        eventToLog = event;\r\n    } else {\r\n        eventToLog = {\r\n            name: event,\r\n            properties\r\n        };\r\n    }\r\n\r\n    logger.log(JSON.stringify(eventToLog));\r\n\r\n    // We do this last, because it may modify the object which is passed.\r\n    this.analytics.sendEvent(event, properties);\r\n};\r\n\r\n/**\r\n * Sends event to analytics.\r\n *\r\n * @param {string | Object} eventName the event name, or an object which\r\n * represents the entire event.\r\n * @param {Object} properties properties to attach to the event\r\n */\r\nStatistics.sendAnalytics = function(eventName, properties = {}) {\r\n    this.analytics.sendEvent(eventName, properties);\r\n};\r\n","import { getLogger } from 'qhsense-meet-logger';\r\nconst logger = getLogger(__filename);\r\n\r\nimport RandomUtil from '../util/RandomUtil';\r\nimport browser from '../browser';\r\n\r\nconst SDPUtil = {\r\n    filterSpecialChars(text) {\r\n        // XXX Neither one of the falsy values (e.g. null, undefined, false,\r\n        // \"\", etc.) \"contain\" special chars.\r\n        // eslint-disable-next-line no-useless-escape\r\n        return text ? text.replace(/[\\\\\\/\\{,\\}\\+]/g, '') : text;\r\n    },\r\n    iceparams(mediadesc, sessiondesc) {\r\n        let data = null;\r\n        let pwd, ufrag;\r\n\r\n        if ((ufrag = SDPUtil.findLine(mediadesc, 'a=ice-ufrag:', sessiondesc))\r\n                && (pwd\r\n                    = SDPUtil.findLine(\r\n                        mediadesc,\r\n                        'a=ice-pwd:',\r\n                        sessiondesc))) {\r\n            data = {\r\n                ufrag: SDPUtil.parseICEUfrag(ufrag),\r\n                pwd: SDPUtil.parseICEPwd(pwd)\r\n            };\r\n        }\r\n\r\n        return data;\r\n    },\r\n    parseICEUfrag(line) {\r\n        return line.substring(12);\r\n    },\r\n    buildICEUfrag(frag) {\r\n        return `a=ice-ufrag:${frag}`;\r\n    },\r\n    parseICEPwd(line) {\r\n        return line.substring(10);\r\n    },\r\n    buildICEPwd(pwd) {\r\n        return `a=ice-pwd:${pwd}`;\r\n    },\r\n    parseMID(line) {\r\n        return line.substring(6);\r\n    },\r\n    parseMLine(line) {\r\n        const data = {};\r\n        const parts = line.substring(2).split(' ');\r\n\r\n        data.media = parts.shift();\r\n        data.port = parts.shift();\r\n        data.proto = parts.shift();\r\n        if (parts[parts.length - 1] === '') { // trailing whitespace\r\n            parts.pop();\r\n        }\r\n        data.fmt = parts;\r\n\r\n        return data;\r\n    },\r\n    buildMLine(mline) {\r\n        return (\r\n            `m=${mline.media} ${mline.port} ${mline.proto} ${\r\n                mline.fmt.join(' ')}`);\r\n    },\r\n    parseRTPMap(line) {\r\n        const data = {};\r\n        let parts = line.substring(9).split(' ');\r\n\r\n        data.id = parts.shift();\r\n        parts = parts[0].split('/');\r\n        data.name = parts.shift();\r\n        data.clockrate = parts.shift();\r\n        data.channels = parts.length ? parts.shift() : '1';\r\n\r\n        return data;\r\n    },\r\n\r\n    /**\r\n     * Parses SDP line \"a=sctpmap:...\" and extracts SCTP port from it.\r\n     * @param line eg. \"a=sctpmap:5000 webrtc-datachannel\"\r\n     * @returns [SCTP port number, protocol, streams]\r\n     */\r\n    parseSCTPMap(line) {\r\n        const parts = line.substring(10).split(' ');\r\n        const sctpPort = parts[0];\r\n        const protocol = parts[1];\r\n\r\n        // Stream count is optional\r\n        const streamCount = parts.length > 2 ? parts[2] : null;\r\n\r\n\r\n        return [ sctpPort, protocol, streamCount ];// SCTP port\r\n    },\r\n    buildRTPMap(el) {\r\n        let line\r\n            = `a=rtpmap:${el.getAttribute('id')} ${el.getAttribute('name')}/${\r\n                el.getAttribute('clockrate')}`;\r\n\r\n        if (el.getAttribute('channels')\r\n            && el.getAttribute('channels') !== '1') {\r\n            line += `/${el.getAttribute('channels')}`;\r\n        }\r\n\r\n        return line;\r\n    },\r\n    parseCrypto(line) {\r\n        const data = {};\r\n        const parts = line.substring(9).split(' ');\r\n\r\n        data.tag = parts.shift();\r\n        data['crypto-suite'] = parts.shift();\r\n        data['key-params'] = parts.shift();\r\n        if (parts.length) {\r\n            data['session-params'] = parts.join(' ');\r\n        }\r\n\r\n        return data;\r\n    },\r\n    parseFingerprint(line) { // RFC 4572\r\n        const data = {};\r\n        const parts = line.substring(14).split(' ');\r\n\r\n        data.hash = parts.shift();\r\n        data.fingerprint = parts.shift();\r\n\r\n        // TODO assert that fingerprint satisfies 2UHEX *(\":\" 2UHEX) ?\r\n        return data;\r\n    },\r\n    parseFmtp(line) {\r\n        const data = [];\r\n        let parts = line.split(' ');\r\n\r\n        parts.shift();\r\n        parts = parts.join(' ').split(';');\r\n        for (let i = 0; i < parts.length; i++) {\r\n            let key = parts[i].split('=')[0];\r\n\r\n            while (key.length && key[0] === ' ') {\r\n                key = key.substring(1);\r\n            }\r\n            const value = parts[i].split('=')[1];\r\n\r\n            if (key && value) {\r\n                data.push({ name: key,\r\n                    value });\r\n            } else if (key) {\r\n                // rfc 4733 (DTMF) style stuff\r\n                data.push({ name: '',\r\n                    value: key });\r\n            }\r\n        }\r\n\r\n        return data;\r\n    },\r\n    parseICECandidate(line) {\r\n        const candidate = {};\r\n        const elems = line.split(' ');\r\n\r\n        candidate.foundation = elems[0].substring(12);\r\n        candidate.component = elems[1];\r\n        candidate.protocol = elems[2].toLowerCase();\r\n        candidate.priority = elems[3];\r\n        candidate.ip = elems[4];\r\n        candidate.port = elems[5];\r\n\r\n        // elems[6] => \"typ\"\r\n        candidate.type = elems[7];\r\n        candidate.generation = 0; // default value, may be overwritten below\r\n        for (let i = 8; i < elems.length; i += 2) {\r\n            switch (elems[i]) {\r\n            case 'raddr':\r\n                candidate['rel-addr'] = elems[i + 1];\r\n                break;\r\n            case 'rport':\r\n                candidate['rel-port'] = elems[i + 1];\r\n                break;\r\n            case 'generation':\r\n                candidate.generation = elems[i + 1];\r\n                break;\r\n            case 'tcptype':\r\n                candidate.tcptype = elems[i + 1];\r\n                break;\r\n            default: // TODO\r\n                logger.log(\r\n                    `parseICECandidate not translating \"${\r\n                        elems[i]}\" = \"${elems[i + 1]}\"`);\r\n            }\r\n        }\r\n        candidate.network = '1';\r\n\r\n        // not applicable to SDP -- FIXME: should be unique, not just random\r\n        // eslint-disable-next-line newline-per-chained-call\r\n        candidate.id = Math.random().toString(36).substr(2, 10);\r\n\r\n        return candidate;\r\n    },\r\n    buildICECandidate(cand) {\r\n        let line = [\r\n            `a=candidate:${cand.foundation}`,\r\n            cand.component,\r\n            cand.protocol,\r\n            cand.priority,\r\n            cand.ip,\r\n            cand.port,\r\n            'typ',\r\n            cand.type\r\n        ].join(' ');\r\n\r\n        line += ' ';\r\n        switch (cand.type) {\r\n        case 'srflx':\r\n        case 'prflx':\r\n        case 'relay':\r\n            if (cand.hasOwnAttribute('rel-addr')\r\n                    && cand.hasOwnAttribute('rel-port')) {\r\n                line += 'raddr';\r\n                line += ' ';\r\n                line += cand['rel-addr'];\r\n                line += ' ';\r\n                line += 'rport';\r\n                line += ' ';\r\n                line += cand['rel-port'];\r\n                line += ' ';\r\n            }\r\n            break;\r\n        }\r\n        if (cand.hasOwnAttribute('tcptype')) {\r\n            line += 'tcptype';\r\n            line += ' ';\r\n            line += cand.tcptype;\r\n            line += ' ';\r\n        }\r\n        line += 'generation';\r\n        line += ' ';\r\n        line += cand.hasOwnAttribute('generation') ? cand.generation : '0';\r\n\r\n        return line;\r\n    },\r\n    parseSSRC(desc) {\r\n        // proprietary mapping of a=ssrc lines\r\n        // TODO: see \"Jingle RTP Source Description\" by Juberti and P. Thatcher\r\n        // on google docs and parse according to that\r\n        const data = new Map();\r\n        const lines = desc.split('\\r\\n');\r\n\r\n        for (let i = 0; i < lines.length; i++) {\r\n            if (lines[i].substring(0, 7) === 'a=ssrc:') {\r\n                // FIXME: Use regex to smartly find the ssrc.\r\n                const ssrc = lines[i].split('a=ssrc:')[1].split(' ')[0];\r\n\r\n                if (!data.get(ssrc)) {\r\n                    data.set(ssrc, []);\r\n                }\r\n\r\n                data.get(ssrc).push(lines[i]);\r\n            }\r\n        }\r\n\r\n        return data;\r\n    },\r\n    parseRTCPFB(line) {\r\n        const parts = line.substr(10).split(' ');\r\n        const data = {};\r\n\r\n        data.pt = parts.shift();\r\n        data.type = parts.shift();\r\n        data.params = parts;\r\n\r\n        return data;\r\n    },\r\n    parseExtmap(line) {\r\n        const parts = line.substr(9).split(' ');\r\n        const data = {};\r\n\r\n        data.value = parts.shift();\r\n        if (data.value.indexOf('/') === -1) {\r\n            data.direction = 'both';\r\n        } else {\r\n            data.direction = data.value.substr(data.value.indexOf('/') + 1);\r\n            data.value = data.value.substr(0, data.value.indexOf('/'));\r\n        }\r\n        data.uri = parts.shift();\r\n        data.params = parts;\r\n\r\n        return data;\r\n    },\r\n    findLine(haystack, needle, sessionpart) {\r\n        let lines = haystack.split('\\r\\n');\r\n\r\n        for (let i = 0; i < lines.length; i++) {\r\n            if (lines[i].substring(0, needle.length) === needle) {\r\n                return lines[i];\r\n            }\r\n        }\r\n        if (!sessionpart) {\r\n            return false;\r\n        }\r\n\r\n        // search session part\r\n        lines = sessionpart.split('\\r\\n');\r\n        for (let j = 0; j < lines.length; j++) {\r\n            if (lines[j].substring(0, needle.length) === needle) {\r\n                return lines[j];\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n    findLines(haystack, needle, sessionpart) {\r\n        let lines = haystack.split('\\r\\n');\r\n        const needles = [];\r\n\r\n        for (let i = 0; i < lines.length; i++) {\r\n            if (lines[i].substring(0, needle.length) === needle) {\r\n                needles.push(lines[i]);\r\n            }\r\n        }\r\n        if (needles.length || !sessionpart) {\r\n            return needles;\r\n        }\r\n\r\n        // search session part\r\n        lines = sessionpart.split('\\r\\n');\r\n        for (let j = 0; j < lines.length; j++) {\r\n            if (lines[j].substring(0, needle.length) === needle) {\r\n                needles.push(lines[j]);\r\n            }\r\n        }\r\n\r\n        return needles;\r\n    },\r\n    candidateToJingle(line) {\r\n        // a=candidate:2979166662 1 udp 2113937151 192.168.2.100 57698 typ host\r\n        // generation 0\r\n        //      <candidate component=... foundation=... generation=... id=...\r\n        // ip=... network=... port=... priority=... protocol=... type=.../>\r\n        if (line.indexOf('candidate:') === 0) {\r\n            // eslint-disable-next-line no-param-reassign\r\n            line = `a=${line}`;\r\n        } else if (line.substring(0, 12) !== 'a=candidate:') {\r\n            logger.log(\r\n                'parseCandidate called with a line that is not a candidate'\r\n                    + ' line');\r\n            logger.log(line);\r\n\r\n            return null;\r\n        }\r\n        if (line.substring(line.length - 2) === '\\r\\n') { // chomp it\r\n            // eslint-disable-next-line no-param-reassign\r\n            line = line.substring(0, line.length - 2);\r\n        }\r\n        const candidate = {};\r\n        const elems = line.split(' ');\r\n\r\n        if (elems[6] !== 'typ') {\r\n            logger.log('did not find typ in the right place');\r\n            logger.log(line);\r\n\r\n            return null;\r\n        }\r\n        candidate.foundation = elems[0].substring(12);\r\n        candidate.component = elems[1];\r\n        candidate.protocol = elems[2].toLowerCase();\r\n        candidate.priority = elems[3];\r\n        candidate.ip = elems[4];\r\n        candidate.port = elems[5];\r\n\r\n        // elems[6] => \"typ\"\r\n        candidate.type = elems[7];\r\n\r\n        candidate.generation = '0'; // default, may be overwritten below\r\n        for (let i = 8; i < elems.length; i += 2) {\r\n            switch (elems[i]) {\r\n            case 'raddr':\r\n                candidate['rel-addr'] = elems[i + 1];\r\n                break;\r\n            case 'rport':\r\n                candidate['rel-port'] = elems[i + 1];\r\n                break;\r\n            case 'generation':\r\n                candidate.generation = elems[i + 1];\r\n                break;\r\n            case 'tcptype':\r\n                candidate.tcptype = elems[i + 1];\r\n                break;\r\n            default: // TODO\r\n                logger.log(`not translating \"${elems[i]}\" = \"${elems[i + 1]}\"`);\r\n            }\r\n        }\r\n        candidate.network = '1';\r\n\r\n        // not applicable to SDP -- FIXME: should be unique, not just random\r\n        // eslint-disable-next-line newline-per-chained-call\r\n        candidate.id = Math.random().toString(36).substr(2, 10);\r\n\r\n        return candidate;\r\n    },\r\n    candidateFromJingle(cand) {\r\n        let line = 'a=candidate:';\r\n\r\n        line += cand.getAttribute('foundation');\r\n        line += ' ';\r\n        line += cand.getAttribute('component');\r\n        line += ' ';\r\n\r\n        let protocol = cand.getAttribute('protocol');\r\n\r\n        // use tcp candidates for FF\r\n\r\n        if (browser.isFirefox() && protocol.toLowerCase() === 'ssltcp') {\r\n            protocol = 'tcp';\r\n        }\r\n\r\n        line += protocol; // .toUpperCase(); // chrome M23 doesn't like this\r\n        line += ' ';\r\n        line += cand.getAttribute('priority');\r\n        line += ' ';\r\n        line += cand.getAttribute('ip');\r\n        line += ' ';\r\n        line += cand.getAttribute('port');\r\n        line += ' ';\r\n        line += 'typ';\r\n        line += ` ${cand.getAttribute('type')}`;\r\n        line += ' ';\r\n        switch (cand.getAttribute('type')) {\r\n        case 'srflx':\r\n        case 'prflx':\r\n        case 'relay':\r\n            if (cand.getAttribute('rel-addr')\r\n                    && cand.getAttribute('rel-port')) {\r\n                line += 'raddr';\r\n                line += ' ';\r\n                line += cand.getAttribute('rel-addr');\r\n                line += ' ';\r\n                line += 'rport';\r\n                line += ' ';\r\n                line += cand.getAttribute('rel-port');\r\n                line += ' ';\r\n            }\r\n            break;\r\n        }\r\n        if (protocol.toLowerCase() === 'tcp') {\r\n            line += 'tcptype';\r\n            line += ' ';\r\n            line += cand.getAttribute('tcptype');\r\n            line += ' ';\r\n        }\r\n        line += 'generation';\r\n        line += ' ';\r\n        line += cand.getAttribute('generation') || '0';\r\n\r\n        return `${line}\\r\\n`;\r\n    },\r\n\r\n    /**\r\n     * Parse the 'most' primary video ssrc from the given m line\r\n     * @param {object} mLine object as parsed from transform.parse\r\n     * @return {number} the primary video ssrc from the given m line\r\n     */\r\n    parsePrimaryVideoSsrc(videoMLine) {\r\n        const numSsrcs = videoMLine.ssrcs\r\n            .map(ssrcInfo => ssrcInfo.id)\r\n            .filter((ssrc, index, array) => array.indexOf(ssrc) === index)\r\n            .length;\r\n        const numGroups\r\n            = (videoMLine.ssrcGroups && videoMLine.ssrcGroups.length) || 0;\r\n\r\n        if (numSsrcs > 1 && numGroups === 0) {\r\n            // Ambiguous, can't figure out the primary\r\n            return;\r\n        }\r\n        let primarySsrc = null;\r\n\r\n        if (numSsrcs === 1) {\r\n            primarySsrc = videoMLine.ssrcs[0].id;\r\n        } else if (numSsrcs === 2) {\r\n            // Can figure it out if there's an FID group\r\n            const fidGroup\r\n                = videoMLine.ssrcGroups.find(\r\n                    group => group.semantics === 'FID');\r\n\r\n            if (fidGroup) {\r\n                primarySsrc = fidGroup.ssrcs.split(' ')[0];\r\n            }\r\n        } else if (numSsrcs >= 3) {\r\n            // Can figure it out if there's a sim group\r\n            const simGroup\r\n                = videoMLine.ssrcGroups.find(\r\n                    group => group.semantics === 'SIM');\r\n\r\n            if (simGroup) {\r\n                primarySsrc = simGroup.ssrcs.split(' ')[0];\r\n            }\r\n        }\r\n\r\n        return primarySsrc;\r\n    },\r\n\r\n    /**\r\n     * Generate an ssrc\r\n     * @returns {number} an ssrc\r\n     */\r\n    generateSsrc() {\r\n        return RandomUtil.randomInt(1, 0xffffffff);\r\n    },\r\n\r\n    /**\r\n     * Get an attribute for the given ssrc with the given attributeName\r\n     *  from the given mline\r\n     * @param {object} mLine an mLine object as parsed from transform.parse\r\n     * @param {number} ssrc the ssrc for which an attribtue is desired\r\n     * @param {string} attributeName the name of the desired attribute\r\n     * @returns {string} the value corresponding to the given ssrc\r\n     *  and attributeName\r\n     */\r\n    getSsrcAttribute(mLine, ssrc, attributeName) {\r\n        for (let i = 0; i < mLine.ssrcs.length; ++i) {\r\n            const ssrcLine = mLine.ssrcs[i];\r\n\r\n            if (ssrcLine.id === ssrc\r\n                && ssrcLine.attribute === attributeName) {\r\n                return ssrcLine.value;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Parses the ssrcs from the group sdp line and\r\n     *  returns them as a list of numbers\r\n     * @param {object} the ssrcGroup object as parsed from\r\n     *  sdp-transform\r\n     * @returns {list<number>} a list of the ssrcs in the group\r\n     *  parsed as numbers\r\n     */\r\n    parseGroupSsrcs(ssrcGroup) {\r\n        return ssrcGroup\r\n            .ssrcs\r\n            .split(' ')\r\n            .map(ssrcStr => parseInt(ssrcStr, 10));\r\n    },\r\n\r\n    /**\r\n     * Get the mline of the given type from the given sdp\r\n     * @param {object} sdp sdp as parsed from transform.parse\r\n     * @param {string} type the type of the desired mline (e.g. \"video\")\r\n     * @returns {object} a media object\r\n     */\r\n    getMedia(sdp, type) {\r\n        return sdp.media.find(m => m.type === type);\r\n    },\r\n\r\n    /**\r\n     * Extracts the ICE username fragment from an SDP string.\r\n     * @param {string} sdp the SDP in raw text format\r\n     */\r\n    getUfrag(sdp) {\r\n        const ufragLines\r\n            = sdp.split('\\n').filter(line => line.startsWith('a=ice-ufrag:'));\r\n\r\n        if (ufragLines.length > 0) {\r\n            return ufragLines[0].substr('a=ice-ufrag:'.length);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the given codecName as the preferred codec by\r\n     *  moving it to the beginning of the payload types\r\n     *  list (modifies the given mline in place).  If there\r\n     *  are multiple options within the same codec (multiple h264\r\n     *  profiles, for instance), this will prefer the first one\r\n     *  that is found.\r\n     * @param {object} videoMLine the video mline object from\r\n     *  an sdp as parsed by transform.parse\r\n     * @param {string} codecName the name of the preferred codec\r\n     */\r\n    preferVideoCodec(videoMLine, codecName) {\r\n        let payloadType = null;\r\n\r\n        if (!videoMLine || !codecName) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < videoMLine.rtp.length; ++i) {\r\n            const rtp = videoMLine.rtp[i];\r\n\r\n            if (rtp.codec\r\n                && rtp.codec.toLowerCase() === codecName.toLowerCase()) {\r\n                payloadType = rtp.payload;\r\n                break;\r\n            }\r\n        }\r\n        if (payloadType) {\r\n            // Call toString() on payloads to get around an issue within\r\n            // SDPTransform that sets payloads as a number, instead of a string,\r\n            // when there is only one payload.\r\n            const payloadTypes\r\n                = videoMLine.payloads\r\n                    .toString()\r\n                    .split(' ')\r\n                    .map(p => parseInt(p, 10));\r\n            const payloadIndex = payloadTypes.indexOf(payloadType);\r\n\r\n            payloadTypes.splice(payloadIndex, 1);\r\n            payloadTypes.unshift(payloadType);\r\n            videoMLine.payloads = payloadTypes.join(' ');\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Strips the given codec from the given mline. All related RTX payload\r\n     * types are also stripped. If the resulting mline would have no codecs,\r\n     * it's disabled.\r\n     *\r\n     * @param {object} videoMLine the video mline object from an sdp as parsed\r\n     * by transform.parse.\r\n     * @param {string} codecName the name of the codec which will be stripped.\r\n     */\r\n    stripVideoCodec(videoMLine, codecName) {\r\n        if (!videoMLine || !codecName) {\r\n            return;\r\n        }\r\n\r\n        const removePts = [];\r\n\r\n        for (const rtp of videoMLine.rtp) {\r\n            if (rtp.codec\r\n                && rtp.codec.toLowerCase() === codecName.toLowerCase()) {\r\n                removePts.push(rtp.payload);\r\n            }\r\n        }\r\n\r\n        if (removePts.length > 0) {\r\n            // We also need to remove the payload types that are related to RTX\r\n            // for the codecs we want to disable.\r\n            const rtxApts = removePts.map(item => `apt=${item}`);\r\n            const rtxPts = videoMLine.fmtp.filter(\r\n                item => rtxApts.indexOf(item.config) !== -1);\r\n\r\n            removePts.push(...rtxPts.map(item => item.payload));\r\n\r\n            // Call toString() on payloads to get around an issue within\r\n            // SDPTransform that sets payloads as a number, instead of a string,\r\n            // when there is only one payload.\r\n            const allPts = videoMLine.payloads\r\n                .toString()\r\n                .split(' ')\r\n                .map(Number);\r\n            const keepPts = allPts.filter(pt => removePts.indexOf(pt) === -1);\r\n\r\n            if (keepPts.length === 0) {\r\n                // There are no other video codecs, disable the stream.\r\n                videoMLine.port = 0;\r\n                videoMLine.direction = 'inactive';\r\n                videoMLine.payloads = '*';\r\n            } else {\r\n                videoMLine.payloads = keepPts.join(' ');\r\n            }\r\n\r\n            videoMLine.rtp = videoMLine.rtp.filter(\r\n                item => keepPts.indexOf(item.payload) !== -1);\r\n            videoMLine.fmtp = videoMLine.fmtp.filter(\r\n                item => keepPts.indexOf(item.payload) !== -1);\r\n            if (videoMLine.rtcpFb) {\r\n                videoMLine.rtcpFb = videoMLine.rtcpFb.filter(\r\n                    item => keepPts.indexOf(item.payload) !== -1);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nexport default SDPUtil;\r\n","const RTCEvents = {\r\n    /**\r\n     * Indicates error while create answer call.\r\n     */\r\n    CREATE_ANSWER_FAILED: 'rtc.create_answer_failed',\r\n\r\n    /**\r\n     * Indicates error while create offer call.\r\n     */\r\n    CREATE_OFFER_FAILED: 'rtc.create_offer_failed',\r\n    DATA_CHANNEL_OPEN: 'rtc.data_channel_open',\r\n    ENDPOINT_CONN_STATUS_CHANGED: 'rtc.endpoint_conn_status_changed',\r\n    DOMINANT_SPEAKER_CHANGED: 'rtc.dominant_speaker_changed',\r\n    LASTN_ENDPOINT_CHANGED: 'rtc.lastn_endpoint_changed',\r\n\r\n    /**\r\n     * Event emitted when the user granted a permission for the camera / mic.\r\n     * Used to keep track of the granted permissions on browsers which don't\r\n     * support the Permissions API.\r\n     */\r\n    GRANTED_PERMISSIONS: 'rtc.granted_permissions',\r\n\r\n    IS_SELECTED_CHANGED: 'rtc.is_selected_change',\r\n\r\n    /**\r\n     * Event emitted when {@link RTC.setLastN} method is called to update with\r\n     * the new value set.\r\n     * The first argument is the value passed to {@link RTC.setLastN}.\r\n     */\r\n    LASTN_VALUE_CHANGED: 'rtc.lastn_value_changed',\r\n\r\n    /**\r\n     * Event emitted when ssrc for a local track is extracted and stored\r\n     * in {@link TraceablePeerConnection}.\r\n     * @param {QHSenseLocalTrack} track which ssrc was updated\r\n     * @param {string} ssrc that was stored\r\n     */\r\n    LOCAL_TRACK_SSRC_UPDATED: 'rtc.local_track_ssrc_updated',\r\n\r\n    TRACK_ATTACHED: 'rtc.track_attached',\r\n\r\n    /**\r\n     * Event fired when we remote track is added to the conference.\r\n     * 1st event argument is the added <tt>QHSenseRemoteTrack</tt> instance.\r\n     **/\r\n    REMOTE_TRACK_ADDED: 'rtc.remote_track_added',\r\n\r\n    // FIXME get rid of this event in favour of NO_DATA_FROM_SOURCE event\r\n    // (currently implemented for local tracks only)\r\n    REMOTE_TRACK_MUTE: 'rtc.remote_track_mute',\r\n\r\n    /**\r\n     * Indicates that the remote track has been removed from the conference.\r\n     * 1st event argument is the removed {@link QHSenseRemoteTrack} instance.\r\n     */\r\n    REMOTE_TRACK_REMOVED: 'rtc.remote_track_removed',\r\n\r\n    // FIXME get rid of this event in favour of NO_DATA_FROM_SOURCE event\r\n    // (currently implemented for local tracks only)\r\n    REMOTE_TRACK_UNMUTE: 'rtc.remote_track_unmute',\r\n\r\n    /**\r\n     * Indicates error while set local description.\r\n     */\r\n    SET_LOCAL_DESCRIPTION_FAILED: 'rtc.set_local_description_failed',\r\n\r\n    /**\r\n     * Indicates error while set remote description.\r\n     */\r\n    SET_REMOTE_DESCRIPTION_FAILED: 'rtc.set_remote_description_failed',\r\n    AUDIO_OUTPUT_DEVICE_CHANGED: 'rtc.audio_output_device_changed',\r\n    DEVICE_LIST_CHANGED: 'rtc.device_list_changed',\r\n\r\n    /**\r\n     * Indicates that the list with available devices will change.\r\n     */\r\n    DEVICE_LIST_WILL_CHANGE: 'rtc.device_list_will_change',\r\n    DEVICE_LIST_AVAILABLE: 'rtc.device_list_available',\r\n\r\n    /**\r\n     * Indicates that a message from another participant is received on\r\n     * data channel.\r\n     */\r\n    ENDPOINT_MESSAGE_RECEIVED: 'rtc.endpoint_message_received',\r\n\r\n    /**\r\n     * Designates an event indicating that the local ICE username fragment of\r\n     * the jingle session has changed.\r\n     * The first argument of the vent is <tt>TraceablePeerConnection</tt> which\r\n     * is the source of the event.\r\n     * The second argument is the actual \"ufrag\" string.\r\n     */\r\n    LOCAL_UFRAG_CHANGED: 'rtc.local_ufrag_changed',\r\n\r\n    /**\r\n     * Designates an event indicating that the local ICE username fragment of\r\n     * the jingle session has changed.\r\n     * The first argument of the vent is <tt>TraceablePeerConnection</tt> which\r\n     * is the source of the event.\r\n     * The second argument is the actual \"ufrag\" string.\r\n     */\r\n    REMOTE_UFRAG_CHANGED: 'rtc.remote_ufrag_changed'\r\n};\r\n\r\nmodule.exports = RTCEvents;\r\n","/**\r\n * This class exports constants and factory methods related to the analytics\r\n * API provided by AnalyticsAdapter. In order for entries in a database to be\r\n * somewhat easily traceable back to the code which produced them, events sent\r\n * through analytics should be defined here.\r\n *\r\n * Since the AnalyticsAdapter API can be used in different ways, for some events\r\n * it is more convenient to just define the event name as a constant. For other\r\n * events a factory function is easier.\r\n *\r\n * A general approach for adding a new event:\r\n * 1. Determine the event type: track, UI, page, or operational. If in doubt use\r\n * operational.\r\n * 2. Determine whether the event is related to other existing events, and\r\n * which fields are desired to be set: name, action, actionSubject, source.\r\n * 3. If the name is sufficient (the other fields are not important), use a\r\n * constant. Otherwise use a factory function.\r\n *\r\n * Note that the AnalyticsAdapter uses the events passed to its functions for\r\n * its own purposes, and might modify them. Because of this, factory functions\r\n * should create new objects.\r\n *\r\n */\r\n\r\n/**\r\n * The constant which identifies an event of type \"operational\".\r\n * @type {string}\r\n */\r\nexport const TYPE_OPERATIONAL = 'operational';\r\n\r\n/**\r\n * The constant which identifies an event of type \"page\".\r\n * @type {string}\r\n */\r\nexport const TYPE_PAGE = 'page';\r\n\r\n/**\r\n * The constant which identifies an event of type \"track\".\r\n * @type {string}\r\n */\r\nexport const TYPE_TRACK = 'track';\r\n\r\n/**\r\n * The constant which identifies an event of type \"ui\".\r\n * @type {string}\r\n */\r\nexport const TYPE_UI = 'ui';\r\n\r\n/**\r\n * The \"action\" value for Jingle events which indicates that the Jingle session\r\n * was restarted (TODO: verify/fix the documentation)\r\n * @type {string}\r\n */\r\nexport const ACTION_JINGLE_RESTART = 'restart';\r\n\r\n/**\r\n * The \"action\" value for Jingle events which indicates that a session-accept\r\n * timed out (TODO: verify/fix the documentation)\r\n * @type {string}\r\n */\r\nexport const ACTION_JINGLE_SA_TIMEOUT = 'session-accept.timeout';\r\n\r\n/**\r\n * The \"action\" value for Jingle events which indicates that a session-initiate\r\n * was received.\r\n * @type {string}\r\n */\r\nexport const ACTION_JINGLE_SI_RECEIVED = 'session-initiate.received';\r\n\r\n/**\r\n * The \"action\" value for Jingle events which indicates that a session-initiate\r\n * not arrived within a timeout (the value is specified in\r\n * the {@link JingleSessionPC}.\r\n * @type {string}\r\n */\r\nexport const ACTION_JINGLE_SI_TIMEOUT = 'session-initiate.timeout';\r\n\r\n/**\r\n * A constant for the \"terminate\" action for Jingle events. TODO: verify/fix\r\n * the documentation)\r\n * @type {string}\r\n */\r\nexport const ACTION_JINGLE_TERMINATE = 'terminate';\r\n\r\n/**\r\n * The \"action\" value for Jingle events which indicates that a transport-replace\r\n * was received.\r\n * @type {string}\r\n */\r\nexport const ACTION_JINGLE_TR_RECEIVED\r\n    = 'transport-replace.received';\r\n\r\n/**\r\n * The \"action\" value for Jingle events which indicates that a transport-replace\r\n * succeeded (TODO: verify/fix the documentation)\r\n * @type {string}\r\n */\r\nexport const ACTION_JINGLE_TR_SUCCESS\r\n    = 'transport-replace.success';\r\n\r\n/**\r\n * The \"action\" value for P2P events which indicates that a connection was\r\n * established (TODO: verify/fix the documentation)\r\n * @type {string}\r\n */\r\nexport const ACTION_P2P_ESTABLISHED = 'established';\r\n\r\n/**\r\n * The \"action\" value for P2P events which indicates that something failed.\r\n * @type {string}\r\n */\r\nexport const ACTION_P2P_FAILED = 'failed';\r\n\r\n/**\r\n * The \"action\" value for P2P events which indicates that a switch to\r\n * qhsense-videobridge happened.\r\n * @type {string}\r\n */\r\nexport const ACTION_P2P_SWITCH_TO_JVB = 'switch.to.jvb';\r\n\r\n/**\r\n * The name of an event which indicates an available device. We send one such\r\n * event per available device once when the available devices are first known,\r\n * and every time that they change\r\n * @type {string}\r\n *\r\n * Properties:\r\n *      audio_input_device_count: the number of audio input devices available at\r\n *          the time the event was sent.\r\n *      audio_output_device_count: the number of audio output devices available\r\n *          at the time the event was sent.\r\n *      video_input_device_count: the number of video input devices available at\r\n *          the time the event was sent.\r\n *      video_output_device_count: the number of video output devices available\r\n *          at the time the event was sent.\r\n *      device_id: an identifier of the device described in this event.\r\n *      device_group_id:\r\n *      device_kind: one of 'audioinput', 'audiooutput', 'videoinput' or\r\n *          'videooutput'.\r\n *      device_label: a string which describes the device.\r\n */\r\nexport const AVAILABLE_DEVICE = 'available.device';\r\n\r\n/**\r\n * This appears to be fired only in certain cases when the XMPP connection\r\n * disconnects (and it was intentional?). It is currently never observed to\r\n * fire in production.\r\n *\r\n * TODO: document\r\n *\r\n * Properties:\r\n *      message: an error message\r\n */\r\nexport const CONNECTION_DISCONNECTED = 'connection.disconnected';\r\n\r\n/**\r\n * Indicates that the user of the application provided feedback in terms of a\r\n * rating (an integer from 1 to 5) and an optional comment.\r\n * Properties:\r\n *      value: the user's rating (an integer from 1 to 5)\r\n *      comment: the user's comment\r\n */\r\nexport const FEEDBACK = 'feedback';\r\n\r\n/**\r\n * Indicates the duration of a particular phase of the ICE connectivity\r\n * establishment.\r\n *\r\n * Properties:\r\n *      phase: the ICE phase (e.g. 'gathering', 'checking', 'establishment')\r\n *      value: the duration in milliseconds.\r\n *      p2p: whether the associated ICE connection is p2p or towards a\r\n *          qhsense-videobridge\r\n *      initiator: whether the local Jingle peer is the initiator or responder\r\n *          in the Jingle session. XXX we probably actually care about the ICE\r\n *          role (controlling vs controlled), and we assume that this correlates\r\n *          with the Jingle initiator.\r\n */\r\nexport const ICE_DURATION = 'ice.duration';\r\n\r\n/**\r\n * Indicates the difference in milliseconds between the ICE establishment time\r\n * for the P2P and JVB connections (e.g. a value of 10 would indicate that the\r\n * P2P connection took 10ms more than JVB connection to establish).\r\n *\r\n * Properties:\r\n *      value: the difference in establishment durations in milliseconds.\r\n *\r\n */\r\nexport const ICE_ESTABLISHMENT_DURATION_DIFF\r\n    = 'ice.establishment.duration.diff';\r\n\r\n/**\r\n * Indicates that the ICE state has changed.\r\n *\r\n * Properties:\r\n *      state: the ICE state which was entered (e.g. 'checking', 'connected',\r\n *          'completed', etc).\r\n *      value: the time in milliseconds (as reported by\r\n *          window.performance.now()) that the state change occurred.\r\n *      p2p: whether the associated ICE connection is p2p or towards a\r\n *          qhsense-videobridge\r\n *      signalingState: The signaling state of the associated PeerConnection\r\n *      reconnect: whether the associated Jingle session is in the process of\r\n *          reconnecting (or is it ICE? TODO: verify/fix the documentation)\r\n */\r\nexport const ICE_STATE_CHANGED = 'ice.state.changed';\r\n\r\n/**\r\n * Indicates that no bytes have been sent for the track.\r\n *\r\n * Properties:\r\n *      mediaType: the media type of the local track ('audio' or 'video').\r\n */\r\nexport const NO_BYTES_SENT = 'track.no-bytes-sent';\r\n\r\n/**\r\n * Indicates that a track was unmuted (?).\r\n *\r\n * Properties:\r\n *      mediaType: the media type of the local track ('audio' or 'video').\r\n *      trackType: the type of the track ('local' or 'remote').\r\n *      value: TODO: document\r\n */\r\nexport const TRACK_UNMUTED = 'track.unmuted';\r\n\r\n/**\r\n * Creates an operational event which indicates that we have received a\r\n * \"bridge down\" event from jicofo.\r\n */\r\nexport const createBridgeDownEvent = function() {\r\n    const bridgeDown = 'bridge.down';\r\n\r\n    return {\r\n        action: bridgeDown,\r\n        actionSubject: bridgeDown,\r\n        type: TYPE_OPERATIONAL\r\n    };\r\n};\r\n\r\n/**\r\n * Creates an event which indicates that the XMPP connection failed\r\n * @param errorType TODO\r\n * @param errorMessage TODO\r\n * @param detail connection failed details.\r\n */\r\nexport const createConnectionFailedEvent\r\n    = function(errorType, errorMessage, details) {\r\n        return {\r\n            type: TYPE_OPERATIONAL,\r\n            action: 'connection.failed',\r\n            attributes: {\r\n                'error_type': errorType,\r\n                'error_message': errorMessage,\r\n                ...details\r\n            }\r\n        };\r\n    };\r\n\r\n/**\r\n * Creates an operational event which indicates that a particular connection\r\n * stage was reached (i.e. the XMPP connection transitioned to the \"connected\"\r\n * state).\r\n *\r\n * @param stage the stage which was reached\r\n * @param attributes additional attributes for the event. This should be an\r\n * object with a \"value\" property indicating a timestamp in milliseconds\r\n * relative to the beginning of the document's lifetime.\r\n *\r\n */\r\nexport const createConnectionStageReachedEvent = function(stage, attributes) {\r\n    const action = 'connection.stage.reached';\r\n\r\n    return {\r\n        action,\r\n        actionSubject: stage,\r\n        attributes,\r\n        source: action,\r\n        type: TYPE_OPERATIONAL\r\n    };\r\n};\r\n\r\n/**\r\n * Creates an operational event for the end-to-end round trip time to a\r\n * specific remote participant.\r\n * @param participantId the ID of the remote participant.\r\n * @param region the region of the remote participant\r\n * @param rtt the rtt\r\n */\r\nexport const createE2eRttEvent = function(participantId, region, rtt) {\r\n    const attributes = {\r\n        'participant_id': participantId,\r\n        region,\r\n        rtt\r\n    };\r\n\r\n    return {\r\n        attributes,\r\n        name: 'e2e_rtt',\r\n        type: TYPE_OPERATIONAL\r\n    };\r\n};\r\n\r\n/**\r\n * Creates an event which indicates that the focus has left the MUC.\r\n */\r\nexport const createFocusLeftEvent = function() {\r\n    const action = 'focus.left';\r\n\r\n    return {\r\n        action,\r\n        actionSubject: action,\r\n        type: TYPE_OPERATIONAL\r\n    };\r\n};\r\n\r\n/**\r\n * Creates an event related to a getUserMedia call.\r\n *\r\n * @param action the type of the result that the event represents: 'error',\r\n * 'success', 'warning', etc.\r\n * @param attributes the attributes to attach to the event.\r\n * @returns {{type: string, source: string, name: string}}\r\n */\r\nexport const createGetUserMediaEvent = function(action, attributes = {}) {\r\n    return {\r\n        type: TYPE_OPERATIONAL,\r\n        source: 'get.user.media',\r\n        action,\r\n        attributes\r\n    };\r\n};\r\n\r\n/**\r\n * Creates an event related to remote participant connection status changes.\r\n *\r\n * @param attributes the attributes to attach to the event.\r\n * @returns {{type: string, source: string, name: string}}\r\n */\r\nexport const createParticipantConnectionStatusEvent = function(attributes = {}) {\r\n    const action = 'duration';\r\n\r\n    return {\r\n        type: TYPE_OPERATIONAL,\r\n        source: 'peer.conn.status',\r\n        action,\r\n        attributes\r\n    };\r\n};\r\n\r\n/**\r\n * Creates an event for a Jingle-related event.\r\n * @param action the action of the event\r\n * @param attributes attributes to add to the event.\r\n */\r\nexport const createJingleEvent = function(action, attributes = {}) {\r\n    return {\r\n        type: TYPE_OPERATIONAL,\r\n        action,\r\n        source: 'jingle',\r\n        attributes\r\n    };\r\n};\r\n\r\n/**\r\n * Creates an event which indicates that a local track was not able to read\r\n * data from its source (a camera or a microphone).\r\n *\r\n * @param mediaType {String} the media type of the local track ('audio' or\r\n * 'video').\r\n */\r\nexport const createNoDataFromSourceEvent = function(mediaType, value) {\r\n    return {\r\n        attributes: {\r\n            'media_type': mediaType,\r\n            value\r\n        },\r\n        action: 'track.no.data.from.source',\r\n        type: TYPE_OPERATIONAL\r\n    };\r\n};\r\n\r\n/**\r\n * Creates an event for a p2p-related event.\r\n * @param action the action of the event\r\n * @param attributes attributes to add to the event.\r\n */\r\nexport const createP2PEvent = function(action, attributes = {}) {\r\n    return {\r\n        type: TYPE_OPERATIONAL,\r\n        action,\r\n        source: 'p2p',\r\n        attributes\r\n    };\r\n};\r\n\r\n/**\r\n * Indicates that we received a remote command to mute.\r\n */\r\nexport const createRemotelyMutedEvent = function() {\r\n    return {\r\n        type: TYPE_OPERATIONAL,\r\n        action: 'remotely.muted'\r\n    };\r\n};\r\n\r\n/**\r\n * Creates an event which contains RTP statistics such as RTT and packet loss.\r\n *\r\n * All average RTP stats are currently reported under 1 event name, but with\r\n * different properties that allows to distinguish between a P2P call, a\r\n * call relayed through TURN or the JVB, and multiparty vs 1:1.\r\n *\r\n * The structure of the event is:\r\n *\r\n * {\r\n *      p2p: true,\r\n *      conferenceSize: 2,\r\n *      localCandidateType: \"relay\",\r\n *      remoteCandidateType: \"relay\",\r\n *      transportType: \"udp\",\r\n *\r\n *      // Average RTT of 200ms\r\n *      \"rtt.avg\": 200,\r\n *      \"rtt.samples\": \"[100, 200, 300]\",\r\n *\r\n *      // Average packet loss of 10%\r\n *      \"packet.loss.avg\": 10,\r\n *      \"packet.loss.samples\": '[5, 10, 15]'\r\n *\r\n *      // Difference in milliseconds in the end-to-end RTT between p2p and jvb.\r\n *      // The e2e RTT through jvb is 15ms shorter:\r\n *      \"rtt.diff\": 15,\r\n *\r\n *      // End-to-end RTT through JVB is ms.\r\n *      \"end2end.rtt.avg\" = 100\r\n * }\r\n *\r\n * Note that the value of the \"samples\" properties are (JSON encoded) strings,\r\n * and not JSON arrays, as events' attributes can not be nested. The samples are\r\n * currently included for debug purposes only and can be removed anytime soon\r\n * from the structure.\r\n *\r\n * Also note that not all of values are present in each event, as values are\r\n * obtained and calculated as part of different process/event pipe. For example\r\n * {@link ConnectionAvgStats} instances are doing the reports for each\r\n * {@link TraceablePeerConnection} and work independently from the main stats\r\n * pipe.\r\n */\r\nexport const createRtpStatsEvent = function(attributes) {\r\n    return {\r\n        type: TYPE_OPERATIONAL,\r\n        action: 'rtp.stats',\r\n        attributes\r\n    };\r\n};\r\n\r\n/**\r\n * Creates an event which contains the round trip time (RTT) to a set of\r\n * regions.\r\n *\r\n * @param attributes\r\n * @returns {{type: string, action: string, attributes: *}}\r\n */\r\nexport const createRttByRegionEvent = function(attributes) {\r\n    return {\r\n        type: TYPE_OPERATIONAL,\r\n        action: 'rtt.by.region',\r\n        attributes\r\n    };\r\n};\r\n\r\n/**\r\n * Creates an event which contains an information related to the bridge channel close event.\r\n *\r\n * @param {string} code - A code from {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\r\n * @param {string} reason - A string which describes the reason for closing the bridge channel.\r\n * @returns {{type: string, action: string, attributes: { code: string, reason: string }}}\r\n */\r\nexport const createBridgeChannelClosedEvent = function(code, reason) {\r\n    return {\r\n        type: TYPE_OPERATIONAL,\r\n        action: 'bridge-channel.error',\r\n        attributes: {\r\n            code,\r\n            reason\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n * Creates an event which indicates the Time To First Media (TTFM).\r\n * It is measured in milliseconds relative to the beginning of the document's\r\n * lifetime (i.e. the origin used by window.performance.now()), and it excludes\r\n * the following:\r\n * 1. The delay due to getUserMedia()\r\n * 2. The period between the MUC being joined and the reception of the Jingle\r\n * session-initiate from jicofo. This is because jicofo will not start a Jingle\r\n * session until there are at least 2 participants in the room.\r\n *\r\n * @param attributes the attributes to add to the event. Currently used fields:\r\n *      mediaType: the media type of the local track ('audio' or 'video').\r\n *      muted: whether the track has ever been muted (?)\r\n *      value: the TTMF in milliseconds.\r\n */\r\nexport const createTtfmEvent = function(attributes) {\r\n    return createConnectionStageReachedEvent('ttfm', attributes);\r\n};\r\n","/**\r\n * The audio type.\r\n */\r\nexport const AUDIO = 'audio';\r\n\r\n/**\r\n * The video type.\r\n */\r\nexport const VIDEO = 'video';\r\n","/* global\r\n          __filename,\r\n          MediaStreamTrack,\r\n          RTCIceCandidate: true,\r\n          RTCPeerConnection,\r\n          RTCSessionDescription: true\r\n*/\r\n\r\nimport { AVAILABLE_DEVICE } from '../../service/statistics/AnalyticsEvents';\r\nimport CameraFacingMode from '../../service/RTC/CameraFacingMode';\r\nimport EventEmitter from 'events';\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\r\nimport QHSenseTrackError from '../../QHSenseTrackError';\r\nimport Listenable from '../util/Listenable';\r\nimport * as MediaType from '../../service/RTC/MediaType';\r\nimport Resolutions from '../../service/RTC/Resolutions';\r\nimport browser from '../browser';\r\nimport RTCEvents from '../../service/RTC/RTCEvents';\r\nimport screenObtainer from './ScreenObtainer';\r\nimport SDPUtil from '../xmpp/SDPUtil';\r\nimport Statistics from '../statistics/statistics';\r\nimport VideoType from '../../service/RTC/VideoType';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n// Require adapter only for certain browsers. This is being done for\r\n// react-native, which has its own shims, and while browsers are being migrated\r\n// over to use adapter's shims.\r\nif (browser.usesAdapter()) {\r\n    require('webrtc-adapter');\r\n}\r\n\r\nconst eventEmitter = new EventEmitter();\r\n\r\nconst AVAILABLE_DEVICES_POLL_INTERVAL_TIME = 3000; // ms\r\n\r\n/**\r\n * Default resolution to obtain for video tracks if no resolution is specified.\r\n * This default is used for old gum flow only, as new gum flow uses\r\n * {@link DEFAULT_CONSTRAINTS}.\r\n */\r\nconst OLD_GUM_DEFAULT_RESOLUTION = 720;\r\n\r\n/**\r\n * Default devices to obtain when no specific devices are specified. This\r\n * default is used for old gum flow only.\r\n */\r\nconst OLD_GUM_DEFAULT_DEVICES = [ 'audio', 'video' ];\r\n\r\n/**\r\n * Default MediaStreamConstraints to use for calls to getUserMedia.\r\n *\r\n * @private\r\n */\r\nconst DEFAULT_CONSTRAINTS = {\r\n    video: {\r\n        aspectRatio: 16 / 9,\r\n        height: {\r\n            ideal: 720,\r\n            max: 720,\r\n            min: 240\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * The default frame rate for Screen Sharing.\r\n */\r\nconst SS_DEFAULT_FRAME_RATE = 5;\r\n\r\n// Currently audio output device change is supported only in Chrome and\r\n// default output always has 'default' device ID\r\nlet audioOutputDeviceId = 'default'; // default device\r\n// whether user has explicitly set a device to use\r\nlet audioOutputChanged = false;\r\n\r\n// Disables all audio processing\r\nlet disableAP = false;\r\n\r\n// Disables Acoustic Echo Cancellation\r\nlet disableAEC = false;\r\n\r\n// Disables Noise Suppression\r\nlet disableNS = false;\r\n\r\n// Disables Automatic Gain Control\r\nlet disableAGC = false;\r\n\r\n// Disables Highpass Filter\r\nlet disableHPF = false;\r\n\r\nconst featureDetectionAudioEl = document.createElement('audio');\r\nconst isAudioOutputDeviceChangeAvailable\r\n    = typeof featureDetectionAudioEl.setSinkId !== 'undefined';\r\n\r\nlet availableDevices;\r\nlet availableDevicesPollTimer;\r\n\r\n/**\r\n * Initialize wrapper function for enumerating devices.\r\n * TODO: remove this, it should no longer be needed.\r\n *\r\n * @returns {?Function}\r\n */\r\nfunction initEnumerateDevicesWithCallback() {\r\n    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {\r\n        return callback => {\r\n            navigator.mediaDevices.enumerateDevices()\r\n                .then(callback, () => callback([]));\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param constraints\r\n * @param isNewStyleConstraintsSupported\r\n * @param resolution\r\n */\r\nfunction setResolutionConstraints(\r\n        constraints,\r\n        isNewStyleConstraintsSupported,\r\n        resolution) {\r\n    if (Resolutions[resolution]) {\r\n        if (isNewStyleConstraintsSupported) {\r\n            constraints.video.width = {\r\n                ideal: Resolutions[resolution].width\r\n            };\r\n            constraints.video.height = {\r\n                ideal: Resolutions[resolution].height\r\n            };\r\n        }\r\n\r\n        constraints.video.mandatory.minWidth = Resolutions[resolution].width;\r\n        constraints.video.mandatory.minHeight = Resolutions[resolution].height;\r\n    }\r\n\r\n    if (constraints.video.mandatory.minWidth) {\r\n        constraints.video.mandatory.maxWidth\r\n            = constraints.video.mandatory.minWidth;\r\n    }\r\n\r\n    if (constraints.video.mandatory.minHeight) {\r\n        constraints.video.mandatory.maxHeight\r\n            = constraints.video.mandatory.minHeight;\r\n    }\r\n}\r\n\r\n/**\r\n * @param {string[]} um required user media types\r\n *\r\n * @param {Object} [options={}] optional parameters\r\n * @param {string} options.resolution\r\n * @param {number} options.bandwidth\r\n * @param {number} options.fps\r\n * @param {string} options.desktopStream\r\n * @param {string} options.cameraDeviceId\r\n * @param {string} options.micDeviceId\r\n * @param {CameraFacingMode} options.facingMode\r\n * @param {bool} firefox_fake_device\r\n * @param {Object} options.frameRate - used only for dekstop sharing.\r\n * @param {Object} options.frameRate.min - Minimum fps\r\n * @param {Object} options.frameRate.max - Maximum fps\r\n */\r\nfunction getConstraints(um, options = {}) {\r\n    const constraints = {\r\n        audio: false,\r\n        video: false\r\n    };\r\n\r\n    // Don't mix new and old style settings for Chromium as this leads\r\n    // to TypeError in new Chromium versions. @see\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=614716\r\n    // This is a temporary solution, in future we will fully split old and\r\n    // new style constraints when new versions of Chromium and Firefox will\r\n    // have stable support of new constraints format. For more information\r\n    const isNewStyleConstraintsSupported\r\n        = browser.isFirefox()\r\n            || browser.isSafariWithVP8()\r\n            || browser.isEdge()\r\n            || browser.isReactNative();\r\n\r\n    if (um.indexOf('video') >= 0) {\r\n        // same behaviour as true\r\n        constraints.video = { mandatory: {},\r\n            optional: [] };\r\n\r\n        if (options.cameraDeviceId) {\r\n            if (isNewStyleConstraintsSupported) {\r\n                // New style of setting device id.\r\n                constraints.video.deviceId = options.cameraDeviceId;\r\n            }\r\n\r\n            // Old style.\r\n            constraints.video.mandatory.sourceId = options.cameraDeviceId;\r\n        } else {\r\n            // Prefer the front i.e. user-facing camera (to the back i.e.\r\n            // environment-facing camera, for example).\r\n            // TODO: Maybe use \"exact\" syntax if options.facingMode is defined,\r\n            // but this probably needs to be decided when updating other\r\n            // constraints, as we currently don't use \"exact\" syntax anywhere.\r\n            const facingMode = options.facingMode || CameraFacingMode.USER;\r\n\r\n            if (isNewStyleConstraintsSupported) {\r\n                constraints.video.facingMode = facingMode;\r\n            }\r\n            constraints.video.optional.push({\r\n                facingMode\r\n            });\r\n        }\r\n\r\n        if (options.minFps || options.maxFps || options.fps) {\r\n            // for some cameras it might be necessary to request 30fps\r\n            // so they choose 30fps mjpg over 10fps yuy2\r\n            if (options.minFps || options.fps) {\r\n                // Fall back to options.fps for backwards compatibility\r\n                options.minFps = options.minFps || options.fps;\r\n                constraints.video.mandatory.minFrameRate = options.minFps;\r\n            }\r\n            if (options.maxFps) {\r\n                constraints.video.mandatory.maxFrameRate = options.maxFps;\r\n            }\r\n        }\r\n\r\n        setResolutionConstraints(\r\n            constraints, isNewStyleConstraintsSupported, options.resolution);\r\n    }\r\n    if (um.indexOf('audio') >= 0) {\r\n        if (browser.isReactNative()) {\r\n            // The react-native-webrtc project that we're currently using\r\n            // expects the audio constraint to be a boolean.\r\n            constraints.audio = true;\r\n        } else if (browser.isFirefox()) {\r\n            if (options.micDeviceId) {\r\n                constraints.audio = {\r\n                    mandatory: {},\r\n                    deviceId: options.micDeviceId, // new style\r\n                    optional: [ {\r\n                        sourceId: options.micDeviceId // old style\r\n                    } ] };\r\n            } else {\r\n                constraints.audio = true;\r\n            }\r\n        } else {\r\n            // same behaviour as true\r\n            constraints.audio = { mandatory: {},\r\n                optional: [] };\r\n            if (options.micDeviceId) {\r\n                if (isNewStyleConstraintsSupported) {\r\n                    // New style of setting device id.\r\n                    constraints.audio.deviceId = options.micDeviceId;\r\n                }\r\n\r\n                // Old style.\r\n                constraints.audio.optional.push({\r\n                    sourceId: options.micDeviceId\r\n                });\r\n            }\r\n\r\n            // if it is good enough for hangouts...\r\n            constraints.audio.optional.push(\r\n                { echoCancellation: !disableAEC && !disableAP },\r\n                { googEchoCancellation: !disableAEC && !disableAP },\r\n                { googAutoGainControl: !disableAGC && !disableAP },\r\n                { googNoiseSuppression: !disableNS && !disableAP },\r\n                { googHighpassFilter: !disableHPF && !disableAP },\r\n                { googNoiseSuppression2: !disableNS && !disableAP },\r\n                { googEchoCancellation2: !disableAEC && !disableAP },\r\n                { googAutoGainControl2: !disableAGC && !disableAP }\r\n            );\r\n        }\r\n    }\r\n    if (um.indexOf('screen') >= 0) {\r\n        if (browser.isChrome()) {\r\n            constraints.video = {\r\n                mandatory: getSSConstraints({\r\n                    ...options,\r\n                    source: 'screen'\r\n                }),\r\n                optional: []\r\n            };\r\n\r\n        } else if (browser.isFirefox()) {\r\n            constraints.video = {\r\n                mozMediaSource: 'window',\r\n                mediaSource: 'window',\r\n                frameRate: options.frameRate || {\r\n                    min: SS_DEFAULT_FRAME_RATE,\r\n                    max: SS_DEFAULT_FRAME_RATE\r\n                }\r\n            };\r\n\r\n        } else {\r\n            const errmsg\r\n                = '\\'screen\\' WebRTC media source is supported only in Chrome'\r\n                    + ' and Firefox';\r\n\r\n            GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\r\n            logger.error(errmsg);\r\n        }\r\n    }\r\n    if (um.indexOf('desktop') >= 0) {\r\n        constraints.video = {\r\n            mandatory: getSSConstraints({\r\n                ...options,\r\n                source: 'desktop'\r\n            }),\r\n            optional: []\r\n        };\r\n    }\r\n\r\n    if (options.bandwidth) {\r\n        if (!constraints.video) {\r\n            // same behaviour as true\r\n            constraints.video = { mandatory: {},\r\n                optional: [] };\r\n        }\r\n        constraints.video.optional.push({ bandwidth: options.bandwidth });\r\n    }\r\n\r\n    // we turn audio for both audio and video tracks, the fake audio & video\r\n    // seems to work only when enabled in one getUserMedia call, we cannot get\r\n    // fake audio separate by fake video this later can be a problem with some\r\n    // of the tests\r\n    if (browser.isFirefox() && options.firefox_fake_device) {\r\n        // seems to be fixed now, removing this experimental fix, as having\r\n        // multiple audio tracks brake the tests\r\n        // constraints.audio = true;\r\n        constraints.fake = true;\r\n    }\r\n\r\n    return constraints;\r\n}\r\n\r\n/**\r\n * Creates a constraints object to be passed into a call to getUserMedia.\r\n *\r\n * @param {Array} um - An array of user media types to get. The accepted\r\n * types are \"video\", \"audio\", and \"desktop.\"\r\n * @param {Object} options - Various values to be added to the constraints.\r\n * @param {string} options.cameraDeviceId - The device id for the video\r\n * capture device to get video from.\r\n * @param {Object} options.constraints - Default constraints object to use\r\n * as a base for the returned constraints.\r\n * @param {Object} options.desktopStream - The desktop source id from which\r\n * to capture a desktop sharing video.\r\n * @param {string} options.facingMode - Which direction the camera is\r\n * pointing to.\r\n * @param {string} options.micDeviceId - The device id for the audio capture\r\n * device to get audio from.\r\n * @param {Object} options.frameRate - used only for dekstop sharing.\r\n * @param {Object} options.frameRate.min - Minimum fps\r\n * @param {Object} options.frameRate.max - Maximum fps\r\n * @private\r\n * @returns {Object}\r\n */\r\nfunction newGetConstraints(um = [], options = {}) {\r\n    // Create a deep copy of the constraints to avoid any modification of\r\n    // the passed in constraints object.\r\n    const constraints = JSON.parse(JSON.stringify(\r\n        options.constraints || DEFAULT_CONSTRAINTS));\r\n\r\n    if (um.indexOf('video') >= 0) {\r\n        if (!constraints.video) {\r\n            constraints.video = {};\r\n        }\r\n\r\n        if (options.cameraDeviceId) {\r\n            constraints.video.deviceId = options.cameraDeviceId;\r\n        } else {\r\n            const facingMode = options.facingMode || CameraFacingMode.USER;\r\n\r\n            constraints.video.facingMode = facingMode;\r\n        }\r\n    } else {\r\n        constraints.video = false;\r\n    }\r\n\r\n    if (um.indexOf('audio') >= 0) {\r\n        if (!constraints.audio || typeof constraints.audio === 'boolean') {\r\n            constraints.audio = {};\r\n        }\r\n\r\n        // NOTE(brian): the new-style ('advanced' instead of 'optional')\r\n        // doesn't seem to carry through the googXXX constraints\r\n        // Changing back to 'optional' here (even with video using\r\n        // the 'advanced' style) allows them to be passed through\r\n        // but also requires the device id to capture to be set in optional\r\n        // as sourceId otherwise the constraints are considered malformed.\r\n        if (!constraints.audio.optional) {\r\n            constraints.audio.optional = [];\r\n        }\r\n\r\n        constraints.audio.optional.push(\r\n            { sourceId: options.micDeviceId },\r\n            { echoCancellation: !disableAEC && !disableAP },\r\n            { googEchoCancellation: !disableAEC && !disableAP },\r\n            { googAutoGainControl: !disableAGC && !disableAP },\r\n            { googNoiseSuppression: !disableNS && !disableAP },\r\n            { googHighpassFilter: !disableHPF && !disableAP },\r\n            { googNoiseSuppression2: !disableNS && !disableAP },\r\n            { googEchoCancellation2: !disableAEC && !disableAP },\r\n            { googAutoGainControl2: !disableAGC && !disableAP }\r\n        );\r\n    } else {\r\n        constraints.audio = false;\r\n    }\r\n\r\n    if (um.indexOf('desktop') >= 0) {\r\n        if (!constraints.video || typeof constraints.video === 'boolean') {\r\n            constraints.video = {};\r\n        }\r\n\r\n        constraints.video = {\r\n            mandatory: getSSConstraints({\r\n                ...options,\r\n                source: 'desktop'\r\n            })\r\n        };\r\n    }\r\n\r\n    return constraints;\r\n}\r\n\r\n/**\r\n * Generates GUM constraints for screen sharing.\r\n *\r\n * @param {Object} options - The options passed to\r\n * <tt>obtainAudioAndVideoPermissions</tt>.\r\n * @returns {Object} - GUM constraints.\r\n *\r\n * TODO: Currently only the new GUM flow and Chrome is using the method. We\r\n * should make it work for all use cases.\r\n */\r\nfunction getSSConstraints(options = {}) {\r\n    const {\r\n        desktopStream,\r\n        frameRate = {\r\n            min: SS_DEFAULT_FRAME_RATE,\r\n            max: SS_DEFAULT_FRAME_RATE\r\n        }\r\n    } = options;\r\n    const { max, min } = frameRate;\r\n\r\n    const constraints = {\r\n        chromeMediaSource: options.source,\r\n        maxWidth: window.screen.width,\r\n        maxHeight: window.screen.height\r\n    };\r\n\r\n    if (typeof min === 'number') {\r\n        constraints.minFrameRate = min;\r\n    }\r\n\r\n    if (typeof max === 'number') {\r\n        constraints.maxFrameRate = max;\r\n    }\r\n\r\n    if (typeof desktopStream !== 'undefined') {\r\n        constraints.chromeMediaSourceId = desktopStream;\r\n    }\r\n\r\n    return constraints;\r\n}\r\n\r\n/**\r\n * Generates constraints for screen sharing when using getDisplayMedia.\r\n * The constraints(MediaTrackConstraints) are applied to the resulting track.\r\n *\r\n * @returns {Object} - MediaTrackConstraints constraints.\r\n */\r\nfunction getTrackSSConstraints(options = {}) {\r\n    // we used to set height and width in the constraints, but this can lead\r\n    // to inconsistencies if the browser is on a lower resolution screen\r\n    // and we share a screen with bigger resolution, so they are now not set\r\n    const constraints = {\r\n        frameRate: SS_DEFAULT_FRAME_RATE\r\n    };\r\n    const { desktopSharingFrameRate } = options;\r\n\r\n    if (desktopSharingFrameRate && desktopSharingFrameRate.max) {\r\n        constraints.frameRate = desktopSharingFrameRate.max;\r\n    }\r\n\r\n    return constraints;\r\n}\r\n\r\n/**\r\n * Updates the granted permissions based on the options we requested and the\r\n * streams we received.\r\n * @param um the options we requested to getUserMedia.\r\n * @param stream the stream we received from calling getUserMedia.\r\n */\r\nfunction updateGrantedPermissions(um, stream) {\r\n    const audioTracksReceived\r\n        = Boolean(stream) && stream.getAudioTracks().length > 0;\r\n    const videoTracksReceived\r\n        = Boolean(stream) && stream.getVideoTracks().length > 0;\r\n    const grantedPermissions = {};\r\n\r\n    if (um.indexOf('video') !== -1) {\r\n        grantedPermissions.video = videoTracksReceived;\r\n    }\r\n    if (um.indexOf('audio') !== -1) {\r\n        grantedPermissions.audio = audioTracksReceived;\r\n    }\r\n\r\n    eventEmitter.emit(RTCEvents.GRANTED_PERMISSIONS, grantedPermissions);\r\n}\r\n\r\n/**\r\n * Checks if new list of available media devices differs from previous one.\r\n * @param {MediaDeviceInfo[]} newDevices - list of new devices.\r\n * @returns {boolean} - true if list is different, false otherwise.\r\n */\r\nfunction compareAvailableMediaDevices(newDevices) {\r\n    if (newDevices.length !== availableDevices.length) {\r\n        return true;\r\n    }\r\n\r\n    /* eslint-disable newline-per-chained-call */\r\n\r\n    return (\r\n        newDevices.map(mediaDeviceInfoToJSON).sort().join('')\r\n            !== availableDevices\r\n                .map(mediaDeviceInfoToJSON).sort().join(''));\r\n\r\n    /* eslint-enable newline-per-chained-call */\r\n\r\n    /**\r\n     *\r\n     * @param info\r\n     */\r\n    function mediaDeviceInfoToJSON(info) {\r\n        return JSON.stringify({\r\n            kind: info.kind,\r\n            deviceId: info.deviceId,\r\n            groupId: info.groupId,\r\n            label: info.label,\r\n            facing: info.facing\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Sends analytics event with the passed device list.\r\n *\r\n * @param {Array<MediaDeviceInfo>} deviceList - List with info about the\r\n * available devices.\r\n * @returns {void}\r\n */\r\nfunction sendDeviceListToAnalytics(deviceList) {\r\n    const audioInputDeviceCount\r\n        = deviceList.filter(d => d.kind === 'audioinput').length;\r\n    const audioOutputDeviceCount\r\n        = deviceList.filter(d => d.kind === 'audiooutput').length;\r\n    const videoInputDeviceCount\r\n        = deviceList.filter(d => d.kind === 'videoinput').length;\r\n    const videoOutputDeviceCount\r\n        = deviceList.filter(d => d.kind === 'videooutput').length;\r\n\r\n    deviceList.forEach(device => {\r\n        const attributes = {\r\n            'audio_input_device_count': audioInputDeviceCount,\r\n            'audio_output_device_count': audioOutputDeviceCount,\r\n            'video_input_device_count': videoInputDeviceCount,\r\n            'video_output_device_count': videoOutputDeviceCount,\r\n            'device_id': device.deviceId,\r\n            'device_group_id': device.groupId,\r\n            'device_kind': device.kind,\r\n            'device_label': device.label\r\n        };\r\n\r\n        Statistics.sendAnalytics(AVAILABLE_DEVICE, attributes);\r\n    });\r\n}\r\n\r\n/**\r\n * Event handler for the 'devicechange' event.\r\n *\r\n * @param {MediaDeviceInfo[]} devices - list of media devices.\r\n * @emits RTCEvents.DEVICE_LIST_CHANGED\r\n */\r\nfunction onMediaDevicesListChanged(devicesReceived) {\r\n    availableDevices = devicesReceived.slice(0);\r\n    logger.info(\r\n        'list of media devices has changed:',\r\n        availableDevices);\r\n\r\n    sendDeviceListToAnalytics(availableDevices);\r\n\r\n    // Used by tracks to update the real device id before the consumer of lib-qhsense-meet receives the new device list.\r\n    eventEmitter.emit(RTCEvents.DEVICE_LIST_WILL_CHANGE, devicesReceived);\r\n\r\n    eventEmitter.emit(RTCEvents.DEVICE_LIST_CHANGED, devicesReceived);\r\n}\r\n\r\n/**\r\n * Handles the newly created Media Streams.\r\n * @param streams the new Media Streams\r\n * @param resolution the resolution of the video streams\r\n * @returns {*[]} object that describes the new streams\r\n */\r\nfunction handleLocalStream(streams, resolution) {\r\n    let audioStream, desktopStream, videoStream;\r\n    const res = [];\r\n\r\n    // XXX The function obtainAudioAndVideoPermissions has examined the type of\r\n    // the browser, its capabilities, etc. and has taken the decision whether to\r\n    // invoke getUserMedia per device (e.g. Firefox) or once for both audio and\r\n    // video (e.g. Chrome). In order to not duplicate the logic here, examine\r\n    // the specified streams and figure out what we've received based on\r\n    // obtainAudioAndVideoPermissions' decision.\r\n    if (streams) {\r\n        // As mentioned above, certian types of browser (e.g. Chrome) support\r\n        // (with a result which meets our requirements expressed bellow) calling\r\n        // getUserMedia once for both audio and video.\r\n        const audioVideo = streams.audioVideo;\r\n\r\n        if (audioVideo) {\r\n            const audioTracks = audioVideo.getAudioTracks();\r\n\r\n            if (audioTracks.length) {\r\n                audioStream = new MediaStream();\r\n                for (let i = 0; i < audioTracks.length; i++) {\r\n                    audioStream.addTrack(audioTracks[i]);\r\n                }\r\n            }\r\n\r\n            const videoTracks = audioVideo.getVideoTracks();\r\n\r\n            if (videoTracks.length) {\r\n                videoStream = new MediaStream();\r\n                for (let j = 0; j < videoTracks.length; j++) {\r\n                    videoStream.addTrack(videoTracks[j]);\r\n                }\r\n            }\r\n        } else {\r\n            // On other types of browser (e.g. Firefox) we choose (namely,\r\n            // obtainAudioAndVideoPermissions) to call getUserMedia per device\r\n            // (type).\r\n            audioStream = streams.audio;\r\n            videoStream = streams.video;\r\n        }\r\n\r\n        desktopStream = streams.desktop;\r\n    }\r\n\r\n    if (desktopStream) {\r\n        const { stream, sourceId, sourceType } = desktopStream;\r\n\r\n        res.push({\r\n            stream,\r\n            sourceId,\r\n            sourceType,\r\n            track: stream.getVideoTracks()[0],\r\n            mediaType: MediaType.VIDEO,\r\n            videoType: VideoType.DESKTOP\r\n        });\r\n    }\r\n    if (audioStream) {\r\n        res.push({\r\n            stream: audioStream,\r\n            track: audioStream.getAudioTracks()[0],\r\n            mediaType: MediaType.AUDIO,\r\n            videoType: null\r\n        });\r\n    }\r\n    if (videoStream) {\r\n        res.push({\r\n            stream: videoStream,\r\n            track: videoStream.getVideoTracks()[0],\r\n            mediaType: MediaType.VIDEO,\r\n            videoType: VideoType.CAMERA,\r\n            resolution\r\n        });\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\n/**\r\n * Represents a default implementation of setting a <tt>MediaStream</tt> as the\r\n * source of a video element that tries to be browser-agnostic through feature\r\n * checking. Note though that it was not completely clear from the predating\r\n * browser-specific implementations what &quot;videoSrc&quot; was because one\r\n * implementation of {@link RTCUtils#getVideoSrc} would return\r\n * <tt>MediaStream</tt> (e.g. Firefox), another a <tt>string</tt> representation\r\n * of the <tt>URL</tt> of the <tt>MediaStream</tt> (e.g. Chrome) and the return\r\n * value was only used by {@link RTCUIHelper#getVideoId} which itself did not\r\n * appear to be used anywhere. Generally, the implementation will try to follow\r\n * the related standards i.e. work with the <tt>srcObject</tt> and <tt>src</tt>\r\n * properties of the specified <tt>element</tt> taking into account vender\r\n * prefixes.\r\n *\r\n * @param element the element whose video source/src is to be set to the\r\n * specified <tt>stream</tt>\r\n * @param {MediaStream} stream the <tt>MediaStream</tt> to set as the video\r\n * source/src of <tt>element</tt>\r\n */\r\nfunction defaultSetVideoSrc(element, stream) {\r\n    // srcObject\r\n    let srcObjectPropertyName = 'srcObject';\r\n\r\n    if (!(srcObjectPropertyName in element)) {\r\n        srcObjectPropertyName = 'mozSrcObject';\r\n        if (!(srcObjectPropertyName in element)) {\r\n            srcObjectPropertyName = null;\r\n        }\r\n    }\r\n    if (srcObjectPropertyName) {\r\n        element[srcObjectPropertyName] = stream;\r\n\r\n        return;\r\n    }\r\n\r\n    // src\r\n    let src;\r\n\r\n    if (stream) {\r\n        src = stream.qhsenseObjectURL;\r\n\r\n        // Save the created URL for stream so we can reuse it and not keep\r\n        // creating URLs.\r\n        if (!src) {\r\n            stream.qhsenseObjectURL = src = URL.createObjectURL(stream);\r\n        }\r\n    }\r\n    element.src = src || '';\r\n}\r\n\r\n/**\r\n *\r\n */\r\nclass RTCUtils extends Listenable {\r\n    /**\r\n     *\r\n     */\r\n    constructor() {\r\n        super(eventEmitter);\r\n    }\r\n\r\n    /**\r\n     * Depending on the browser, sets difference instance methods for\r\n     * interacting with user media and adds methods to native WebRTC-related\r\n     * objects. Also creates an instance variable for peer connection\r\n     * constraints.\r\n     *\r\n     * @param {Object} options\r\n     * @returns {void}\r\n     */\r\n    init(options = {}) {\r\n        if (typeof options.disableAEC === 'boolean') {\r\n            disableAEC = options.disableAEC;\r\n            logger.info(`Disable AEC: ${disableAEC}`);\r\n        }\r\n        if (typeof options.disableNS === 'boolean') {\r\n            disableNS = options.disableNS;\r\n            logger.info(`Disable NS: ${disableNS}`);\r\n        }\r\n        if (typeof options.disableAP === 'boolean') {\r\n            disableAP = options.disableAP;\r\n            logger.info(`Disable AP: ${disableAP}`);\r\n        }\r\n        if (typeof options.disableAGC === 'boolean') {\r\n            disableAGC = options.disableAGC;\r\n            logger.info(`Disable AGC: ${disableAGC}`);\r\n        }\r\n        if (typeof options.disableHPF === 'boolean') {\r\n            disableHPF = options.disableHPF;\r\n            logger.info(`Disable HPF: ${disableHPF}`);\r\n        }\r\n\r\n        availableDevices = undefined;\r\n        window.clearInterval(availableDevicesPollTimer);\r\n        availableDevicesPollTimer = undefined;\r\n\r\n        this.enumerateDevices = initEnumerateDevicesWithCallback();\r\n\r\n        if (browser.usesNewGumFlow()) {\r\n            this.RTCPeerConnectionType = RTCPeerConnection;\r\n\r\n            this.attachMediaStream\r\n                = wrapAttachMediaStream((element, stream) => {\r\n                    if (element) {\r\n                        element.srcObject = stream;\r\n                    }\r\n                });\r\n\r\n            this.getStreamID = ({ id }) => id;\r\n            this.getTrackID = ({ id }) => id;\r\n        } else if (browser.isChromiumBased() // this is chrome < 61\r\n                || browser.isReactNative()) {\r\n\r\n            this.RTCPeerConnectionType = RTCPeerConnection;\r\n\r\n            this.attachMediaStream\r\n                = wrapAttachMediaStream((element, stream) => {\r\n                    defaultSetVideoSrc(element, stream);\r\n\r\n                    return element;\r\n                });\r\n\r\n            this.getStreamID = function({ id }) {\r\n                // A. MediaStreams from FF endpoints have the characters '{' and\r\n                // '}' that make jQuery choke.\r\n                // B. The react-native-webrtc implementation that we use at the\r\n                // time of this writing returns a number for the id of\r\n                // MediaStream. Let's just say that a number contains no special\r\n                // characters.\r\n                return (\r\n                    typeof id === 'number'\r\n                        ? id\r\n                        : SDPUtil.filterSpecialChars(id));\r\n            };\r\n            this.getTrackID = ({ id }) => id;\r\n\r\n            if (!MediaStream.prototype.getVideoTracks) {\r\n                MediaStream.prototype.getVideoTracks = function() {\r\n                    return this.videoTracks;\r\n                };\r\n            }\r\n            if (!MediaStream.prototype.getAudioTracks) {\r\n                MediaStream.prototype.getAudioTracks = function() {\r\n                    return this.audioTracks;\r\n                };\r\n            }\r\n        } else {\r\n            const message = 'Endpoint does not appear to be WebRTC-capable';\r\n\r\n            logger.error(message);\r\n            throw new Error(message);\r\n        }\r\n\r\n        this._initPCConstraints(options);\r\n\r\n        screenObtainer.init(\r\n            options,\r\n            this.getUserMediaWithConstraints.bind(this));\r\n\r\n        if (this.isDeviceListAvailable()) {\r\n            this.enumerateDevices(ds => {\r\n                availableDevices = ds.splice(0);\r\n\r\n                logger.debug('Available devices: ', availableDevices);\r\n                sendDeviceListToAnalytics(availableDevices);\r\n\r\n                eventEmitter.emit(\r\n                    RTCEvents.DEVICE_LIST_AVAILABLE,\r\n                    availableDevices);\r\n\r\n\r\n                // Use a shared callback to handle both the devicechange event\r\n                // and the polling implementations. This prevents duplication\r\n                // and works around a chrome bug (verified to occur on 68) where\r\n                // devicechange fires twice in a row, which can cause async post\r\n                // devicechange processing to collide.\r\n                const updateKnownDevices = () => this.enumerateDevices(pds => {\r\n                    if (compareAvailableMediaDevices(pds)) {\r\n                        onMediaDevicesListChanged(pds);\r\n                    }\r\n                });\r\n\r\n                if (browser.supportsDeviceChangeEvent()) {\r\n                    navigator.mediaDevices.addEventListener(\r\n                        'devicechange',\r\n                        updateKnownDevices);\r\n                } else {\r\n                    // Periodically poll enumerateDevices() method to check if\r\n                    // list of media devices has changed.\r\n                    availableDevicesPollTimer = window.setInterval(\r\n                        updateKnownDevices,\r\n                        AVAILABLE_DEVICES_POLL_INTERVAL_TIME);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates instance objects for peer connection constraints both for p2p\r\n     * and outside of p2p.\r\n     *\r\n     * @params {Object} options - Configuration for setting RTCUtil's instance\r\n     * objects for peer connection constraints.\r\n     * @params {boolean} options.useIPv6 - Set to true if IPv6 should be used.\r\n     * @params {boolean} options.disableSuspendVideo - Whether or not video\r\n     * should become suspended if bandwidth estimation becomes low.\r\n     * @params {Object} options.testing - Additional configuration for work in\r\n     * development.\r\n     * @params {Object} options.testing.forceP2PSuspendVideoRatio - True if\r\n     * video should become suspended if bandwidth estimation becomes low while\r\n     * in peer to peer connection mode.\r\n     */\r\n    _initPCConstraints(options) {\r\n        if (browser.isFirefox()) {\r\n            this.pcConstraints = {};\r\n        } else if (browser.isChromiumBased() || browser.isReactNative()) {\r\n            this.pcConstraints = { optional: [\r\n                { googHighStartBitrate: 0 },\r\n                { googPayloadPadding: true },\r\n                { googScreencastMinBitrate: 100 },\r\n                { googCpuOveruseDetection: true },\r\n                { googCpuOveruseEncodeUsage: true },\r\n                { googCpuUnderuseThreshold: 55 },\r\n                { googCpuOveruseThreshold: 85 }\r\n            ] };\r\n\r\n            if (options.useIPv6) {\r\n                // https://code.google.com/p/webrtc/issues/detail?id=2828\r\n                this.pcConstraints.optional.push({ googIPv6: true });\r\n            }\r\n\r\n            this.p2pPcConstraints\r\n                = JSON.parse(JSON.stringify(this.pcConstraints));\r\n\r\n            // Allows sending of video to be suspended if the bandwidth\r\n            // estimation is too low.\r\n            if (!options.disableSuspendVideo) {\r\n                this.pcConstraints.optional.push(\r\n                    { googSuspendBelowMinBitrate: true });\r\n            }\r\n\r\n            // There's no reason not to use this for p2p\r\n            this.p2pPcConstraints.optional.push({\r\n                googSuspendBelowMinBitrate: true\r\n            });\r\n        }\r\n\r\n        this.p2pPcConstraints = this.p2pPcConstraints || this.pcConstraints;\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n\r\n    /**\r\n    * @param {string[]} um required user media types\r\n    * @param {Object} [options] optional parameters\r\n    * @param {string} options.resolution\r\n    * @param {number} options.bandwidth\r\n    * @param {number} options.fps\r\n    * @param {string} options.desktopStream\r\n    * @param {string} options.cameraDeviceId\r\n    * @param {string} options.micDeviceId\r\n    * @param {Object} options.frameRate - used only for dekstop sharing.\r\n    * @param {Object} options.frameRate.min - Minimum fps\r\n    * @param {Object} options.frameRate.max - Maximum fps\r\n    * @returns {Promise} Returns a media stream on success or a QHSenseTrackError\r\n    * on failure.\r\n    **/\r\n    getUserMediaWithConstraints(um, options = {}) {\r\n        const constraints = getConstraints(um, options);\r\n\r\n        logger.info('Get media constraints', constraints);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            navigator.mediaDevices.getUserMedia(constraints)\r\n                .then(stream => {\r\n                    logger.log('onUserMediaSuccess');\r\n                    updateGrantedPermissions(um, stream);\r\n                    resolve(stream);\r\n                })\r\n                .catch(error => {\r\n                    logger.warn('Failed to get access to local media. '\r\n                        + ` ${error} ${constraints} `);\r\n                    updateGrantedPermissions(um, undefined);\r\n                    reject(new QHSenseTrackError(error, constraints, um));\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Acquires a media stream via getUserMedia that\r\n     * matches the given constraints\r\n     *\r\n     * @param {array} umDevices which devices to acquire (e.g. audio, video)\r\n     * @param {Object} constraints - Stream specifications to use.\r\n     * @returns {Promise}\r\n     */\r\n    _newGetUserMediaWithConstraints(umDevices, constraints = {}) {\r\n        return new Promise((resolve, reject) => {\r\n            navigator.mediaDevices.getUserMedia(constraints)\r\n                .then(stream => {\r\n                    logger.log('onUserMediaSuccess');\r\n                    updateGrantedPermissions(umDevices, stream);\r\n                    resolve(stream);\r\n                })\r\n                .catch(error => {\r\n                    logger.warn('Failed to get access to local media. '\r\n                        + ` ${error} ${constraints} `);\r\n                    updateGrantedPermissions(umDevices, undefined);\r\n                    reject(new QHSenseTrackError(error, constraints, umDevices));\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Acquire a display stream via the screenObtainer. This requires extra\r\n     * logic compared to use screenObtainer versus normal device capture logic\r\n     * in RTCUtils#_newGetUserMediaWithConstraints.\r\n     *\r\n     * @param {Object} options\r\n     * @param {Object} options.desktopSharingExtensionExternalInstallation\r\n     * @param {string[]} options.desktopSharingSources\r\n     * @param {Object} options.desktopSharingFrameRate\r\n     * @param {Object} options.desktopSharingFrameRate.min - Minimum fps\r\n     * @param {Object} options.desktopSharingFrameRate.max - Maximum fps\r\n     * @returns {Promise} A promise which will be resolved with an object which\r\n     * contains the acquired display stream. If desktop sharing is not supported\r\n     * then a rejected promise will be returned.\r\n     */\r\n    _newGetDesktopMedia(options) {\r\n        if (!screenObtainer.isSupported() || !browser.supportsVideo()) {\r\n            return Promise.reject(\r\n                new Error('Desktop sharing is not supported!'));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            screenObtainer.obtainStream(\r\n                this._parseDesktopSharingOptions(options),\r\n                stream => {\r\n                    resolve(stream);\r\n                },\r\n                error => {\r\n                    reject(error);\r\n                });\r\n        });\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Creates the local MediaStreams.\r\n     * @param {Object} [options] optional parameters\r\n     * @param {Array} options.devices the devices that will be requested\r\n     * @param {string} options.resolution resolution constraints\r\n     * @param {string} options.cameraDeviceId\r\n     * @param {string} options.micDeviceId\r\n     * @param {Object} options.desktopSharingFrameRate\r\n     * @param {Object} options.desktopSharingFrameRate.min - Minimum fps\r\n     * @param {Object} options.desktopSharingFrameRate.max - Maximum fps\r\n     * @returns {*} Promise object that will receive the new QHSenseTracks\r\n     */\r\n    obtainAudioAndVideoPermissions(options = {}) {\r\n        options.devices = options.devices || [ ...OLD_GUM_DEFAULT_DEVICES ];\r\n        options.resolution = options.resolution || OLD_GUM_DEFAULT_RESOLUTION;\r\n\r\n        const requestingDesktop = options.devices.includes('desktop');\r\n\r\n        if (requestingDesktop && !screenObtainer.isSupported()) {\r\n            return Promise.reject(\r\n                new Error('Desktop sharing is not supported!'));\r\n        }\r\n\r\n        return this._getAudioAndVideoStreams(options).then(streams =>\r\n            handleLocalStream(streams, options.resolution));\r\n    }\r\n\r\n    /**\r\n     * Performs one call to getUserMedia for audio and/or video and another call\r\n     * for desktop.\r\n     *\r\n     * @param {Object} options - An object describing how the gUM request should\r\n     * be executed. See {@link obtainAudioAndVideoPermissions} for full options.\r\n     * @returns {*} Promise object that will receive the new QHSenseTracks on\r\n     * success or a QHSenseTrackError on failure.\r\n     */\r\n    _getAudioAndVideoStreams(options) {\r\n        const requestingDesktop = options.devices.includes('desktop');\r\n\r\n        options.devices = options.devices.filter(device =>\r\n            device !== 'desktop');\r\n\r\n        const gumPromise = options.devices.length\r\n            ? this.getUserMediaWithConstraints(options.devices, options)\r\n            : Promise.resolve(null);\r\n\r\n        return gumPromise\r\n            .then(avStream => {\r\n                // If any requested devices are missing, call gum again in\r\n                // an attempt to obtain the actual error. For example, the\r\n                // requested video device is missing or permission was\r\n                // denied.\r\n                const missingTracks\r\n                    = this._getMissingTracks(options.devices, avStream);\r\n\r\n                if (missingTracks.length) {\r\n                    this.stopMediaStream(avStream);\r\n\r\n                    return this.getUserMediaWithConstraints(\r\n                        missingTracks, options)\r\n\r\n                        // GUM has already failed earlier and this success\r\n                        // handling should not be reached.\r\n                        .then(() => Promise.reject(new QHSenseTrackError(\r\n                            { name: 'UnknownError' },\r\n                            getConstraints(options.devices, options),\r\n                            missingTracks)));\r\n                }\r\n\r\n                return avStream;\r\n            })\r\n            .then(audioVideo => {\r\n                if (!requestingDesktop) {\r\n                    return { audioVideo };\r\n                }\r\n\r\n                if (options.desktopSharingSourceDevice) {\r\n                    this.stopMediaStream(audioVideo);\r\n\r\n                    throw new Error('Using a camera as screenshare source is'\r\n                        + 'not supported on this browser.');\r\n                }\r\n\r\n                return new Promise((resolve, reject) => {\r\n                    screenObtainer.obtainStream(\r\n                        this._parseDesktopSharingOptions(options),\r\n                        desktop => resolve({\r\n                            audioVideo,\r\n                            desktop\r\n                        }),\r\n                        error => {\r\n                            if (audioVideo) {\r\n                                this.stopMediaStream(audioVideo);\r\n                            }\r\n                            reject(error);\r\n                        });\r\n                });\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Private utility for determining if the passed in MediaStream contains\r\n     * tracks of the type(s) specified in the requested devices.\r\n     *\r\n     * @param {string[]} requestedDevices - The track types that are expected to\r\n     * be includes in the stream.\r\n     * @param {MediaStream} stream - The MediaStream to check if it has the\r\n     * expected track types.\r\n     * @returns {string[]} An array of string with the missing track types. The\r\n     * array will be empty if all requestedDevices are found in the stream.\r\n     */\r\n    _getMissingTracks(requestedDevices = [], stream) {\r\n        const missingDevices = [];\r\n\r\n        const audioDeviceRequested = requestedDevices.includes('audio');\r\n        const audioTracksReceived\r\n            = stream && stream.getAudioTracks().length > 0;\r\n\r\n        if (audioDeviceRequested && !audioTracksReceived) {\r\n            missingDevices.push('audio');\r\n        }\r\n\r\n        const videoDeviceRequested = requestedDevices.includes('video');\r\n        const videoTracksReceived\r\n            = stream && stream.getVideoTracks().length > 0;\r\n\r\n        if (videoDeviceRequested && !videoTracksReceived) {\r\n            missingDevices.push('video');\r\n        }\r\n\r\n        return missingDevices;\r\n    }\r\n\r\n    /**\r\n     * Returns an object formatted for specifying desktop sharing parameters.\r\n     *\r\n     * @param {Object} options - Takes in the same options object as\r\n     * {@link obtainAudioAndVideoPermissions}.\r\n     * @returns {Object}\r\n     */\r\n    _parseDesktopSharingOptions(options) {\r\n        return {\r\n            ...options.desktopSharingExtensionExternalInstallation,\r\n            desktopSharingSources: options.desktopSharingSources,\r\n            gumOptions: {\r\n                frameRate: options.desktopSharingFrameRate\r\n            },\r\n            trackOptions: getTrackSSConstraints(options)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets streams from specified device types. This function intentionally\r\n     * ignores errors for upstream to catch and handle instead.\r\n     *\r\n     * @param {Object} options - A hash describing what devices to get and\r\n     * relevant constraints.\r\n     * @param {string[]} options.devices - The types of media to capture. Valid\r\n     * values are \"desktop\", \"audio\", and \"video\".\r\n     * @param {Object} options.desktopSharingFrameRate\r\n     * @param {Object} options.desktopSharingFrameRate.min - Minimum fps\r\n     * @param {Object} options.desktopSharingFrameRate.max - Maximum fps\r\n     * @param {String} options.desktopSharingSourceDevice - The device id or\r\n     * label for a video input source that should be used for screensharing.\r\n     * @returns {Promise} The promise, when successful, will return an array of\r\n     * meta data for the requested device type, which includes the stream and\r\n     * track. If an error occurs, it will be deferred to the caller for\r\n     * handling.\r\n     */\r\n    newObtainAudioAndVideoPermissions(options) {\r\n        logger.info('Using the new gUM flow');\r\n\r\n        const mediaStreamsMetaData = [];\r\n\r\n        // Declare private functions to be used in the promise chain below.\r\n        // These functions are declared in the scope of this function because\r\n        // they are not being used anywhere else, so only this function needs to\r\n        // know about them.\r\n\r\n        /**\r\n         * Executes a request for desktop media if specified in options.\r\n         *\r\n         * @returns {Promise}\r\n         */\r\n        const maybeRequestDesktopDevice = function() {\r\n            const umDevices = options.devices || [];\r\n            const isDesktopDeviceRequested\r\n                = umDevices.indexOf('desktop') !== -1;\r\n\r\n            if (!isDesktopDeviceRequested) {\r\n                return Promise.resolve();\r\n            }\r\n\r\n            const {\r\n                desktopSharingExtensionExternalInstallation,\r\n                desktopSharingSourceDevice,\r\n                desktopSharingSources,\r\n                desktopSharingFrameRate\r\n            } = options;\r\n\r\n            // Attempt to use a video input device as a screenshare source if\r\n            // the option is defined.\r\n            if (desktopSharingSourceDevice) {\r\n                const matchingDevice\r\n                    = availableDevices && availableDevices.find(device =>\r\n                        device.kind === 'videoinput'\r\n                            && (device.deviceId === desktopSharingSourceDevice\r\n                            || device.label === desktopSharingSourceDevice));\r\n                const requestedDevices = [ 'video' ];\r\n\r\n                // Leverage the helper used by {@link _newGetDesktopMedia} to\r\n                // get constraints for the desktop stream.\r\n                const { gumOptions, trackOptions }\r\n                    = this._parseDesktopSharingOptions(options);\r\n\r\n                // Create a custom constraints object to use exact device\r\n                // matching to make sure there is no fallthrough to another\r\n                // camera device. If a matching device could not be found, try\r\n                // anyways and let the caller handle errors.\r\n                const constraints = {\r\n                    video: {\r\n                        ...gumOptions,\r\n                        deviceId: {\r\n                            exact: (matchingDevice && matchingDevice.deviceId)\r\n                                || desktopSharingSourceDevice\r\n                        }\r\n                    }\r\n                };\r\n\r\n                return this._newGetUserMediaWithConstraints(\r\n                    requestedDevices, constraints)\r\n                    .then(stream => {\r\n                        const track = stream && stream.getTracks()[0];\r\n                        const applyConstrainsPromise\r\n                            = track && track.applyConstraints\r\n                                ? track.applyConstraints(trackOptions)\r\n                                : Promise.resolve();\r\n\r\n                        return applyConstrainsPromise\r\n                            .then(() => {\r\n                                return {\r\n                                    sourceType: 'device',\r\n                                    stream\r\n                                };\r\n                            });\r\n                    });\r\n            }\r\n\r\n            return this._newGetDesktopMedia({\r\n                desktopSharingExtensionExternalInstallation,\r\n                desktopSharingSources,\r\n                desktopSharingFrameRate\r\n            });\r\n        }.bind(this);\r\n\r\n        /**\r\n         * Creates a meta data object about the passed in desktopStream and\r\n         * pushes the meta data to the internal array mediaStreamsMetaData to be\r\n         * returned later.\r\n         *\r\n         * @param {MediaStreamTrack} desktopStream - A track for a desktop\r\n         * capture.\r\n         * @returns {void}\r\n         */\r\n        const maybeCreateAndAddDesktopTrack = function(desktopStream) {\r\n            if (!desktopStream) {\r\n                return;\r\n            }\r\n\r\n            const { stream, sourceId, sourceType } = desktopStream;\r\n\r\n            mediaStreamsMetaData.push({\r\n                stream,\r\n                sourceId,\r\n                sourceType,\r\n                track: stream.getVideoTracks()[0],\r\n                videoType: VideoType.DESKTOP\r\n            });\r\n        };\r\n\r\n        /**\r\n         * Executes a request for audio and/or video, as specified in options.\r\n         * By default both audio and video will be captured if options.devices\r\n         * is not defined.\r\n         *\r\n         * @returns {Promise}\r\n         */\r\n        const maybeRequestCaptureDevices = function() {\r\n            const umDevices = options.devices || [ 'audio', 'video' ];\r\n            const requestedCaptureDevices = umDevices.filter(device =>\r\n                device === 'audio'\r\n                || (device === 'video' && browser.supportsVideo()));\r\n\r\n            if (!requestedCaptureDevices.length) {\r\n                return Promise.resolve();\r\n            }\r\n\r\n            const constraints = newGetConstraints(\r\n                requestedCaptureDevices, options);\r\n\r\n            logger.info('Got media constraints: ', constraints);\r\n\r\n            return this._newGetUserMediaWithConstraints(\r\n                requestedCaptureDevices, constraints);\r\n        }.bind(this);\r\n\r\n        /**\r\n         * Splits the passed in media stream into separate audio and video\r\n         * streams and creates meta data objects for each and pushes them to the\r\n         * internal array mediaStreamsMetaData to be returned later.\r\n         *\r\n         * @param {MediaStreamTrack} avStream - A track for with audio and/or\r\n         * video track.\r\n         * @returns {void}\r\n         */\r\n        const maybeCreateAndAddAVTracks = function(avStream) {\r\n            if (!avStream) {\r\n                return;\r\n            }\r\n\r\n            const audioTracks = avStream.getAudioTracks();\r\n\r\n            if (audioTracks.length) {\r\n                const audioStream = new MediaStream(audioTracks);\r\n\r\n                mediaStreamsMetaData.push({\r\n                    stream: audioStream,\r\n                    track: audioStream.getAudioTracks()[0],\r\n                    effects: options.effects\r\n                });\r\n            }\r\n\r\n            const videoTracks = avStream.getVideoTracks();\r\n\r\n            if (videoTracks.length) {\r\n                const videoStream = new MediaStream(videoTracks);\r\n\r\n                mediaStreamsMetaData.push({\r\n                    stream: videoStream,\r\n                    track: videoStream.getVideoTracks()[0],\r\n                    videoType: VideoType.CAMERA,\r\n                    effects: options.effects\r\n                });\r\n            }\r\n        };\r\n\r\n        return maybeRequestDesktopDevice()\r\n            .then(maybeCreateAndAddDesktopTrack)\r\n            .then(maybeRequestCaptureDevices)\r\n            .then(maybeCreateAndAddAVTracks)\r\n            .then(() => mediaStreamsMetaData)\r\n            .catch(error => {\r\n                mediaStreamsMetaData.forEach(({ stream }) => {\r\n                    this.stopMediaStream(stream);\r\n                });\r\n\r\n                return Promise.reject(error);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Checks whether it is possible to enumerate available cameras/microphones.\r\n     *\r\n     * @returns {boolean} {@code true} if the device listing is available;\r\n     * {@code false}, otherwise.\r\n     */\r\n    isDeviceListAvailable() {\r\n        return Boolean(\r\n            navigator.mediaDevices\r\n                && navigator.mediaDevices.enumerateDevices);\r\n    }\r\n\r\n    /**\r\n     * Returns true if changing the input (camera / microphone) or output\r\n     * (audio) device is supported and false if not.\r\n     * @params {string} [deviceType] - type of device to change. Default is\r\n     *      undefined or 'input', 'output' - for audio output device change.\r\n     * @returns {boolean} true if available, false otherwise.\r\n     */\r\n    isDeviceChangeAvailable(deviceType) {\r\n        return deviceType === 'output' || deviceType === 'audiooutput'\r\n            ? isAudioOutputDeviceChangeAvailable\r\n            : browser.isChromiumBased()\r\n                || browser.isFirefox() || browser.isEdge();\r\n    }\r\n\r\n    /**\r\n     * A method to handle stopping of the stream.\r\n     * One point to handle the differences in various implementations.\r\n     * @param mediaStream MediaStream object to stop.\r\n     */\r\n    stopMediaStream(mediaStream) {\r\n        if (!mediaStream) {\r\n            return;\r\n        }\r\n\r\n        mediaStream.getTracks().forEach(track => {\r\n            if (track.stop) {\r\n                track.stop();\r\n            }\r\n        });\r\n\r\n        // leave stop for implementation still using it\r\n        if (mediaStream.stop) {\r\n            mediaStream.stop();\r\n        }\r\n\r\n        // The MediaStream implementation of the react-native-webrtc project has\r\n        // an explicit release method that is to be invoked in order to release\r\n        // used resources such as memory.\r\n        if (mediaStream.release) {\r\n            mediaStream.release();\r\n        }\r\n\r\n        // if we have done createObjectURL, lets clean it\r\n        const url = mediaStream.qhsenseObjectURL;\r\n\r\n        if (url) {\r\n            delete mediaStream.qhsenseObjectURL;\r\n            URL.revokeObjectURL(url);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns whether the desktop sharing is enabled or not.\r\n     * @returns {boolean}\r\n     */\r\n    isDesktopSharingEnabled() {\r\n        return screenObtainer.isSupported();\r\n    }\r\n\r\n    /**\r\n     * Sets current audio output device.\r\n     * @param {string} deviceId - id of 'audiooutput' device from\r\n     *      navigator.mediaDevices.enumerateDevices(), 'default' for default\r\n     *      device\r\n     * @returns {Promise} - resolves when audio output is changed, is rejected\r\n     *      otherwise\r\n     */\r\n    setAudioOutputDevice(deviceId) {\r\n        if (!this.isDeviceChangeAvailable('output')) {\r\n            return Promise.reject(\r\n                new Error('Audio output device change is not supported'));\r\n        }\r\n\r\n        return featureDetectionAudioEl.setSinkId(deviceId)\r\n            .then(() => {\r\n                audioOutputDeviceId = deviceId;\r\n                audioOutputChanged = true;\r\n\r\n                logger.log(`Audio output device set to ${deviceId}`);\r\n\r\n                eventEmitter.emit(RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED,\r\n                    deviceId);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Returns currently used audio output device id, '' stands for default\r\n     * device\r\n     * @returns {string}\r\n     */\r\n    getAudioOutputDevice() {\r\n        return audioOutputDeviceId;\r\n    }\r\n\r\n    /**\r\n     * Returns list of available media devices if its obtained, otherwise an\r\n     * empty array is returned/\r\n     * @returns {Array} list of available media devices.\r\n     */\r\n    getCurrentlyAvailableMediaDevices() {\r\n        return availableDevices;\r\n    }\r\n\r\n    /**\r\n     * Returns event data for device to be reported to stats.\r\n     * @returns {MediaDeviceInfo} device.\r\n     */\r\n    getEventDataForActiveDevice(device) {\r\n        const deviceList = [];\r\n        const deviceData = {\r\n            'deviceId': device.deviceId,\r\n            'kind': device.kind,\r\n            'label': device.label,\r\n            'groupId': device.groupId\r\n        };\r\n\r\n        deviceList.push(deviceData);\r\n\r\n        return { deviceList };\r\n    }\r\n\r\n    /**\r\n     * Configures the given PeerConnection constraints to either enable or\r\n     * disable (according to the value of the 'enable' parameter) the\r\n     * 'googSuspendBelowMinBitrate' option.\r\n     * @param constraints the constraints on which to operate.\r\n     * @param enable {boolean} whether to enable or disable the suspend video\r\n     * option.\r\n     */\r\n    setSuspendVideo(constraints, enable) {\r\n        if (!constraints.optional) {\r\n            constraints.optional = [];\r\n        }\r\n\r\n        // Get rid of all \"googSuspendBelowMinBitrate\" constraints (we assume\r\n        // that the elements of constraints.optional contain a single property).\r\n        constraints.optional\r\n            = constraints.optional.filter(\r\n                c => !c.hasOwnProperty('googSuspendBelowMinBitrate'));\r\n\r\n        if (enable) {\r\n            constraints.optional.push({ googSuspendBelowMinBitrate: 'true' });\r\n        }\r\n    }\r\n}\r\n\r\nconst rtcUtils = new RTCUtils();\r\n\r\n/**\r\n * Wraps original attachMediaStream function to set current audio output device\r\n * if this is supported.\r\n * @param {Function} origAttachMediaStream\r\n * @returns {Function}\r\n */\r\nfunction wrapAttachMediaStream(origAttachMediaStream) {\r\n    return function(element, stream) {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        const res = origAttachMediaStream.apply(rtcUtils, arguments);\r\n\r\n        if (stream\r\n                && rtcUtils.isDeviceChangeAvailable('output')\r\n                && stream.getAudioTracks\r\n                && stream.getAudioTracks().length\r\n\r\n                // we skip setting audio output if there was no explicit change\r\n                && audioOutputChanged) {\r\n            element.setSinkId(rtcUtils.getAudioOutputDevice())\r\n                .catch(function(ex) {\r\n                    const err\r\n                        = new QHSenseTrackError(ex, null, [ 'audiooutput' ]);\r\n\r\n                    GlobalOnErrorHandler.callUnhandledRejectionHandler({\r\n                        promise: this, // eslint-disable-line no-invalid-this\r\n                        reason: err\r\n                    });\r\n\r\n                    logger.warn(\r\n                        'Failed to set audio output device for the element.'\r\n                            + ' Default audio output device will be used'\r\n                            + ' instead',\r\n                        element,\r\n                        err);\r\n                });\r\n        }\r\n\r\n        return res;\r\n    };\r\n}\r\n\r\nexport default rtcUtils;\r\n","/**\r\n * This utility class defines custom onerror and onunhandledrejection functions.\r\n * The custom error handlers respect the previously-defined error handlers.\r\n * GlobalOnErrorHandler class provides utilities to add many custom error\r\n * handlers and to execute the error handlers directly.\r\n */\r\n\r\n\r\n/**\r\n * List with global error handlers that will be executed.\r\n */\r\nconst handlers = [];\r\n\r\n// If an old handler exists, also fire its events.\r\nconst oldOnErrorHandler = window.onerror;\r\n\r\n/**\r\n * Custom error handler that calls the old global error handler and executes\r\n * all handlers that were previously added.\r\n */\r\nfunction QHSenseGlobalErrorHandler(...args) {\r\n    handlers.forEach(handler => handler(...args));\r\n    oldOnErrorHandler && oldOnErrorHandler(...args);\r\n}\r\n\r\n// If an old handler exists, also fire its events.\r\nconst oldOnUnhandledRejection = window.onunhandledrejection;\r\n\r\n/**\r\n * Custom handler that calls the old global handler and executes all handlers\r\n * that were previously added. This handler handles rejected Promises.\r\n */\r\nfunction QHSenseGlobalUnhandledRejection(event) {\r\n    handlers.forEach(handler => handler(null, null, null, null, event.reason));\r\n    oldOnUnhandledRejection && oldOnUnhandledRejection(event);\r\n}\r\n\r\n// Setting the custom error handlers.\r\nwindow.onerror = QHSenseGlobalErrorHandler;\r\nwindow.onunhandledrejection = QHSenseGlobalUnhandledRejection;\r\n\r\nconst GlobalOnErrorHandler = {\r\n    /**\r\n     * Adds new error handlers.\r\n     * @param handler the new handler.\r\n     */\r\n    addHandler(handler) {\r\n        handlers.push(handler);\r\n    },\r\n\r\n    /**\r\n     * Calls the global error handler if there is one.\r\n     * @param error the error to pass to the error handler\r\n     */\r\n    callErrorHandler(error) {\r\n        const errHandler = window.onerror;\r\n\r\n        if (!errHandler) {\r\n            return;\r\n        }\r\n        errHandler(null, null, null, null, error);\r\n    },\r\n\r\n    /**\r\n     * Calls the global rejection handler if there is one.\r\n     * @param error the error to pass to the rejection handler.\r\n     */\r\n    callUnhandledRejectionHandler(error) {\r\n        const errHandler = window.onunhandledrejection;\r\n\r\n        if (!errHandler) {\r\n            return;\r\n        }\r\n        errHandler(error);\r\n    }\r\n};\r\n\r\n\r\nmodule.exports = GlobalOnErrorHandler;\r\n","/**\r\n * The errors for the QHSenseTrack objects.\r\n */\r\n\r\n/**\r\n * Generic error for jidesha extension for Chrome.\r\n */\r\nexport const CHROME_EXTENSION_GENERIC_ERROR\r\n    = 'gum.chrome_extension_generic_error';\r\n\r\n/**\r\n * An error which indicates that the jidesha extension for Chrome is\r\n * failed to install.\r\n */\r\nexport const CHROME_EXTENSION_INSTALLATION_ERROR\r\n    = 'gum.chrome_extension_installation_error';\r\n\r\n/**\r\n * This error indicates that the attempt to start screensharing was initiated by\r\n * a script which did not originate in user gesture handler. It means that\r\n * you should to trigger the action again in response to a button click for\r\n * example.\r\n * @type {string}\r\n */\r\nexport const CHROME_EXTENSION_USER_GESTURE_REQUIRED\r\n    = 'gum.chrome_extension_user_gesture_required';\r\n\r\n/**\r\n * An error which indicates that user canceled screen sharing window\r\n * selection dialog in jidesha extension for Chrome.\r\n */\r\nexport const CHROME_EXTENSION_USER_CANCELED\r\n    = 'gum.chrome_extension_user_canceled';\r\n\r\n/**\r\n * An error which indicates that some of requested constraints in\r\n * getUserMedia call were not satisfied.\r\n */\r\nexport const CONSTRAINT_FAILED = 'gum.constraint_failed';\r\n\r\n/**\r\n * A generic error which indicates an error occurred while selecting\r\n * a DesktopCapturerSource from the electron app.\r\n */\r\nexport const ELECTRON_DESKTOP_PICKER_ERROR\r\n    = 'gum.electron_desktop_picker_error';\r\n\r\n/**\r\n * An error which indicates a custom desktop picker could not be detected\r\n * for the electron app.\r\n */\r\nexport const ELECTRON_DESKTOP_PICKER_NOT_FOUND\r\n    = 'gum.electron_desktop_picker_not_found';\r\n\r\n/**\r\n * An error which indicates that the jidesha extension for Firefox is\r\n * needed to proceed with screen sharing, and that it is not installed.\r\n */\r\nexport const FIREFOX_EXTENSION_NEEDED = 'gum.firefox_extension_needed';\r\n\r\n/**\r\n * Generic getUserMedia error.\r\n */\r\nexport const GENERAL = 'gum.general';\r\n\r\n/**\r\n * An error which indicates that requested device was not found.\r\n */\r\nexport const NOT_FOUND = 'gum.not_found';\r\n\r\n/**\r\n * An error which indicates that user denied permission to share requested\r\n * device.\r\n */\r\nexport const PERMISSION_DENIED = 'gum.permission_denied';\r\n\r\n/**\r\n * An error which indicates that track has been already disposed and cannot\r\n * be longer used.\r\n */\r\nexport const TRACK_IS_DISPOSED = 'track.track_is_disposed';\r\n\r\n/**\r\n * An error which indicates that track has no MediaStream associated.\r\n */\r\nexport const TRACK_NO_STREAM_FOUND = 'track.no_stream_found';\r\n\r\n/**\r\n * An error which indicates that requested video resolution is not supported\r\n * by a webcam.\r\n */\r\nexport const UNSUPPORTED_RESOLUTION = 'gum.unsupported_resolution';\r\n","/* global __filename */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\n\r\nimport BridgeChannel from './BridgeChannel';\r\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\r\nimport * as QHSenseConferenceEvents from '../../QHSenseConferenceEvents';\r\nimport QHSenseLocalTrack from './QHSenseLocalTrack';\r\nimport Listenable from '../util/Listenable';\r\nimport { safeCounterIncrement } from '../util/MathUtil';\r\nimport * as MediaType from '../../service/RTC/MediaType';\r\nimport browser from '../browser';\r\nimport RTCEvents from '../../service/RTC/RTCEvents';\r\nimport RTCUtils from './RTCUtils';\r\nimport Statistics from '../statistics/statistics';\r\nimport TraceablePeerConnection from './TraceablePeerConnection';\r\nimport VideoType from '../../service/RTC/VideoType';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * The counter used to generated id numbers assigned to peer connections\r\n * @type {number}\r\n */\r\nlet peerConnectionIdCounter = 0;\r\n\r\n/**\r\n * The counter used to generate id number for the local\r\n * <code>MediaStreamTrack</code>s.\r\n * @type {number}\r\n */\r\nlet rtcTrackIdCounter = 0;\r\n\r\n/**\r\n *\r\n * @param tracksInfo\r\n * @param options\r\n */\r\nfunction createLocalTracks(tracksInfo, options) {\r\n    const newTracks = [];\r\n    let deviceId = null;\r\n\r\n    tracksInfo.forEach(trackInfo => {\r\n        if (trackInfo.mediaType === MediaType.AUDIO) {\r\n            deviceId = options.micDeviceId;\r\n        } else if (trackInfo.videoType === VideoType.CAMERA) {\r\n            deviceId = options.cameraDeviceId;\r\n        }\r\n        rtcTrackIdCounter = safeCounterIncrement(rtcTrackIdCounter);\r\n        const localTrack = new QHSenseLocalTrack({\r\n            ...trackInfo,\r\n            deviceId,\r\n            facingMode: options.facingMode,\r\n            rtcId: rtcTrackIdCounter,\r\n            effects: options.effects\r\n        });\r\n\r\n        newTracks.push(localTrack);\r\n    });\r\n\r\n    return newTracks;\r\n}\r\n\r\n/**\r\n * Creates {@code QHSenseLocalTrack} instances from the passed in meta information\r\n * about MedieaTracks.\r\n *\r\n * @param {Object[]} mediaStreamMetaData - An array of meta information with\r\n * MediaTrack instances. Each can look like:\r\n * {{\r\n *     stream: MediaStream instance that holds a track with audio or video,\r\n *     track: MediaTrack within the MediaStream,\r\n *     videoType: \"camera\" or \"desktop\" or falsy,\r\n *     sourceId: ID of the desktopsharing source,\r\n *     sourceType: The desktopsharing source type,\r\n *     effects: Array of effect types\r\n * }}\r\n */\r\nfunction _newCreateLocalTracks(mediaStreamMetaData = []) {\r\n    return mediaStreamMetaData.map(metaData => {\r\n        const {\r\n            sourceId,\r\n            sourceType,\r\n            stream,\r\n            track,\r\n            videoType,\r\n            effects\r\n        } = metaData;\r\n\r\n        const { deviceId, facingMode } = track.getSettings();\r\n\r\n        // FIXME Move rtcTrackIdCounter to a static method in QHSenseLocalTrack\r\n        // so RTC does not need to handle ID management. This move would be\r\n        // safer to do once the old createLocalTracks is removed.\r\n        rtcTrackIdCounter = safeCounterIncrement(rtcTrackIdCounter);\r\n\r\n        return new QHSenseLocalTrack({\r\n            deviceId,\r\n            facingMode,\r\n            mediaType: track.kind,\r\n            rtcId: rtcTrackIdCounter,\r\n            sourceId,\r\n            sourceType,\r\n            stream,\r\n            track,\r\n            videoType: videoType || null,\r\n            effects\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport default class RTC extends Listenable {\r\n    /**\r\n     *\r\n     * @param conference\r\n     * @param options\r\n     */\r\n    constructor(conference, options = {}) {\r\n        super();\r\n        this.conference = conference;\r\n\r\n        /**\r\n         * A map of active <tt>TraceablePeerConnection</tt>.\r\n         * @type {Map.<number, TraceablePeerConnection>}\r\n         */\r\n        this.peerConnections = new Map();\r\n\r\n        this.localTracks = [];\r\n\r\n        this.options = options;\r\n\r\n        // BridgeChannel instance.\r\n        // @private\r\n        // @type {BridgeChannel}\r\n        this._channel = null;\r\n\r\n        // A flag whether we had received that the channel had opened we can\r\n        // get this flag out of sync if for some reason channel got closed\r\n        // from server, a desired behaviour so we can see errors when this\r\n        // happen.\r\n        // @private\r\n        // @type {boolean}\r\n        this._channelOpen = false;\r\n\r\n        /**\r\n         * The value specified to the last invocation of setLastN before the\r\n         * channel completed opening. If non-null, the value will be sent\r\n         * through a channel (once) as soon as it opens and will then be\r\n         * discarded.\r\n         * @private\r\n         * @type {number}\r\n         */\r\n        this._lastN = -1;\r\n\r\n        /**\r\n         * Defines the last N endpoints list. It can be null or an array once\r\n         * initialised with a channel last N event.\r\n         * @type {Array<string>|null}\r\n         * @private\r\n         */\r\n        this._lastNEndpoints = null;\r\n\r\n        /**\r\n         * The number representing the maximum video height the local client\r\n         * should receive from the bridge.\r\n         *\r\n         * @type {number|undefined}\r\n         * @private\r\n         */\r\n        this._maxFrameHeight = undefined;\r\n\r\n        /**\r\n         * The endpoint ID of currently pinned participant or <tt>null</tt> if\r\n         * no user is pinned.\r\n         * @type {string|null}\r\n         * @private\r\n         */\r\n        this._pinnedEndpoint = null;\r\n\r\n        /**\r\n         * The endpoint IDs of currently selected participants.\r\n         *\r\n         * @type {Array}\r\n         * @private\r\n         */\r\n        this._selectedEndpoints = [];\r\n\r\n        // The last N change listener.\r\n        this._lastNChangeListener = this._onLastNChanged.bind(this);\r\n\r\n        this._onDeviceListChanged = this._onDeviceListChanged.bind(this);\r\n        this._updateAudioOutputForAudioTracks\r\n            = this._updateAudioOutputForAudioTracks.bind(this);\r\n\r\n        // Switch audio output device on all remote audio tracks. Local audio\r\n        // tracks handle this event by themselves.\r\n        if (RTCUtils.isDeviceChangeAvailable('output')) {\r\n            RTCUtils.addListener(\r\n                RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED,\r\n                this._updateAudioOutputForAudioTracks\r\n            );\r\n\r\n            RTCUtils.addListener(\r\n                RTCEvents.DEVICE_LIST_CHANGED,\r\n                this._onDeviceListChanged\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes any listeners and stored state from this {@code RTC} instance.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    destroy() {\r\n        RTCUtils.removeListener(\r\n            RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED,\r\n            this._updateAudioOutputForAudioTracks\r\n        );\r\n\r\n        RTCUtils.removeListener(\r\n            RTCEvents.DEVICE_LIST_CHANGED,\r\n            this._onDeviceListChanged\r\n        );\r\n\r\n        this.removeListener(\r\n            RTCEvents.LASTN_ENDPOINT_CHANGED,\r\n            this._lastNChangeListener\r\n        );\r\n\r\n        if (this._channelOpenListener) {\r\n            this.removeListener(\r\n                RTCEvents.DATA_CHANNEL_OPEN,\r\n                this._channelOpenListener\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exposes the private helper for converting a WebRTC MediaStream to a\r\n     * QHSenseLocalTrack.\r\n     *\r\n     * @param {Array<Object>} tracksInfo\r\n     * @returns {Array<QHSenseLocalTrack>}\r\n     */\r\n    static newCreateLocalTracks(tracksInfo) {\r\n        return _newCreateLocalTracks(tracksInfo);\r\n    }\r\n\r\n    /**\r\n     * Creates the local MediaStreams.\r\n     * @param {object} [options] Optional parameters.\r\n     * @param {array} options.devices The devices that will be requested.\r\n     * @param {string} options.resolution Resolution constraints.\r\n     * @param {string} options.cameraDeviceId\r\n     * @param {string} options.micDeviceId\r\n     * @returns {*} Promise object that will receive the new QHSenseTracks\r\n     */\r\n    static obtainAudioAndVideoPermissions(options) {\r\n        const usesNewGumFlow = browser.usesNewGumFlow();\r\n        const obtainMediaPromise = usesNewGumFlow\r\n            ? RTCUtils.newObtainAudioAndVideoPermissions(options)\r\n            : RTCUtils.obtainAudioAndVideoPermissions(options);\r\n\r\n        return obtainMediaPromise.then(tracksInfo => {\r\n            if (usesNewGumFlow) {\r\n                return _newCreateLocalTracks(tracksInfo);\r\n            }\r\n\r\n            return createLocalTracks(tracksInfo, options);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Initializes the bridge channel of this instance.\r\n     * At least one of both, peerconnection or wsUrl parameters, must be\r\n     * given.\r\n     * @param {RTCPeerConnection} [peerconnection] WebRTC peer connection\r\n     * instance.\r\n     * @param {string} [wsUrl] WebSocket URL.\r\n     */\r\n    initializeBridgeChannel(peerconnection, wsUrl) {\r\n        this._channel = new BridgeChannel(\r\n            peerconnection, wsUrl, this.eventEmitter);\r\n\r\n        this._channelOpenListener = () => {\r\n            // Mark that channel as opened.\r\n            this._channelOpen = true;\r\n\r\n            // When the channel becomes available, tell the bridge about\r\n            // video selections so that it can do adaptive simulcast,\r\n            // we want the notification to trigger even if userJid\r\n            // is undefined, or null.\r\n            try {\r\n                this._channel.sendPinnedEndpointMessage(\r\n                    this._pinnedEndpoint);\r\n                this._channel.sendSelectedEndpointsMessage(\r\n                    this._selectedEndpoints);\r\n\r\n                if (typeof this._maxFrameHeight !== 'undefined') {\r\n                    this._channel.sendReceiverVideoConstraintMessage(\r\n                        this._maxFrameHeight);\r\n                }\r\n            } catch (error) {\r\n                GlobalOnErrorHandler.callErrorHandler(error);\r\n                logger.error(\r\n                    `Cannot send selected(${this._selectedEndpoint})`\r\n                    + `pinned(${this._pinnedEndpoint})`\r\n                    + `frameHeight(${this._maxFrameHeight}) endpoint message`,\r\n                    error);\r\n            }\r\n\r\n            this.removeListener(RTCEvents.DATA_CHANNEL_OPEN,\r\n                this._channelOpenListener);\r\n            this._channelOpenListener = null;\r\n\r\n            // If setLastN was invoked before the bridge channel completed\r\n            // opening, apply the specified value now that the channel\r\n            // is open. NOTE that -1 is the default value assumed by both\r\n            // RTC module and the JVB.\r\n            if (this._lastN !== -1) {\r\n                this._channel.sendSetLastNMessage(this._lastN);\r\n            }\r\n        };\r\n\r\n        this.addListener(RTCEvents.DATA_CHANNEL_OPEN,\r\n            this._channelOpenListener);\r\n\r\n        // Add Last N change listener.\r\n        this.addListener(RTCEvents.LASTN_ENDPOINT_CHANGED,\r\n            this._lastNChangeListener);\r\n    }\r\n\r\n    /**\r\n     * Callback invoked when the list of known audio and video devices has\r\n     * been updated. Attempts to update the known available audio output\r\n     * devices.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onDeviceListChanged() {\r\n        this._updateAudioOutputForAudioTracks(RTCUtils.getAudioOutputDevice());\r\n    }\r\n\r\n    /**\r\n     * Receives events when Last N had changed.\r\n     * @param {array} lastNEndpoints The new Last N endpoints.\r\n     * @private\r\n     */\r\n    _onLastNChanged(lastNEndpoints = []) {\r\n        const oldLastNEndpoints = this._lastNEndpoints || [];\r\n        let leavingLastNEndpoints = [];\r\n        let enteringLastNEndpoints = [];\r\n\r\n        this._lastNEndpoints = lastNEndpoints;\r\n\r\n        leavingLastNEndpoints = oldLastNEndpoints.filter(\r\n            id => !this.isInLastN(id));\r\n\r\n        enteringLastNEndpoints = lastNEndpoints.filter(\r\n            id => oldLastNEndpoints.indexOf(id) === -1);\r\n\r\n        this.conference.eventEmitter.emit(\r\n            QHSenseConferenceEvents.LAST_N_ENDPOINTS_CHANGED,\r\n            leavingLastNEndpoints,\r\n            enteringLastNEndpoints);\r\n    }\r\n\r\n    /**\r\n     * Should be called when current media session ends and after the\r\n     * PeerConnection has been closed using PeerConnection.close() method.\r\n     */\r\n    onCallEnded() {\r\n        if (this._channel) {\r\n            // The BridgeChannel is not explicitly closed as the PeerConnection\r\n            // is closed on call ended which triggers datachannel onclose\r\n            // events. If using a WebSocket, the channel must be closed since\r\n            // it is not managed by the PeerConnection.\r\n            // The reference is cleared to disable any logic related to the\r\n            // channel.\r\n            if (this._channel && this._channel.mode === 'websocket') {\r\n                this._channel.close();\r\n            }\r\n\r\n            this._channel = null;\r\n            this._channelOpen = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum video size the local participant should receive from\r\n     * remote participants. Will cache the value and send it through the channel\r\n     * once it is created.\r\n     *\r\n     * @param {number} maxFrameHeightPixels the maximum frame height, in pixels,\r\n     * this receiver is willing to receive.\r\n     * @returns {void}\r\n     */\r\n    setReceiverVideoConstraint(maxFrameHeight) {\r\n        this._maxFrameHeight = maxFrameHeight;\r\n\r\n        if (this._channel && this._channelOpen) {\r\n            this._channel.sendReceiverVideoConstraintMessage(maxFrameHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Elects the participants with the given ids to be the selected\r\n     * participants in order to always receive video for this participant (even\r\n     * when last n is enabled). If there is no channel we store it and send it\r\n     * through the channel once it is created.\r\n     *\r\n     * @param {Array<string>} ids - The user ids.\r\n     * @throws NetworkError or InvalidStateError or Error if the operation\r\n     * fails.\r\n     * @returns {void}\r\n     */\r\n    selectEndpoints(ids) {\r\n        this._selectedEndpoints = ids;\r\n\r\n        if (this._channel && this._channelOpen) {\r\n            this._channel.sendSelectedEndpointsMessage(ids);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Elects the participant with the given id to be the pinned participant in\r\n     * order to always receive video for this participant (even when last n is\r\n     * enabled).\r\n     * @param {stirng} id The user id.\r\n     * @throws NetworkError or InvalidStateError or Error if the operation\r\n     * fails.\r\n     */\r\n    pinEndpoint(id) {\r\n        // Cache the value if channel is missing, till we open it.\r\n        this._pinnedEndpoint = id;\r\n        if (this._channel && this._channelOpen) {\r\n            this._channel.sendPinnedEndpointMessage(id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param eventType\r\n     * @param listener\r\n     */\r\n    static addListener(eventType, listener) {\r\n        RTCUtils.addListener(eventType, listener);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param eventType\r\n     * @param listener\r\n     */\r\n    static removeListener(eventType, listener) {\r\n        RTCUtils.removeListener(eventType, listener);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param options\r\n     */\r\n    static init(options = {}) {\r\n        this.options = options;\r\n\r\n        return RTCUtils.init(this.options);\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n\r\n    /**\r\n     * Creates new <tt>TraceablePeerConnection</tt>\r\n     * @param {SignalingLayer} signaling The signaling layer that will\r\n     *      provide information about the media or participants which is not\r\n     *      carried over SDP.\r\n     * @param {object} iceConfig An object describing the ICE config like\r\n     *      defined in the WebRTC specification.\r\n     * @param {boolean} isP2P Indicates whether or not the new TPC will be used\r\n     *      in a peer to peer type of session.\r\n     * @param {object} options The config options.\r\n     * @param {boolean} options.disableSimulcast If set to 'true' will disable\r\n     *      the simulcast.\r\n     * @param {boolean} options.disableRtx If set to 'true' will disable the\r\n     *      RTX.\r\n     * @param {boolean} options.disableH264 If set to 'true' H264 will be\r\n     *      disabled by removing it from the SDP.\r\n     * @param {boolean} options.preferH264 If set to 'true' H264 will be\r\n     *      preferred over other video codecs.\r\n     * @param {boolean} options.startSilent If set to 'true' no audio will be sent or received.\r\n     * @return {TraceablePeerConnection}\r\n     */\r\n    createPeerConnection(signaling, iceConfig, isP2P, options) {\r\n        const pcConstraints = RTC.getPCConstraints(isP2P);\r\n\r\n        if (typeof options.abtestSuspendVideo !== 'undefined') {\r\n            RTCUtils.setSuspendVideo(pcConstraints, options.abtestSuspendVideo);\r\n\r\n            Statistics.analytics.addPermanentProperties(\r\n                { abtestSuspendVideo: options.abtestSuspendVideo });\r\n        }\r\n\r\n        // FIXME: We should rename iceConfig to pcConfig.\r\n        if (browser.supportsSdpSemantics()) {\r\n            iceConfig.sdpSemantics = 'plan-b';\r\n        }\r\n\r\n        peerConnectionIdCounter = safeCounterIncrement(peerConnectionIdCounter);\r\n\r\n        const newConnection\r\n            = new TraceablePeerConnection(\r\n                this,\r\n                peerConnectionIdCounter,\r\n                signaling,\r\n                iceConfig, pcConstraints,\r\n                isP2P, options);\r\n\r\n        this.peerConnections.set(newConnection.id, newConnection);\r\n\r\n        return newConnection;\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Removed given peer connection from this RTC module instance.\r\n     * @param {TraceablePeerConnection} traceablePeerConnection\r\n     * @return {boolean} <tt>true</tt> if the given peer connection was removed\r\n     * successfully or <tt>false</tt> if there was no peer connection mapped in\r\n     * this RTC instance.\r\n     */\r\n    _removePeerConnection(traceablePeerConnection) {\r\n        const id = traceablePeerConnection.id;\r\n\r\n        if (this.peerConnections.has(id)) {\r\n            // NOTE Remote tracks are not removed here.\r\n            this.peerConnections.delete(id);\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param track\r\n     */\r\n    addLocalTrack(track) {\r\n        if (!track) {\r\n            throw new Error('track must not be null nor undefined');\r\n        }\r\n\r\n        this.localTracks.push(track);\r\n\r\n        track.conference = this.conference;\r\n    }\r\n\r\n    /**\r\n     * Returns the current value for \"lastN\" - the amount of videos are going\r\n     * to be delivered. When set to -1 for unlimited or all available videos.\r\n     * @return {number}\r\n     */\r\n    getLastN() {\r\n        return this._lastN;\r\n    }\r\n\r\n    /**\r\n     * Get local video track.\r\n     * @returns {QHSenseLocalTrack|undefined}\r\n     */\r\n    getLocalVideoTrack() {\r\n        const localVideo = this.getLocalTracks(MediaType.VIDEO);\r\n\r\n\r\n        return localVideo.length ? localVideo[0] : undefined;\r\n    }\r\n\r\n    /**\r\n     * Get local audio track.\r\n     * @returns {QHSenseLocalTrack|undefined}\r\n     */\r\n    getLocalAudioTrack() {\r\n        const localAudio = this.getLocalTracks(MediaType.AUDIO);\r\n\r\n\r\n        return localAudio.length ? localAudio[0] : undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the local tracks of the given media type, or all local tracks if\r\n     * no specific type is given.\r\n     * @param {MediaType} [mediaType] Optional media type filter.\r\n     * (audio or video).\r\n     */\r\n    getLocalTracks(mediaType) {\r\n        let tracks = this.localTracks.slice();\r\n\r\n        if (mediaType !== undefined) {\r\n            tracks = tracks.filter(\r\n                track => track.getType() === mediaType);\r\n        }\r\n\r\n        return tracks;\r\n    }\r\n\r\n    /**\r\n     * Obtains all remote tracks currently known to this RTC module instance.\r\n     * @param {MediaType} [mediaType] The remote tracks will be filtered\r\n     *      by their media type if this argument is specified.\r\n     * @return {Array<QHSenseRemoteTrack>}\r\n     */\r\n    getRemoteTracks(mediaType) {\r\n        let remoteTracks = [];\r\n\r\n        for (const tpc of this.peerConnections.values()) {\r\n            const pcRemoteTracks = tpc.getRemoteTracks(undefined, mediaType);\r\n\r\n            if (pcRemoteTracks) {\r\n                remoteTracks = remoteTracks.concat(pcRemoteTracks);\r\n            }\r\n        }\r\n\r\n        return remoteTracks;\r\n    }\r\n\r\n    /**\r\n     * Set mute for all local audio streams attached to the conference.\r\n     * @param value The mute value.\r\n     * @returns {Promise}\r\n     */\r\n    setAudioMute(value) {\r\n        const mutePromises = [];\r\n\r\n        this.getLocalTracks(MediaType.AUDIO).forEach(audioTrack => {\r\n            // this is a Promise\r\n            mutePromises.push(value ? audioTrack.mute() : audioTrack.unmute());\r\n        });\r\n\r\n        // We return a Promise from all Promises so we can wait for their\r\n        // execution.\r\n        return Promise.all(mutePromises);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param track\r\n     */\r\n    removeLocalTrack(track) {\r\n        const pos = this.localTracks.indexOf(track);\r\n\r\n        if (pos === -1) {\r\n            return;\r\n        }\r\n\r\n        this.localTracks.splice(pos, 1);\r\n    }\r\n\r\n    /**\r\n     * Removes all QHSenseRemoteTracks associated with given MUC nickname\r\n     * (resource part of the JID). Returns array of removed tracks.\r\n     *\r\n     * @param {string} Owner The resource part of the MUC JID.\r\n     * @returns {QHSenseRemoteTrack[]}\r\n     */\r\n    removeRemoteTracks(owner) {\r\n        let removedTracks = [];\r\n\r\n        for (const tpc of this.peerConnections.values()) {\r\n            const pcRemovedTracks = tpc.removeRemoteTracks(owner);\r\n\r\n            removedTracks = removedTracks.concat(pcRemovedTracks);\r\n        }\r\n\r\n        logger.debug(\r\n            `Removed remote tracks for ${owner}`\r\n                + ` count: ${removedTracks.length}`);\r\n\r\n        return removedTracks;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    static getPCConstraints(isP2P) {\r\n        const pcConstraints\r\n            = isP2P ? RTCUtils.p2pPcConstraints : RTCUtils.pcConstraints;\r\n\r\n        if (!pcConstraints) {\r\n            return {};\r\n        }\r\n\r\n        return JSON.parse(JSON.stringify(pcConstraints));\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param elSelector\r\n     * @param stream\r\n     */\r\n    static attachMediaStream(elSelector, stream) {\r\n        return RTCUtils.attachMediaStream(elSelector, stream);\r\n    }\r\n\r\n    /**\r\n     * Returns the id of the given stream.\r\n     * @param {MediaStream} stream\r\n     */\r\n    static getStreamID(stream) {\r\n        return RTCUtils.getStreamID(stream);\r\n    }\r\n\r\n    /**\r\n     * Returns the id of the given track.\r\n     * @param {MediaStreamTrack} track\r\n     */\r\n    static getTrackID(track) {\r\n        return RTCUtils.getTrackID(track);\r\n    }\r\n\r\n    /**\r\n     * Returns true if retrieving the the list of input devices is supported\r\n     * and false if not.\r\n     */\r\n    static isDeviceListAvailable() {\r\n        return RTCUtils.isDeviceListAvailable();\r\n    }\r\n\r\n    /**\r\n     * Returns true if changing the input (camera / microphone) or output\r\n     * (audio) device is supported and false if not.\r\n     * @param {string} [deviceType] Type of device to change. Default is\r\n     *      undefined or 'input', 'output' - for audio output device change.\r\n     * @returns {boolean} true if available, false otherwise.\r\n     */\r\n    static isDeviceChangeAvailable(deviceType) {\r\n        return RTCUtils.isDeviceChangeAvailable(deviceType);\r\n    }\r\n\r\n    /**\r\n     * Returns whether the current execution environment supports WebRTC (for\r\n     * use within this library).\r\n     *\r\n     * @returns {boolean} {@code true} if WebRTC is supported in the current\r\n     * execution environment (for use within this library); {@code false},\r\n     * otherwise.\r\n     */\r\n    static isWebRtcSupported() {\r\n        return browser.isSupported();\r\n    }\r\n\r\n    /**\r\n     * Returns currently used audio output device id, '' stands for default\r\n     * device\r\n     * @returns {string}\r\n     */\r\n    static getAudioOutputDevice() {\r\n        return RTCUtils.getAudioOutputDevice();\r\n    }\r\n\r\n    /**\r\n     * Returns list of available media devices if its obtained, otherwise an\r\n     * empty array is returned/\r\n     * @returns {array} list of available media devices.\r\n     */\r\n    static getCurrentlyAvailableMediaDevices() {\r\n        return RTCUtils.getCurrentlyAvailableMediaDevices();\r\n    }\r\n\r\n    /**\r\n     * Returns event data for device to be reported to stats.\r\n     * @returns {MediaDeviceInfo} device.\r\n     */\r\n    static getEventDataForActiveDevice(device) {\r\n        return RTCUtils.getEventDataForActiveDevice(device);\r\n    }\r\n\r\n    /**\r\n     * Sets current audio output device.\r\n     * @param {string} deviceId Id of 'audiooutput' device from\r\n     *      navigator.mediaDevices.enumerateDevices().\r\n     * @returns {Promise} resolves when audio output is changed, is rejected\r\n     *      otherwise\r\n     */\r\n    static setAudioOutputDevice(deviceId) {\r\n        return RTCUtils.setAudioOutputDevice(deviceId);\r\n    }\r\n\r\n    /**\r\n     * Returns <tt>true<tt/> if given WebRTC MediaStream is considered a valid\r\n     * \"user\" stream which means that it's not a \"receive only\" stream nor a\r\n     * \"mixed\" JVB stream.\r\n     *\r\n     * Clients that implement Unified Plan, such as Firefox use recvonly\r\n     * \"streams/channels/tracks\" for receiving remote stream/tracks, as opposed\r\n     * to Plan B where there are only 3 channels: audio, video and data.\r\n     *\r\n     * @param {MediaStream} stream The WebRTC MediaStream instance.\r\n     * @returns {boolean}\r\n     */\r\n    static isUserStream(stream) {\r\n        return RTC.isUserStreamById(RTCUtils.getStreamID(stream));\r\n    }\r\n\r\n    /**\r\n     * Returns <tt>true<tt/> if a WebRTC MediaStream identified by given stream\r\n     * ID is considered a valid \"user\" stream which means that it's not a\r\n     * \"receive only\" stream nor a \"mixed\" JVB stream.\r\n     *\r\n     * Clients that implement Unified Plan, such as Firefox use recvonly\r\n     * \"streams/channels/tracks\" for receiving remote stream/tracks, as opposed\r\n     * to Plan B where there are only 3 channels: audio, video and data.\r\n     *\r\n     * @param {string} streamId The id of WebRTC MediaStream.\r\n     * @returns {boolean}\r\n     */\r\n    static isUserStreamById(streamId) {\r\n        return streamId && streamId !== 'mixedmslabel'\r\n            && streamId !== 'default';\r\n    }\r\n\r\n    /**\r\n     * Allows to receive list of available cameras/microphones.\r\n     * @param {function} callback Would receive array of devices as an\r\n     *      argument.\r\n     */\r\n    static enumerateDevices(callback) {\r\n        RTCUtils.enumerateDevices(callback);\r\n    }\r\n\r\n    /**\r\n     * A method to handle stopping of the stream.\r\n     * One point to handle the differences in various implementations.\r\n     * @param {MediaStream} mediaStream MediaStream object to stop.\r\n     */\r\n    static stopMediaStream(mediaStream) {\r\n        RTCUtils.stopMediaStream(mediaStream);\r\n    }\r\n\r\n    /**\r\n     * Returns whether the desktop sharing is enabled or not.\r\n     * @returns {boolean}\r\n     */\r\n    static isDesktopSharingEnabled() {\r\n        return RTCUtils.isDesktopSharingEnabled();\r\n    }\r\n\r\n    /**\r\n     * Closes the currently opened bridge channel.\r\n     */\r\n    closeBridgeChannel() {\r\n        if (this._channel) {\r\n            this._channel.close();\r\n            this._channelOpen = false;\r\n\r\n            this.removeListener(RTCEvents.LASTN_ENDPOINT_CHANGED,\r\n                this._lastNChangeListener);\r\n        }\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n    /**\r\n     *\r\n     * @param {TraceablePeerConnection} tpc\r\n     * @param {number} ssrc\r\n     * @param {number} audioLevel\r\n     * @param {boolean} isLocal\r\n     */\r\n    setAudioLevel(tpc, ssrc, audioLevel, isLocal) {\r\n        const track = tpc.getTrackBySSRC(ssrc);\r\n\r\n        if (!track) {\r\n            return;\r\n        } else if (!track.isAudioTrack()) {\r\n            logger.warn(`Received audio level for non-audio track: ${ssrc}`);\r\n\r\n            return;\r\n        } else if (track.isLocal() !== isLocal) {\r\n            logger.error(\r\n                `${track} was expected to ${isLocal ? 'be' : 'not be'} local`);\r\n        }\r\n\r\n        track.setAudioLevel(audioLevel, tpc);\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Sends message via the bridge channel.\r\n     * @param {string} to The id of the endpoint that should receive the\r\n     *      message. If \"\" the message will be sent to all participants.\r\n     * @param {object} payload The payload of the message.\r\n     * @throws NetworkError or InvalidStateError or Error if the operation\r\n     * fails or there is no data channel created.\r\n     */\r\n    sendChannelMessage(to, payload) {\r\n        if (this._channel) {\r\n            this._channel.sendMessage(to, payload);\r\n        } else {\r\n            throw new Error('Channel support is disabled!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Selects a new value for \"lastN\". The requested amount of videos are going\r\n     * to be delivered after the value is in effect. Set to -1 for unlimited or\r\n     * all available videos.\r\n     * @param {number} value the new value for lastN.\r\n     */\r\n    setLastN(value) {\r\n        if (this._lastN !== value) {\r\n            this._lastN = value;\r\n            if (this._channel && this._channelOpen) {\r\n                this._channel.sendSetLastNMessage(value);\r\n            }\r\n            this.eventEmitter.emit(RTCEvents.LASTN_VALUE_CHANGED, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates if the endpoint id is currently included in the last N.\r\n     * @param {string} id The endpoint id that we check for last N.\r\n     * @returns {boolean} true if the endpoint id is in the last N or if we\r\n     * don't have bridge channel support, otherwise we return false.\r\n     */\r\n    isInLastN(id) {\r\n        return !this._lastNEndpoints // lastNEndpoints not initialised yet.\r\n            || this._lastNEndpoints.indexOf(id) > -1;\r\n    }\r\n\r\n    /**\r\n     * Updates the target audio output device for all remote audio tracks.\r\n     *\r\n     * @param {string} deviceId - The device id of the audio ouput device to\r\n     * use for all remote tracks.\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _updateAudioOutputForAudioTracks(deviceId) {\r\n        const remoteAudioTracks = this.getRemoteTracks(MediaType.AUDIO);\r\n\r\n        for (const track of remoteAudioTracks) {\r\n            track.setAudioOutput(deviceId);\r\n        }\r\n    }\r\n}\r\n","/* global module */\r\n/**\r\n * Enumeration of the video types\r\n * @type {{CAMERA: string, DESKTOP: string}}\r\n */\r\nconst VideoType = {\r\n    /**\r\n     * The camera video type.\r\n     */\r\n    CAMERA: 'camera',\r\n\r\n    /**\r\n     * The desktop video type.\r\n     */\r\n    DESKTOP: 'desktop'\r\n};\r\n\r\nmodule.exports = VideoType;\r\n","import * as QHSenseTrackErrors from './QHSenseTrackErrors';\r\n\r\nconst TRACK_ERROR_TO_MESSAGE_MAP = {};\r\n\r\nTRACK_ERROR_TO_MESSAGE_MAP[QHSenseTrackErrors.UNSUPPORTED_RESOLUTION]\r\n    = 'Video resolution is not supported: ';\r\nTRACK_ERROR_TO_MESSAGE_MAP[QHSenseTrackErrors.CHROME_EXTENSION_INSTALLATION_ERROR]\r\n    = 'Failed to install Chrome extension';\r\nTRACK_ERROR_TO_MESSAGE_MAP[\r\n    QHSenseTrackErrors.CHROME_EXTENSION_USER_GESTURE_REQUIRED]\r\n    = 'Failed to install Chrome extension - installations can only be initiated'\r\n        + ' by a user gesture.';\r\nTRACK_ERROR_TO_MESSAGE_MAP[QHSenseTrackErrors.CHROME_EXTENSION_USER_CANCELED]\r\n    = 'User canceled Chrome\\'s screen sharing prompt';\r\nTRACK_ERROR_TO_MESSAGE_MAP[QHSenseTrackErrors.CHROME_EXTENSION_GENERIC_ERROR]\r\n    = 'Unknown error from Chrome extension';\r\nTRACK_ERROR_TO_MESSAGE_MAP[QHSenseTrackErrors.ELECTRON_DESKTOP_PICKER_ERROR]\r\n    = 'Unkown error from desktop picker';\r\nTRACK_ERROR_TO_MESSAGE_MAP[QHSenseTrackErrors.ELECTRON_DESKTOP_PICKER_NOT_FOUND]\r\n    = 'Failed to detect desktop picker';\r\nTRACK_ERROR_TO_MESSAGE_MAP[QHSenseTrackErrors.GENERAL]\r\n    = 'Generic getUserMedia error';\r\nTRACK_ERROR_TO_MESSAGE_MAP[QHSenseTrackErrors.PERMISSION_DENIED]\r\n    = 'User denied permission to use device(s): ';\r\nTRACK_ERROR_TO_MESSAGE_MAP[QHSenseTrackErrors.NOT_FOUND]\r\n    = 'Requested device(s) was/were not found: ';\r\nTRACK_ERROR_TO_MESSAGE_MAP[QHSenseTrackErrors.CONSTRAINT_FAILED]\r\n    = 'Constraint could not be satisfied: ';\r\nTRACK_ERROR_TO_MESSAGE_MAP[QHSenseTrackErrors.TRACK_IS_DISPOSED]\r\n    = 'Track has been already disposed';\r\nTRACK_ERROR_TO_MESSAGE_MAP[QHSenseTrackErrors.TRACK_NO_STREAM_FOUND]\r\n    = 'Track does not have an associated Media Stream';\r\n\r\n// FIXME: Using prototype inheritance because otherwise instanceof is not\r\n// working properly (see https://github.com/babel/babel/issues/3083)\r\n\r\n/**\r\n *\r\n * Represents an error that occurred to a QHSenseTrack. Can represent various\r\n * types of errors. For error descriptions (@see QHSenseTrackErrors).\r\n *\r\n * @extends Error\r\n *\r\n *\r\n * @constructor\r\n * @param {Object|string} error - error object or error name\r\n * @param {Object|string} (options) - getUserMedia constraints object or\r\n * error message\r\n * @param {('audio'|'video'|'desktop'|'screen'|'audiooutput')[]} (devices) -\r\n * list of getUserMedia requested devices\r\n */\r\nfunction QHSenseTrackError(error, options, devices) {\r\n    if (typeof error === 'object' && typeof error.name !== 'undefined') {\r\n        /**\r\n         * Additional information about original getUserMedia error\r\n         * and constraints.\r\n         * @type {{\r\n         *     error: Object,\r\n         *     constraints: Object,\r\n         *     devices: Array.<'audio'|'video'|'desktop'|'screen'>\r\n         * }}\r\n         */\r\n        this.gum = {\r\n            error,\r\n            constraints: options,\r\n            devices: devices && Array.isArray(devices)\r\n                ? devices.slice(0)\r\n                : undefined\r\n        };\r\n\r\n        switch (error.name) {\r\n        case 'NotAllowedError':\r\n        case 'PermissionDeniedError':\r\n        case 'SecurityError':\r\n            this.name = QHSenseTrackErrors.PERMISSION_DENIED;\r\n            this.message\r\n                = TRACK_ERROR_TO_MESSAGE_MAP[this.name]\r\n                    + (this.gum.devices || []).join(', ');\r\n            break;\r\n        case 'DevicesNotFoundError':\r\n        case 'NotFoundError':\r\n            this.name = QHSenseTrackErrors.NOT_FOUND;\r\n            this.message\r\n                = TRACK_ERROR_TO_MESSAGE_MAP[this.name]\r\n                    + (this.gum.devices || []).join(', ');\r\n            break;\r\n        case 'ConstraintNotSatisfiedError':\r\n        case 'OverconstrainedError': {\r\n            const constraintName = error.constraintName || error.constraint;\r\n\r\n            // we treat deviceId as unsupported resolution, as we want to\r\n            // retry and finally if everything fails to remove deviceId from\r\n            // mandatory constraints\r\n            if (options\r\n                    && options.video\r\n                    && (!devices || devices.indexOf('video') > -1)\r\n                    && (constraintName === 'minWidth'\r\n                        || constraintName === 'maxWidth'\r\n                        || constraintName === 'minHeight'\r\n                        || constraintName === 'maxHeight'\r\n                        || constraintName === 'width'\r\n                        || constraintName === 'height'\r\n                        || constraintName === 'deviceId')) {\r\n                this.name = QHSenseTrackErrors.UNSUPPORTED_RESOLUTION;\r\n                this.message\r\n                    = TRACK_ERROR_TO_MESSAGE_MAP[this.name]\r\n                        + getResolutionFromFailedConstraint(\r\n                            constraintName,\r\n                            options);\r\n            } else {\r\n                this.name = QHSenseTrackErrors.CONSTRAINT_FAILED;\r\n                this.message\r\n                    = TRACK_ERROR_TO_MESSAGE_MAP[this.name]\r\n                        + error.constraintName;\r\n            }\r\n            break;\r\n        }\r\n\r\n        default:\r\n            this.name = QHSenseTrackErrors.GENERAL;\r\n            this.message\r\n                = error.message || TRACK_ERROR_TO_MESSAGE_MAP[this.name];\r\n            break;\r\n        }\r\n    } else if (typeof error === 'string') {\r\n        if (TRACK_ERROR_TO_MESSAGE_MAP[error]) {\r\n            this.name = error;\r\n            this.message = options || TRACK_ERROR_TO_MESSAGE_MAP[error];\r\n        } else {\r\n            // this is some generic error that do not fit any of our\r\n            // pre-defined errors, so don't give it any specific name, just\r\n            // store message\r\n            this.message = error;\r\n        }\r\n    } else {\r\n        throw new Error('Invalid arguments');\r\n    }\r\n\r\n    this.stack = error.stack || (new Error()).stack;\r\n}\r\n\r\nQHSenseTrackError.prototype = Object.create(Error.prototype);\r\nQHSenseTrackError.prototype.constructor = QHSenseTrackError;\r\n\r\n/**\r\n * Gets failed resolution constraint from corresponding object.\r\n * @param {string} failedConstraintName\r\n * @param {Object} constraints\r\n * @returns {string|number}\r\n */\r\nfunction getResolutionFromFailedConstraint(failedConstraintName, constraints) {\r\n    if (constraints && constraints.video && constraints.video.mandatory) {\r\n        switch (failedConstraintName) {\r\n        case 'width':\r\n            return constraints.video.mandatory.minWidth;\r\n        case 'height':\r\n            return constraints.video.mandatory.minHeight;\r\n        default:\r\n            return constraints.video.mandatory[failedConstraintName] || '';\r\n        }\r\n    }\r\n\r\n    return '';\r\n}\r\n\r\nexport default QHSenseTrackError;\r\n","/**\r\n * The media track was removed to the conference.\r\n */\r\nexport const LOCAL_TRACK_STOPPED = 'track.stopped';\r\n\r\n/**\r\n * Audio levels of a this track was changed.\r\n * The first argument is a number with audio level value in range [0, 1].\r\n * The second argument is a <tt>TraceablePeerConnection</tt> which is the peer\r\n * connection which measured the audio level (one audio track can be added\r\n * to multiple peer connection at the same time). This argument is optional for\r\n * local tracks for which we can measure audio level without the peer\r\n * connection (the value will be <tt>undefined</tt>).\r\n *\r\n * NOTE The second argument should be treated as library internal and can be\r\n * removed at any time.\r\n */\r\nexport const TRACK_AUDIO_LEVEL_CHANGED = 'track.audioLevelsChanged';\r\n\r\n/**\r\n * The audio output of the track was changed.\r\n */\r\nexport const TRACK_AUDIO_OUTPUT_CHANGED = 'track.audioOutputChanged';\r\n\r\n/**\r\n * A media track mute status was changed.\r\n */\r\nexport const TRACK_MUTE_CHANGED = 'track.trackMuteChanged';\r\n\r\n/**\r\n * The video type(\"camera\" or \"desktop\") of the track was changed.\r\n */\r\nexport const TRACK_VIDEOTYPE_CHANGED = 'track.videoTypeChanged';\r\n\r\n/**\r\n * Indicates that the track is not receiving any data even though we expect it\r\n * to receive data (i.e. the stream is not stopped).\r\n */\r\nexport const NO_DATA_FROM_SOURCE = 'track.no_data_from_source';\r\n","/**\r\n * The errors for the conference.\r\n */\r\n\r\n/**\r\n * Indicates that client must be authenticated to create the conference.\r\n */\r\nexport const AUTHENTICATION_REQUIRED = 'conference.authenticationRequired';\r\n\r\n/**\r\n * Indicates that chat error occurred.\r\n */\r\nexport const CHAT_ERROR = 'conference.chatError';\r\n\r\n/**\r\n * Indicates that conference has been destroyed.\r\n */\r\nexport const CONFERENCE_DESTROYED = 'conference.destroyed';\r\n\r\n/**\r\n * Indicates that max users limit has been reached.\r\n */\r\nexport const CONFERENCE_MAX_USERS = 'conference.max_users';\r\n\r\n/**\r\n * Indicates that a connection error occurred when trying to join a conference.\r\n */\r\nexport const CONNECTION_ERROR = 'conference.connectionError';\r\n\r\n/**\r\n * Indicates that a connection error is due to not allowed,\r\n * occurred when trying to join a conference.\r\n */\r\nexport const NOT_ALLOWED_ERROR = 'conference.connectionError.notAllowed';\r\n\r\n/**\r\n * Indicates that focus error happened.\r\n */\r\nexport const FOCUS_DISCONNECTED = 'conference.focusDisconnected';\r\n\r\n/**\r\n * Indicates that focus left the conference.\r\n */\r\nexport const FOCUS_LEFT = 'conference.focusLeft';\r\n\r\n/**\r\n * Indicates that graceful shutdown happened.\r\n */\r\nexport const GRACEFUL_SHUTDOWN = 'conference.gracefulShutdown';\r\n\r\n/**\r\n * Indicates that the versions of the server side components are incompatible\r\n * with the client side.\r\n */\r\nexport const INCOMPATIBLE_SERVER_VERSIONS\r\n    = 'conference.incompatible_server_versions';\r\n\r\n/**\r\n * Indicates that offer/answer had failed.\r\n */\r\nexport const OFFER_ANSWER_FAILED = 'conference.offerAnswerFailed';\r\n\r\n/**\r\n * Indicates that password cannot be set for this conference.\r\n */\r\nexport const PASSWORD_NOT_SUPPORTED = 'conference.passwordNotSupported';\r\n\r\n/**\r\n * Indicates that a password is required in order to join the conference.\r\n */\r\nexport const PASSWORD_REQUIRED = 'conference.passwordRequired';\r\n\r\n/**\r\n * Indicates that reservation system returned error.\r\n */\r\nexport const RESERVATION_ERROR = 'conference.reservationError';\r\n\r\n/**\r\n * Indicates that the conference setup failed.\r\n */\r\nexport const SETUP_FAILED = 'conference.setup_failed';\r\n\r\n/**\r\n * Indicates that there is no available videobridge.\r\n */\r\nexport const VIDEOBRIDGE_NOT_AVAILABLE = 'conference.videobridgeNotAvailable';\r\n","/* global $ */\r\n\r\nimport SDPUtil from './SDPUtil';\r\n\r\n/**\r\n *\r\n * @param sdp\r\n */\r\nexport default function SDP(sdp) {\r\n    const media = sdp.split('\\r\\nm=');\r\n\r\n    for (let i = 1, length = media.length; i < length; i++) {\r\n        let mediaI = `m=${media[i]}`;\r\n\r\n        if (i !== length - 1) {\r\n            mediaI += '\\r\\n';\r\n        }\r\n        media[i] = mediaI;\r\n    }\r\n    const session = `${media.shift()}\\r\\n`;\r\n\r\n    this.media = media;\r\n    this.raw = session + media.join('');\r\n    this.session = session;\r\n}\r\n\r\n/**\r\n * A flag will make {@link transportToJingle} and {@link jingle2media} replace\r\n * ICE candidates IPs with invalid value of '1.1.1.1' which will cause ICE\r\n * failure. The flag is used in the automated testing.\r\n * @type {boolean}\r\n */\r\nSDP.prototype.failICE = false;\r\n\r\n/**\r\n * Whether or not to remove TCP ice candidates when translating from/to jingle.\r\n * @type {boolean}\r\n */\r\nSDP.prototype.removeTcpCandidates = false;\r\n\r\n/**\r\n * Whether or not to remove UDP ice candidates when translating from/to jingle.\r\n * @type {boolean}\r\n */\r\nSDP.prototype.removeUdpCandidates = false;\r\n\r\n/**\r\n * Returns map of MediaChannel mapped per channel idx.\r\n */\r\nSDP.prototype.getMediaSsrcMap = function() {\r\n    const self = this;\r\n    const mediaSSRCs = {};\r\n    let tmp;\r\n\r\n    for (let mediaindex = 0; mediaindex < self.media.length; mediaindex++) {\r\n        tmp = SDPUtil.findLines(self.media[mediaindex], 'a=ssrc:');\r\n        const mid\r\n            = SDPUtil.parseMID(\r\n                SDPUtil.findLine(self.media[mediaindex], 'a=mid:'));\r\n        const media = {\r\n            mediaindex,\r\n            mid,\r\n            ssrcs: {},\r\n            ssrcGroups: []\r\n        };\r\n\r\n        mediaSSRCs[mediaindex] = media;\r\n        tmp.forEach(line => {\r\n            const linessrc = line.substring(7).split(' ')[0];\r\n\r\n            // allocate new ChannelSsrc\r\n\r\n            if (!media.ssrcs[linessrc]) {\r\n                media.ssrcs[linessrc] = {\r\n                    ssrc: linessrc,\r\n                    lines: []\r\n                };\r\n            }\r\n            media.ssrcs[linessrc].lines.push(line);\r\n        });\r\n        tmp = SDPUtil.findLines(self.media[mediaindex], 'a=ssrc-group:');\r\n        tmp.forEach(line => {\r\n            const idx = line.indexOf(' ');\r\n            const semantics = line.substr(0, idx).substr(13);\r\n            const ssrcs = line.substr(14 + semantics.length).split(' ');\r\n\r\n            if (ssrcs.length) {\r\n                media.ssrcGroups.push({\r\n                    semantics,\r\n                    ssrcs\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    return mediaSSRCs;\r\n};\r\n\r\n/**\r\n * Returns <tt>true</tt> if this SDP contains given SSRC.\r\n * @param ssrc the ssrc to check.\r\n * @returns {boolean} <tt>true</tt> if this SDP contains given SSRC.\r\n */\r\nSDP.prototype.containsSSRC = function(ssrc) {\r\n    // FIXME this code is really strange - improve it if you can\r\n    const medias = this.getMediaSsrcMap();\r\n    let result = false;\r\n\r\n    Object.keys(medias).forEach(mediaindex => {\r\n        if (result) {\r\n            return;\r\n        }\r\n        if (medias[mediaindex].ssrcs[ssrc]) {\r\n            result = true;\r\n        }\r\n    });\r\n\r\n    return result;\r\n};\r\n\r\n// remove iSAC and CN from SDP\r\nSDP.prototype.mangle = function() {\r\n    let i, j, lines, mline, newdesc, rtpmap;\r\n\r\n    for (i = 0; i < this.media.length; i++) {\r\n        lines = this.media[i].split('\\r\\n');\r\n        lines.pop(); // remove empty last element\r\n        mline = SDPUtil.parseMLine(lines.shift());\r\n        if (mline.media !== 'audio') {\r\n            continue; // eslint-disable-line no-continue\r\n        }\r\n        newdesc = '';\r\n        mline.fmt.length = 0;\r\n        for (j = 0; j < lines.length; j++) {\r\n            if (lines[j].substr(0, 9) === 'a=rtpmap:') {\r\n                rtpmap = SDPUtil.parseRTPMap(lines[j]);\r\n                if (rtpmap.name === 'CN' || rtpmap.name === 'ISAC') {\r\n                    continue; // eslint-disable-line no-continue\r\n                }\r\n                mline.fmt.push(rtpmap.id);\r\n            }\r\n            newdesc += `${lines[j]}\\r\\n`;\r\n        }\r\n        this.media[i] = `${SDPUtil.buildMLine(mline)}\\r\\n${newdesc}`;\r\n    }\r\n    this.raw = this.session + this.media.join('');\r\n};\r\n\r\n// remove lines matching prefix from session section\r\nSDP.prototype.removeSessionLines = function(prefix) {\r\n    const self = this;\r\n    const lines = SDPUtil.findLines(this.session, prefix);\r\n\r\n    lines.forEach(line => {\r\n        self.session = self.session.replace(`${line}\\r\\n`, '');\r\n    });\r\n    this.raw = this.session + this.media.join('');\r\n\r\n    return lines;\r\n};\r\n\r\n// remove lines matching prefix from a media section specified by mediaindex\r\n// TODO: non-numeric mediaindex could match mid\r\nSDP.prototype.removeMediaLines = function(mediaindex, prefix) {\r\n    const self = this;\r\n    const lines = SDPUtil.findLines(this.media[mediaindex], prefix);\r\n\r\n    lines.forEach(line => {\r\n        self.media[mediaindex]\r\n            = self.media[mediaindex].replace(`${line}\\r\\n`, '');\r\n    });\r\n    this.raw = this.session + this.media.join('');\r\n\r\n    return lines;\r\n};\r\n\r\n// add content's to a jingle element\r\nSDP.prototype.toJingle = function(elem, thecreator) {\r\n    let i, j, k, lines, mline, rtpmap, ssrc, tmp;\r\n\r\n    // new bundle plan\r\n\r\n    lines = SDPUtil.findLines(this.session, 'a=group:');\r\n    if (lines.length) {\r\n        for (i = 0; i < lines.length; i++) {\r\n            tmp = lines[i].split(' ');\r\n            const semantics = tmp.shift().substr(8);\r\n\r\n            elem.c('group', { xmlns: 'urn:xmpp:jingle:apps:grouping:0',\r\n                semantics });\r\n            for (j = 0; j < tmp.length; j++) {\r\n                elem.c('content', { name: tmp[j] }).up();\r\n            }\r\n            elem.up();\r\n        }\r\n    }\r\n    for (i = 0; i < this.media.length; i++) {\r\n        mline = SDPUtil.parseMLine(this.media[i].split('\\r\\n')[0]);\r\n        if (!(mline.media === 'audio'\r\n              || mline.media === 'video'\r\n              || mline.media === 'application')) {\r\n            continue; // eslint-disable-line no-continue\r\n        }\r\n        const assrcline = SDPUtil.findLine(this.media[i], 'a=ssrc:');\r\n\r\n        if (assrcline) {\r\n            ssrc = assrcline.substring(7).split(' ')[0]; // take the first\r\n        } else {\r\n            ssrc = false;\r\n        }\r\n\r\n        elem.c('content', { creator: thecreator,\r\n            name: mline.media });\r\n        const amidline = SDPUtil.findLine(this.media[i], 'a=mid:');\r\n\r\n        if (amidline) {\r\n            // prefer identifier from a=mid if present\r\n            const mid = SDPUtil.parseMID(amidline);\r\n\r\n            elem.attrs({ name: mid });\r\n        }\r\n\r\n        if (SDPUtil.findLine(this.media[i], 'a=rtpmap:').length) {\r\n            elem.c('description',\r\n                { xmlns: 'urn:xmpp:jingle:apps:rtp:1',\r\n                    media: mline.media });\r\n            if (ssrc) {\r\n                elem.attrs({ ssrc });\r\n            }\r\n            for (j = 0; j < mline.fmt.length; j++) {\r\n                rtpmap\r\n                    = SDPUtil.findLine(\r\n                        this.media[i],\r\n                        `a=rtpmap:${mline.fmt[j]}`);\r\n                elem.c('payload-type', SDPUtil.parseRTPMap(rtpmap));\r\n\r\n                // put any 'a=fmtp:' + mline.fmt[j] lines into <param name=foo\r\n                // value=bar/>\r\n                const afmtpline\r\n                    = SDPUtil.findLine(\r\n                        this.media[i],\r\n                        `a=fmtp:${mline.fmt[j]}`);\r\n\r\n                if (afmtpline) {\r\n                    tmp = SDPUtil.parseFmtp(afmtpline);\r\n\r\n                    // eslint-disable-next-line max-depth\r\n                    for (k = 0; k < tmp.length; k++) {\r\n                        elem.c('parameter', tmp[k]).up();\r\n                    }\r\n                }\r\n\r\n                // XEP-0293 -- map a=rtcp-fb\r\n                this.rtcpFbToJingle(i, elem, mline.fmt[j]);\r\n\r\n                elem.up();\r\n            }\r\n            const crypto\r\n                = SDPUtil.findLines(this.media[i], 'a=crypto:', this.session);\r\n\r\n            if (crypto.length) {\r\n                elem.c('encryption', { required: 1 });\r\n                crypto.forEach(\r\n                    line => elem.c('crypto', SDPUtil.parseCrypto(line)).up());\r\n                elem.up(); // end of encryption\r\n            }\r\n\r\n            if (ssrc) {\r\n                const ssrcMap = SDPUtil.parseSSRC(this.media[i]);\r\n\r\n                for (const [ availableSsrc, ssrcParameters ] of ssrcMap) {\r\n                    elem.c('source', {\r\n                        ssrc: availableSsrc,\r\n                        xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'\r\n                    });\r\n\r\n                    ssrcParameters.forEach(ssrcSdpLine => {\r\n                        // get everything after first space\r\n                        const idx = ssrcSdpLine.indexOf(' ');\r\n                        const kv = ssrcSdpLine.substr(idx + 1);\r\n\r\n                        elem.c('parameter');\r\n                        if (kv.indexOf(':') === -1) {\r\n                            elem.attrs({ name: kv });\r\n                        } else {\r\n                            const name = kv.split(':', 2)[0];\r\n\r\n                            elem.attrs({ name });\r\n\r\n                            let v = kv.split(':', 2)[1];\r\n\r\n                            v = SDPUtil.filterSpecialChars(v);\r\n                            elem.attrs({ value: v });\r\n                        }\r\n                        elem.up();\r\n                    });\r\n\r\n                    elem.up();\r\n                }\r\n\r\n                // XEP-0339 handle ssrc-group attributes\r\n                const ssrcGroupLines\r\n                    = SDPUtil.findLines(this.media[i], 'a=ssrc-group:');\r\n\r\n                ssrcGroupLines.forEach(line => {\r\n                    const idx = line.indexOf(' ');\r\n                    const semantics = line.substr(0, idx).substr(13);\r\n                    const ssrcs = line.substr(14 + semantics.length).split(' ');\r\n\r\n                    if (ssrcs.length) {\r\n                        elem.c('ssrc-group', { semantics,\r\n                            xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\r\n                        ssrcs.forEach(s => elem.c('source', { ssrc: s }).up());\r\n                        elem.up();\r\n                    }\r\n                });\r\n            }\r\n\r\n            const ridLines = SDPUtil.findLines(this.media[i], 'a=rid');\r\n\r\n            if (ridLines.length) {\r\n                // Map a line which looks like \"a=rid:2 send\" to just\r\n                // the rid (\"2\")\r\n                const rids = ridLines\r\n                    .map(ridLine => ridLine.split(':')[1])\r\n                    .map(ridInfo => ridInfo.split(' ')[0]);\r\n\r\n                rids.forEach(rid => {\r\n                    elem.c('source', {\r\n                        rid,\r\n                        xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'\r\n                    });\r\n                    elem.up();\r\n                });\r\n                const unifiedSimulcast\r\n                    = SDPUtil.findLine(this.media[i], 'a=simulcast');\r\n\r\n                if (unifiedSimulcast) {\r\n                    elem.c('rid-group', {\r\n                        semantics: 'SIM',\r\n                        xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'\r\n                    });\r\n                    rids.forEach(rid => {\r\n                        elem.c('source', { rid }).up();\r\n                    });\r\n                    elem.up();\r\n                }\r\n            }\r\n\r\n            if (SDPUtil.findLine(this.media[i], 'a=rtcp-mux')) {\r\n                elem.c('rtcp-mux').up();\r\n            }\r\n\r\n            // XEP-0293 -- map a=rtcp-fb:*\r\n            this.rtcpFbToJingle(i, elem, '*');\r\n\r\n            // XEP-0294\r\n            lines = SDPUtil.findLines(this.media[i], 'a=extmap:');\r\n            if (lines.length) {\r\n                for (j = 0; j < lines.length; j++) {\r\n                    tmp = SDPUtil.parseExtmap(lines[j]);\r\n                    elem.c('rtp-hdrext', {\r\n                        xmlns: 'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0',\r\n                        uri: tmp.uri,\r\n                        id: tmp.value\r\n                    });\r\n\r\n                    // eslint-disable-next-line max-depth\r\n                    if (tmp.hasOwnProperty('direction')) {\r\n\r\n                        // eslint-disable-next-line max-depth\r\n                        switch (tmp.direction) {\r\n                        case 'sendonly':\r\n                            elem.attrs({ senders: 'responder' });\r\n                            break;\r\n                        case 'recvonly':\r\n                            elem.attrs({ senders: 'initiator' });\r\n                            break;\r\n                        case 'sendrecv':\r\n                            elem.attrs({ senders: 'both' });\r\n                            break;\r\n                        case 'inactive':\r\n                            elem.attrs({ senders: 'none' });\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    // TODO: handle params\r\n                    elem.up();\r\n                }\r\n            }\r\n            elem.up(); // end of description\r\n        }\r\n\r\n        // map ice-ufrag/pwd, dtls fingerprint, candidates\r\n        this.transportToJingle(i, elem);\r\n\r\n        const m = this.media[i];\r\n\r\n        if (SDPUtil.findLine(m, 'a=sendrecv', this.session)) {\r\n            elem.attrs({ senders: 'both' });\r\n        } else if (SDPUtil.findLine(m, 'a=sendonly', this.session)) {\r\n            elem.attrs({ senders: 'initiator' });\r\n        } else if (SDPUtil.findLine(m, 'a=recvonly', this.session)) {\r\n            elem.attrs({ senders: 'responder' });\r\n        } else if (SDPUtil.findLine(m, 'a=inactive', this.session)) {\r\n            elem.attrs({ senders: 'none' });\r\n        }\r\n        if (mline.port === '0') {\r\n            // estos hack to reject an m-line\r\n            elem.attrs({ senders: 'rejected' });\r\n        }\r\n        elem.up(); // end of content\r\n    }\r\n    elem.up();\r\n\r\n    return elem;\r\n};\r\n\r\nSDP.prototype.transportToJingle = function(mediaindex, elem) {\r\n    let tmp;\r\n    const self = this;\r\n\r\n    elem.c('transport');\r\n\r\n    // XEP-0343 DTLS/SCTP\r\n    const sctpmap\r\n        = SDPUtil.findLine(this.media[mediaindex], 'a=sctpmap:', self.session);\r\n\r\n    if (sctpmap) {\r\n        const sctpAttrs = SDPUtil.parseSCTPMap(sctpmap);\r\n\r\n        elem.c('sctpmap', {\r\n            xmlns: 'urn:xmpp:jingle:transports:dtls-sctp:1',\r\n            number: sctpAttrs[0], /* SCTP port */\r\n            protocol: sctpAttrs[1] /* protocol */\r\n        });\r\n\r\n        // Optional stream count attribute\r\n        if (sctpAttrs.length > 2) {\r\n            elem.attrs({ streams: sctpAttrs[2] });\r\n        }\r\n        elem.up();\r\n    }\r\n\r\n    // XEP-0320\r\n    const fingerprints\r\n        = SDPUtil.findLines(\r\n            this.media[mediaindex],\r\n            'a=fingerprint:',\r\n            this.session);\r\n\r\n    fingerprints.forEach(line => {\r\n        tmp = SDPUtil.parseFingerprint(line);\r\n        tmp.xmlns = 'urn:xmpp:jingle:apps:dtls:0';\r\n        elem.c('fingerprint').t(tmp.fingerprint);\r\n        delete tmp.fingerprint;\r\n\r\n        // eslint-disable-next-line no-param-reassign\r\n        line\r\n            = SDPUtil.findLine(\r\n                self.media[mediaindex],\r\n                'a=setup:',\r\n                self.session);\r\n        if (line) {\r\n            tmp.setup = line.substr(8);\r\n        }\r\n        elem.attrs(tmp);\r\n        elem.up(); // end of fingerprint\r\n    });\r\n    tmp = SDPUtil.iceparams(this.media[mediaindex], this.session);\r\n    if (tmp) {\r\n        tmp.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';\r\n        elem.attrs(tmp);\r\n\r\n        // XEP-0176\r\n        const lines\r\n            = SDPUtil.findLines(\r\n                this.media[mediaindex],\r\n                'a=candidate:',\r\n                this.session);\r\n\r\n        if (lines.length) { // add any a=candidate lines\r\n            lines.forEach(line => {\r\n                const candidate = SDPUtil.candidateToJingle(line);\r\n\r\n                if (self.failICE) {\r\n                    candidate.ip = '1.1.1.1';\r\n                }\r\n                const protocol\r\n                    = candidate && typeof candidate.protocol === 'string'\r\n                        ? candidate.protocol.toLowerCase()\r\n                        : '';\r\n\r\n                if ((self.removeTcpCandidates\r\n                        && (protocol === 'tcp' || protocol === 'ssltcp'))\r\n                    || (self.removeUdpCandidates && protocol === 'udp')) {\r\n                    return;\r\n                }\r\n                elem.c('candidate', candidate).up();\r\n            });\r\n        }\r\n    }\r\n    elem.up(); // end of transport\r\n};\r\n\r\n// XEP-0293\r\nSDP.prototype.rtcpFbToJingle = function(mediaindex, elem, payloadtype) {\r\n    const lines\r\n        = SDPUtil.findLines(\r\n            this.media[mediaindex],\r\n            `a=rtcp-fb:${payloadtype}`);\r\n\r\n    lines.forEach(line => {\r\n        const tmp = SDPUtil.parseRTCPFB(line);\r\n\r\n        if (tmp.type === 'trr-int') {\r\n            elem.c('rtcp-fb-trr-int', {\r\n                xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0',\r\n                value: tmp.params[0]\r\n            });\r\n            elem.up();\r\n        } else {\r\n            elem.c('rtcp-fb', {\r\n                xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0',\r\n                type: tmp.type\r\n            });\r\n            if (tmp.params.length > 0) {\r\n                elem.attrs({ 'subtype': tmp.params[0] });\r\n            }\r\n            elem.up();\r\n        }\r\n    });\r\n};\r\n\r\nSDP.prototype.rtcpFbFromJingle = function(elem, payloadtype) { // XEP-0293\r\n    let media = '';\r\n    let tmp\r\n        = elem.find(\r\n            '>rtcp-fb-trr-int[xmlns=\"urn:xmpp:jingle:apps:rtp:rtcp-fb:0\"]');\r\n\r\n    if (tmp.length) {\r\n        media += 'a=rtcp-fb:* trr-int ';\r\n        if (tmp.attr('value')) {\r\n            media += tmp.attr('value');\r\n        } else {\r\n            media += '0';\r\n        }\r\n        media += '\\r\\n';\r\n    }\r\n    tmp = elem.find('>rtcp-fb[xmlns=\"urn:xmpp:jingle:apps:rtp:rtcp-fb:0\"]');\r\n    tmp.each(function() {\r\n        /* eslint-disable no-invalid-this */\r\n        media += `a=rtcp-fb:${payloadtype} ${$(this).attr('type')}`;\r\n        if ($(this).attr('subtype')) {\r\n            media += ` ${$(this).attr('subtype')}`;\r\n        }\r\n        media += '\\r\\n';\r\n\r\n        /* eslint-enable no-invalid-this */\r\n    });\r\n\r\n    return media;\r\n};\r\n\r\n// construct an SDP from a jingle stanza\r\nSDP.prototype.fromJingle = function(jingle) {\r\n    const self = this;\r\n\r\n    this.raw = 'v=0\\r\\n'\r\n        + 'o=- 1923518516 2 IN IP4 0.0.0.0\\r\\n'// FIXME\r\n        + 's=-\\r\\n'\r\n        + 't=0 0\\r\\n';\r\n\r\n    // http://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-04\r\n    // #section-8\r\n    const groups\r\n        = $(jingle).find('>group[xmlns=\"urn:xmpp:jingle:apps:grouping:0\"]');\r\n\r\n    if (groups.length) {\r\n        groups.each((idx, group) => {\r\n            const contents\r\n                = $(group)\r\n                    .find('>content')\r\n                    .map((_, content) => content.getAttribute('name'))\r\n                    .get();\r\n\r\n            if (contents.length > 0) {\r\n                self.raw\r\n                    += `a=group:${\r\n                        group.getAttribute('semantics')\r\n                            || group.getAttribute('type')} ${\r\n                        contents.join(' ')}\\r\\n`;\r\n            }\r\n        });\r\n    }\r\n\r\n    this.session = this.raw;\r\n    jingle.find('>content').each(function() {\r\n        // eslint-disable-next-line no-invalid-this\r\n        const m = self.jingle2media($(this));\r\n\r\n        self.media.push(m);\r\n    });\r\n\r\n    // reconstruct msid-semantic -- apparently not necessary\r\n    /*\r\n     var msid = SDPUtil.parseSSRC(this.raw);\r\n     if (msid.hasOwnProperty('mslabel')) {\r\n     this.session += \"a=msid-semantic: WMS \" + msid.mslabel + \"\\r\\n\";\r\n     }\r\n     */\r\n\r\n    this.raw = this.session + this.media.join('');\r\n};\r\n\r\n// translate a jingle content element into an an SDP media part\r\nSDP.prototype.jingle2media = function(content) {\r\n    const desc = content.find('description');\r\n    let media = '';\r\n    const self = this;\r\n    const sctp = content.find(\r\n        '>transport>sctpmap[xmlns=\"urn:xmpp:jingle:transports:dtls-sctp:1\"]');\r\n\r\n    let tmp = { media: desc.attr('media') };\r\n\r\n    tmp.port = '1';\r\n    if (content.attr('senders') === 'rejected') {\r\n        // estos hack to reject an m-line.\r\n        tmp.port = '0';\r\n    }\r\n    if (content.find('>transport>fingerprint').length\r\n            || desc.find('encryption').length) {\r\n        tmp.proto = sctp.length ? 'DTLS/SCTP' : 'RTP/SAVPF';\r\n    } else {\r\n        tmp.proto = 'RTP/AVPF';\r\n    }\r\n    if (sctp.length) {\r\n        media += `m=application ${tmp.port} DTLS/SCTP ${\r\n            sctp.attr('number')}\\r\\n`;\r\n        media += `a=sctpmap:${sctp.attr('number')} ${sctp.attr('protocol')}`;\r\n\r\n        const streamCount = sctp.attr('streams');\r\n\r\n        if (streamCount) {\r\n            media += ` ${streamCount}\\r\\n`;\r\n        } else {\r\n            media += '\\r\\n';\r\n        }\r\n    } else {\r\n        tmp.fmt\r\n            = desc\r\n                .find('payload-type')\r\n                .map(function() {\r\n                    // eslint-disable-next-line no-invalid-this\r\n                    return this.getAttribute('id');\r\n                })\r\n                .get();\r\n        media += `${SDPUtil.buildMLine(tmp)}\\r\\n`;\r\n    }\r\n\r\n    media += 'c=IN IP4 0.0.0.0\\r\\n';\r\n    if (!sctp.length) {\r\n        media += 'a=rtcp:1 IN IP4 0.0.0.0\\r\\n';\r\n    }\r\n    tmp\r\n        = content.find(\r\n            '>transport[xmlns=\"urn:xmpp:jingle:transports:ice-udp:1\"]');\r\n    if (tmp.length) {\r\n        if (tmp.attr('ufrag')) {\r\n            media += `${SDPUtil.buildICEUfrag(tmp.attr('ufrag'))}\\r\\n`;\r\n        }\r\n        if (tmp.attr('pwd')) {\r\n            media += `${SDPUtil.buildICEPwd(tmp.attr('pwd'))}\\r\\n`;\r\n        }\r\n        tmp.find('>fingerprint').each(function() {\r\n            /* eslint-disable no-invalid-this */\r\n            // FIXME: check namespace at some point\r\n            media += `a=fingerprint:${this.getAttribute('hash')}`;\r\n            media += ` ${$(this).text()}`;\r\n            media += '\\r\\n';\r\n            if (this.getAttribute('setup')) {\r\n                media += `a=setup:${this.getAttribute('setup')}\\r\\n`;\r\n            }\r\n\r\n            /* eslint-enable no-invalid-this */\r\n        });\r\n    }\r\n    switch (content.attr('senders')) {\r\n    case 'initiator':\r\n        media += 'a=sendonly\\r\\n';\r\n        break;\r\n    case 'responder':\r\n        media += 'a=recvonly\\r\\n';\r\n        break;\r\n    case 'none':\r\n        media += 'a=inactive\\r\\n';\r\n        break;\r\n    case 'both':\r\n        media += 'a=sendrecv\\r\\n';\r\n        break;\r\n    }\r\n    media += `a=mid:${content.attr('name')}\\r\\n`;\r\n\r\n    // <description><rtcp-mux/></description>\r\n    // see http://code.google.com/p/libjingle/issues/detail?id=309 -- no spec\r\n    // though\r\n    // and http://mail.jabber.org/pipermail/jingle/2011-December/001761.html\r\n    if (desc.find('rtcp-mux').length) {\r\n        media += 'a=rtcp-mux\\r\\n';\r\n    }\r\n\r\n    if (desc.find('encryption').length) {\r\n        desc.find('encryption>crypto').each(function() {\r\n            /* eslint-disable no-invalid-this */\r\n            media += `a=crypto:${this.getAttribute('tag')}`;\r\n            media += ` ${this.getAttribute('crypto-suite')}`;\r\n            media += ` ${this.getAttribute('key-params')}`;\r\n            if (this.getAttribute('session-params')) {\r\n                media += ` ${this.getAttribute('session-params')}`;\r\n            }\r\n            media += '\\r\\n';\r\n\r\n            /* eslint-enable no-invalid-this */\r\n        });\r\n    }\r\n    desc.find('payload-type').each(function() {\r\n        /* eslint-disable no-invalid-this */\r\n        media += `${SDPUtil.buildRTPMap(this)}\\r\\n`;\r\n        if ($(this).find('>parameter').length) {\r\n            media += `a=fmtp:${this.getAttribute('id')} `;\r\n            media\r\n                += $(this)\r\n                    .find('parameter')\r\n                    .map(function() {\r\n                        const name = this.getAttribute('name');\r\n\r\n                        return (\r\n                            (name ? `${name}=` : '')\r\n                                + this.getAttribute('value'));\r\n                    })\r\n                    .get()\r\n                    .join('; ');\r\n            media += '\\r\\n';\r\n        }\r\n\r\n        // xep-0293\r\n        media += self.rtcpFbFromJingle($(this), this.getAttribute('id'));\r\n\r\n        /* eslint-enable no-invalid-this */\r\n    });\r\n\r\n    // xep-0293\r\n    media += self.rtcpFbFromJingle(desc, '*');\r\n\r\n    // xep-0294\r\n    tmp\r\n        = desc.find(\r\n            '>rtp-hdrext[xmlns=\"urn:xmpp:jingle:apps:rtp:rtp-hdrext:0\"]');\r\n    tmp.each(function() {\r\n        /* eslint-disable no-invalid-this */\r\n        media\r\n            += `a=extmap:${this.getAttribute('id')} ${\r\n                this.getAttribute('uri')}\\r\\n`;\r\n\r\n        /* eslint-enable no-invalid-this */\r\n    });\r\n\r\n    content\r\n        .find(\r\n            '>transport[xmlns=\"urn:xmpp:jingle:transports:ice-udp:1\"]'\r\n                + '>candidate')\r\n        .each(function() {\r\n            /* eslint-disable no-invalid-this */\r\n            let protocol = this.getAttribute('protocol');\r\n\r\n            protocol\r\n                = typeof protocol === 'string' ? protocol.toLowerCase() : '';\r\n\r\n            if ((self.removeTcpCandidates\r\n                    && (protocol === 'tcp' || protocol === 'ssltcp'))\r\n                || (self.removeUdpCandidates && protocol === 'udp')) {\r\n                return;\r\n            } else if (self.failICE) {\r\n                this.setAttribute('ip', '1.1.1.1');\r\n            }\r\n\r\n            media += SDPUtil.candidateFromJingle(this);\r\n\r\n            /* eslint-enable no-invalid-this */\r\n        });\r\n\r\n    // XEP-0339 handle ssrc-group attributes\r\n    content\r\n        .find('description>ssrc-group[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]')\r\n        .each(function() {\r\n            /* eslint-disable no-invalid-this */\r\n            const semantics = this.getAttribute('semantics');\r\n            const ssrcs\r\n                = $(this)\r\n                    .find('>source')\r\n                    .map(function() {\r\n                        return this.getAttribute('ssrc');\r\n                    })\r\n                    .get();\r\n\r\n            if (ssrcs.length) {\r\n                media += `a=ssrc-group:${semantics} ${ssrcs.join(' ')}\\r\\n`;\r\n            }\r\n\r\n            /* eslint-enable no-invalid-this */\r\n        });\r\n\r\n    tmp\r\n        = content.find(\r\n            'description>source[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]');\r\n    tmp.each(function() {\r\n        /* eslint-disable no-invalid-this */\r\n        const ssrc = this.getAttribute('ssrc');\r\n\r\n        // eslint-disable-next-line newline-per-chained-call\r\n        $(this).find('>parameter').each(function() {\r\n            const name = this.getAttribute('name');\r\n            let value = this.getAttribute('value');\r\n\r\n            value = SDPUtil.filterSpecialChars(value);\r\n            media += `a=ssrc:${ssrc} ${name}`;\r\n            if (value && value.length) {\r\n                media += `:${value}`;\r\n            }\r\n            media += '\\r\\n';\r\n        });\r\n\r\n        /* eslint-enable no-invalid-this */\r\n    });\r\n\r\n    return media;\r\n};\r\n","// TODO: Maybe fix the values to 'Chrome', 'Internet Explorer', etc. Currently\r\n// this values needs to be as they are becuse they are going to analytics,\r\n// callstats, etc.\r\n\r\nexport const CHROME = 'chrome';\r\n\r\nexport const OPERA = 'opera';\r\n\r\nexport const FIREFOX = 'firefox';\r\n\r\nexport const INTERNET_EXPLORER = 'iexplorer';\r\n\r\nexport const EDGE = 'edge';\r\n\r\nexport const SAFARI = 'safari';\r\n\r\nexport const NWJS = 'nwjs';\r\n\r\nexport const ELECTRON = 'electron';\r\n\r\nexport const REACT_NATIVE = 'react-native';\r\n\r\nexport const UNKNOWN = 'unknown';\r\n","import bowser from 'bowser';\r\n\r\nimport {\r\n    CHROME,\r\n    OPERA,\r\n    FIREFOX,\r\n    INTERNET_EXPLORER,\r\n    EDGE,\r\n    SAFARI,\r\n    NWJS,\r\n    ELECTRON,\r\n    REACT_NATIVE,\r\n    UNKNOWN\r\n} from './browsers';\r\n\r\n/**\r\n * Maps the names of the browsers from bowser to the internal names defined in\r\n * ./browsers.js\r\n */\r\nconst bowserNameToQHSenseName = {\r\n    'Chrome': CHROME,\r\n    'Chromium': CHROME,\r\n    'Opera': OPERA,\r\n    'Firefox': FIREFOX,\r\n    'Internet Explorer': INTERNET_EXPLORER,\r\n    'Microsoft Edge': EDGE,\r\n    'Safari': SAFARI\r\n};\r\n\r\n/**\r\n * Detects a Chromium based environent.\r\n * \r\n * NOTE: Here we cannot check solely for \"Chrome\" in the UA string and the\r\n * \"window.chrome\" property, because Edge has both, so we add an explicit\r\n * check for NOT Edge.\r\n *\r\n * @returns {Object|undefined} - The name (CHROME) and version.\r\n */\r\nfunction _detectChromiumBased() {\r\n    const userAgent = navigator.userAgent;\r\n\r\n    if (Boolean(window.chrome)\r\n            && !userAgent.match(/Edge/) && userAgent.match(/Chrome/)) {\r\n        const version = userAgent.match(/Chrome\\/([\\d.]+)/)[1];\r\n\r\n        return {\r\n            name: CHROME,\r\n            version\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Detects Electron environment.\r\n *\r\n * @returns {Object|undefined} - The name (ELECTRON) and version.\r\n */\r\nfunction _detectElectron() {\r\n    const userAgent = navigator.userAgent;\r\n\r\n    if (userAgent.match(/Electron/)) {\r\n        const version = userAgent.match(/Electron\\/([\\d.]+)/)[1];\r\n\r\n        return {\r\n            name: ELECTRON,\r\n            version\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Detects NWJS environment.\r\n *\r\n * @returns {Object|undefined} - The name (NWJS) and version.\r\n */\r\nfunction _detectNWJS() {\r\n    const userAgent = navigator.userAgent;\r\n\r\n    if (userAgent.match(/QHSenseMeetNW/)) {\r\n        const version = userAgent.match(/QHSenseMeetNW\\/([\\d.]+)/)[1];\r\n\r\n        return {\r\n            name: NWJS,\r\n            version\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Detects React Native environment.\r\n * @returns {Object|undefined} - The name (REACT_NATIVE) and version.\r\n */\r\nfunction _detectReactNative() {\r\n    const match\r\n        = navigator.userAgent.match(/\\b(react[ \\t_-]*native)(?:\\/(\\S+))?/i);\r\n    let version;\r\n\r\n    // If we're remote debugging a React Native app, it may be treated as\r\n    // Chrome. Check navigator.product as well and always return some version\r\n    // even if we can't get the real one.\r\n\r\n    if (match || navigator.product === 'ReactNative') {\r\n        let name;\r\n\r\n        if (match && match.length > 2) {\r\n            name = match[1];\r\n            version = match[2];\r\n        }\r\n        name || (name = 'react-native');\r\n        version || (version = 'unknown');\r\n\r\n        return {\r\n            name: REACT_NATIVE,\r\n            version\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Returns information about the current browser.\r\n *\r\n * @returns {Object} - The name and version of the browser.\r\n */\r\nfunction _detect() {\r\n    let browserInfo;\r\n    const detectors = [\r\n        _detectReactNative,\r\n        _detectElectron,\r\n        _detectNWJS\r\n    ];\r\n\r\n    // Try all browser detectors\r\n    for (let i = 0; i < detectors.length; i++) {\r\n        browserInfo = detectors[i]();\r\n        if (browserInfo) {\r\n            return browserInfo;\r\n        }\r\n    }\r\n\r\n    const { name, version } = bowser;\r\n\r\n    if (name in bowserNameToQHSenseName) {\r\n        return {\r\n            name: bowserNameToQHSenseName[name],\r\n            version\r\n        };\r\n    }\r\n\r\n    // Detect other browsers with the Chrome engine, such as Vivaldi.\r\n    browserInfo = _detectChromiumBased();\r\n    if (browserInfo) {\r\n        return browserInfo;\r\n    }\r\n\r\n    return {\r\n        name: UNKNOWN,\r\n        version: undefined\r\n    };\r\n}\r\n\r\n/**\r\n * Implements browser detection.\r\n */\r\nexport default class BrowserDetection {\r\n    /**\r\n     * Creates new BrowserDetection instance.\r\n     *\r\n     * @param {Object} [browserInfo] - Information about the browser.\r\n     * @param {string} browserInfo.name - The name of the browser.\r\n     * @param {string} browserInfo.version - The version of the browser.\r\n     */\r\n    constructor(browserInfo) {\r\n        let name, version;\r\n\r\n        if (typeof browserInfo === 'undefined') {\r\n            const detectedBrowserInfo = _detect();\r\n\r\n            name = detectedBrowserInfo.name;\r\n            version = detectedBrowserInfo.version;\r\n        } else if (browserInfo.name in bowserNameToQHSenseName) {\r\n            name = bowserNameToQHSenseName[browserInfo.name];\r\n            version = browserInfo.version;\r\n        } else {\r\n            name = UNKNOWN;\r\n            version = undefined;\r\n        }\r\n\r\n        this._name = name;\r\n        this._version = version;\r\n    }\r\n\r\n    /**\r\n     * Gets current browser name.\r\n     * @returns {string}\r\n     */\r\n    getName() {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Checks if current browser is Chrome.\r\n     * @returns {boolean}\r\n     */\r\n    isChrome() {\r\n        return this._name === CHROME;\r\n    }\r\n\r\n    /**\r\n     * Checks if current browser is Opera.\r\n     * @returns {boolean}\r\n     */\r\n    isOpera() {\r\n        return this._name === OPERA;\r\n    }\r\n\r\n    /**\r\n     * Checks if current browser is Firefox.\r\n     * @returns {boolean}\r\n     */\r\n    isFirefox() {\r\n        return this._name === FIREFOX;\r\n    }\r\n\r\n    /**\r\n     * Checks if current browser is Internet Explorer.\r\n     * @returns {boolean}\r\n     */\r\n    isIExplorer() {\r\n        return this._name === INTERNET_EXPLORER;\r\n    }\r\n\r\n    /**\r\n     * Checks if current browser is Microsoft Edge.\r\n     * @returns {boolean}\r\n     */\r\n    isEdge() {\r\n        return this._name === EDGE;\r\n    }\r\n\r\n    /**\r\n     * Checks if current browser is Safari.\r\n     * @returns {boolean}\r\n     */\r\n    isSafari() {\r\n        return this._name === SAFARI;\r\n    }\r\n\r\n    /**\r\n     * Checks if current environment is NWJS.\r\n     * @returns {boolean}\r\n     */\r\n    isNWJS() {\r\n        return this._name === NWJS;\r\n    }\r\n\r\n    /**\r\n     * Checks if current environment is Electron.\r\n     * @returns {boolean}\r\n     */\r\n    isElectron() {\r\n        return this._name === ELECTRON;\r\n    }\r\n\r\n    /**\r\n     * Checks if current environment is React Native.\r\n     * @returns {boolean}\r\n     */\r\n    isReactNative() {\r\n        return this._name === REACT_NATIVE;\r\n    }\r\n\r\n    /**\r\n     * Returns the version of the current browser.\r\n     * @returns {string}\r\n     */\r\n    getVersion() {\r\n        return this._version;\r\n    }\r\n\r\n    /**\r\n     * Compares the passed version with the current browser version.\r\n     * {@see https://github.com/lancedikson/bowser}\r\n     */\r\n    static compareVersions = bowser.compareVersions;\r\n\r\n    /**\r\n     * Compares the passed version with the current browser version.\r\n     *\r\n     * @param {*} version - The version to compare with. Anything different\r\n     * than string will be converted to string.\r\n     * @returns {number|undefined} - Returns 0 if the version is equal to the\r\n     * current one, 1 if the version is greater than the current one, -1 if the\r\n     * version is lower than the current one and undefined if the current\r\n     * browser version is unknown.\r\n     */\r\n    compareVersion(version) {\r\n        if (this._version) {\r\n            return bowser.compareVersions([ String(version), this._version ]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compares the passed version with the current browser version.\r\n     *\r\n     * @param {*} version - The version to compare with. Anything different\r\n     * than string will be converted to string.\r\n     * @returns {boolean|undefined} - Returns true if the current version is\r\n     * greater than the passed version and false otherwise. Returns undefined if\r\n     * the current browser version is unknown.\r\n     */\r\n    isVersionGreaterThan(version) {\r\n        return this.compareVersion(version) === -1;\r\n    }\r\n\r\n    /**\r\n     * Compares the passed version with the current browser version.\r\n     *\r\n     * @param {*} version - The version to compare with. Anything different\r\n     * than string will be converted to string.\r\n     * @returns {boolean|undefined} - Returns true if the current version is\r\n     * lower than the passed version and false otherwise. Returns undefined if\r\n     * the current browser version is unknown.\r\n     */\r\n    isVersionLessThan(version) {\r\n        return this.compareVersion(version) === 1;\r\n    }\r\n\r\n    /**\r\n     * Compares the passed version with the current browser version.\r\n     *\r\n     * @param {*} version - The version to compare with. Anything different\r\n     * than string will be converted to string.\r\n     * @returns {boolean|undefined} - Returns true if the current version is\r\n     * equal to the passed version and false otherwise. Returns undefined if\r\n     * the current browser version is unknown.\r\n     */\r\n    isVersionEqualTo(version) {\r\n        return this.compareVersion(version) === 0;\r\n    }\r\n}\r\n","export * from './browser-capabilities';\r\nexport * from './browser-detection';\r\nexport * from './avatar';\r\n","/**\r\n * Status that video SIP GW service is available.\r\n * @type {string}\r\n */\r\nexport const STATUS_AVAILABLE = 'available';\r\n\r\n/**\r\n * Status that video SIP GW service is not available.\r\n * @type {string}\r\n */\r\nexport const STATUS_UNDEFINED = 'undefined';\r\n\r\n/**\r\n * Status that video SIP GW service is available but there are no free nodes\r\n * at the moment to serve new requests.\r\n * @type {string}\r\n */\r\nexport const STATUS_BUSY = 'busy';\r\n\r\n/**\r\n * Video SIP GW session state, currently running.\r\n * @type {string}\r\n */\r\nexport const STATE_ON = 'on';\r\n\r\n/**\r\n * Video SIP GW session state, currently stopped and not running.\r\n * @type {string}\r\n */\r\nexport const STATE_OFF = 'off';\r\n\r\n/**\r\n * Video SIP GW session state, currently is starting.\r\n * @type {string}\r\n */\r\nexport const STATE_PENDING = 'pending';\r\n\r\n/**\r\n * Video SIP GW session state, has observed some issues and is retrying at the\r\n * moment.\r\n * @type {string}\r\n */\r\nexport const STATE_RETRYING = 'retrying';\r\n\r\n/**\r\n * Video SIP GW session state, tried to start but it failed.\r\n * @type {string}\r\n */\r\nexport const STATE_FAILED = 'failed';\r\n\r\n/**\r\n * Error on trying to create video SIP GW session in conference where\r\n * there is no room connection (hasn't joined or has left the room).\r\n * @type {string}\r\n */\r\nexport const ERROR_NO_CONNECTION = 'error_no_connection';\r\n\r\n/**\r\n * Error on trying to create video SIP GW session with address for which\r\n * there is an already created session.\r\n * @type {string}\r\n */\r\nexport const ERROR_SESSION_EXISTS = 'error_session_already_exists';\r\n","/**\r\n * The events for the connection.\r\n */\r\n\r\n/**\r\n * Indicates that the connection has been disconnected. The event provides\r\n * the following parameters to its listeners:\r\n *\r\n * @param msg {string} a message associated with the disconnect such as the\r\n * last (known) error message\r\n */\r\nexport const CONNECTION_DISCONNECTED = 'connection.connectionDisconnected';\r\n\r\n/**\r\n * Indicates that the connection has been established. The event provides\r\n * the following parameters to its listeners:\r\n *\r\n * @param id {string} the ID of the local endpoint/participant/peer (within\r\n * the context of the established connection)\r\n */\r\nexport const CONNECTION_ESTABLISHED = 'connection.connectionEstablished';\r\n\r\n/**\r\n * Indicates that the connection has been failed for some reason. The event\r\n * provides the following parameters to its listeners:\r\n *\r\n * @param errType {QHSenseConnectionErrors} the type of error associated with\r\n * the failure\r\n * @param errReason {string} the error (message) associated with the failure\r\n * @param credentials {object} the credentials used to connect (if any)\r\n * @param errReasonDetails {object} an optional object with details about\r\n * the error, like shard moving, suspending. Used for analytics purposes.\r\n */\r\nexport const CONNECTION_FAILED = 'connection.connectionFailed';\r\n\r\n/**\r\n * Indicates that the performed action cannot be executed because the\r\n * connection is not in the correct state(connected, disconnected, etc.)\r\n */\r\nexport const WRONG_STATE = 'connection.wrongState';\r\n","var parser = require('./parser');\nvar writer = require('./writer');\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseFmtpConfig = parser.parseFmtpConfig;\nexports.parseParams = parser.parseParams;\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n","/**\r\n * Notifies about audio level in RTP statistics by SSRC.\r\n *\r\n * @param ssrc - The synchronization source identifier (SSRC) of the\r\n * endpoint/participant whose audio level is being reported.\r\n * @param {number} audioLevel - The audio level of <tt>ssrc</tt> according to\r\n * RTP statistics.\r\n * @param {boolean} isLocal - <tt>true</tt> if <tt>ssrc</tt> identifies the\r\n * local endpoint/participant; otherwise, <tt>false</tt>.\r\n */\r\nexport const AUDIO_LEVEL = 'statistics.audioLevel';\r\n\r\n/**\r\n * An event fired just before the statistics module gets disposes and it's\r\n * the last chance to submit some logs that will end up in stats services like\r\n * CallStats (if enabled).\r\n */\r\nexport const BEFORE_DISPOSED = 'statistics.before_disposed';\r\n\r\n/**\r\n * An event carrying all statistics by ssrc.\r\n */\r\nexport const BYTE_SENT_STATS = 'statistics.byte_sent_stats';\r\n\r\n/**\r\n * An event carrying connection statistics.\r\n *\r\n * @param {object} connectionStats - The connection statistics carried by the\r\n * event such as <tt>bandwidth</tt>, <tt>bitrate</tt>, <tt>packetLoss</tt>,\r\n * <tt>resolution</tt>, and <tt>transport</tt>.\r\n */\r\nexport const CONNECTION_STATS = 'statistics.connectionstats';\r\n","import EventEmitter from 'events';\r\n\r\n/**\r\n * The class implements basic event operations - add/remove listener.\r\n * NOTE: The purpose of the class is to be extended in order to add\r\n * this functionality to other classes.\r\n */\r\nexport default class Listenable {\r\n    /**\r\n     * Creates new instance.\r\n     * @param {EventEmitter} eventEmitter\r\n     * @constructor\r\n     */\r\n    constructor(eventEmitter = new EventEmitter()) {\r\n        this.eventEmitter = eventEmitter;\r\n\r\n        // aliases for addListener/removeListener\r\n        this.addEventListener = this.on = this.addListener;\r\n        this.removeEventListener = this.off = this.removeListener;\r\n    }\r\n\r\n    /**\r\n     * Adds new listener.\r\n     * @param {String} eventName the name of the event\r\n     * @param {Function} listener the listener.\r\n     */\r\n    addListener(eventName, listener) {\r\n        this.eventEmitter.addListener(eventName, listener);\r\n    }\r\n\r\n    /**\r\n     * Removes listener.\r\n     * @param {String} eventName the name of the event that triggers the\r\n     * listener\r\n     * @param {Function} listener the listener.\r\n     */\r\n    removeListener(eventName, listener) {\r\n        this.eventEmitter.removeListener(eventName, listener);\r\n    }\r\n}\r\n","import { getLogger } from 'qhsense-meet-logger';\r\nconst logger = getLogger(__filename);\r\n\r\nimport UsernameGenerator from '../util/UsernameGenerator';\r\n\r\nlet _callStatsUserName;\r\n\r\nlet _machineId;\r\n\r\n/**\r\n *\r\n */\r\nexport default {\r\n    /**\r\n     * Returns fake username for callstats\r\n     * @returns {string} fake username for callstats\r\n     */\r\n    get callStatsUserName() {\r\n        if (!_callStatsUserName) {\r\n            const localStorage = getLocalStorage();\r\n\r\n            if (localStorage) {\r\n                _callStatsUserName = localStorage.getItem('callStatsUserName');\r\n            }\r\n            if (!_callStatsUserName) {\r\n                _callStatsUserName = generateCallStatsUserName();\r\n                if (localStorage) {\r\n                    localStorage.setItem(\r\n                        'callStatsUserName',\r\n                        _callStatsUserName);\r\n                }\r\n            }\r\n        }\r\n\r\n        return _callStatsUserName;\r\n    },\r\n\r\n    /**\r\n     * Returns current machine id.\r\n     * @returns {string} machine id\r\n     */\r\n    get machineId() {\r\n        if (!_machineId) {\r\n            const localStorage = getLocalStorage();\r\n\r\n            if (localStorage) {\r\n                _machineId = localStorage.getItem('qhsenseMeetId');\r\n            }\r\n            if (!_machineId) {\r\n                _machineId = generateQHSenseMeetId();\r\n                if (localStorage) {\r\n                    localStorage.setItem('qhsenseMeetId', _machineId);\r\n                }\r\n            }\r\n        }\r\n\r\n        return _machineId;\r\n    },\r\n\r\n    /**\r\n     * Returns current session id.\r\n     * @returns {string} current session id\r\n     */\r\n    get sessionId() {\r\n        // We may update sessionId in localStorage from another QHSenseConference\r\n        // instance and that's why we should always re-read it.\r\n        const localStorage = getLocalStorage();\r\n\r\n        return localStorage ? localStorage.getItem('sessionId') : undefined;\r\n    },\r\n\r\n    /**\r\n     * Save current session id.\r\n     * @param {string} sessionId session id\r\n     */\r\n    set sessionId(sessionId) {\r\n        const localStorage = getLocalStorage();\r\n\r\n        if (localStorage) {\r\n            if (sessionId) {\r\n                localStorage.setItem('sessionId', sessionId);\r\n            } else {\r\n                localStorage.removeItem('sessionId');\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Generate fake username for callstats.\r\n * @returns {string} fake random username\r\n */\r\nfunction generateCallStatsUserName() {\r\n    const username = UsernameGenerator.generateUsername();\r\n\r\n    logger.log('generated callstats uid', username);\r\n\r\n    return username;\r\n}\r\n\r\n/**\r\n * Generate unique id.\r\n * @returns {string} random unique id\r\n */\r\nfunction generateQHSenseMeetId() {\r\n    const qhsenseMeetId = generateUniqueId();\r\n\r\n    logger.log('generated id', qhsenseMeetId);\r\n\r\n    return qhsenseMeetId;\r\n}\r\n\r\n/**\r\n * Gets the localStorage of the browser. (Technically, gets the localStorage of\r\n * the global object because there may be no browser but React Native for\r\n * example).\r\n * @returns {Storage} the local Storage object (if any)\r\n */\r\nfunction getLocalStorage() {\r\n    let storage;\r\n\r\n    try {\r\n        // eslint-disable-next-line no-invalid-this\r\n        storage = (window || this).localStorage;\r\n    } catch (error) {\r\n        logger.error(error);\r\n    }\r\n\r\n    return storage;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nfunction generateUniqueId() {\r\n    return _p8() + _p8() + _p8() + _p8();\r\n}\r\n\r\n/**\r\n *\r\n */\r\nfunction _p8() {\r\n    return `${Math.random().toString(16)}000000000`.substr(2, 8);\r\n}\r\n","import * as transform from 'sdp-transform';\r\n\r\n/**\r\n * Parses the primary SSRC of given SSRC group.\r\n * @param {object} group the SSRC group object as defined by the 'sdp-transform'\r\n * @return {Number} the primary SSRC number\r\n */\r\nexport function parsePrimarySSRC(group) {\r\n    return parseInt(group.ssrcs.split(' ')[0], 10);\r\n}\r\n\r\n/**\r\n * Parses the secondary SSRC of given SSRC group.\r\n * @param {object} group the SSRC group object as defined by the 'sdp-transform'\r\n * @return {Number} the secondary SSRC number\r\n */\r\nexport function parseSecondarySSRC(group) {\r\n    return parseInt(group.ssrcs.split(' ')[1], 10);\r\n}\r\n\r\n/**\r\n * Tells how many distinct SSRCs are contained in given media line.\r\n * @param {Object} mLine the media line object as defined by 'sdp-transform' lib\r\n * @return {number}\r\n */\r\nfunction _getSSRCCount(mLine) {\r\n    if (!mLine.ssrcs) {\r\n        return 0;\r\n    }\r\n\r\n    return mLine.ssrcs\r\n        .map(ssrcInfo => ssrcInfo.id)\r\n        .filter((ssrc, index, array) => array.indexOf(ssrc) === index)\r\n        .length;\r\n}\r\n\r\n/**\r\n * A wrapper around 'sdp-transform' media description object which provides\r\n * utility methods for common SDP/SSRC related operations.\r\n */\r\nclass MLineWrap {\r\n\r\n    /**\r\n     * Creates new <tt>MLineWrap</t>>\r\n     * @param {Object} mLine the media line object as defined by 'sdp-transform'\r\n     * lib.\r\n     */\r\n    constructor(mLine) {\r\n        if (!mLine) {\r\n            throw new Error('mLine is undefined');\r\n        }\r\n\r\n        this.mLine = mLine;\r\n    }\r\n\r\n    /**\r\n     * Getter for the mLine's \"ssrcs\" array. If the array was undefined an empty\r\n     * one will be preassigned.\r\n     *\r\n     * @return {Array<Object>} an array of 'sdp-transform' SSRC attributes\r\n     * objects.\r\n     */\r\n    get ssrcs() {\r\n        if (!this.mLine.ssrcs) {\r\n            this.mLine.ssrcs = [];\r\n        }\r\n\r\n        return this.mLine.ssrcs;\r\n    }\r\n\r\n    /**\r\n     * Setter for the mLine's \"ssrcs\" array.\r\n     *\r\n     * @param {Array<Object>} ssrcs an array of 'sdp-transform' SSRC attributes\r\n     * objects.\r\n     */\r\n    set ssrcs(ssrcs) {\r\n        this.mLine.ssrcs = ssrcs;\r\n    }\r\n\r\n    /**\r\n     * Returns the direction of the underlying media description.\r\n     * @return {string} the media direction name as defined in the SDP.\r\n     */\r\n    get direction() {\r\n        return this.mLine.direction;\r\n    }\r\n\r\n    /**\r\n     * Modifies the direction of the underlying media description.\r\n     * @param {string} direction the new direction to be set\r\n     */\r\n    set direction(direction) {\r\n        this.mLine.direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Exposes the SSRC group array of the underlying media description object.\r\n     * @return {Array.<Object>}\r\n     */\r\n    get ssrcGroups() {\r\n        if (!this.mLine.ssrcGroups) {\r\n            this.mLine.ssrcGroups = [];\r\n        }\r\n\r\n        return this.mLine.ssrcGroups;\r\n    }\r\n\r\n    /**\r\n     * Modifies the SSRC groups array of the underlying media description\r\n     * object.\r\n     * @param {Array.<Object>} ssrcGroups\r\n     */\r\n    set ssrcGroups(ssrcGroups) {\r\n        this.mLine.ssrcGroups = ssrcGroups;\r\n    }\r\n\r\n    /**\r\n     * Obtains value from SSRC attribute.\r\n     * @param {number} ssrcNumber the SSRC number for which attribute is to be\r\n     * found\r\n     * @param {string} attrName the name of the SSRC attribute to be found.\r\n     * @return {string|undefined} the value of SSRC attribute or\r\n     * <tt>undefined</tt> if no such attribute exists.\r\n     */\r\n    getSSRCAttrValue(ssrcNumber, attrName) {\r\n        const attribute = this.ssrcs.find(\r\n            ssrcObj => ssrcObj.id === ssrcNumber\r\n            && ssrcObj.attribute === attrName);\r\n\r\n\r\n        return attribute && attribute.value;\r\n    }\r\n\r\n    /**\r\n     * Removes all attributes for given SSRC number.\r\n     * @param {number} ssrcNum the SSRC number for which all attributes will be\r\n     * removed.\r\n     */\r\n    removeSSRC(ssrcNum) {\r\n        if (!this.mLine.ssrcs || !this.mLine.ssrcs.length) {\r\n            return;\r\n        }\r\n\r\n        this.mLine.ssrcs\r\n            = this.mLine.ssrcs.filter(ssrcObj => ssrcObj.id !== ssrcNum);\r\n    }\r\n\r\n    /**\r\n     * Adds SSRC attribute\r\n     * @param {object} ssrcObj the SSRC attribute object as defined in\r\n     * the 'sdp-transform' lib.\r\n     */\r\n    addSSRCAttribute(ssrcObj) {\r\n        this.ssrcs.push(ssrcObj);\r\n    }\r\n\r\n    /**\r\n     * Finds a SSRC group matching both semantics and SSRCs in order.\r\n     * @param {string} semantics the name of the semantics\r\n     * @param {string} [ssrcs] group SSRCs as a string (like it's defined in\r\n     * SSRC group object of the 'sdp-transform' lib) e.g. \"1232546 342344 25434\"\r\n     * @return {object|undefined} the SSRC group object or <tt>undefined</tt> if\r\n     * not found.\r\n     */\r\n    findGroup(semantics, ssrcs) {\r\n        return this.ssrcGroups.find(\r\n            group =>\r\n                group.semantics === semantics\r\n                    && (!ssrcs || ssrcs === group.ssrcs));\r\n    }\r\n\r\n    /**\r\n     * Finds all groups matching given semantic's name.\r\n     * @param {string} semantics the name of the semantics\r\n     * @return {Array.<object>} an array of SSRC group objects as defined by\r\n     * the 'sdp-transform' lib.\r\n     */\r\n    findGroups(semantics) {\r\n        return this.ssrcGroups.filter(\r\n            group => group.semantics === semantics);\r\n    }\r\n\r\n    /**\r\n     * Finds all groups matching given semantic's name and group's primary SSRC.\r\n     * @param {string} semantics the name of the semantics\r\n     * @param {number} primarySSRC the primary SSRC number to be matched\r\n     * @return {Object} SSRC group object as defined by the 'sdp-transform' lib.\r\n     */\r\n    findGroupByPrimarySSRC(semantics, primarySSRC) {\r\n        return this.ssrcGroups.find(\r\n            group => group.semantics === semantics\r\n                && parsePrimarySSRC(group) === primarySSRC);\r\n    }\r\n\r\n    /**\r\n     * @param {string|null} msid the media stream id or <tt>null</tt> to match\r\n     * the first SSRC object with any 'msid' value.\r\n     * @return {Object|undefined} the SSRC object as defined by 'sdp-transform'\r\n     * lib.\r\n     */\r\n    findSSRCByMSID(msid) {\r\n        return this.ssrcs.find(\r\n            ssrcObj => ssrcObj.attribute === 'msid'\r\n                && (msid === null || ssrcObj.value === msid));\r\n    }\r\n\r\n    /**\r\n     * Gets the SSRC count for the underlying media description.\r\n     * @return {number}\r\n     */\r\n    getSSRCCount() {\r\n        return _getSSRCCount(this.mLine);\r\n    }\r\n\r\n    /**\r\n     * Checks whether the underlying media description contains any SSRC groups.\r\n     * @return {boolean} <tt>true</tt> if there are any SSRC groups or\r\n     * <tt>false</tt> otherwise.\r\n     */\r\n    containsAnySSRCGroups() {\r\n        return this.mLine.ssrcGroups !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Finds the primary video SSRC.\r\n     * @returns {number|undefined} the primary video ssrc\r\n     * @throws Error if the underlying media description is not a video\r\n     */\r\n    getPrimaryVideoSsrc() {\r\n        const mediaType = this.mLine.type;\r\n\r\n        if (mediaType !== 'video') {\r\n            throw new Error(\r\n                `getPrimarySsrc doesn't work with '${mediaType}'`);\r\n        }\r\n\r\n        const numSsrcs = _getSSRCCount(this.mLine);\r\n\r\n        if (numSsrcs === 1) {\r\n            // Not using \"ssrcs\" getter on purpose here\r\n            return this.mLine.ssrcs[0].id;\r\n        }\r\n\r\n        // Look for a SIM, FID, or FEC-FR group\r\n        if (this.mLine.ssrcGroups) {\r\n            const simGroup = this.findGroup('SIM');\r\n\r\n            if (simGroup) {\r\n                return parsePrimarySSRC(simGroup);\r\n            }\r\n            const fidGroup = this.findGroup('FID');\r\n\r\n            if (fidGroup) {\r\n                return parsePrimarySSRC(fidGroup);\r\n            }\r\n            const fecGroup = this.findGroup('FEC-FR');\r\n\r\n            if (fecGroup) {\r\n                return parsePrimarySSRC(fecGroup);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains RTX SSRC from the underlying video description (the\r\n     * secondary SSRC of the first \"FID\" group found)\r\n     * @param {number} primarySsrc the video ssrc for which to find the\r\n     * corresponding rtx ssrc\r\n     * @returns {number|undefined} the rtx ssrc (or undefined if there isn't\r\n     * one)\r\n     */\r\n    getRtxSSRC(primarySsrc) {\r\n        const fidGroup = this.findGroupByPrimarySSRC('FID', primarySsrc);\r\n\r\n\r\n        return fidGroup && parseSecondarySSRC(fidGroup);\r\n    }\r\n\r\n    /**\r\n     * Obtains all SSRCs contained in the underlying media description.\r\n     * @return {Array.<number>} an array with all SSRC as numbers.\r\n     */\r\n    getSSRCs() {\r\n        return this.ssrcs\r\n            .map(ssrcInfo => ssrcInfo.id)\r\n            .filter((ssrc, index, array) => array.indexOf(ssrc) === index);\r\n    }\r\n\r\n    /**\r\n     * Obtains primary video SSRCs.\r\n     * @return {Array.<number>} an array of all primary video SSRCs as numbers.\r\n     * @throws Error if the wrapped media description is not a video.\r\n     */\r\n    getPrimaryVideoSSRCs() {\r\n        const mediaType = this.mLine.type;\r\n\r\n        if (mediaType !== 'video') {\r\n            throw new Error(\r\n                `getPrimaryVideoSSRCs doesn't work with ${mediaType}`);\r\n        }\r\n\r\n        const videoSSRCs = this.getSSRCs();\r\n\r\n        for (const ssrcGroupInfo of this.ssrcGroups) {\r\n            // Right now, FID and FEC-FR groups are the only ones we parse to\r\n            // disqualify streams.  If/when others arise we'll\r\n            // need to add support for them here\r\n            if (ssrcGroupInfo.semantics === 'FID'\r\n                    || ssrcGroupInfo.semantics === 'FEC-FR') {\r\n                // secondary streams should be filtered out\r\n                const secondarySsrc = parseSecondarySSRC(ssrcGroupInfo);\r\n\r\n                videoSSRCs.splice(\r\n                    videoSSRCs.indexOf(secondarySsrc), 1);\r\n            }\r\n        }\r\n\r\n        return videoSSRCs;\r\n    }\r\n\r\n    /**\r\n     * Dumps all SSRC groups of this media description to JSON.\r\n     */\r\n    dumpSSRCGroups() {\r\n        return JSON.stringify(this.mLine.ssrcGroups);\r\n    }\r\n\r\n    /**\r\n     * Removes all SSRC groups which contain given SSRC number at any position.\r\n     * @param {number} ssrc the SSRC for which all matching groups are to be\r\n     * removed.\r\n     */\r\n    removeGroupsWithSSRC(ssrc) {\r\n        if (!this.mLine.ssrcGroups) {\r\n            return;\r\n        }\r\n\r\n        this.mLine.ssrcGroups = this.mLine.ssrcGroups\r\n            .filter(groupInfo => groupInfo.ssrcs.indexOf(`${ssrc}`) === -1);\r\n    }\r\n\r\n    /**\r\n     * Removes groups that match given semantics.\r\n     * @param {string} semantics e.g. \"SIM\" or \"FID\"\r\n     */\r\n    removeGroupsBySemantics(semantics) {\r\n        if (!this.mLine.ssrcGroups) {\r\n            return;\r\n        }\r\n\r\n        this.mLine.ssrcGroups\r\n            = this.mLine.ssrcGroups\r\n                .filter(groupInfo => groupInfo.semantics !== semantics);\r\n    }\r\n\r\n    /**\r\n     * Replaces SSRC (does not affect SSRC groups, but only attributes).\r\n     * @param {number} oldSSRC the old SSRC number\r\n     * @param {number} newSSRC the new SSRC number\r\n     */\r\n    replaceSSRC(oldSSRC, newSSRC) {\r\n        if (this.mLine.ssrcs) {\r\n            this.mLine.ssrcs.forEach(ssrcInfo => {\r\n                if (ssrcInfo.id === oldSSRC) {\r\n                    ssrcInfo.id = newSSRC;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds given SSRC group to this media description.\r\n     * @param {object} group the SSRC group object as defined by\r\n     * the 'sdp-transform' lib.\r\n     */\r\n    addSSRCGroup(group) {\r\n        this.ssrcGroups.push(group);\r\n    }\r\n}\r\n\r\n/**\r\n * Utility class for SDP manipulation using the 'sdp-transform' library.\r\n *\r\n * Typical use usage scenario:\r\n *\r\n * const transformer = new SdpTransformWrap(rawSdp);\r\n * const videoMLine = transformer.selectMedia('video);\r\n * if (videoMLine) {\r\n *     videoMLiner.addSSRCAttribute({\r\n *         id: 2342343,\r\n *         attribute: \"cname\",\r\n *         value: \"someCname\"\r\n *     });\r\n *     rawSdp = transformer.toRawSdp();\r\n * }\r\n */\r\nexport class SdpTransformWrap {\r\n\r\n    /**\r\n     * Creates new instance and parses the raw SDP into objects using\r\n     * 'sdp-transform' lib.\r\n     * @param {string} rawSDP the SDP in raw text format.\r\n     */\r\n    constructor(rawSDP) {\r\n        this.parsedSDP = transform.parse(rawSDP);\r\n    }\r\n\r\n    /**\r\n     * Selects the first media SDP of given name.\r\n     * @param {string} mediaType the name of the media e.g. 'audio', 'video',\r\n     * 'data'.\r\n     * @return {MLineWrap|null} return {@link MLineWrap} instance for the media\r\n     * line or <tt>null</tt> if not found. The object returned references\r\n     * the underlying SDP state held by this <tt>SdpTransformWrap</tt> instance\r\n     * (it's not a copy).\r\n     */\r\n    selectMedia(mediaType) {\r\n        const selectedMLine\r\n            = this.parsedSDP.media.find(mLine => mLine.type === mediaType);\r\n\r\n        return selectedMLine ? new MLineWrap(selectedMLine) : null;\r\n    }\r\n\r\n    /**\r\n     * Converts the currently stored SDP state in this instance to raw text SDP\r\n     * format.\r\n     * @return {string}\r\n     */\r\n    toRawSDP() {\r\n        return transform.write(this.parsedSDP);\r\n    }\r\n}\r\n","/**\r\n * The know jingle actions that can be sent and should be acted upon by\r\n * {@code ProxyConnectionService} and {@code ProxyConnectionPC}.\r\n */\r\nexport const ACTIONS = {\r\n    ACCEPT: 'session-accept',\r\n    CONNECTION_ERROR: 'connection-error-encountered',\r\n    INITIATE: 'session-initiate',\r\n    TERMINATE: 'session-terminate',\r\n    TRANSPORT_INFO: 'transport-info',\r\n    UNAVAILABLE: 'unavailable'\r\n};\r\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","const Resolutions = {\r\n    '1080': {\r\n        width: 1920,\r\n        height: 1080,\r\n        order: 8\r\n    },\r\n    'fullhd': {\r\n        width: 1920,\r\n        height: 1080,\r\n        order: 8\r\n    },\r\n    '720': {\r\n        width: 1280,\r\n        height: 720,\r\n        order: 7\r\n    },\r\n    'hd': {\r\n        width: 1280,\r\n        height: 720,\r\n        order: 7\r\n    },\r\n    '960': {\r\n        width: 960,\r\n        height: 720,\r\n        order: 6\r\n    },\r\n    '540': {\r\n        width: 960,\r\n        height: 540,\r\n        order: 5\r\n    },\r\n    'qhd': {\r\n        width: 960,\r\n        height: 540,\r\n        order: 5\r\n    },\r\n\r\n    // 16:9 resolution first.\r\n    '360': {\r\n        width: 640,\r\n        height: 360,\r\n        order: 4\r\n    },\r\n    '640': {\r\n        width: 640,\r\n        height: 480,\r\n        order: 3\r\n    },\r\n    'vga': {\r\n        width: 640,\r\n        height: 480,\r\n        order: 3\r\n    },\r\n\r\n    // 16:9 resolution first.\r\n    '180': {\r\n        width: 320,\r\n        height: 180,\r\n        order: 2\r\n    },\r\n    '320': {\r\n        width: 320,\r\n        height: 240,\r\n        order: 1\r\n    }\r\n};\r\n\r\nmodule.exports = Resolutions;\r\n","/**\r\n * The pending Jingle session state which means the session as defined in\r\n * XEP-0166(before 'session-invite/session-accept' took place).\r\n *\r\n * @type {string}\r\n */\r\nexport const PENDING = 'pending';\r\n\r\n/**\r\n * The active Jingle session state as defined in XEP-0166\r\n * (after 'session-invite'/'session-accept').\r\n *\r\n * @type {string}\r\n */\r\nexport const ACTIVE = 'active';\r\n\r\n/**\r\n * The ended Jingle session state as defined in XEP-0166\r\n * (after 'session-terminate').\r\n * @type {string}\r\n */\r\nexport const ENDED = 'ended';\r\n","/* global callstats */\r\n\r\nimport browser from '../browser';\r\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\r\n\r\nconst logger = require('qhsense-meet-logger').getLogger(__filename);\r\n\r\n/**\r\n * We define enumeration of wrtcFuncNames as we need them before\r\n * callstats is initialized to queue events.\r\n * @const\r\n * @see http://www.callstats.io/api/#enumeration-of-wrtcfuncnames\r\n */\r\nconst wrtcFuncNames = {\r\n    createOffer: 'createOffer',\r\n    createAnswer: 'createAnswer',\r\n    setLocalDescription: 'setLocalDescription',\r\n    setRemoteDescription: 'setRemoteDescription',\r\n    addIceCandidate: 'addIceCandidate',\r\n    getUserMedia: 'getUserMedia',\r\n    iceConnectionFailure: 'iceConnectionFailure',\r\n    signalingError: 'signalingError',\r\n    applicationLog: 'applicationLog'\r\n};\r\n\r\n/**\r\n * We define enumeration of fabricEvent as we need them before\r\n * callstats is initialized to queue events.\r\n * @const\r\n * @see http://www.callstats.io/api/#enumeration-of-fabricevent\r\n */\r\nconst fabricEvent = {\r\n    fabricHold: 'fabricHold',\r\n    fabricResume: 'fabricResume',\r\n    audioMute: 'audioMute',\r\n    audioUnmute: 'audioUnmute',\r\n    videoPause: 'videoPause',\r\n    videoResume: 'videoResume',\r\n    fabricUsageEvent: 'fabricUsageEvent',\r\n    fabricStats: 'fabricStats',\r\n    fabricTerminated: 'fabricTerminated',\r\n    screenShareStart: 'screenShareStart',\r\n    screenShareStop: 'screenShareStop',\r\n    dominantSpeaker: 'dominantSpeaker',\r\n    activeDeviceList: 'activeDeviceList'\r\n};\r\n\r\n/**\r\n * The user id to report to callstats as destination.\r\n * @type {string}\r\n */\r\nconst DEFAULT_REMOTE_USER = 'qhsense';\r\n\r\n/**\r\n * Type of pending reports, can be event or an error.\r\n * @type {{ERROR: string, EVENT: string}}\r\n */\r\nconst reportType = {\r\n    ERROR: 'error',\r\n    EVENT: 'event',\r\n    MST_WITH_USERID: 'mstWithUserID'\r\n};\r\n\r\n/**\r\n * Set of currently existing {@link CallStats} instances.\r\n * @type {Set<CallStats>}\r\n */\r\nlet _fabrics;\r\n\r\n/**\r\n * An instance of this class is a wrapper for the CallStats API fabric. A fabric\r\n * reports one peer connection the the CallStats backend and is allocated with\r\n * {@link callstats.addNewFabric}. It has a bunch of instance methods for\r\n * reporting various events. A fabric is considered disposed when\r\n * {@link CallStats.sendTerminateEvent} is executed.\r\n *\r\n * Currently only one backend instance can be created ever and it's done using\r\n * {@link CallStats.initBackend}. At the time of this writing there is no way to\r\n * explicitly shutdown the backend, but it's supposed to close it's connection\r\n * automatically, after all fabrics have been terminated.\r\n */\r\nexport default class CallStats {\r\n    /**\r\n     * A callback passed to {@link callstats.addNewFabric}.\r\n     * @param {string} error 'success' means ok\r\n     * @param {string} msg some more details\r\n     * @private\r\n     */\r\n    static _addNewFabricCallback(error, msg) {\r\n        if (CallStats.backend && error !== 'success') {\r\n            logger.error(`Monitoring status: ${error} msg: ${msg}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback passed to {@link callstats.initialize} (backend initialization)\r\n     * @param {string} error 'success' means ok\r\n     * @param {String} msg\r\n     * @private\r\n     */\r\n    static _initCallback(error, msg) {\r\n        logger.log(`CallStats Status: err=${error} msg=${msg}`);\r\n\r\n        // there is no lib, nothing to report to\r\n        if (error !== 'success') {\r\n            return;\r\n        }\r\n\r\n        CallStats.backendInitialized = true;\r\n\r\n        // I hate that\r\n        let atLeastOneFabric = false;\r\n        let defaultInstance = null;\r\n\r\n        for (const callStatsInstance of CallStats.fabrics.values()) {\r\n            if (!callStatsInstance.hasFabric) {\r\n                logger.debug('addNewFabric - initCallback');\r\n                if (callStatsInstance._addNewFabric()) {\r\n                    atLeastOneFabric = true;\r\n                    if (!defaultInstance) {\r\n                        defaultInstance = callStatsInstance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!atLeastOneFabric) {\r\n            return;\r\n        }\r\n\r\n        CallStats._emptyReportQueue(defaultInstance);\r\n    }\r\n\r\n    /**\r\n     * Empties report queue.\r\n     *\r\n     * @param {CallStats} csInstance - The callstats instance.\r\n     * @private\r\n     */\r\n    static _emptyReportQueue(csInstance) {\r\n        // There is no conference ID nor a PeerConnection available when some of\r\n        // the events are scheduled on the reportsQueue, so those will be\r\n        // reported on the first initialized fabric.\r\n        const defaultConfID = csInstance.confID;\r\n        const defaultPC = csInstance.peerconnection;\r\n\r\n        // notify callstats about failures if there were any\r\n        for (const report of CallStats.reportsQueue) {\r\n            if (report.type === reportType.ERROR) {\r\n                const errorData = report.data;\r\n\r\n                CallStats._reportError(\r\n                    csInstance,\r\n                    errorData.type,\r\n                    errorData.error,\r\n                    errorData.pc || defaultPC);\r\n            } else if (report.type === reportType.EVENT) {\r\n                // if we have and event to report and we failed to add\r\n                // fabric this event will not be reported anyway, returning\r\n                // an error\r\n                const eventData = report.data;\r\n\r\n                CallStats.backend.sendFabricEvent(\r\n                    report.pc || defaultPC,\r\n                    eventData.event,\r\n                    defaultConfID,\r\n                    eventData.eventData);\r\n            } else if (report.type === reportType.MST_WITH_USERID) {\r\n                const data = report.data;\r\n\r\n                CallStats.backend.associateMstWithUserID(\r\n                    report.pc || defaultPC,\r\n                    data.callStatsId,\r\n                    defaultConfID,\r\n                    data.ssrc,\r\n                    data.usageLabel,\r\n                    data.containerId\r\n                );\r\n            }\r\n        }\r\n        CallStats.reportsQueue.length = 0;\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n    /**\r\n     * Reports an error to callstats.\r\n     *\r\n     * @param {CallStats} [cs]\r\n     * @param type the type of the error, which will be one of the wrtcFuncNames\r\n     * @param error the error\r\n     * @param pc the peerconnection\r\n     * @private\r\n     */\r\n    static _reportError(cs, type, error, pc) {\r\n        let _error = error;\r\n\r\n        if (!_error) {\r\n            logger.warn('No error is passed!');\r\n            _error = new Error('Unknown error');\r\n        }\r\n        if (CallStats.backendInitialized && cs) {\r\n            CallStats.backend.reportError(pc, cs.confID, type, _error);\r\n        } else {\r\n            CallStats.reportsQueue.push({\r\n                type: reportType.ERROR,\r\n                data: {\r\n                    error: _error,\r\n                    pc,\r\n                    type\r\n                }\r\n            });\r\n        }\r\n\r\n        // else just ignore it\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Reports an error to callstats.\r\n     *\r\n     * @param {CallStats} cs\r\n     * @param event the type of the event, which will be one of the fabricEvent\r\n     * @param eventData additional data to pass to event\r\n     * @private\r\n     */\r\n    static _reportEvent(cs, event, eventData) {\r\n        const pc = cs && cs.peerconnection;\r\n        const confID = cs && cs.confID;\r\n\r\n        if (CallStats.backendInitialized && cs) {\r\n            CallStats.backend.sendFabricEvent(pc, event, confID, eventData);\r\n        } else {\r\n            CallStats.reportsQueue.push({\r\n                confID,\r\n                pc,\r\n                type: reportType.EVENT,\r\n                data: { event,\r\n                    eventData }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wraps some of the CallStats API method and logs their calls with\r\n     * arguments on the debug logging level. Also wraps some of the backend\r\n     * methods execution into try catch blocks to not crash the app in case\r\n     * there is a problem with the backend itself.\r\n     * @param {callstats} theBackend\r\n     * @private\r\n     */\r\n    static _traceAndCatchBackendCalls(theBackend) {\r\n        const tryCatchMethods = [\r\n            'associateMstWithUserID',\r\n            'sendFabricEvent',\r\n            'sendUserFeedback'\r\n\r\n            // 'reportError', - this one needs special handling - see code below\r\n        ];\r\n\r\n        for (const methodName of tryCatchMethods) {\r\n            const originalMethod = theBackend[methodName];\r\n\r\n            theBackend[methodName] = function(...theArguments) {\r\n                try {\r\n                    return originalMethod.apply(theBackend, theArguments);\r\n                } catch (e) {\r\n                    GlobalOnErrorHandler.callErrorHandler(e);\r\n                }\r\n            };\r\n        }\r\n        const debugMethods = [\r\n            'associateMstWithUserID',\r\n            'sendFabricEvent',\r\n            'sendUserFeedback'\r\n\r\n            // 'reportError', - this one needs special handling - see code below\r\n        ];\r\n\r\n        for (const methodName of debugMethods) {\r\n            const originalMethod = theBackend[methodName];\r\n\r\n            theBackend[methodName] = function(...theArguments) {\r\n                logger.debug(methodName, theArguments);\r\n                originalMethod.apply(theBackend, theArguments);\r\n            };\r\n        }\r\n        const originalReportError = theBackend.reportError;\r\n\r\n        /* eslint-disable max-params */\r\n        theBackend.reportError = function(pc, cs, type, ...args) {\r\n            // Logs from the logger are submitted on the applicationLog event\r\n            // \"type\". Logging the arguments on the logger will create endless\r\n            // loop, because it will put all the logs to the logger queue again.\r\n            if (type === wrtcFuncNames.applicationLog) {\r\n                // NOTE otherArguments are not logged to the console on purpose\r\n                // to not log the whole log batch\r\n                // FIXME check the current logging level (currently not exposed\r\n                // by the logger implementation)\r\n                // NOTE it is not safe to log whole objects on react-native as\r\n                // those contain too many circular references and may crash\r\n                // the app.\r\n                if (!browser.isReactNative()) {\r\n                    console && console.debug('reportError', pc, cs, type);\r\n                }\r\n            } else {\r\n                logger.debug('reportError', pc, cs, type, ...args);\r\n            }\r\n            try {\r\n                originalReportError.call(theBackend, pc, cs, type, ...args);\r\n            } catch (exception) {\r\n                if (type === wrtcFuncNames.applicationLog) {\r\n                    console && console.error('reportError', exception);\r\n                } else {\r\n                    GlobalOnErrorHandler.callErrorHandler(exception);\r\n                }\r\n            }\r\n        };\r\n\r\n        /* eslint-enable max-params */\r\n    }\r\n\r\n    /**\r\n     * Returns the Set with the currently existing {@link CallStats} instances.\r\n     * Lazily initializes the Set to allow any Set polyfills to be applied.\r\n     * @type {Set<CallStats>}\r\n     */\r\n    static get fabrics() {\r\n        if (!_fabrics) {\r\n            _fabrics = new Set();\r\n        }\r\n\r\n        return _fabrics;\r\n    }\r\n\r\n    /**\r\n     * Initializes the CallStats backend. Should be called only if\r\n     * {@link CallStats.isBackendInitialized} returns <tt>false</tt>.\r\n     * @param {object} options\r\n     * @param {String} options.callStatsID CallStats credentials - ID\r\n     * @param {String} options.callStatsSecret CallStats credentials - secret\r\n     * @param {string} options.aliasName the <tt>aliasName</tt> part of\r\n     * the <tt>userID</tt> aka endpoint ID, see CallStats docs for more info.\r\n     * @param {string} options.userName the <tt>userName</tt> part of\r\n     * the <tt>userID</tt> aka display name, see CallStats docs for more info.\r\n     *\r\n     */\r\n    static initBackend(options) {\r\n        if (CallStats.backend) {\r\n            throw new Error('CallStats backend has been initialized already!');\r\n        }\r\n        try {\r\n            const CallStatsBackend = callstats;\r\n\r\n            CallStats.backend = new CallStatsBackend();\r\n            CallStats._traceAndCatchBackendCalls(CallStats.backend);\r\n            CallStats.userID = {\r\n                aliasName: options.aliasName,\r\n                userName: options.userName\r\n            };\r\n            CallStats.callStatsID = options.callStatsID;\r\n            CallStats.callStatsSecret = options.callStatsSecret;\r\n\r\n            let configParams;\r\n\r\n            if (options.applicationName) {\r\n                configParams = {\r\n                    applicationVersion:\r\n                        `${options.applicationName} (${\r\n                            browser.getName()})`\r\n                };\r\n            }\r\n\r\n            if (options.confID) {\r\n                // we first check is there a tenant in the confID\r\n                const match = options.confID.match(/.*\\/(.*)\\/.*/);\r\n\r\n                // if there is no tenant, we will just set '/'\r\n                configParams.siteID = (match && match[1]) || '/';\r\n            }\r\n\r\n            // userID is generated or given by the origin server\r\n            CallStats.backend.initialize(\r\n                CallStats.callStatsID,\r\n                CallStats.callStatsSecret,\r\n                CallStats.userID,\r\n                CallStats._initCallback,\r\n                undefined,\r\n                configParams);\r\n\r\n            const getWiFiStatsMethod = options.getWiFiStatsMethod;\r\n\r\n            if (getWiFiStatsMethod) {\r\n                CallStats.backend.attachWifiStatsHandler(getWiFiStatsMethod);\r\n\r\n                getWiFiStatsMethod().then(result => {\r\n                    if (result) {\r\n                        logger.info('Reported wifi addresses:'\r\n                            , JSON.parse(result).addresses);\r\n                    }\r\n                })\r\n                .catch(() => {});// eslint-disable-line no-empty-function\r\n            }\r\n\r\n            return true;\r\n        } catch (e) {\r\n            // The callstats.io API failed to initialize (e.g. because its\r\n            // download did not succeed in general or on time). Further attempts\r\n            // to utilize it cannot possibly succeed.\r\n            GlobalOnErrorHandler.callErrorHandler(e);\r\n            CallStats.backend = null;\r\n            logger.error(e);\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the CallStats backend has been created. It does not mean that\r\n     * it has been initialized, but only that the API instance has been\r\n     * allocated successfully.\r\n     * @return {boolean} <tt>true</tt> if backend exists or <tt>false</tt>\r\n     * otherwise\r\n     */\r\n    static isBackendInitialized() {\r\n        return Boolean(CallStats.backend);\r\n    }\r\n\r\n    /**\r\n     * Notifies CallStats about active device.\r\n     * @param {{deviceList: {String:String}}} devicesData list of devices with\r\n     * their data\r\n     * @param {CallStats} cs callstats instance related to the event\r\n     */\r\n    static sendActiveDeviceListEvent(devicesData, cs) {\r\n        CallStats._reportEvent(cs, fabricEvent.activeDeviceList, devicesData);\r\n    }\r\n\r\n    /**\r\n     * Notifies CallStats that there is a log we want to report.\r\n     *\r\n     * @param {Error} e error to send or {String} message\r\n     * @param {CallStats} cs callstats instance related to the error (optional)\r\n     */\r\n    static sendApplicationLog(e, cs) {\r\n        try {\r\n            CallStats._reportError(\r\n                cs,\r\n                wrtcFuncNames.applicationLog,\r\n                e,\r\n                cs && cs.peerconnection);\r\n        } catch (error) {\r\n            // If sendApplicationLog fails it should not be printed to\r\n            // the logger, because it will try to push the logs again\r\n            // (through sendApplicationLog) and an endless loop is created.\r\n            if (console && (typeof console.error === 'function')) {\r\n                // FIXME send analytics event as well\r\n                console.error('sendApplicationLog failed', error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends the given feedback through CallStats.\r\n     *\r\n     * @param {string} conferenceID the conference ID for which the feedback\r\n     * will be reported.\r\n     * @param overall an integer between 1 and 5 indicating the\r\n     * user feedback\r\n     * @param comment detailed feedback from the user.\r\n     */\r\n    static sendFeedback(conferenceID, overall, comment) {\r\n        if (CallStats.backend) {\r\n            CallStats.backend.sendUserFeedback(\r\n                conferenceID, {\r\n                    userID: CallStats.userID,\r\n                    overall,\r\n                    comment\r\n                });\r\n        } else {\r\n            logger.error('Failed to submit feedback to CallStats - no backend');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Notifies CallStats that getUserMedia failed.\r\n     *\r\n     * @param {Error} e error to send\r\n     * @param {CallStats} cs callstats instance related to the error (optional)\r\n     */\r\n    static sendGetUserMediaFailed(e, cs) {\r\n        CallStats._reportError(cs, wrtcFuncNames.getUserMedia, e, null);\r\n    }\r\n\r\n    /**\r\n     * Notifies CallStats for mute events\r\n     * @param mute {boolean} true for muted and false for not muted\r\n     * @param type {String} \"audio\"/\"video\"\r\n     * @param {CallStats} cs callstats instance related to the event\r\n     */\r\n    static sendMuteEvent(mute, type, cs) {\r\n        let event;\r\n\r\n        if (type === 'video') {\r\n            event = mute ? fabricEvent.videoPause : fabricEvent.videoResume;\r\n        } else {\r\n            event = mute ? fabricEvent.audioMute : fabricEvent.audioUnmute;\r\n        }\r\n\r\n        CallStats._reportEvent(cs, event);\r\n    }\r\n\r\n    /**\r\n     * Creates new CallStats instance that handles all callstats API calls for\r\n     * given {@link TraceablePeerConnection}. Each instance is meant to handle\r\n     * one CallStats fabric added with 'addFabric' API method for the\r\n     * {@link TraceablePeerConnection} instance passed in the constructor.\r\n     * @param {TraceablePeerConnection} tpc\r\n     * @param {Object} options\r\n     * @param {string} options.confID the conference ID that wil be used to\r\n     * report the session.\r\n     * @param {string} [options.remoteUserID='qhsense'] the remote user ID to\r\n     * which given <tt>tpc</tt> is connected.\r\n     */\r\n    constructor(tpc, options) {\r\n        this.confID = options.confID;\r\n        this.tpc = tpc;\r\n        this.peerconnection = tpc.peerconnection;\r\n        this.remoteUserID = options.remoteUserID || DEFAULT_REMOTE_USER;\r\n        this.hasFabric = false;\r\n\r\n        CallStats.fabrics.add(this);\r\n\r\n        if (CallStats.backendInitialized) {\r\n            this._addNewFabric();\r\n\r\n            // if this is the first fabric let's try to empty the\r\n            // report queue. Reports all events that we recorded between\r\n            // backend initialization and receiving the first fabric\r\n            if (CallStats.fabrics.size === 1) {\r\n                CallStats._emptyReportQueue(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes CallStats fabric by calling \"addNewFabric\" for\r\n     * the peer connection associated with this instance.\r\n     * @return {boolean} true if the call was successful or false otherwise.\r\n     */\r\n    _addNewFabric() {\r\n        logger.info('addNewFabric', this.remoteUserID);\r\n        try {\r\n            const fabricAttributes = {\r\n                remoteEndpointType:\r\n                    this.tpc.isP2P\r\n                        ? CallStats.backend.endpointType.peer\r\n                        : CallStats.backend.endpointType.server\r\n            };\r\n            const ret\r\n                = CallStats.backend.addNewFabric(\r\n                    this.peerconnection,\r\n                    this.remoteUserID,\r\n                    CallStats.backend.fabricUsage.multiplex,\r\n                    this.confID,\r\n                    fabricAttributes,\r\n                    CallStats._addNewFabricCallback);\r\n\r\n            this.hasFabric = true;\r\n\r\n            const success = ret.status === 'success';\r\n\r\n            if (!success) {\r\n                logger.error('callstats fabric not initilized', ret.message);\r\n            }\r\n\r\n            return success;\r\n\r\n        } catch (error) {\r\n            GlobalOnErrorHandler.callErrorHandler(error);\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n\r\n    /**\r\n     * Lets CallStats module know where is given SSRC rendered by providing\r\n     * renderer tag ID.\r\n     * If the lib is not initialized yet queue the call for later, when it's\r\n     * ready.\r\n     * @param {number} ssrc the SSRC of the stream\r\n     * @param {boolean} isLocal indicates whether this the stream is local\r\n     * @param {string|null} streamEndpointId if the stream is not local the it\r\n     * needs to contain the stream owner's ID\r\n     * @param {string} usageLabel meaningful usage label of this stream like\r\n     *        'microphone', 'camera' or 'screen'.\r\n     * @param {string} containerId  the id of media 'audio' or 'video' tag which\r\n     *        renders the stream.\r\n     */\r\n    associateStreamWithVideoTag(\r\n            ssrc,\r\n            isLocal,\r\n            streamEndpointId,\r\n            usageLabel,\r\n            containerId) {\r\n        if (!CallStats.backend) {\r\n            return;\r\n        }\r\n\r\n        const callStatsId = isLocal ? CallStats.userID : streamEndpointId;\r\n\r\n        if (CallStats.backendInitialized) {\r\n            CallStats.backend.associateMstWithUserID(\r\n                this.peerconnection,\r\n                callStatsId,\r\n                this.confID,\r\n                ssrc,\r\n                usageLabel,\r\n                containerId);\r\n        } else {\r\n            CallStats.reportsQueue.push({\r\n                type: reportType.MST_WITH_USERID,\r\n                pc: this.peerconnection,\r\n                data: {\r\n                    callStatsId,\r\n                    containerId,\r\n                    ssrc,\r\n                    usageLabel\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Notifies CallStats that we are the new dominant speaker in the\r\n     * conference.\r\n     */\r\n    sendDominantSpeakerEvent() {\r\n        CallStats._reportEvent(this, fabricEvent.dominantSpeaker);\r\n    }\r\n\r\n    /**\r\n     * Notifies CallStats that the fabric for the underlying peerconnection was\r\n     * closed and no evens should be reported, after this call.\r\n     */\r\n    sendTerminateEvent() {\r\n        if (CallStats.backendInitialized) {\r\n            CallStats.backend.sendFabricEvent(\r\n                this.peerconnection,\r\n                CallStats.backend.fabricEvent.fabricTerminated,\r\n                this.confID);\r\n        }\r\n        CallStats.fabrics.delete(this);\r\n    }\r\n\r\n    /**\r\n     * Notifies CallStats for ice connection failed\r\n     */\r\n    sendIceConnectionFailedEvent() {\r\n        CallStats._reportError(\r\n            this,\r\n            wrtcFuncNames.iceConnectionFailure,\r\n            null,\r\n            this.peerconnection);\r\n    }\r\n\r\n    /**\r\n     * Notifies CallStats that peer connection failed to create offer.\r\n     *\r\n     * @param {Error} e error to send\r\n     */\r\n    sendCreateOfferFailed(e) {\r\n        CallStats._reportError(\r\n            this, wrtcFuncNames.createOffer, e, this.peerconnection);\r\n    }\r\n\r\n    /**\r\n     * Notifies CallStats that peer connection failed to create answer.\r\n     *\r\n     * @param {Error} e error to send\r\n     */\r\n    sendCreateAnswerFailed(e) {\r\n        CallStats._reportError(\r\n            this, wrtcFuncNames.createAnswer, e, this.peerconnection);\r\n    }\r\n\r\n    /**\r\n     * Sends either resume or hold event for the fabric associated with\r\n     * the underlying peerconnection.\r\n     * @param {boolean} isResume true to resume or false to hold\r\n     */\r\n    sendResumeOrHoldEvent(isResume) {\r\n        CallStats._reportEvent(\r\n            this,\r\n            isResume ? fabricEvent.fabricResume : fabricEvent.fabricHold);\r\n    }\r\n\r\n    /**\r\n     * Notifies CallStats for screen sharing events\r\n     * @param {boolean} start true for starting screen sharing and\r\n     * false for not stopping\r\n     * @param {string|null} ssrc - optional ssrc value, used only when\r\n     * starting screen sharing.\r\n     */\r\n    sendScreenSharingEvent(start, ssrc) {\r\n        let eventData;\r\n\r\n        if (ssrc) {\r\n            eventData = { ssrc };\r\n        }\r\n\r\n        CallStats._reportEvent(\r\n            this,\r\n            start ? fabricEvent.screenShareStart : fabricEvent.screenShareStop,\r\n            eventData);\r\n    }\r\n\r\n    /**\r\n     * Notifies CallStats that peer connection failed to set local description.\r\n     *\r\n     * @param {Error} e error to send\r\n     */\r\n    sendSetLocalDescFailed(e) {\r\n        CallStats._reportError(\r\n            this, wrtcFuncNames.setLocalDescription, e, this.peerconnection);\r\n    }\r\n\r\n    /**\r\n     * Notifies CallStats that peer connection failed to set remote description.\r\n     *\r\n     * @param {Error} e error to send\r\n     */\r\n    sendSetRemoteDescFailed(e) {\r\n        CallStats._reportError(\r\n            this, wrtcFuncNames.setRemoteDescription, e, this.peerconnection);\r\n    }\r\n\r\n    /**\r\n     * Notifies CallStats that peer connection failed to add ICE candidate.\r\n     *\r\n     * @param {Error} e error to send\r\n     */\r\n    sendAddIceCandidateFailed(e) {\r\n        CallStats._reportError(\r\n            this, wrtcFuncNames.addIceCandidate, e, this.peerconnection);\r\n    }\r\n}\r\n\r\n/**\r\n * The CallStats API backend instance\r\n * @type {callstats}\r\n */\r\nCallStats.backend = null;\r\n\r\n// some errors/events may happen before CallStats init\r\n// in this case we accumulate them in this array\r\n// and send them to callstats on init\r\nCallStats.reportsQueue = [];\r\n\r\n/**\r\n * Whether the library was successfully initialized(the backend) using its\r\n * initialize method.\r\n * @type {boolean}\r\n */\r\nCallStats.backendInitialized = false;\r\n\r\n/**\r\n * Part of the CallStats credentials - application ID\r\n * @type {string}\r\n */\r\nCallStats.callStatsID = null;\r\n\r\n/**\r\n * Part of the CallStats credentials - application secret\r\n * @type {string}\r\n */\r\nCallStats.callStatsSecret = null;\r\n\r\n/**\r\n * Local CallStats user ID structure. Can be set only once when\r\n * {@link backend} is initialized, so it's static for the time being.\r\n * See CallStats API for more info:\r\n * https://www.callstats.io/api/#userid\r\n * @type {object}\r\n */\r\nCallStats.userID = null;\r\n","/**\r\n * Indicates that the local connection statistics were updated.\r\n */\r\nexport const LOCAL_STATS_UPDATED = 'cq.local_stats_updated';\r\n\r\n/**\r\n * Indicates that the connection statistics for a particular remote participant\r\n * were updated.\r\n */\r\nexport const REMOTE_STATS_UPDATED = 'cq.remote_stats_updated';\r\n","/**\r\n * @const\r\n */\r\nconst ALPHANUM\r\n    = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n\r\n/**\r\n * Hexadecimal digits.\r\n * @const\r\n */\r\nconst HEX_DIGITS = '0123456789abcdef';\r\n\r\n/**\r\n * Generates random int within the range [min, max]\r\n * @param min the minimum value for the generated number\r\n * @param max the maximum value for the generated number\r\n * @returns random int number\r\n */\r\nfunction randomInt(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\n/**\r\n * Get random element from array or string.\r\n * @param {Array|string} arr source\r\n * @returns array element or string character\r\n */\r\nfunction randomElement(arr) {\r\n    return arr[randomInt(0, arr.length - 1)];\r\n}\r\n\r\n/**\r\n * Generate random alphanumeric string.\r\n * @param {number} length expected string length\r\n * @returns {string} random string of specified length\r\n */\r\nfunction randomAlphanumStr(length) {\r\n    let result = '';\r\n\r\n    for (let i = 0; i < length; i += 1) {\r\n        result += randomElement(ALPHANUM);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Exported interface.\r\n */\r\nconst RandomUtil = {\r\n    /**\r\n     * Returns a random hex digit.\r\n     * @returns {*}\r\n     */\r\n    randomHexDigit() {\r\n        return randomElement(HEX_DIGITS);\r\n    },\r\n\r\n    /**\r\n     * Returns a random string of hex digits with length 'len'.\r\n     * @param len the length.\r\n     */\r\n    randomHexString(len) {\r\n        let ret = '';\r\n\r\n        while (len--) { // eslint-disable-line no-param-reassign\r\n            ret += this.randomHexDigit();\r\n        }\r\n\r\n        return ret;\r\n    },\r\n    randomElement,\r\n    randomAlphanumStr,\r\n    randomInt\r\n};\r\n\r\nmodule.exports = RandomUtil;\r\n","import Listenable from '../util/Listenable';\r\n\r\n/**\r\n * Creates ConnectionPlugin class that extends the passed class.\r\n * @param {Class} base the definition of the class that will be extended by\r\n * ConnectionPlugin\r\n */\r\nfunction getConnectionPluginDefinition(base = class {}) {\r\n    /**\r\n     * Base class for strophe connection plugins.\r\n     */\r\n    return class extends base {\r\n        /**\r\n         *\r\n         */\r\n        constructor(...args) {\r\n            super(...args);\r\n            this.connection = null;\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param connection\r\n         */\r\n        init(connection) {\r\n            this.connection = connection;\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * ConnectionPlugin class.\r\n */\r\nexport default getConnectionPluginDefinition();\r\n\r\n/**\r\n * ConnectionPlugin class that extends Listenable.\r\n */\r\nexport const ConnectionPluginListenable\r\n    = getConnectionPluginDefinition(Listenable);\r\n","/* global $ */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport { $msg, Strophe } from 'strophe.js';\r\nimport 'strophejs-plugin-disco';\r\n\r\nimport RandomUtil from '../util/RandomUtil';\r\nimport * as QHSenseConnectionErrors from '../../QHSenseConnectionErrors';\r\nimport * as QHSenseConnectionEvents from '../../QHSenseConnectionEvents';\r\nimport browser from '../browser';\r\nimport initEmuc from './strophe.emuc';\r\nimport initJingle from './strophe.jingle';\r\nimport initStropheUtil from './strophe.util';\r\nimport initPing from './strophe.ping';\r\nimport initRayo from './strophe.rayo';\r\nimport initStropheLogger from './strophe.logger';\r\nimport LastSuccessTracker from './StropheBoshLastSuccess';\r\nimport Listenable from '../util/Listenable';\r\nimport Caps from './Caps';\r\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\r\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n *\r\n * @param token\r\n * @param bosh\r\n */\r\nfunction createConnection(token, bosh = '/http-bind') {\r\n    // Append token as URL param\r\n    if (token) {\r\n        // eslint-disable-next-line no-param-reassign\r\n        bosh += `${bosh.indexOf('?') === -1 ? '?' : '&'}token=${token}`;\r\n    }\r\n\r\n    const conn = new Strophe.Connection(bosh);\r\n\r\n    // The default maxRetries is 5, which is too long.\r\n    conn.maxRetries = 3;\r\n\r\n    return conn;\r\n}\r\n\r\n// FIXME: remove once we have a default config template. -saghul\r\n/**\r\n * A list of ice servers to use by default for P2P.\r\n */\r\nexport const DEFAULT_STUN_SERVERS = [\r\n    { urls: 'stun:stun.l.google.com:19302' },\r\n    { urls: 'stun:stun1.l.google.com:19302' },\r\n    { urls: 'stun:stun2.l.google.com:19302' }\r\n];\r\n\r\n/**\r\n * The name of the field used to recognize a chat message as carrying a JSON\r\n * payload from another endpoint.\r\n * If the json-message of a chat message contains a valid JSON object, and\r\n * the JSON has this key, then it is a valid json-message to be sent.\r\n */\r\nexport const QHSENSE_MEET_MUC_TYPE = 'type';\r\n\r\n/**\r\n *\r\n */\r\nexport default class XMPP extends Listenable {\r\n    /**\r\n     * FIXME describe all options\r\n     * @param {Object} options\r\n     * @param {Array<Object>} options.p2pStunServers see\r\n     * {@link JingleConnectionPlugin} for more details.\r\n     * @param token\r\n     */\r\n    constructor(options, token) {\r\n        super();\r\n        this.connection = null;\r\n        this.disconnectInProgress = false;\r\n        this.connectionTimes = {};\r\n        this.options = options;\r\n        this.token = token;\r\n        this.authenticatedUser = false;\r\n        this._initStrophePlugins(this);\r\n\r\n        this.connection = createConnection(token, options.bosh);\r\n\r\n        this._lastSuccessTracker = new LastSuccessTracker();\r\n        this._lastSuccessTracker.startTracking(this.connection);\r\n\r\n        this.caps = new Caps(this.connection, this.options.clientNode);\r\n\r\n        // Initialize features advertised in disco-info\r\n        this.initFeaturesList();\r\n\r\n        // Setup a disconnect on unload as a way to facilitate API consumers. It\r\n        // sounds like they would want that. A problem for them though may be if\r\n        // they wanted to utilize the connected connection in an unload handler\r\n        // of their own. However, it should be fairly easy for them to do that\r\n        // by registering their unload handler before us.\r\n        $(window).on('beforeunload unload', ev => {\r\n            this.disconnect(ev).catch(() => {\r\n                // ignore errors in order to not brake the unload.\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Initializes the list of feature advertised through the disco-info\r\n     * mechanism.\r\n     */\r\n    initFeaturesList() {\r\n        // http://xmpp.org/extensions/xep-0167.html#support\r\n        // http://xmpp.org/extensions/xep-0176.html#support\r\n        this.caps.addFeature('urn:xmpp:jingle:1');\r\n        this.caps.addFeature('urn:xmpp:jingle:apps:rtp:1');\r\n        this.caps.addFeature('urn:xmpp:jingle:transports:ice-udp:1');\r\n        this.caps.addFeature('urn:xmpp:jingle:apps:dtls:0');\r\n        this.caps.addFeature('urn:xmpp:jingle:transports:dtls-sctp:1');\r\n        this.caps.addFeature('urn:xmpp:jingle:apps:rtp:audio');\r\n        this.caps.addFeature('urn:xmpp:jingle:apps:rtp:video');\r\n\r\n        if (!this.options.disableRtx && browser.supportsRtx()) {\r\n            this.caps.addFeature('urn:ietf:rfc:4588');\r\n        }\r\n\r\n        // this is dealt with by SDP O/A so we don't need to announce this\r\n        // XEP-0293\r\n        // this.caps.addFeature('urn:xmpp:jingle:apps:rtp:rtcp-fb:0');\r\n        // XEP-0294\r\n        // this.caps.addFeature('urn:xmpp:jingle:apps:rtp:rtp-hdrext:0');\r\n\r\n        this.caps.addFeature('urn:ietf:rfc:5761'); // rtcp-mux\r\n        this.caps.addFeature('urn:ietf:rfc:5888'); // a=group, e.g. bundle\r\n\r\n        // this.caps.addFeature('urn:ietf:rfc:5576'); // a=ssrc\r\n\r\n        // Enable Lipsync ?\r\n        if (browser.isChrome() && this.options.enableLipSync !== false) {\r\n            logger.info('Lip-sync enabled !');\r\n            this.caps.addFeature('http://jitsi.org/meet/lipsync');\r\n        }\r\n\r\n        if (this.connection.rayo) {\r\n            this.caps.addFeature('urn:xmpp:rayo:client:1');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns {@code true} if the PING functionality is supported by the server\r\n     * or {@code false} otherwise.\r\n     * @returns {boolean}\r\n     */\r\n    isPingSupported() {\r\n        return this._pingSupported !== false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    getConnection() {\r\n        return this.connection;\r\n    }\r\n\r\n    /**\r\n     * Receive connection status changes and handles them.\r\n     *\r\n     * @param {Object} credentials\r\n     * @param {string} credentials.jid - The user's XMPP ID passed to the\r\n     * connect method. For example, 'user@xmpp.com'.\r\n     * @param {string} credentials.password - The password passed to the connect\r\n     * method.\r\n     * @param {string} status - One of Strophe's connection status strings.\r\n     * @param {string} [msg] - The connection error message provided by Strophe.\r\n     */\r\n    connectionHandler(credentials = {}, status, msg) {\r\n        const now = window.performance.now();\r\n        const statusStr = Strophe.getStatusString(status).toLowerCase();\r\n\r\n        this.connectionTimes[statusStr] = now;\r\n        logger.log(\r\n            `(TIME) Strophe ${statusStr}${msg ? `[${msg}]` : ''}:\\t`,\r\n            now);\r\n\r\n        this.eventEmitter.emit(XMPPEvents.CONNECTION_STATUS_CHANGED, credentials, status, msg);\r\n        if (status === Strophe.Status.CONNECTED\r\n            || status === Strophe.Status.ATTACHED) {\r\n            if (this.options.useStunTurn\r\n                || (this.options.p2p && this.options.p2p.useStunTurn)) {\r\n                this.connection.jingle.getStunAndTurnCredentials();\r\n            }\r\n\r\n            logger.info(`My Jabber ID: ${this.connection.jid}`);\r\n\r\n            // Schedule ping ?\r\n            const pingJid = this.connection.domain;\r\n\r\n            this.caps.getFeaturesAndIdentities(pingJid)\r\n                .then(({ features, identities }) => {\r\n                    if (features.has(Strophe.NS.PING)) {\r\n                        this._pingSupported = true;\r\n                        this.connection.ping.startInterval(pingJid);\r\n                    } else {\r\n                        logger.warn(`Ping NOT supported by ${pingJid}`);\r\n                    }\r\n\r\n                    // check for speakerstats\r\n                    identities.forEach(identity => {\r\n                        if (identity.type === 'speakerstats') {\r\n                            this.speakerStatsComponentAddress = identity.name;\r\n\r\n                            this.connection.addHandler(\r\n                                this._onPrivateMessage.bind(this), null,\r\n                                'message', null, null);\r\n                        }\r\n                    });\r\n                })\r\n                .catch(error => {\r\n                    const errmsg = 'Feature discovery error';\r\n\r\n                    GlobalOnErrorHandler.callErrorHandler(\r\n                        new Error(`${errmsg}: ${error}`));\r\n                    logger.error(errmsg, error);\r\n                });\r\n\r\n            if (credentials.password) {\r\n                this.authenticatedUser = true;\r\n            }\r\n            if (this.connection && this.connection.connected\r\n                && Strophe.getResourceFromJid(this.connection.jid)) {\r\n                // .connected is true while connecting?\r\n                // this.connection.send($pres());\r\n                this.eventEmitter.emit(\r\n                    QHSenseConnectionEvents.CONNECTION_ESTABLISHED,\r\n                    Strophe.getResourceFromJid(this.connection.jid));\r\n            }\r\n        } else if (status === Strophe.Status.CONNFAIL) {\r\n            if (msg === 'x-strophe-bad-non-anon-jid') {\r\n                this.anonymousConnectionFailed = true;\r\n            } else {\r\n                this.connectionFailed = true;\r\n            }\r\n            this.lastErrorMsg = msg;\r\n            if (msg === 'giving-up') {\r\n                this.eventEmitter.emit(\r\n                    QHSenseConnectionEvents.CONNECTION_FAILED,\r\n                    QHSenseConnectionErrors.OTHER_ERROR, msg);\r\n            }\r\n        } else if (status === Strophe.Status.DISCONNECTED) {\r\n            // Stop ping interval\r\n            this.connection.ping.stopInterval();\r\n            const wasIntentionalDisconnect = this.disconnectInProgress;\r\n            const errMsg = msg || this.lastErrorMsg;\r\n\r\n            this.disconnectInProgress = false;\r\n            if (this.anonymousConnectionFailed) {\r\n                // prompt user for username and password\r\n                this.eventEmitter.emit(\r\n                    QHSenseConnectionEvents.CONNECTION_FAILED,\r\n                    QHSenseConnectionErrors.PASSWORD_REQUIRED);\r\n            } else if (this.connectionFailed) {\r\n                this.eventEmitter.emit(\r\n                    QHSenseConnectionEvents.CONNECTION_FAILED,\r\n                    QHSenseConnectionErrors.OTHER_ERROR,\r\n                    errMsg,\r\n                    undefined, /* credentials */\r\n                    this._getConnectionFailedReasonDetails());\r\n            } else if (wasIntentionalDisconnect) {\r\n                this.eventEmitter.emit(\r\n                    QHSenseConnectionEvents.CONNECTION_DISCONNECTED, errMsg);\r\n            } else {\r\n                // XXX if Strophe drops the connection while not being asked to,\r\n                // it means that most likely some serious error has occurred.\r\n                // One currently known case is when a BOSH request fails for\r\n                // more than 4 times. The connection is dropped without\r\n                // supplying a reason(error message/event) through the API.\r\n                logger.error('XMPP connection dropped!');\r\n\r\n                // XXX if the last request error is within 5xx range it means it\r\n                // was a server failure\r\n                const lastErrorStatus = Strophe.getLastErrorStatus();\r\n\r\n                if (lastErrorStatus >= 500 && lastErrorStatus < 600) {\r\n                    this.eventEmitter.emit(\r\n                        QHSenseConnectionEvents.CONNECTION_FAILED,\r\n                        QHSenseConnectionErrors.SERVER_ERROR,\r\n                        errMsg || 'server-error',\r\n                        /* credentials */ undefined,\r\n                        /* details */ {\r\n                            timeSinceLastSuccess: this._lastSuccessTracker.getTimeSinceLastSuccess()\r\n                        });\r\n                } else {\r\n                    this.eventEmitter.emit(\r\n                        QHSenseConnectionEvents.CONNECTION_FAILED,\r\n                        QHSenseConnectionErrors.CONNECTION_DROPPED_ERROR,\r\n                        errMsg || 'connection-dropped-error',\r\n                        /* credentials */ undefined,\r\n                        /* details */ {\r\n                            timeSinceLastSuccess: this._lastSuccessTracker.getTimeSinceLastSuccess()\r\n                        });\r\n                }\r\n            }\r\n        } else if (status === Strophe.Status.AUTHFAIL) {\r\n            // wrong password or username, prompt user\r\n            this.eventEmitter.emit(\r\n                QHSenseConnectionEvents.CONNECTION_FAILED,\r\n                QHSenseConnectionErrors.PASSWORD_REQUIRED,\r\n                msg,\r\n                credentials);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param jid\r\n     * @param password\r\n     */\r\n    _connect(jid, password) {\r\n        // connection.connect() starts the connection process.\r\n        //\r\n        // As the connection process proceeds, the user supplied callback will\r\n        // be triggered multiple times with status updates. The callback should\r\n        // take two arguments - the status code and the error condition.\r\n        //\r\n        // The status code will be one of the values in the Strophe.Status\r\n        // constants. The error condition will be one of the conditions defined\r\n        // in RFC 3920 or the condition strophe-parsererror.\r\n        //\r\n        // The Parameters wait, hold and route are optional and only relevant\r\n        // for BOSH connections. Please see XEP 124 for a more detailed\r\n        // explanation of the optional parameters.\r\n        //\r\n        // Connection status constants for use by the connection handler\r\n        // callback.\r\n        //\r\n        //  Status.ERROR - An error has occurred (websockets specific)\r\n        //  Status.CONNECTING - The connection is currently being made\r\n        //  Status.CONNFAIL - The connection attempt failed\r\n        //  Status.AUTHENTICATING - The connection is authenticating\r\n        //  Status.AUTHFAIL - The authentication attempt failed\r\n        //  Status.CONNECTED - The connection has succeeded\r\n        //  Status.DISCONNECTED - The connection has been terminated\r\n        //  Status.DISCONNECTING - The connection is currently being terminated\r\n        //  Status.ATTACHED - The connection has been attached\r\n\r\n        this.anonymousConnectionFailed = false;\r\n        this.connectionFailed = false;\r\n        this.lastErrorMsg = undefined;\r\n        this.connection.connect(\r\n            jid,\r\n            password,\r\n            this.connectionHandler.bind(this, {\r\n                jid,\r\n                password\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Attach to existing connection. Can be used for optimizations. For\r\n     * example: if the connection is created on the server we can attach to it\r\n     * and start using it.\r\n     *\r\n     * @param options {object} connecting options - rid, sid, jid and password.\r\n     */\r\n    attach(options) {\r\n        const now = this.connectionTimes.attaching = window.performance.now();\r\n\r\n        logger.log(`(TIME) Strophe Attaching\\t:${now}`);\r\n        this.connection.attach(options.jid, options.sid,\r\n            parseInt(options.rid, 10) + 1,\r\n            this.connectionHandler.bind(this, {\r\n                jid: options.jid,\r\n                password: options.password\r\n            }));\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param jid\r\n     * @param password\r\n     */\r\n    connect(jid, password) {\r\n        if (!jid) {\r\n            const { anonymousdomain, domain } = this.options.hosts;\r\n            let configDomain = anonymousdomain || domain;\r\n\r\n            // Force authenticated domain if room is appended with '?login=true'\r\n            // or if we're joining with the token\r\n\r\n            // FIXME Do not rely on window.location because (1) React Native\r\n            // does not have a window.location by default and (2) here we cannot\r\n            // know for sure that query/search has not be stripped from\r\n            // window.location by the time the following executes.\r\n            const { location } = window;\r\n\r\n            if (anonymousdomain) {\r\n                const search = location && location.search;\r\n\r\n                if ((search && search.indexOf('login=true') !== -1)\r\n                        || this.token) {\r\n                    configDomain = domain;\r\n                }\r\n            }\r\n\r\n            // eslint-disable-next-line no-param-reassign\r\n            jid = configDomain || (location && location.hostname);\r\n        }\r\n\r\n        return this._connect(jid, password);\r\n    }\r\n\r\n    /**\r\n     * Joins or creates a muc with the provided jid, created from the passed\r\n     * in room name and muc host and onCreateResource result.\r\n     *\r\n     * @param {string} roomName - The name of the muc to join.\r\n     * @param {Object} options - Configuration for how to join the muc.\r\n     * @param {Function} [onCreateResource] - Callback to invoke when a resource\r\n     * is to be added to the jid.\r\n     * @returns {Promise} Resolves with an instance of a strophe muc.\r\n     */\r\n    createRoom(roomName, options, onCreateResource) {\r\n        let roomjid = `${roomName}@${this.options.hosts.muc}/`;\r\n\r\n        const mucNickname = onCreateResource\r\n            ? onCreateResource(this.connection.jid, this.authenticatedUser)\r\n            : RandomUtil.randomHexString(8).toLowerCase();\r\n\r\n        logger.info(`JID ${this.connection.jid} using MUC nickname ${mucNickname}`);\r\n        roomjid += mucNickname;\r\n\r\n        return this.connection.emuc.createRoom(roomjid, null, options);\r\n    }\r\n\r\n    /**\r\n     * Returns the jid of the participant associated with the Strophe connection.\r\n     *\r\n     * @returns {string} The jid of the participant.\r\n     */\r\n    getJid() {\r\n        return this.connection.jid;\r\n    }\r\n\r\n    /**\r\n     * Returns the logs from strophe.jingle.\r\n     * @returns {Object}\r\n     */\r\n    getJingleLog() {\r\n        const jingle = this.connection.jingle;\r\n\r\n\r\n        return jingle ? jingle.getLog() : {};\r\n    }\r\n\r\n    /**\r\n     * Returns the logs from strophe.\r\n     */\r\n    getXmppLog() {\r\n        return (this.connection.logger || {}).log || null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    dial(...args) {\r\n        this.connection.rayo.dial(...args);\r\n    }\r\n\r\n    /**\r\n     * Pings the server. Remember to check {@link isPingSupported} before using\r\n     * this method.\r\n     * @param timeout how many ms before a timeout should occur.\r\n     * @returns {Promise} resolved on ping success and reject on an error or\r\n     * a timeout.\r\n     */\r\n    ping(timeout) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.isPingSupported()) {\r\n                this.connection.ping\r\n                    .ping(this.connection.domain, resolve, reject, timeout);\r\n            } else {\r\n                reject('PING operation is not supported by the server');\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param jid\r\n     * @param mute\r\n     */\r\n    setMute(jid, mute) {\r\n        this.connection.moderate.setMute(jid, mute);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param jid\r\n     */\r\n    eject(jid) {\r\n        this.connection.moderate.eject(jid);\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    getSessions() {\r\n        return this.connection.jingle.sessions;\r\n    }\r\n\r\n    /**\r\n     * Disconnects this from the XMPP server (if this is connected).\r\n     *\r\n     * @param {Object} ev - Optionally, the event which triggered the necessity to\r\n     * disconnect from the XMPP server (e.g. beforeunload, unload).\r\n     * @returns {Promise} - Resolves when the disconnect process is finished or rejects with an error.\r\n     */\r\n    disconnect(ev) {\r\n        if (this.disconnectInProgress || !this.connection) {\r\n            this.eventEmitter.emit(QHSenseConnectionEvents.WRONG_STATE);\r\n\r\n            return Promise.reject(new Error('Wrong connection state!'));\r\n        }\r\n\r\n        this.disconnectInProgress = true;\r\n\r\n        return new Promise(resolve => {\r\n            const disconnectListener = (credentials, status) => {\r\n                if (status === Strophe.Status.DISCONNECTED) {\r\n                    resolve();\r\n                    this.eventEmitter.removeListener(XMPPEvents.CONNECTION_STATUS_CHANGED, disconnectListener);\r\n                }\r\n            };\r\n\r\n            this.eventEmitter.on(XMPPEvents.CONNECTION_STATUS_CHANGED, disconnectListener);\r\n\r\n            // XXX Strophe is asynchronously sending by default. Unfortunately, that\r\n            // means that there may not be enough time to send an unavailable\r\n            // presence or disconnect at all. Switching Strophe to synchronous\r\n            // sending is not much of an option because it may lead to a noticeable\r\n            // delay in navigating away from the current location. As a compromise,\r\n            // we will try to increase the chances of sending an unavailable\r\n            // presence and/or disconecting within the short time span that we have\r\n            // upon unloading by invoking flush() on the connection. We flush() once\r\n            // before disconnect() in order to attemtp to have its unavailable\r\n            // presence at the top of the send queue. We flush() once more after\r\n            // disconnect() in order to attempt to have its unavailable presence\r\n            // sent as soon as possible.\r\n            this.connection.flush();\r\n\r\n            if (ev !== null && typeof ev !== 'undefined') {\r\n                const evType = ev.type;\r\n\r\n                if (evType === 'beforeunload' || evType === 'unload') {\r\n                    // XXX Whatever we said above, synchronous sending is the best\r\n                    // (known) way to properly disconnect from the XMPP server.\r\n                    // Consequently, it may be fine to have the source code and\r\n                    // comment it in or out depending on whether we want to run with\r\n                    // it for some time.\r\n                    this.connection.options.sync = true;\r\n                }\r\n            }\r\n\r\n            this.connection.disconnect();\r\n\r\n            if (this.connection.options.sync !== true) {\r\n                this.connection.flush();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    _initStrophePlugins() {\r\n        const iceConfig = {\r\n            jvb: { iceServers: [ ] },\r\n            p2p: { iceServers: [ ] }\r\n        };\r\n\r\n        const p2pStunServers = (this.options.p2p\r\n            && this.options.p2p.stunServers) || DEFAULT_STUN_SERVERS;\r\n\r\n        if (Array.isArray(p2pStunServers)) {\r\n            logger.info('P2P STUN servers: ', p2pStunServers);\r\n            iceConfig.p2p.iceServers = p2pStunServers;\r\n        }\r\n\r\n        if (this.options.p2p && this.options.p2p.iceTransportPolicy) {\r\n            logger.info('P2P ICE transport policy: ',\r\n                this.options.p2p.iceTransportPolicy);\r\n\r\n            iceConfig.p2p.iceTransportPolicy\r\n                = this.options.p2p.iceTransportPolicy;\r\n        }\r\n\r\n        initEmuc(this);\r\n        initJingle(this, this.eventEmitter, iceConfig);\r\n        initStropheUtil();\r\n        initPing(this);\r\n        initRayo();\r\n        initStropheLogger();\r\n    }\r\n\r\n    /**\r\n     * Returns details about connection failure. Shard change or is it after\r\n     * suspend.\r\n     * @returns {object} contains details about a connection failure.\r\n     * @private\r\n     */\r\n    _getConnectionFailedReasonDetails() {\r\n        const details = {};\r\n\r\n        // check for moving between shard if information is available\r\n        if (this.options.deploymentInfo\r\n            && this.options.deploymentInfo.shard\r\n            && this.connection._proto\r\n            && this.connection._proto.lastResponseHeaders) {\r\n\r\n            // split headers by line\r\n            const headersArr = this.connection._proto.lastResponseHeaders\r\n                .trim().split(/[\\r\\n]+/);\r\n            const headers = {};\r\n\r\n            headersArr.forEach(line => {\r\n                const parts = line.split(': ');\r\n                const header = parts.shift();\r\n                const value = parts.join(': ');\r\n\r\n                headers[header] = value;\r\n            });\r\n\r\n            /* eslint-disable camelcase */\r\n            details.shard_changed\r\n                = this.options.deploymentInfo.shard\r\n                    !== headers['x-qhsense-shard'];\r\n            /* eslint-enable camelcase */\r\n        }\r\n\r\n        /* eslint-disable camelcase */\r\n        // check for possible suspend\r\n        details.suspend_time = this.connection.ping.getPingSuspendTime();\r\n        /* eslint-enable camelcase */\r\n\r\n        return details;\r\n    }\r\n\r\n    /**\r\n     * Notifies speaker stats component if available that we are the new\r\n     * dominant speaker in the conference.\r\n     * @param {String} roomJid - The room jid where the speaker event occurred.\r\n     */\r\n    sendDominantSpeakerEvent(roomJid) {\r\n        // no speaker stats component advertised\r\n        if (!this.speakerStatsComponentAddress || !roomJid) {\r\n            return;\r\n        }\r\n\r\n        const msg = $msg({ to: this.speakerStatsComponentAddress });\r\n\r\n        msg.c('speakerstats', {\r\n            xmlns: 'http://jitsi.org/jitmeet',\r\n            room: roomJid })\r\n            .up();\r\n\r\n        this.connection.send(msg);\r\n    }\r\n\r\n    /**\r\n     * Check if the given argument is a valid JSON ENDPOINT_MESSAGE string by\r\n     * parsing it and checking if it has a field called 'type'.\r\n     *\r\n     * @param {string} jsonString check if this string is a valid json string\r\n     * and contains the special structure.\r\n     * @returns {boolean, object} if given object is a valid JSON string, return\r\n     * the json object. Otherwise, returns false.\r\n     */\r\n    tryParseJSONAndVerify(jsonString) {\r\n        try {\r\n            const json = JSON.parse(jsonString);\r\n\r\n            // Handle non-exception-throwing cases:\r\n            // Neither JSON.parse(false) or JSON.parse(1234) throw errors,\r\n            // hence the type-checking,\r\n            // but... JSON.parse(null) returns null, and\r\n            // typeof null === \"object\",\r\n            // so we must check for that, too.\r\n            // Thankfully, null is falsey, so this suffices:\r\n            if (json && typeof json === 'object') {\r\n                const type = json[QHSENSE_MEET_MUC_TYPE];\r\n\r\n                if (typeof type !== 'undefined') {\r\n                    return json;\r\n                }\r\n\r\n                logger.debug('parsing valid json but does not have correct '\r\n                    + 'structure', 'topic: ', type);\r\n            }\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * A private message is received, message that is not addressed to the muc.\r\n     * We expect private message coming from speaker stats component if it is\r\n     * enabled and running.\r\n     *\r\n     * @param {string} msg - The message.\r\n     */\r\n    _onPrivateMessage(msg) {\r\n        const from = msg.getAttribute('from');\r\n\r\n        if (!this.speakerStatsComponentAddress\r\n            || from !== this.speakerStatsComponentAddress) {\r\n            return;\r\n        }\r\n\r\n        const jsonMessage = $(msg).find('>json-message')\r\n            .text();\r\n        const parsedJson = this.tryParseJSONAndVerify(jsonMessage);\r\n\r\n        if (parsedJson\r\n            && parsedJson[QHSENSE_MEET_MUC_TYPE] === 'speakerstats'\r\n            && parsedJson.users) {\r\n            this.eventEmitter.emit(\r\n                XMPPEvents.SPEAKER_STATS_RECEIVED, parsedJson.users);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n","/**\r\n * The errors for the connection.\r\n */\r\n\r\n/**\r\n * Indicates that the connection was dropped with an error which was most likely\r\n * caused by some networking issues. The dropped term in this context means that\r\n * the connection was closed unexpectedly (not on user's request).\r\n *\r\n * One example is 'item-not-found' error thrown by Prosody when the BOSH session\r\n * times out after 60 seconds of inactivity. On the other hand 'item-not-found'\r\n * could also happen when BOSH request is sent to the server with the session-id\r\n * that is not know to the server. But this should not happen in lib-qhsense-meet\r\n * case as long as the service is configured correctly (there is no bug).\r\n */\r\nexport const CONNECTION_DROPPED_ERROR = 'connection.droppedError';\r\n\r\n/**\r\n * Not specified errors.\r\n */\r\nexport const OTHER_ERROR = 'connection.otherError';\r\n\r\n/**\r\n * Indicates that a password is required in order to join the conference.\r\n */\r\nexport const PASSWORD_REQUIRED = 'connection.passwordRequired';\r\n\r\n/**\r\n * Indicates that the connection was dropped, because of too many 5xx HTTP\r\n * errors on BOSH requests.\r\n */\r\nexport const SERVER_ERROR = 'connection.serverError';\r\n","/**\r\n * Event triggered when participant's muted status changes.\r\n * @param {string} endpointId the track owner's identifier (MUC nickname)\r\n * @param {MediaType} mediaType \"audio\" or \"video\"\r\n * @param {boolean} isMuted the new muted state\r\n */\r\nexport const PEER_MUTED_CHANGED = 'signaling.peerMuted';\r\n\r\n/**\r\n * Event triggered when participant's video type changes.\r\n * @param {string} endpointId the video owner's ID (MUC nickname)\r\n * @param {VideoType} videoType the new value\r\n */\r\nexport const PEER_VIDEO_TYPE_CHANGED = 'signaling.peerVideoType';\r\n","/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n /* eslint-env node */\r\n'use strict';\r\n\r\nvar logDisabled_ = true;\r\nvar deprecationWarnings_ = true;\r\n\r\n// Utility methods.\r\nvar utils = {\r\n  disableLog: function(bool) {\r\n    if (typeof bool !== 'boolean') {\r\n      return new Error('Argument type: ' + typeof bool +\r\n          '. Please use a boolean.');\r\n    }\r\n    logDisabled_ = bool;\r\n    return (bool) ? 'adapter.js logging disabled' :\r\n        'adapter.js logging enabled';\r\n  },\r\n\r\n  /**\r\n   * Disable or enable deprecation warnings\r\n   * @param {!boolean} bool set to true to disable warnings.\r\n   */\r\n  disableWarnings: function(bool) {\r\n    if (typeof bool !== 'boolean') {\r\n      return new Error('Argument type: ' + typeof bool +\r\n          '. Please use a boolean.');\r\n    }\r\n    deprecationWarnings_ = !bool;\r\n    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\r\n  },\r\n\r\n  log: function() {\r\n    if (typeof window === 'object') {\r\n      if (logDisabled_) {\r\n        return;\r\n      }\r\n      if (typeof console !== 'undefined' && typeof console.log === 'function') {\r\n        console.log.apply(console, arguments);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Shows a deprecation warning suggesting the modern and spec-compatible API.\r\n   */\r\n  deprecated: function(oldMethod, newMethod) {\r\n    if (!deprecationWarnings_) {\r\n      return;\r\n    }\r\n    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\r\n        ' instead.');\r\n  },\r\n\r\n  /**\r\n   * Extract browser version out of the provided user agent string.\r\n   *\r\n   * @param {!string} uastring userAgent string.\r\n   * @param {!string} expr Regular expression used as match criteria.\r\n   * @param {!number} pos position in the version string to be returned.\r\n   * @return {!number} browser version.\r\n   */\r\n  extractVersion: function(uastring, expr, pos) {\r\n    var match = uastring.match(expr);\r\n    return match && match.length >= pos && parseInt(match[pos], 10);\r\n  },\r\n\r\n  /**\r\n   * Browser detector.\r\n   *\r\n   * @return {object} result containing browser and version\r\n   *     properties.\r\n   */\r\n  detectBrowser: function(window) {\r\n    var navigator = window && window.navigator;\r\n\r\n    // Returned result object.\r\n    var result = {};\r\n    result.browser = null;\r\n    result.version = null;\r\n\r\n    // Fail early if it's not a browser\r\n    if (typeof window === 'undefined' || !window.navigator) {\r\n      result.browser = 'Not a browser.';\r\n      return result;\r\n    }\r\n\r\n    // Firefox.\r\n    if (navigator.mozGetUserMedia) {\r\n      result.browser = 'firefox';\r\n      result.version = this.extractVersion(navigator.userAgent,\r\n          /Firefox\\/(\\d+)\\./, 1);\r\n    } else if (navigator.webkitGetUserMedia) {\r\n      // Chrome, Chromium, Webview, Opera, all use the chrome shim for now\r\n      if (window.webkitRTCPeerConnection) {\r\n        result.browser = 'chrome';\r\n        result.version = this.extractVersion(navigator.userAgent,\r\n          /Chrom(e|ium)\\/(\\d+)\\./, 2);\r\n      } else { // Safari (in an unpublished version) or unknown webkit-based.\r\n        if (navigator.userAgent.match(/Version\\/(\\d+).(\\d+)/)) {\r\n          result.browser = 'safari';\r\n          result.version = this.extractVersion(navigator.userAgent,\r\n            /AppleWebKit\\/(\\d+)\\./, 1);\r\n        } else { // unknown webkit-based browser.\r\n          result.browser = 'Unsupported webkit-based browser ' +\r\n              'with GUM support but no WebRTC support.';\r\n          return result;\r\n        }\r\n      }\r\n    } else if (navigator.mediaDevices &&\r\n        navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge.\r\n      result.browser = 'edge';\r\n      result.version = this.extractVersion(navigator.userAgent,\r\n          /Edge\\/(\\d+).(\\d+)$/, 2);\r\n    } else if (navigator.mediaDevices &&\r\n        navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\r\n        // Safari, with webkitGetUserMedia removed.\r\n      result.browser = 'safari';\r\n      result.version = this.extractVersion(navigator.userAgent,\r\n          /AppleWebKit\\/(\\d+)\\./, 1);\r\n    } else { // Default fallthrough: not supported.\r\n      result.browser = 'Not a supported browser.';\r\n      return result;\r\n    }\r\n\r\n    return result;\r\n  },\r\n\r\n};\r\n\r\n// Export.\r\nmodule.exports = {\r\n  log: utils.log,\r\n  deprecated: utils.deprecated,\r\n  disableLog: utils.disableLog,\r\n  disableWarnings: utils.disableWarnings,\r\n  extractVersion: utils.extractVersion,\r\n  shimCreateObjectURL: utils.shimCreateObjectURL,\r\n  detectBrowser: utils.detectBrowser.bind(utils)\r\n};\r\n","/**\r\n * The possible camera facing modes. For now support only 'user' and\r\n * 'environment' because 'left' and 'right' are not used anywhere in our\r\n * projects at the time of this writing. For more information please refer to\r\n * https://w3c.github.io/mediacapture-main/getusermedia.html\r\n * #def-constraint-facingMode.\r\n *\r\n * @enum {string}\r\n */\r\nconst CameraFacingMode = {\r\n    /**\r\n     * The mode which specifies the environment-facing camera.\r\n     */\r\n    ENVIRONMENT: 'environment',\r\n\r\n    /**\r\n     * The mode which specifies the user-facing camera.\r\n     */\r\n    USER: 'user'\r\n};\r\n\r\nmodule.exports = CameraFacingMode;\r\n","/* global chrome, $, alert */\r\n\r\nimport QHSenseTrackError from '../../QHSenseTrackError';\r\nimport * as QHSenseTrackErrors from '../../QHSenseTrackErrors';\r\nimport browser from '../browser';\r\n\r\nconst logger = require('qhsense-meet-logger').getLogger(__filename);\r\nconst GlobalOnErrorHandler = require('../util/GlobalOnErrorHandler');\r\n\r\n/**\r\n * Indicates whether the Chrome desktop sharing extension is installed.\r\n * @type {boolean}\r\n */\r\nlet chromeExtInstalled = false;\r\n\r\n/**\r\n * Indicates whether an update of the Chrome desktop sharing extension is\r\n * required.\r\n * @type {boolean}\r\n */\r\nlet chromeExtUpdateRequired = false;\r\n\r\nlet gumFunction = null;\r\n\r\n/**\r\n * The error message returned by chrome when the extension is installed.\r\n */\r\nconst CHROME_NO_EXTENSION_ERROR_MSG // eslint-disable-line no-unused-vars\r\n    = 'Could not establish connection. Receiving end does not exist.';\r\n\r\n/**\r\n * Handles obtaining a stream from a screen capture on different browsers.\r\n */\r\nconst ScreenObtainer = {\r\n    /**\r\n     * If not <tt>null</tt> it means that the initialization process is still in\r\n     * progress. It is used to make desktop stream request wait and continue\r\n     * after it's done.\r\n     * {@type Promise|null}\r\n     */\r\n    intChromeExtPromise: null,\r\n\r\n    obtainStream: null,\r\n\r\n    /**\r\n     * Initializes the function used to obtain a screen capture\r\n     * (this.obtainStream).\r\n     *\r\n     * @param {object} options\r\n     * @param {boolean} [options.desktopSharingChromeDisabled]\r\n     * @param {boolean} [options.desktopSharingChromeExtId]\r\n     * @param {boolean} [options.desktopSharingFirefoxDisabled]\r\n     * @param {Function} gum GUM method\r\n     */\r\n    init(options = {\r\n        desktopSharingChromeDisabled: false,\r\n        desktopSharingChromeExtId: null,\r\n        desktopSharingFirefoxDisabled: false\r\n    }, gum) {\r\n        this.options = options;\r\n        gumFunction = gum;\r\n\r\n        this.obtainStream = this._createObtainStreamMethod(options);\r\n\r\n        if (!this.obtainStream) {\r\n            logger.info('Desktop sharing disabled');\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns a method which will be used to obtain the screen sharing stream\r\n     * (based on the browser type).\r\n     *\r\n     * @param {object} options passed from {@link init} - check description\r\n     * there\r\n     * @returns {Function}\r\n     * @private\r\n     */\r\n    _createObtainStreamMethod(options) {\r\n        if (browser.isNWJS()) {\r\n            return (_, onSuccess, onFailure) => {\r\n                window.QHSenseMeetNW.obtainDesktopStream(\r\n                    onSuccess,\r\n                    (error, constraints) => {\r\n                        let qhsenseError;\r\n\r\n                        // FIXME:\r\n                        // This is very very dirty fix for recognising that the\r\n                        // user have clicked the cancel button from the Desktop\r\n                        // sharing pick window. The proper solution would be to\r\n                        // detect this in the NWJS application by checking the\r\n                        // streamId === \"\". Even better solution would be to\r\n                        // stop calling GUM from the NWJS app and just pass the\r\n                        // streamId to lib-qhsense-meet. This way the desktop\r\n                        // sharing implementation for NWJS and chrome extension\r\n                        // will be the same and lib-qhsense-meet will be able to\r\n                        // control the constraints, check the streamId, etc.\r\n                        //\r\n                        // I cannot find documentation about \"InvalidStateError\"\r\n                        // but this is what we are receiving from GUM when the\r\n                        // streamId for the desktop sharing is \"\".\r\n\r\n                        if (error && error.name === 'InvalidStateError') {\r\n                            qhsenseError = new QHSenseTrackError(\r\n                                QHSenseTrackErrors.CHROME_EXTENSION_USER_CANCELED\r\n                            );\r\n                        } else {\r\n                            qhsenseError = new QHSenseTrackError(\r\n                                error, constraints, [ 'desktop' ]);\r\n                        }\r\n                        (typeof onFailure === 'function')\r\n                            && onFailure(qhsenseError);\r\n                    });\r\n            };\r\n        } else if (browser.isElectron()) {\r\n            return this.obtainScreenOnElectron;\r\n        } else if (browser.isChrome() || browser.isOpera()) {\r\n            if (browser.supportsGetDisplayMedia()\r\n                    && !options.desktopSharingChromeDisabled) {\r\n\r\n                return this.obtainScreenFromGetDisplayMedia;\r\n            } else if (options.desktopSharingChromeDisabled\r\n                || !options.desktopSharingChromeExtId) {\r\n\r\n                return null;\r\n            }\r\n\r\n            logger.info('Using Chrome extension for desktop sharing');\r\n            this.intChromeExtPromise\r\n                = initChromeExtension(options).then(() => {\r\n                    this.intChromeExtPromise = null;\r\n                });\r\n\r\n            return this.obtainScreenFromExtension;\r\n        } else if (browser.isFirefox()) {\r\n            if (options.desktopSharingFirefoxDisabled) {\r\n                return null;\r\n            } else if (browser.supportsGetDisplayMedia()) {\r\n                // Firefox 66 support getDisplayMedia\r\n                return this.obtainScreenFromGetDisplayMedia;\r\n            }\r\n\r\n            // Legacy Firefox\r\n            return this.obtainScreenOnFirefox;\r\n        } else if (browser.isEdge() && browser.supportsGetDisplayMedia()) {\r\n            return this.obtainScreenFromGetDisplayMedia;\r\n        }\r\n\r\n        logger.log(\r\n            'Screen sharing not supported by the current browser: ',\r\n            browser.getName());\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Checks whether obtaining a screen capture is supported in the current\r\n     * environment.\r\n     * @returns {boolean}\r\n     */\r\n    isSupported() {\r\n        return this.obtainStream !== null;\r\n    },\r\n\r\n    /**\r\n     * Obtains a screen capture stream on Firefox.\r\n     * @param callback\r\n     * @param errorCallback\r\n     */\r\n    obtainScreenOnFirefox(options, callback, errorCallback) {\r\n        obtainWebRTCScreen(options.gumOptions, callback, errorCallback);\r\n    },\r\n\r\n    /**\r\n     * Obtains a screen capture stream on Electron.\r\n     *\r\n     * @param {Object} [options] - Screen sharing options.\r\n     * @param {Array<string>} [options.desktopSharingSources] - Array with the\r\n     * sources that have to be displayed in the desktop picker window ('screen',\r\n     * 'window', etc.).\r\n     * @param onSuccess - Success callback.\r\n     * @param onFailure - Failure callback.\r\n     */\r\n    obtainScreenOnElectron(options = {}, onSuccess, onFailure) {\r\n        if (window.QHSenseMeetScreenObtainer\r\n            && window.QHSenseMeetScreenObtainer.openDesktopPicker) {\r\n            const { desktopSharingSources, gumOptions } = options;\r\n\r\n            window.QHSenseMeetScreenObtainer.openDesktopPicker(\r\n                {\r\n                    desktopSharingSources: desktopSharingSources\r\n                        || this.options.desktopSharingChromeSources\r\n                },\r\n                (streamId, streamType) =>\r\n                    onGetStreamResponse(\r\n                        {\r\n                            response: {\r\n                                streamId,\r\n                                streamType\r\n                            },\r\n                            gumOptions\r\n                        },\r\n                        onSuccess,\r\n                        onFailure\r\n                    ),\r\n                err => onFailure(new QHSenseTrackError(\r\n                    QHSenseTrackErrors.ELECTRON_DESKTOP_PICKER_ERROR,\r\n                    err\r\n                ))\r\n            );\r\n        } else {\r\n            onFailure(new QHSenseTrackError(\r\n                QHSenseTrackErrors.ELECTRON_DESKTOP_PICKER_NOT_FOUND));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Asks Chrome extension to call chooseDesktopMedia and gets chrome\r\n     * 'desktop' stream for returned stream token.\r\n     */\r\n    obtainScreenFromExtension(options, streamCallback, failCallback) {\r\n        if (this.intChromeExtPromise !== null) {\r\n            this.intChromeExtPromise.then(() => {\r\n                this.obtainScreenFromExtension(\r\n                    options, streamCallback, failCallback);\r\n            });\r\n\r\n            return;\r\n        }\r\n\r\n        const {\r\n            desktopSharingChromeExtId,\r\n            desktopSharingChromeSources\r\n        } = this.options;\r\n\r\n        const {\r\n            gumOptions\r\n        } = options;\r\n\r\n        const doGetStreamFromExtensionOptions = {\r\n            desktopSharingChromeExtId,\r\n            desktopSharingChromeSources:\r\n                options.desktopSharingSources || desktopSharingChromeSources,\r\n            gumOptions\r\n        };\r\n\r\n        if (chromeExtInstalled) {\r\n            doGetStreamFromExtension(\r\n                doGetStreamFromExtensionOptions,\r\n                streamCallback,\r\n                failCallback);\r\n        } else {\r\n            if (chromeExtUpdateRequired) {\r\n                /* eslint-disable no-alert */\r\n                alert(\r\n                    'QHSense Desktop Streamer requires update. '\r\n                    + 'Changes will take effect after next Chrome restart.');\r\n\r\n                /* eslint-enable no-alert */\r\n            }\r\n\r\n            this.handleExternalInstall(options, streamCallback,\r\n                failCallback);\r\n        }\r\n    },\r\n\r\n    /* eslint-disable max-params */\r\n\r\n    handleExternalInstall(options, streamCallback, failCallback, e) {\r\n        const webStoreInstallUrl = getWebStoreInstallUrl(this.options);\r\n\r\n        options.listener('waitingForExtension', webStoreInstallUrl);\r\n        this.checkForChromeExtensionOnInterval(options, streamCallback,\r\n            failCallback, e);\r\n    },\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    checkForChromeExtensionOnInterval(options, streamCallback, failCallback) {\r\n        if (options.checkAgain() === false) {\r\n            failCallback(new QHSenseTrackError(\r\n                QHSenseTrackErrors.CHROME_EXTENSION_INSTALLATION_ERROR));\r\n\r\n            return;\r\n        }\r\n        waitForExtensionAfterInstall(this.options, options.interval, 1)\r\n            .then(() => {\r\n                chromeExtInstalled = true;\r\n                options.listener('extensionFound');\r\n                this.obtainScreenFromExtension(options,\r\n                    streamCallback, failCallback);\r\n            })\r\n            .catch(() => {\r\n                this.checkForChromeExtensionOnInterval(options,\r\n                    streamCallback, failCallback);\r\n            });\r\n    },\r\n\r\n    /**\r\n     * Obtains a screen capture stream using getDisplayMedia.\r\n     *\r\n     * @param callback - The success callback.\r\n     * @param errorCallback - The error callback.\r\n     */\r\n    obtainScreenFromGetDisplayMedia(options, callback, errorCallback) {\r\n        logger.info('Using getDisplayMedia for screen sharing');\r\n\r\n        let getDisplayMedia;\r\n\r\n        if (navigator.getDisplayMedia) {\r\n            getDisplayMedia = navigator.getDisplayMedia.bind(navigator);\r\n        } else {\r\n            // eslint-disable-next-line max-len\r\n            getDisplayMedia = navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices);\r\n        }\r\n\r\n        getDisplayMedia({ video: true })\r\n            .then(stream => {\r\n                let applyConstraintsPromise;\r\n\r\n                if (stream\r\n                    && stream.getTracks()\r\n                    && stream.getTracks().length > 0) {\r\n                    applyConstraintsPromise = stream.getTracks()[0]\r\n                        .applyConstraints(options.trackOptions);\r\n                } else {\r\n                    applyConstraintsPromise = Promise.resolve();\r\n                }\r\n\r\n                applyConstraintsPromise.then(() =>\r\n                    callback({\r\n                        stream,\r\n                        sourceId: stream.id\r\n                    }));\r\n            })\r\n            .catch(() =>\r\n                errorCallback(new QHSenseTrackError(QHSenseTrackErrors\r\n                    .CHROME_EXTENSION_USER_CANCELED)));\r\n    }\r\n};\r\n\r\n/**\r\n * Obtains a desktop stream using getUserMedia.\r\n * For this to work on Chrome, the\r\n * 'chrome://flags/#enable-usermedia-screen-capture' flag must be enabled.\r\n *\r\n * On firefox, the document's domain must be white-listed in the\r\n * 'media.getusermedia.screensharing.allowed_domains' preference in\r\n * 'about:config'.\r\n */\r\nfunction obtainWebRTCScreen(options, streamCallback, failCallback) {\r\n    gumFunction([ 'screen' ], options)\r\n        .then(stream => streamCallback({ stream }), failCallback);\r\n}\r\n\r\n/**\r\n * Constructs inline install URL for Chrome desktop streaming extension.\r\n * The 'chromeExtensionId' must be defined in options parameter.\r\n * @param options supports \"desktopSharingChromeExtId\"\r\n * @returns {string}\r\n */\r\nfunction getWebStoreInstallUrl(options) {\r\n    return (\r\n        `https://chrome.google.com/webstore/detail/${\r\n            options.desktopSharingChromeExtId}`);\r\n}\r\n\r\n/**\r\n * Checks whether an update of the Chrome extension is required.\r\n * @param minVersion minimal required version\r\n * @param extVersion current extension version\r\n * @returns {boolean}\r\n */\r\nfunction isUpdateRequired(minVersion, extVersion) {\r\n    try {\r\n        const s1 = minVersion.split('.');\r\n        const s2 = extVersion.split('.');\r\n\r\n        const len = Math.max(s1.length, s2.length);\r\n\r\n        for (let i = 0; i < len; i++) {\r\n            let n1 = 0,\r\n                n2 = 0;\r\n\r\n            if (i < s1.length) {\r\n                n1 = parseInt(s1[i], 10);\r\n            }\r\n            if (i < s2.length) {\r\n                n2 = parseInt(s2[i], 10);\r\n            }\r\n\r\n            if (isNaN(n1) || isNaN(n2)) {\r\n                return true;\r\n            } else if (n1 !== n2) {\r\n                return n1 > n2;\r\n            }\r\n        }\r\n\r\n        // will happen if both versions have identical numbers in\r\n        // their components (even if one of them is longer, has more components)\r\n        return false;\r\n    } catch (e) {\r\n        GlobalOnErrorHandler.callErrorHandler(e);\r\n        logger.error('Failed to parse extension version', e);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param callback\r\n * @param options\r\n */\r\nfunction checkChromeExtInstalled(callback, options) {\r\n    if (typeof chrome === 'undefined' || !chrome || !chrome.runtime) {\r\n        // No API, so no extension for sure\r\n        callback(false, false);\r\n\r\n        return;\r\n    }\r\n    chrome.runtime.sendMessage(\r\n        options.desktopSharingChromeExtId,\r\n        { getVersion: true },\r\n        response => {\r\n            if (!response || !response.version) {\r\n                // Communication failure - assume that no endpoint exists\r\n                logger.warn(\r\n                    'Extension not installed?: ', chrome.runtime.lastError);\r\n                callback(false, false);\r\n\r\n                return;\r\n            }\r\n\r\n            // Check installed extension version\r\n            const extVersion = response.version;\r\n\r\n            logger.log(`Extension version is: ${extVersion}`);\r\n            const updateRequired\r\n                = isUpdateRequired(\r\n                    options.desktopSharingChromeMinExtVersion,\r\n                    extVersion);\r\n\r\n            callback(!updateRequired, updateRequired);\r\n        }\r\n    );\r\n}\r\n\r\n/**\r\n *\r\n * @param options\r\n * @param streamCallback\r\n * @param failCallback\r\n */\r\nfunction doGetStreamFromExtension(options, streamCallback, failCallback) {\r\n    const {\r\n        desktopSharingChromeSources,\r\n        desktopSharingChromeExtId,\r\n        gumOptions\r\n    } = options;\r\n\r\n    // Sends 'getStream' msg to the extension.\r\n    // Extension id must be defined in the config.\r\n    chrome.runtime.sendMessage(\r\n        desktopSharingChromeExtId,\r\n        {\r\n            getStream: true,\r\n            sources: desktopSharingChromeSources\r\n        },\r\n        response => {\r\n            if (!response) {\r\n                // possibly re-wraping error message to make code consistent\r\n                const lastError = chrome.runtime.lastError;\r\n\r\n                failCallback(lastError instanceof Error\r\n                    ? lastError\r\n                    : new QHSenseTrackError(\r\n                        QHSenseTrackErrors.CHROME_EXTENSION_GENERIC_ERROR,\r\n                        lastError));\r\n\r\n                return;\r\n            }\r\n            logger.log('Response from extension: ', response);\r\n            onGetStreamResponse(\r\n                {\r\n                    response,\r\n                    gumOptions\r\n                },\r\n                streamCallback,\r\n                failCallback\r\n            );\r\n        }\r\n    );\r\n}\r\n\r\n/**\r\n * Initializes <link rel=chrome-webstore-item /> with extension id set in\r\n * config.js to support inline installs. Host site must be selected as main\r\n * website of published extension.\r\n * @param options supports \"desktopSharingChromeExtId\"\r\n */\r\nfunction initInlineInstalls(options) {\r\n    if ($('link[rel=chrome-webstore-item]').length === 0) {\r\n        $('head').append('<link rel=\"chrome-webstore-item\">');\r\n    }\r\n    $('link[rel=chrome-webstore-item]').attr('href',\r\n        getWebStoreInstallUrl(options));\r\n}\r\n\r\n/**\r\n *\r\n * @param options\r\n *\r\n * @return {Promise} - a Promise resolved once the initialization process is\r\n * finished.\r\n */\r\nfunction initChromeExtension(options) {\r\n    // Initialize Chrome extension inline installs\r\n    initInlineInstalls(options);\r\n\r\n    return new Promise(resolve => {\r\n        // Check if extension is installed\r\n        checkChromeExtInstalled((installed, updateRequired) => {\r\n            chromeExtInstalled = installed;\r\n            chromeExtUpdateRequired = updateRequired;\r\n            logger.info(\r\n                `Chrome extension installed: ${\r\n                    chromeExtInstalled} updateRequired: ${\r\n                    chromeExtUpdateRequired}`);\r\n            resolve();\r\n        }, options);\r\n    });\r\n}\r\n\r\n/**\r\n * Checks \"retries\" times on every \"waitInterval\"ms whether the ext is alive.\r\n * @param {Object} options the options passed to ScreanObtainer.obtainStream\r\n * @param {int} waitInterval the number of ms between retries\r\n * @param {int} retries the number of retries\r\n * @returns {Promise} returns promise that will be resolved when the extension\r\n * is alive and rejected if the extension is not alive even after \"retries\"\r\n * checks\r\n */\r\nfunction waitForExtensionAfterInstall(options, waitInterval, retries) {\r\n    if (retries === 0) {\r\n        return Promise.reject();\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n        let currentRetries = retries;\r\n        const interval = window.setInterval(() => {\r\n            checkChromeExtInstalled(installed => {\r\n                if (installed) {\r\n                    window.clearInterval(interval);\r\n                    resolve();\r\n                } else {\r\n                    currentRetries--;\r\n                    if (currentRetries === 0) {\r\n                        reject();\r\n                        window.clearInterval(interval);\r\n                    }\r\n                }\r\n            }, options);\r\n        }, waitInterval);\r\n    });\r\n}\r\n\r\n/**\r\n * Handles response from external application / extension and calls GUM to\r\n * receive the desktop streams or reports error.\r\n * @param {object} options\r\n * @param {object} options.response\r\n * @param {string} options.response.streamId - the streamId for the desktop\r\n * stream.\r\n * @param {string} options.response.error - error to be reported.\r\n * @param {object} options.gumOptions - options passed to GUM.\r\n * @param {Function} onSuccess - callback for success.\r\n * @param {Function} onFailure - callback for failure.\r\n * @param {object} gumOptions - options passed to GUM.\r\n */\r\nfunction onGetStreamResponse(\r\n        options = {\r\n            response: {},\r\n            gumOptions: {}\r\n        },\r\n        onSuccess,\r\n        onFailure) {\r\n    const { streamId, streamType, error } = options.response || {};\r\n\r\n    if (streamId) {\r\n        const gumOptions = {\r\n            desktopStream: streamId,\r\n            ...options.gumOptions\r\n        };\r\n\r\n        gumFunction([ 'desktop' ], gumOptions)\r\n            .then(stream => onSuccess({\r\n                stream,\r\n                sourceId: streamId,\r\n                sourceType: streamType\r\n            }), onFailure);\r\n    } else {\r\n        // As noted in Chrome Desktop Capture API:\r\n        // If user didn't select any source (i.e. canceled the prompt)\r\n        // then the callback is called with an empty streamId.\r\n        if (streamId === '') {\r\n            onFailure(new QHSenseTrackError(\r\n                QHSenseTrackErrors.CHROME_EXTENSION_USER_CANCELED));\r\n\r\n            return;\r\n        }\r\n\r\n        onFailure(new QHSenseTrackError(\r\n            QHSenseTrackErrors.CHROME_EXTENSION_GENERIC_ERROR,\r\n            error));\r\n    }\r\n}\r\n\r\nexport default ScreenObtainer;\r\n","/* global __filename */\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport * as QHSenseConferenceEvents from '../../QHSenseConferenceEvents';\r\nimport * as QHSenseTrackEvents from '../../QHSenseTrackEvents';\r\nimport * as MediaType from '../../service/RTC/MediaType';\r\nimport browser from '../browser';\r\nimport RTCEvents from '../../service/RTC/RTCEvents';\r\nimport Statistics from '../statistics/statistics';\r\nimport { createParticipantConnectionStatusEvent } from '../../service/statistics/AnalyticsEvents';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Default value of 500 milliseconds for\r\n * {@link ParticipantConnectionStatus.outOfLastNTimeout}.\r\n *\r\n * @type {number}\r\n */\r\nconst DEFAULT_NOT_IN_LAST_N_TIMEOUT = 500;\r\n\r\n/**\r\n * Default value of 2000 milliseconds for\r\n * {@link ParticipantConnectionStatus.rtcMuteTimeout}.\r\n *\r\n * @type {number}\r\n */\r\nconst DEFAULT_RTC_MUTE_TIMEOUT = 10000;\r\n\r\n/**\r\n * The time to wait a track to be restored. Track which was out of lastN\r\n * should be inactive and when entering lastN it becomes restoring and when\r\n * data is received from bridge it will become active, but if no data is\r\n * received for some time we set status of that participant connection to\r\n * interrupted.\r\n * @type {number}\r\n */\r\nconst DEFAULT_RESTORING_TIMEOUT = 10000;\r\n\r\n/**\r\n * Participant connection statuses.\r\n *\r\n * @type {{\r\n *      ACTIVE: string,\r\n *      INACTIVE: string,\r\n *      INTERRUPTED: string,\r\n *      RESTORING: string\r\n * }}\r\n */\r\nexport const ParticipantConnectionStatus = {\r\n    /**\r\n     * Status indicating that connection is currently active.\r\n     */\r\n    ACTIVE: 'active',\r\n\r\n    /**\r\n     * Status indicating that connection is currently inactive.\r\n     * Inactive means the connection was stopped on purpose from the bridge,\r\n     * like exiting lastN or adaptivity decided to drop video because of not\r\n     * enough bandwidth.\r\n     */\r\n    INACTIVE: 'inactive',\r\n\r\n    /**\r\n     * Status indicating that connection is currently interrupted.\r\n     */\r\n    INTERRUPTED: 'interrupted',\r\n\r\n    /**\r\n     * Status indicating that connection is currently restoring.\r\n     */\r\n    RESTORING: 'restoring'\r\n};\r\n\r\n/**\r\n * Class is responsible for emitting\r\n * QHSenseConferenceEvents.PARTICIPANT_CONN_STATUS_CHANGED events.\r\n */\r\nexport default class ParticipantConnectionStatusHandler {\r\n    /* eslint-disable max-params*/\r\n    /**\r\n     * Calculates the new {@link ParticipantConnectionStatus} based on\r\n     * the values given for some specific remote user. It is assumed that\r\n     * the conference is currently in the JVB mode (in contrary to the P2P mode)\r\n     * @param {boolean} isConnectionActiveByJvb true if the JVB did not get any\r\n     * data from the user for the last 15 seconds.\r\n     * @param {boolean} isInLastN indicates whether the user is in the last N\r\n     * set. When set to false it means that JVB is not sending any video for\r\n     * the user.\r\n     * @param {boolean} isRestoringTimedout if true it means that the user has\r\n     * been outside of last N too long to be considered\r\n     * {@link ParticipantConnectionStatus.RESTORING}.\r\n     * @param {boolean} isVideoMuted true if the user is video muted and we\r\n     * should not expect to receive any video.\r\n     * @param {boolean} isVideoTrackFrozen if the current browser support video\r\n     * frozen detection then it will be set to true when the video track is\r\n     * frozen. If the current browser does not support frozen detection the it's\r\n     * always false.\r\n     * @return {ParticipantConnectionStatus} the new connection status for\r\n     * the user for whom the values above were provided.\r\n     * @private\r\n     */\r\n    static _getNewStateForJvbMode(\r\n            isConnectionActiveByJvb,\r\n            isInLastN,\r\n            isRestoringTimedout,\r\n            isVideoMuted,\r\n            isVideoTrackFrozen) {\r\n        if (!isConnectionActiveByJvb) {\r\n            // when there is a connection problem signaled from jvb\r\n            // it means no media was flowing for at least 15secs, so both audio\r\n            // and video are most likely interrupted\r\n            return ParticipantConnectionStatus.INTERRUPTED;\r\n        } else if (isVideoMuted) {\r\n            // If the connection is active according to JVB and the user is\r\n            // video muted there is no way for the connection to be inactive,\r\n            // because the detection logic below only makes sense for video.\r\n            return ParticipantConnectionStatus.ACTIVE;\r\n        }\r\n\r\n        // Logic when isVideoTrackFrozen is supported\r\n        if (browser.supportsVideoMuteOnConnInterrupted()) {\r\n            if (!isVideoTrackFrozen) {\r\n                // If the video is playing we're good\r\n                return ParticipantConnectionStatus.ACTIVE;\r\n            } else if (isInLastN) {\r\n                return isRestoringTimedout\r\n                    ? ParticipantConnectionStatus.INTERRUPTED\r\n                    : ParticipantConnectionStatus.RESTORING;\r\n            }\r\n\r\n            return ParticipantConnectionStatus.INACTIVE;\r\n        }\r\n\r\n        // Because this browser is incapable of detecting frozen video we must\r\n        // rely on the lastN value\r\n        return isInLastN\r\n            ? ParticipantConnectionStatus.ACTIVE\r\n            : ParticipantConnectionStatus.INACTIVE;\r\n    }\r\n\r\n    /* eslint-enable max-params*/\r\n\r\n    /**\r\n     * In P2P mode we don't care about any values coming from the JVB and\r\n     * the connection status can be only active or interrupted.\r\n     * @param {boolean} isVideoMuted the user if video muted\r\n     * @param {boolean} isVideoTrackFrozen true if the video track for\r\n     * the remote user is currently frozen. If the current browser does not\r\n     * support video frozen detection then it's always false.\r\n     * @return {ParticipantConnectionStatus}\r\n     * @private\r\n     */\r\n    static _getNewStateForP2PMode(isVideoMuted, isVideoTrackFrozen) {\r\n        if (!browser.supportsVideoMuteOnConnInterrupted()) {\r\n            // There's no way to detect problems in P2P when there's no video\r\n            // track frozen detection...\r\n            return ParticipantConnectionStatus.ACTIVE;\r\n        }\r\n\r\n        return isVideoMuted || !isVideoTrackFrozen\r\n            ? ParticipantConnectionStatus.ACTIVE\r\n            : ParticipantConnectionStatus.INTERRUPTED;\r\n    }\r\n\r\n    /**\r\n     * Creates new instance of <tt>ParticipantConnectionStatus</tt>.\r\n     *\r\n     * @constructor\r\n     * @param {RTC} rtc the RTC service instance\r\n     * @param {QHSenseConference} conference parent conference instance\r\n     * @param {Object} options\r\n     * @param {number} [options.rtcMuteTimeout=2000] custom value for\r\n     * {@link ParticipantConnectionStatus.rtcMuteTimeout}.\r\n     * @param {number} [options.outOfLastNTimeout=500] custom value for\r\n     * {@link ParticipantConnectionStatus.outOfLastNTimeout}.\r\n     */\r\n    constructor(rtc, conference, options) {\r\n        this.rtc = rtc;\r\n        this.conference = conference;\r\n\r\n        /**\r\n         * A map of the \"endpoint ID\"(which corresponds to the resource part\r\n         * of MUC JID(nickname)) to the timeout callback IDs scheduled using\r\n         * window.setTimeout.\r\n         * @type {Object.<string, number>}\r\n         */\r\n        this.trackTimers = {};\r\n\r\n        /**\r\n         * This map holds the endpoint connection status received from the JVB\r\n         * (as it might be different than the one stored in QHSenseParticipant).\r\n         * Required for getting back in sync when remote video track is removed.\r\n         * @type {Object.<string, boolean>}\r\n         */\r\n        this.connStatusFromJvb = { };\r\n\r\n        /**\r\n         * If video track frozen detection through RTC mute event is supported,\r\n         * we wait some time until video track is considered frozen. But because\r\n         * when the user falls out of last N it is expected for the video to\r\n         * freeze this timeout must be significantly reduced in \"out of last N\"\r\n         * case.\r\n         *\r\n         * Basically this value is used instead of {@link rtcMuteTimeout} when\r\n         * user is not in last N.\r\n         * @type {number}\r\n         */\r\n        this.outOfLastNTimeout\r\n            = typeof options.outOfLastNTimeout === 'number'\r\n                ? options.outOfLastNTimeout : DEFAULT_NOT_IN_LAST_N_TIMEOUT;\r\n\r\n        /**\r\n         * How long we're going to wait after the RTC video track muted event\r\n         * for the corresponding signalling mute event, before the connection\r\n         * interrupted is fired. The default value is\r\n         * {@link DEFAULT_RTC_MUTE_TIMEOUT}.\r\n         *\r\n         * @type {number} amount of time in milliseconds\r\n         */\r\n        this.rtcMuteTimeout\r\n            = typeof options.rtcMuteTimeout === 'number'\r\n                ? options.rtcMuteTimeout : DEFAULT_RTC_MUTE_TIMEOUT;\r\n\r\n        /**\r\n         * This map holds a timestamp indicating  when participant's video track\r\n         * was RTC muted (it is assumed that each participant can have only 1\r\n         * video track at a time). The purpose of storing the timestamp is to\r\n         * avoid the transition to disconnected status in case of legitimate\r\n         * video mute operation where the signalling video muted event can\r\n         * arrive shortly after RTC muted event.\r\n         *\r\n         * The key is participant's ID which is the same as endpoint id in\r\n         * the Colibri conference allocated on the JVB.\r\n         *\r\n         * The value is a timestamp measured in milliseconds obtained with\r\n         * <tt>Date.now()</tt>.\r\n         *\r\n         * FIXME merge this logic with NO_DATA_FROM_SOURCE event\r\n         *       implemented in QHSenseLocalTrack by extending the event to\r\n         *       the remote track and allowing to set different timeout for\r\n         *       local and remote tracks.\r\n         *\r\n         * @type {Object.<string, number>}\r\n         */\r\n        this.rtcMutedTimestamp = { };\r\n        logger.info(`RtcMuteTimeout set to: ${this.rtcMuteTimeout}`);\r\n\r\n        /**\r\n         * This map holds the timestamps indicating when participant's video\r\n         * entered lastN set. Participants entering lastN will have connection\r\n         * status restoring and when we start receiving video will become\r\n         * active, but if video is not received for certain time\r\n         * {@link DEFAULT_RESTORING_TIMEOUT} that participant connection status\r\n         * will become interrupted.\r\n         *\r\n         * @type {Map<string, number>}\r\n         */\r\n        this.enteredLastNTimestamp = new Map();\r\n\r\n        /**\r\n         * A map of the \"endpoint ID\"(which corresponds to the resource part\r\n         * of MUC JID(nickname)) to the restoring timeout callback IDs\r\n         * scheduled using window.setTimeout.\r\n         *\r\n         * @type {Map<string, number>}\r\n         */\r\n        this.restoringTimers = new Map();\r\n\r\n        /**\r\n         * A map that holds the current connection status (along with all the internal events that happen\r\n         * while in that state).\r\n         *\r\n         * The goal is to send this information to the analytics backend for post-mortem analysis.\r\n         */\r\n        this.peerConnStatusMap = new Map();\r\n    }\r\n\r\n    /**\r\n     * Gets the video frozen timeout for given user.\r\n     * @param {string} id endpoint/participant ID\r\n     * @return {number} how long are we going to wait since RTC video muted\r\n     * even, before a video track is considered frozen.\r\n     * @private\r\n     */\r\n    _getVideoFrozenTimeout(id) {\r\n        return this.rtc.isInLastN(id)\r\n            ? this.rtcMuteTimeout : this.outOfLastNTimeout;\r\n    }\r\n\r\n    /**\r\n     * Initializes <tt>ParticipantConnectionStatus</tt> and bind required event\r\n     * listeners.\r\n     */\r\n    init() {\r\n\r\n        this._onEndpointConnStatusChanged\r\n            = this.onEndpointConnStatusChanged.bind(this);\r\n\r\n        this.rtc.addListener(\r\n            RTCEvents.ENDPOINT_CONN_STATUS_CHANGED,\r\n            this._onEndpointConnStatusChanged);\r\n\r\n        // Handles P2P status changes\r\n        this._onP2PStatus = this.refreshConnectionStatusForAll.bind(this);\r\n        this.conference.on(QHSenseConferenceEvents.P2P_STATUS, this._onP2PStatus);\r\n\r\n        // On some browsers MediaStreamTrack trigger \"onmute\"/\"onunmute\"\r\n        // events for video type tracks when they stop receiving data which is\r\n        // often a sign that remote user is having connectivity issues\r\n        if (browser.supportsVideoMuteOnConnInterrupted()) {\r\n\r\n            this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this);\r\n            this.rtc.addListener(\r\n                RTCEvents.REMOTE_TRACK_MUTE, this._onTrackRtcMuted);\r\n\r\n            this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this);\r\n            this.rtc.addListener(\r\n                RTCEvents.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted);\r\n\r\n            // Track added/removed listeners are used to bind \"mute\"/\"unmute\"\r\n            // event handlers\r\n            this._onRemoteTrackAdded = this.onRemoteTrackAdded.bind(this);\r\n            this.conference.on(\r\n                QHSenseConferenceEvents.TRACK_ADDED,\r\n                this._onRemoteTrackAdded);\r\n\r\n            this._onRemoteTrackRemoved = this.onRemoteTrackRemoved.bind(this);\r\n            this.conference.on(\r\n                QHSenseConferenceEvents.TRACK_REMOVED,\r\n                this._onRemoteTrackRemoved);\r\n\r\n            // Listened which will be bound to QHSenseRemoteTrack to listen for\r\n            // signalling mute/unmute events.\r\n            this._onSignallingMuteChanged\r\n                = this.onSignallingMuteChanged.bind(this);\r\n        }\r\n\r\n        this._onLastNChanged = this._onLastNChanged.bind(this);\r\n        this.conference.on(\r\n            QHSenseConferenceEvents.LAST_N_ENDPOINTS_CHANGED,\r\n            this._onLastNChanged);\r\n\r\n        this._onLastNValueChanged\r\n            = this.refreshConnectionStatusForAll.bind(this);\r\n        this.rtc.on(\r\n            RTCEvents.LASTN_VALUE_CHANGED, this._onLastNValueChanged);\r\n    }\r\n\r\n    /**\r\n     * Removes all event listeners and disposes of all resources held by this\r\n     * instance.\r\n     */\r\n    dispose() {\r\n\r\n        this.rtc.removeListener(\r\n            RTCEvents.ENDPOINT_CONN_STATUS_CHANGED,\r\n            this._onEndpointConnStatusChanged);\r\n\r\n        if (browser.supportsVideoMuteOnConnInterrupted()) {\r\n            this.rtc.removeListener(\r\n                RTCEvents.REMOTE_TRACK_MUTE,\r\n                this._onTrackRtcMuted);\r\n            this.rtc.removeListener(\r\n                RTCEvents.REMOTE_TRACK_UNMUTE,\r\n                this._onTrackRtcUnmuted);\r\n\r\n            this.conference.off(\r\n                QHSenseConferenceEvents.TRACK_ADDED,\r\n                this._onRemoteTrackAdded);\r\n            this.conference.off(\r\n                QHSenseConferenceEvents.TRACK_REMOVED,\r\n                this._onRemoteTrackRemoved);\r\n        }\r\n\r\n        this.conference.off(\r\n            QHSenseConferenceEvents.LAST_N_ENDPOINTS_CHANGED,\r\n            this._onLastNChanged);\r\n\r\n        this.rtc.removeListener(\r\n            RTCEvents.LASTN_VALUE_CHANGED, this._onLastNValueChanged);\r\n\r\n        this.conference.off(\r\n            QHSenseConferenceEvents.P2P_STATUS, this._onP2PStatus);\r\n\r\n        const participantIds = Object.keys(this.trackTimers);\r\n\r\n        for (const participantId of participantIds) {\r\n            this.clearTimeout(participantId);\r\n            this.clearRtcMutedTimestamp(participantId);\r\n        }\r\n\r\n        // Clear RTC connection status cache\r\n        this.connStatusFromJvb = {};\r\n    }\r\n\r\n    /**\r\n     * Handles RTCEvents.ENDPOINT_CONN_STATUS_CHANGED triggered when we receive\r\n     * notification over the data channel from the bridge about endpoint's\r\n     * connection status update.\r\n     * @param {string} endpointId the endpoint ID(MUC nickname/resource JID)\r\n     * @param {boolean} isActive true if the connection is OK or false otherwise\r\n     */\r\n    onEndpointConnStatusChanged(endpointId, isActive) {\r\n\r\n        logger.debug(\r\n            `Detector RTCEvents.ENDPOINT_CONN_STATUS_CHANGED(${Date.now()}): ${\r\n                endpointId}: ${isActive}`);\r\n\r\n        // Filter out events for the local JID for now\r\n        if (endpointId !== this.conference.myUserId()) {\r\n            // Store the status received over the data channels\r\n            this.connStatusFromJvb[endpointId] = isActive;\r\n            this.figureOutConnectionStatus(endpointId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Changes connection status.\r\n     * @param {QHSenseParticipant} participant\r\n     * @param newStatus\r\n     */\r\n    _changeConnectionStatus(participant, newStatus) {\r\n        if (participant.getConnectionStatus() !== newStatus) {\r\n\r\n            const endpointId = participant.getId();\r\n\r\n            participant._setConnectionStatus(newStatus);\r\n\r\n            logger.debug(\r\n                `Emit endpoint conn status(${Date.now()}) ${endpointId}: ${\r\n                    newStatus}`);\r\n\r\n            // Log the event on CallStats\r\n            Statistics.sendLog(\r\n                JSON.stringify({\r\n                    id: 'peer.conn.status',\r\n                    participant: endpointId,\r\n                    status: newStatus\r\n                }));\r\n\r\n\r\n            this.conference.eventEmitter.emit(\r\n                QHSenseConferenceEvents.PARTICIPANT_CONN_STATUS_CHANGED,\r\n                endpointId, newStatus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset the postponed \"connection interrupted\" event which was previously\r\n     * scheduled as a timeout on RTC 'onmute' event.\r\n     *\r\n     * @param {string} participantId the participant for which the \"connection\r\n     * interrupted\" timeout was scheduled\r\n     */\r\n    clearTimeout(participantId) {\r\n        if (this.trackTimers[participantId]) {\r\n            window.clearTimeout(this.trackTimers[participantId]);\r\n            this.trackTimers[participantId] = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the timestamp of the RTC muted event for participant's video track\r\n     * @param {string} participantId the id of the conference participant which\r\n     * is the same as the Colibri endpoint ID of the video channel allocated for\r\n     * the user on the videobridge.\r\n     */\r\n    clearRtcMutedTimestamp(participantId) {\r\n        this.rtcMutedTimestamp[participantId] = null;\r\n    }\r\n\r\n    /**\r\n     * Bind signalling mute event listeners for video {QHSenseRemoteTrack} when\r\n     * a new one is added to the conference.\r\n     *\r\n     * @param {QHSenseTrack} remoteTrack the {QHSenseTrack} which is being added to\r\n     * the conference.\r\n     */\r\n    onRemoteTrackAdded(remoteTrack) {\r\n        if (!remoteTrack.isLocal()\r\n                && remoteTrack.getType() === MediaType.VIDEO) {\r\n\r\n            logger.debug(\r\n                `Detector on remote track added for: ${\r\n                    remoteTrack.getParticipantId()}`);\r\n\r\n            remoteTrack.on(\r\n                QHSenseTrackEvents.TRACK_MUTE_CHANGED,\r\n                this._onSignallingMuteChanged);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all event listeners bound to the remote video track and clears\r\n     * any related timeouts.\r\n     *\r\n     * @param {QHSenseRemoteTrack} remoteTrack the remote track which is being\r\n     * removed from the conference.\r\n     */\r\n    onRemoteTrackRemoved(remoteTrack) {\r\n        if (!remoteTrack.isLocal()\r\n                && remoteTrack.getType() === MediaType.VIDEO) {\r\n\r\n            const endpointId = remoteTrack.getParticipantId();\r\n\r\n            logger.debug(`Detector on remote track removed: ${endpointId}`);\r\n\r\n            remoteTrack.off(\r\n                QHSenseTrackEvents.TRACK_MUTE_CHANGED,\r\n                this._onSignallingMuteChanged);\r\n\r\n            this.clearTimeout(endpointId);\r\n            this.clearRtcMutedTimestamp(endpointId);\r\n\r\n            this.figureOutConnectionStatus(endpointId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if given participant's video is considered frozen.\r\n     * @param {QHSenseParticipant} participant\r\n     * @return {boolean} <tt>true</tt> if the video has frozen for given\r\n     * participant or <tt>false</tt> when it's either not considered frozen\r\n     * (yet) or if freeze detection is not supported by the current browser.\r\n     *\r\n     * FIXME merge this logic with NO_DATA_FROM_SOURCE event\r\n     *       implemented in QHSenseLocalTrack by extending the event to\r\n     *       the remote track and allowing to set different timeout for\r\n     *       local and remote tracks.\r\n     *\r\n     */\r\n    isVideoTrackFrozen(participant) {\r\n        if (!browser.supportsVideoMuteOnConnInterrupted()) {\r\n            return false;\r\n        }\r\n\r\n        const id = participant.getId();\r\n        const hasAnyVideoRTCMuted = participant.hasAnyVideoTrackWebRTCMuted();\r\n        const rtcMutedTimestamp = this.rtcMutedTimestamp[id];\r\n        const timeout = this._getVideoFrozenTimeout(id);\r\n\r\n        return hasAnyVideoRTCMuted\r\n            && typeof rtcMutedTimestamp === 'number'\r\n            && (Date.now() - rtcMutedTimestamp) >= timeout;\r\n    }\r\n\r\n    /**\r\n     * Goes over every participant and updates connectivity status.\r\n     * Should be called when a parameter which affects all of the participants\r\n     * is changed (P2P for example).\r\n     */\r\n    refreshConnectionStatusForAll() {\r\n        const participants = this.conference.getParticipants();\r\n\r\n        for (const participant of participants) {\r\n            this.figureOutConnectionStatus(participant.getId());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Figures out (and updates) the current connectivity status for\r\n     * the participant identified by the given id.\r\n     *\r\n     * @param {string} id the participant's id (MUC nickname or Colibri endpoint\r\n     * ID).\r\n     */\r\n    figureOutConnectionStatus(id) {\r\n        const participant = this.conference.getParticipantById(id);\r\n\r\n        if (!participant) {\r\n            // Probably the participant is no longer in the conference\r\n            // (at the time of writing this code, participant is\r\n            // detached from the conference and TRACK_REMOVED events are\r\n            // fired),\r\n            // so we don't care, but let's print the warning for\r\n            // debugging purpose\r\n            logger.warn(`figure out conn status - no participant for: ${id}`);\r\n\r\n            return;\r\n        }\r\n\r\n        const inP2PMode = this.conference.isP2PActive();\r\n        const isRestoringTimedOut = this._isRestoringTimedout(id);\r\n        const audioOnlyMode = this.rtc.getLastN() === 0;\r\n\r\n        // NOTE Overriding videoMuted to true for audioOnlyMode should disable\r\n        // any detection based on video playback or the last N.\r\n        const isVideoMuted = participant.isVideoMuted() || audioOnlyMode;\r\n        const isVideoTrackFrozen = this.isVideoTrackFrozen(participant);\r\n        const isInLastN = this.rtc.isInLastN(id);\r\n        let isConnActiveByJvb = this.connStatusFromJvb[id];\r\n\r\n        if (typeof isConnActiveByJvb !== 'boolean') {\r\n            // If no status was received from the JVB it means that it's active\r\n            // (the bridge does not send notification unless there is a problem)\r\n            logger.debug('Assuming connection active by JVB - no notification');\r\n            isConnActiveByJvb = true;\r\n        }\r\n\r\n        const newState\r\n            = inP2PMode\r\n                ? ParticipantConnectionStatusHandler._getNewStateForP2PMode(\r\n                    isVideoMuted,\r\n                    isVideoTrackFrozen)\r\n                : ParticipantConnectionStatusHandler._getNewStateForJvbMode(\r\n                    isConnActiveByJvb,\r\n                    isInLastN,\r\n                    isRestoringTimedOut,\r\n                    isVideoMuted,\r\n                    isVideoTrackFrozen);\r\n\r\n        // if the new state is not restoring clear timers and timestamps\r\n        // that we use to track the restoring state\r\n        if (newState !== ParticipantConnectionStatus.RESTORING) {\r\n            this._clearRestoringTimer(id);\r\n        }\r\n\r\n        logger.debug(\r\n            `Figure out conn status for ${id}, is video muted: ${\r\n                isVideoMuted} is active(jvb): ${\r\n                isConnActiveByJvb} video track frozen: ${\r\n                isVideoTrackFrozen} p2p mode: ${\r\n                inP2PMode} is in last N: ${\r\n                isInLastN} currentStatus => newStatus: ${\r\n                participant.getConnectionStatus()} => ${newState}`);\r\n\r\n        const nowMs = new Date().getTime();\r\n        const internalState = {\r\n            'instantMs': nowMs,\r\n            'isVideoMuted': isVideoMuted,\r\n            'isConnActiveByJvb': isConnActiveByJvb,\r\n            'isVideoTrackFrozen': isVideoTrackFrozen,\r\n            'inP2PMode': inP2PMode,\r\n            'inInLastN': isInLastN\r\n        };\r\n\r\n        if (!this.peerConnStatusMap[id] || this.peerConnStatusMap[id].state !== newState) {\r\n            // The peer connection status has changed. Compute the duration of the current\r\n            // connection status and send it as an analytics event.\r\n            if (this.peerConnStatusMap[id]) {\r\n                this.peerConnStatusMap[id].value = nowMs - this.peerConnStatusMap[id].startedMs;\r\n                Statistics.sendAnalytics(\r\n                    createParticipantConnectionStatusEvent(this.peerConnStatusMap[id]));\r\n            }\r\n\r\n            // And start a new status for the participant.\r\n            this.peerConnStatusMap[id] = {\r\n                'internalStates': [ internalState ],\r\n                'state': newState,\r\n                'startedMs': nowMs\r\n            };\r\n        } else {\r\n            // The connection status hasn't changed, but there was an internal state change.\r\n            // Register the internal state.\r\n            this.peerConnStatusMap[id].internalStates.push(internalState);\r\n        }\r\n\r\n        this._changeConnectionStatus(participant, newState);\r\n    }\r\n\r\n    /**\r\n     * On change in Last N set check all leaving and entering participants to\r\n     * change their corresponding statuses.\r\n     *\r\n     * @param {Array<string>} leavingLastN array of ids leaving lastN.\r\n     * @param {Array<string>} enteringLastN array of ids entering lastN.\r\n     * @private\r\n     */\r\n    _onLastNChanged(leavingLastN = [], enteringLastN = []) {\r\n        const now = Date.now();\r\n\r\n        logger.debug(\r\n            'leaving/entering lastN', leavingLastN, enteringLastN, now);\r\n\r\n        for (const id of leavingLastN) {\r\n            this.enteredLastNTimestamp.delete(id);\r\n            this._clearRestoringTimer(id);\r\n            this.figureOutConnectionStatus(id);\r\n        }\r\n        for (const id of enteringLastN) {\r\n            // store the timestamp this id is entering lastN\r\n            this.enteredLastNTimestamp.set(id, now);\r\n            this.figureOutConnectionStatus(id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the restoring timer for participant's video track and the\r\n     * timestamp for entering lastN.\r\n     *\r\n     * @param {string} participantId the id of the conference participant which\r\n     * is the same as the Colibri endpoint ID of the video channel allocated for\r\n     * the user on the videobridge.\r\n     */\r\n    _clearRestoringTimer(participantId) {\r\n        const rTimer = this.restoringTimers.get(participantId);\r\n\r\n        if (rTimer) {\r\n            clearTimeout(rTimer);\r\n            this.restoringTimers.delete(participantId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether a track had stayed enough in restoring state, compares\r\n     * current time and the time the track entered in lastN. If it hasn't\r\n     * timedout and there is no timer added, add new timer in order to give it\r\n     * more time to become active or mark it as interrupted on next check.\r\n     *\r\n     * @param {string} participantId the id of the conference participant which\r\n     * is the same as the Colibri endpoint ID of the video channel allocated for\r\n     * the user on the videobridge.\r\n     * @returns {boolean} <tt>true</tt> if the track was in restoring state\r\n     * more than the timeout ({@link DEFAULT_RESTORING_TIMEOUT}.) in order to\r\n     * set its status to interrupted.\r\n     * @private\r\n     */\r\n    _isRestoringTimedout(participantId) {\r\n        const enteredLastNTimestamp\r\n            = this.enteredLastNTimestamp.get(participantId);\r\n\r\n        if (enteredLastNTimestamp\r\n            && (Date.now() - enteredLastNTimestamp)\r\n                >= DEFAULT_RESTORING_TIMEOUT) {\r\n            return true;\r\n        }\r\n\r\n        // still haven't reached timeout, if there is no timer scheduled,\r\n        // schedule one so we can track the restoring state and change it after\r\n        // reaching the timeout\r\n        const rTimer = this.restoringTimers.get(participantId);\r\n\r\n        if (!rTimer) {\r\n            this.restoringTimers.set(participantId, setTimeout(\r\n                () => this.figureOutConnectionStatus(participantId),\r\n                DEFAULT_RESTORING_TIMEOUT));\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Handles RTC 'onmute' event for the video track.\r\n     *\r\n     * @param {QHSenseRemoteTrack} track the video track for which 'onmute' event\r\n     * will be processed.\r\n     */\r\n    onTrackRtcMuted(track) {\r\n        const participantId = track.getParticipantId();\r\n        const participant = this.conference.getParticipantById(participantId);\r\n\r\n        logger.debug(`Detector track RTC muted: ${participantId}`, Date.now());\r\n        if (!participant) {\r\n            logger.error(`No participant for id: ${participantId}`);\r\n\r\n            return;\r\n        }\r\n        this.rtcMutedTimestamp[participantId] = Date.now();\r\n        if (!participant.isVideoMuted()) {\r\n            // If the user is not muted according to the signalling we'll give\r\n            // it some time, before the connection interrupted event is\r\n            // triggered.\r\n            this.clearTimeout(participantId);\r\n\r\n            // The timeout is reduced when user is not in the last N\r\n            const timeout = this._getVideoFrozenTimeout(participantId);\r\n\r\n            this.trackTimers[participantId] = window.setTimeout(() => {\r\n                logger.debug(\r\n                    `Set RTC mute timeout for: ${participantId}\\\r\n                     of ${timeout} ms`);\r\n                this.clearTimeout(participantId);\r\n                this.figureOutConnectionStatus(participantId);\r\n            }, timeout);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles RTC 'onunmute' event for the video track.\r\n     *\r\n     * @param {QHSenseRemoteTrack} track the video track for which 'onunmute'\r\n     * event will be processed.\r\n     */\r\n    onTrackRtcUnmuted(track) {\r\n        const participantId = track.getParticipantId();\r\n\r\n        logger.debug(\r\n            `Detector track RTC unmuted: ${participantId}`, Date.now());\r\n\r\n        this.clearTimeout(participantId);\r\n        this.clearRtcMutedTimestamp(participantId);\r\n\r\n        this.figureOutConnectionStatus(participantId);\r\n    }\r\n\r\n    /**\r\n     * Here the signalling \"mute\"/\"unmute\" events are processed.\r\n     *\r\n     * @param {QHSenseRemoteTrack} track the remote video track for which\r\n     * the signalling mute/unmute event will be processed.\r\n     */\r\n    onSignallingMuteChanged(track) {\r\n        const participantId = track.getParticipantId();\r\n\r\n        logger.debug(\r\n            `Detector on track signalling mute changed: ${participantId}`,\r\n            track.isMuted());\r\n\r\n        this.figureOutConnectionStatus(participantId);\r\n    }\r\n}\r\n","/**\r\n * A collection of utility functions for taking in XML and parsing it to return\r\n * certain values.\r\n */\r\nexport default {\r\n    /**\r\n     * Parses the presence update of the focus and returns an object with the\r\n     * statuses related to recording.\r\n     *\r\n     * @param {Node} presence - An XMPP presence update.\r\n     * @returns {Object} The current presence values related to recording.\r\n     */\r\n    getFocusRecordingUpdate(presence) {\r\n        const jibriStatus = presence\r\n            && presence.getElementsByTagName('jibri-recording-status')[0];\r\n\r\n        if (!jibriStatus) {\r\n            return;\r\n        }\r\n\r\n        return {\r\n            error: jibriStatus.getAttribute('failure_reason'),\r\n            recordingMode: jibriStatus.getAttribute('recording_mode'),\r\n            sessionID: jibriStatus.getAttribute('session_id'),\r\n            status: jibriStatus.getAttribute('status')\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Parses the presence update from a hidden domain participant and returns\r\n     * an object with the statuses related to recording.\r\n     *\r\n     * @param {Node} presence - An XMPP presence update.\r\n     * @returns {Object} The current presence values related to recording.\r\n     */\r\n    getHiddenDomainUpdate(presence) {\r\n        const liveStreamViewURLContainer\r\n            = presence.getElementsByTagName('live-stream-view-url')[0];\r\n        const liveStreamViewURL = liveStreamViewURLContainer\r\n            && liveStreamViewURLContainer.textContent;\r\n        const modeContainer\r\n            = presence.getElementsByTagName('mode')[0];\r\n        const mode = modeContainer\r\n            && modeContainer.textContent\r\n            && modeContainer.textContent.toLowerCase();\r\n        const sessionIDContainer\r\n            = presence.getElementsByTagName('session_id')[0];\r\n        const sessionID\r\n            = sessionIDContainer && sessionIDContainer.textContent;\r\n\r\n        return {\r\n            liveStreamViewURL,\r\n            mode,\r\n            sessionID\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Returns the recording session ID from a successful IQ.\r\n     *\r\n     * @param {Node} response - The response from the IQ.\r\n     * @returns {string} The session ID of the recording session.\r\n     */\r\n    getSessionIdFromIq(response) {\r\n        const jibri = response && response.getElementsByTagName('jibri')[0];\r\n\r\n        return jibri && jibri.getAttribute('session_id');\r\n    },\r\n\r\n    /**\r\n     * Returns the recording session ID from a presence, if it exists.\r\n     *\r\n     * @param {Node} presence - An XMPP presence update.\r\n     * @returns {string|undefined} The session ID of the recording session.\r\n     */\r\n    getSessionId(presence) {\r\n        const sessionIdContainer\r\n            = presence.getElementsByTagName('session_id')[0];\r\n        const sessionId = sessionIdContainer && sessionIdContainer.textContent;\r\n\r\n        return sessionId;\r\n    },\r\n\r\n    /**\r\n     * Returns whether or not a presence is from the focus.\r\n     *\r\n     * @param {Node} presence - An XMPP presence update.\r\n     * @returns {boolean} True if the presence is from the focus.\r\n     */\r\n    isFromFocus(presence) {\r\n        return presence.getAttribute('from').includes('focus');\r\n    }\r\n};\r\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/* global __filename, $ */\r\n\r\nimport {\r\n    ICE_DURATION,\r\n    ICE_STATE_CHANGED\r\n} from '../../service/statistics/AnalyticsEvents';\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport { $iq, Strophe } from 'strophe.js';\r\nimport { integerHash } from '../util/StringUtils';\r\n\r\nimport JingleSession from './JingleSession';\r\nimport * as JingleSessionState from './JingleSessionState';\r\nimport SDP from './SDP';\r\nimport SDPDiffer from './SDPDiffer';\r\nimport SDPUtil from './SDPUtil';\r\nimport SignalingLayerImpl from './SignalingLayerImpl';\r\n\r\nimport RTCEvents from '../../service/RTC/RTCEvents';\r\nimport Statistics from '../statistics/statistics';\r\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\r\nimport AsyncQueue from '../util/AsyncQueue';\r\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Constant tells how long we're going to wait for IQ response, before timeout\r\n * error is  triggered.\r\n * @type {number}\r\n */\r\nconst IQ_TIMEOUT = 10000;\r\n\r\n/*\r\n * The default number of samples (per stat) to keep when webrtc stats gathering\r\n * is enabled in TraceablePeerConnection.\r\n */\r\nconst DEFAULT_MAX_STATS = 300;\r\n\r\n/**\r\n * @typedef {Object} JingleSessionPCOptions\r\n * @property {Object} abTesting - A/B testing related options (ask George).\r\n * @property {boolean} abTesting.enableSuspendVideoTest - enables the suspend\r\n * video test ?(ask George).\r\n * @property {boolean} disableH264 - Described in the config.js[1].\r\n * @property {boolean} disableRtx - Described in the config.js[1].\r\n * @property {boolean} disableSimulcast - Described in the config.js[1].\r\n * @property {boolean} enableLayerSuspension - Described in the config.js[1].\r\n * @property {boolean} failICE - it's an option used in the tests. Set to\r\n * <tt>true</tt> to block any real candidates and make the ICE fail.\r\n * @property {boolean} gatherStats - Described in the config.js[1].\r\n * @property {object} p2p - Peer to peer related options (FIXME those could be\r\n * fetched from config.p2p on the upper level).\r\n * @property {boolean} p2p.disableH264 - Described in the config.js[1].\r\n * @property {boolean} p2p.preferH264 - Described in the config.js[1].\r\n * @property {boolean} preferH264 - Described in the config.js[1].\r\n * @property {Object} testing - Testing and/or experimental options.\r\n * @property {boolean} testing.enableFirefoxSimulcast - Described in the\r\n * config.js[1].\r\n * @property {boolean} webrtcIceUdpDisable - Described in the config.js[1].\r\n * @property {boolean} webrtcIceTcpDisable - Described in the config.js[1].\r\n *\r\n */\r\n/**\r\n *\r\n */\r\nexport default class JingleSessionPC extends JingleSession {\r\n    /**\r\n     * Parses 'senders' attribute of the video content.\r\n     * @param {jQuery} jingleContents\r\n     * @return {string|null} one of the values of content \"senders\" attribute\r\n     * defined by Jingle. If there is no \"senders\" attribute or if the value is\r\n     * invalid then <tt>null</tt> will be returned.\r\n     * @private\r\n     */\r\n    static parseVideoSenders(jingleContents) {\r\n        const videoContents = jingleContents.find('>content[name=\"video\"]');\r\n\r\n        if (videoContents.length) {\r\n            const senders = videoContents[0].getAttribute('senders');\r\n\r\n            if (senders === 'both'\r\n                || senders === 'initiator'\r\n                || senders === 'responder'\r\n                || senders === 'none') {\r\n                return senders;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n\r\n    /**\r\n     * Creates new <tt>JingleSessionPC</tt>\r\n     * @param {string} sid the Jingle Session ID - random string which\r\n     * identifies the session\r\n     * @param {string} localJid our JID\r\n     * @param {string} remoteJid remote peer JID\r\n     * @param {Strophe.Connection} connection Strophe XMPP connection instance\r\n     * used to send packets.\r\n     * @param mediaConstraints the media constraints object passed to\r\n     * createOffer/Answer, as defined by the WebRTC standard\r\n     * @param iceConfig the ICE servers config object as defined by the WebRTC\r\n     * standard.\r\n     * @param {boolean} isP2P indicates whether this instance is\r\n     * meant to be used in a direct, peer to peer connection or <tt>false</tt>\r\n     * if it's a JVB connection.\r\n     * @param {boolean} isInitiator indicates if it will be the side which\r\n     * initiates the session.\r\n     * @constructor\r\n     *\r\n     * @implements {SignalingLayer}\r\n     */\r\n    constructor(\r\n            sid,\r\n            localJid,\r\n            remoteJid,\r\n            connection,\r\n            mediaConstraints,\r\n            iceConfig,\r\n            isP2P,\r\n            isInitiator) {\r\n        super(\r\n            sid,\r\n            localJid,\r\n            remoteJid, connection, mediaConstraints, iceConfig, isInitiator);\r\n\r\n        /**\r\n         * The bridge session's identifier. One Jingle session can during\r\n         * it's lifetime participate in multiple bridge sessions managed by\r\n         * Jicofo. A new bridge session is started whenever Jicofo sends\r\n         * 'session-initiate' or 'transport-replace'.\r\n         *\r\n         * @type {?string}\r\n         * @private\r\n         */\r\n        this._bridgeSessionId = null;\r\n\r\n        /**\r\n         * Stores result of {@link window.performance.now()} at the time when\r\n         * ICE enters 'checking' state.\r\n         * @type {number|null} null if no value has been stored yet\r\n         * @private\r\n         */\r\n        this._iceCheckingStartedTimestamp = null;\r\n\r\n        /**\r\n         * Stores result of {@link window.performance.now()} at the time when\r\n         * first ICE candidate is spawned by the peerconnection to mark when\r\n         * ICE gathering started. That's, because ICE gathering state changed\r\n         * events are not supported by most of the browsers, so we try something\r\n         * that will work everywhere. It may not be as accurate, but given that\r\n         * 'host' candidate usually comes first, the delay should be minimal.\r\n         * @type {number|null} null if no value has been stored yet\r\n         * @private\r\n         */\r\n        this._gatheringStartedTimestamp = null;\r\n\r\n        /**\r\n         * Indicates whether or not this session is willing to send/receive\r\n         * video media. When set to <tt>false</tt> the underlying peer\r\n         * connection will disable local video transfer and the remote peer will\r\n         * be will be asked to stop sending video via 'content-modify' IQ\r\n         * (the senders attribute of video contents will be adjusted\r\n         * accordingly). Note that this notification is sent only in P2P\r\n         * session, because Jicofo does not support it yet. Obviously when\r\n         * the value is changed from <tt>false</tt> to <tt>true</tt> another\r\n         * notification will be sent to resume video transfer on the remote\r\n         * side.\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._localVideoActive = true;\r\n\r\n        /**\r\n         * Indicates whether or not the remote peer has video transfer active.\r\n         * When set to <tt>true</tt> it means that remote peer is neither\r\n         * sending nor willing to receive video. In such case we'll ask\r\n         * our peerconnection to stop sending video by calling\r\n         * {@link TraceablePeerConnection.setVideoTransferActive} with\r\n         * <tt>false</tt>.\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._remoteVideoActive = true;\r\n\r\n        /**\r\n         * Marks that ICE gathering duration has been reported already. That\r\n         * prevents reporting it again, after eventual 'transport-replace' (JVB\r\n         * conference migration/ICE restart).\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._gatheringReported = false;\r\n\r\n        this.lasticecandidate = false;\r\n        this.closed = false;\r\n\r\n        /**\r\n         * Indicates whether or not this <tt>JingleSessionPC</tt> is used in\r\n         * a peer to peer type of session.\r\n         * @type {boolean} <tt>true</tt> if it's a peer to peer\r\n         * session or <tt>false</tt> if it's a JVB session\r\n         */\r\n        this.isP2P = isP2P;\r\n\r\n        /**\r\n         * The signaling layer implementation.\r\n         * @type {SignalingLayerImpl}\r\n         */\r\n        this.signalingLayer = new SignalingLayerImpl();\r\n\r\n        /**\r\n         * The queue used to serialize operations done on the peerconnection.\r\n         *\r\n         * @type {AsyncQueue}\r\n         */\r\n        this.modificationQueue = new AsyncQueue();\r\n\r\n        /**\r\n         * Flag used to guarantee that the connection established event is\r\n         * triggered just once.\r\n         * @type {boolean}\r\n         */\r\n        this.wasConnected = false;\r\n\r\n        /**\r\n         * Keeps track of how long (in ms) it took from ICE start to ICE\r\n         * connect.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.establishmentDuration = undefined;\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Checks whether or not this session instance is still operational.\r\n     * @private\r\n     * @returns {boolean} {@code true} if operation or {@code false} otherwise.\r\n     */\r\n    _assertNotEnded() {\r\n        return this.state !== JingleSessionState.ENDED;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     * @param {JingleSessionPCOptions} options  - a set of config options.\r\n     */\r\n    doInitialize(options) {\r\n        this.failICE = Boolean(options.failICE);\r\n        this.lasticecandidate = false;\r\n        this.options = options;\r\n\r\n        /**\r\n         * {@code true} if reconnect is in progress.\r\n         * @type {boolean}\r\n         */\r\n        this.isReconnect = false;\r\n\r\n        /**\r\n         * Set to {@code true} if the connection was ever stable\r\n         * @type {boolean}\r\n         */\r\n        this.wasstable = false;\r\n        this.webrtcIceUdpDisable = Boolean(options.webrtcIceUdpDisable);\r\n        this.webrtcIceTcpDisable = Boolean(options.webrtcIceTcpDisable);\r\n\r\n        const pcOptions = { disableRtx: options.disableRtx };\r\n\r\n        if (options.gatherStats) {\r\n            pcOptions.maxstats = DEFAULT_MAX_STATS;\r\n        }\r\n\r\n        if (this.isP2P) {\r\n            // simulcast needs to be disabled for P2P (121) calls\r\n            pcOptions.disableSimulcast = true;\r\n            pcOptions.disableH264 = options.p2p && options.p2p.disableH264;\r\n            pcOptions.preferH264 = options.p2p && options.p2p.preferH264;\r\n\r\n            const abtestSuspendVideo = this._abtestSuspendVideoEnabled(options);\r\n\r\n            if (typeof abtestSuspendVideo !== 'undefined') {\r\n                pcOptions.abtestSuspendVideo = abtestSuspendVideo;\r\n            }\r\n        } else {\r\n            // H264 does not support simulcast, so it needs to be disabled.\r\n            pcOptions.disableSimulcast\r\n                = options.disableSimulcast\r\n                    || (options.preferH264 && !options.disableH264);\r\n            pcOptions.preferH264 = options.preferH264;\r\n            pcOptions.enableFirefoxSimulcast\r\n                = options.testing && options.testing.enableFirefoxSimulcast;\r\n            pcOptions.enableLayerSuspension = options.enableLayerSuspension;\r\n        }\r\n\r\n        if (options.startSilent) {\r\n            pcOptions.startSilent = true;\r\n        }\r\n\r\n        this.peerconnection\r\n            = this.rtc.createPeerConnection(\r\n                    this.signalingLayer,\r\n                    this.iceConfig,\r\n                    this.isP2P,\r\n                    pcOptions);\r\n\r\n        this.peerconnection.onicecandidate = ev => {\r\n            if (!ev) {\r\n                // There was an incomplete check for ev before which left\r\n                // the last line of the function unprotected from a potential\r\n                // throw of an exception. Consequently, it may be argued that\r\n                // the check is unnecessary. Anyway, I'm leaving it and making\r\n                // the check complete.\r\n                return;\r\n            }\r\n\r\n            // XXX this is broken, candidate is not parsed.\r\n            const candidate = ev.candidate;\r\n            const now = window.performance.now();\r\n\r\n            if (candidate) {\r\n                if (this._gatheringStartedTimestamp === null) {\r\n                    this._gatheringStartedTimestamp = now;\r\n                }\r\n\r\n                // Discard candidates of disabled protocols.\r\n                let protocol = candidate.protocol;\r\n\r\n                if (typeof protocol === 'string') {\r\n                    protocol = protocol.toLowerCase();\r\n                    if (protocol === 'tcp' || protocol === 'ssltcp') {\r\n                        if (this.webrtcIceTcpDisable) {\r\n                            return;\r\n                        }\r\n                    } else if (protocol === 'udp') {\r\n                        if (this.webrtcIceUdpDisable) {\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            } else if (!this._gatheringReported) {\r\n                // End of gathering\r\n                Statistics.sendAnalytics(\r\n                    ICE_DURATION,\r\n                    {\r\n                        phase: 'gathering',\r\n                        value: now - this._gatheringStartedTimestamp,\r\n                        p2p: this.isP2P,\r\n                        initiator: this.isInitiator\r\n                    });\r\n                this._gatheringReported = true;\r\n            }\r\n            this.sendIceCandidate(candidate);\r\n        };\r\n\r\n        // Note there is a change in the spec about closed:\r\n        // This value moved into the RTCPeerConnectionState enum in\r\n        // the May 13, 2016 draft of the specification, as it reflects the state\r\n        // of the RTCPeerConnection, not the signaling connection. You now\r\n        // detect a closed connection by checking for connectionState to be\r\n        // \"closed\" instead.\r\n        // I suppose at some point this will be moved to onconnectionstatechange\r\n        this.peerconnection.onsignalingstatechange = () => {\r\n            if (this.peerconnection.signalingState === 'stable') {\r\n                this.wasstable = true;\r\n            } else if (this.peerconnection.signalingState === 'closed'\r\n                || this.peerconnection.connectionState === 'closed') {\r\n                this.room.eventEmitter.emit(XMPPEvents.SUSPEND_DETECTED, this);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * The oniceconnectionstatechange event handler contains the code to\r\n         * execute when the iceconnectionstatechange event, of type Event,\r\n         * is received by this RTCPeerConnection. Such an event is sent when\r\n         * the value of RTCPeerConnection.iceConnectionState changes.\r\n         */\r\n        this.peerconnection.oniceconnectionstatechange = () => {\r\n            const now = window.performance.now();\r\n\r\n            if (!this.isP2P) {\r\n                this.room.connectionTimes[\r\n                    `ice.state.${this.peerconnection.iceConnectionState}`]\r\n                    = now;\r\n            }\r\n            logger.log(\r\n                `(TIME) ICE ${this.peerconnection.iceConnectionState}`\r\n                    + ` P2P? ${this.isP2P}:\\t`,\r\n                now);\r\n\r\n            Statistics.sendAnalytics(\r\n                ICE_STATE_CHANGED,\r\n                {\r\n                    p2p: this.isP2P,\r\n                    state: this.peerconnection.iceConnectionState,\r\n                    'signaling_state': this.peerconnection.signalingState,\r\n                    reconnect: this.isReconnect,\r\n                    value: now\r\n                });\r\n\r\n            this.room.eventEmitter.emit(\r\n                XMPPEvents.ICE_CONNECTION_STATE_CHANGED,\r\n                this,\r\n                this.peerconnection.iceConnectionState);\r\n            switch (this.peerconnection.iceConnectionState) {\r\n            case 'checking':\r\n                this._iceCheckingStartedTimestamp = now;\r\n                break;\r\n            case 'connected':\r\n                // Informs interested parties that the connection has been\r\n                // restored.\r\n                if (this.peerconnection.signalingState === 'stable') {\r\n                    if (this.isReconnect) {\r\n                        this.room.eventEmitter.emit(\r\n                            XMPPEvents.CONNECTION_RESTORED, this);\r\n                    }\r\n                }\r\n\r\n                if (!this.wasConnected && this.wasstable) {\r\n\r\n                    Statistics.sendAnalytics(\r\n                        ICE_DURATION,\r\n                        {\r\n                            phase: 'checking',\r\n                            value: now - this._iceCheckingStartedTimestamp,\r\n                            p2p: this.isP2P,\r\n                            initiator: this.isInitiator\r\n                        });\r\n\r\n                    // Switch between ICE gathering and ICE checking whichever\r\n                    // started first (scenarios are different for initiator\r\n                    // vs responder)\r\n                    const iceStarted\r\n                        = Math.min(\r\n                            this._iceCheckingStartedTimestamp,\r\n                            this._gatheringStartedTimestamp);\r\n\r\n                    this.establishmentDuration = now - iceStarted;\r\n\r\n                    Statistics.sendAnalytics(\r\n                        ICE_DURATION,\r\n                        {\r\n                            phase: 'establishment',\r\n                            value: this.establishmentDuration,\r\n                            p2p: this.isP2P,\r\n                            initiator: this.isInitiator\r\n                        });\r\n\r\n                    this.wasConnected = true;\r\n                    this.room.eventEmitter.emit(\r\n                        XMPPEvents.CONNECTION_ESTABLISHED, this);\r\n                }\r\n                this.isReconnect = false;\r\n                break;\r\n            case 'disconnected':\r\n                this.isReconnect = true;\r\n\r\n                // Informs interested parties that the connection has been\r\n                // interrupted.\r\n                if (this.wasstable) {\r\n                    this.room.eventEmitter.emit(\r\n                        XMPPEvents.CONNECTION_INTERRUPTED, this);\r\n                }\r\n                break;\r\n            case 'failed':\r\n                this.room.eventEmitter.emit(\r\n                    XMPPEvents.CONNECTION_ICE_FAILED, this);\r\n                break;\r\n            }\r\n        };\r\n        this.peerconnection.onnegotiationneeded = () => {\r\n            this.room.eventEmitter.emit(XMPPEvents.PEERCONNECTION_READY, this);\r\n        };\r\n\r\n        // The signaling layer will bind it's listeners at this point\r\n        this.signalingLayer.setChatRoom(this.room);\r\n\r\n        if (!this.isP2P && options.enableLayerSuspension) {\r\n            // If this is the bridge session, we'll listen for\r\n            // IS_SELECTED_CHANGED events and notify the peer connection\r\n            this.rtc.addListener(RTCEvents.IS_SELECTED_CHANGED,\r\n                isSelected => {\r\n                    this.peerconnection.setIsSelected(isSelected);\r\n                    logger.info('Doing local O/A due to '\r\n                        + 'IS_SELECTED_CHANGED event');\r\n                    this.modificationQueue.push(finishedCallback => {\r\n                        this._renegotiate()\r\n                            .then(finishedCallback)\r\n                            .catch(finishedCallback);\r\n                    });\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends given candidate in Jingle 'transport-info' message.\r\n     * @param {RTCIceCandidate} candidate the WebRTC ICE candidate instance\r\n     * @private\r\n     */\r\n    sendIceCandidate(candidate) {\r\n        const localSDP = new SDP(this.peerconnection.localDescription.sdp);\r\n\r\n        if (candidate && !this.lasticecandidate) {\r\n            const ice\r\n                = SDPUtil.iceparams(\r\n                    localSDP.media[candidate.sdpMLineIndex], localSDP.session);\r\n            const jcand = SDPUtil.candidateToJingle(candidate.candidate);\r\n\r\n            if (!(ice && jcand)) {\r\n                const errorMesssage = 'failed to get ice && jcand';\r\n\r\n                GlobalOnErrorHandler.callErrorHandler(new Error(errorMesssage));\r\n                logger.error(errorMesssage);\r\n\r\n                return;\r\n            }\r\n            ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';\r\n\r\n            if (this.usedrip) {\r\n                if (this.dripContainer.length === 0) {\r\n                    // start 20ms callout\r\n                    setTimeout(() => {\r\n                        if (this.dripContainer.length === 0) {\r\n                            return;\r\n                        }\r\n                        this.sendIceCandidates(this.dripContainer);\r\n                        this.dripContainer = [];\r\n                    }, 20);\r\n                }\r\n                this.dripContainer.push(candidate);\r\n            } else {\r\n                this.sendIceCandidates([ candidate ]);\r\n            }\r\n        } else {\r\n            logger.log('sendIceCandidate: last candidate.');\r\n\r\n            // FIXME: remember to re-think in ICE-restart\r\n            this.lasticecandidate = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends given candidates in Jingle 'transport-info' message.\r\n     * @param {Array<RTCIceCandidate>} candidates an array of the WebRTC ICE\r\n     * candidate instances\r\n     * @private\r\n     */\r\n    sendIceCandidates(candidates) {\r\n        if (!this._assertNotEnded('sendIceCandidates')) {\r\n\r\n            return;\r\n        }\r\n\r\n        logger.log('sendIceCandidates', candidates);\r\n        const cand = $iq({ to: this.remoteJid,\r\n            type: 'set' })\r\n            .c('jingle', { xmlns: 'urn:xmpp:jingle:1',\r\n                action: 'transport-info',\r\n                initiator: this.initiatorJid,\r\n                sid: this.sid });\r\n\r\n        const localSDP = new SDP(this.peerconnection.localDescription.sdp);\r\n\r\n        for (let mid = 0; mid < localSDP.media.length; mid++) {\r\n            const cands = candidates.filter(el => el.sdpMLineIndex === mid);\r\n            const mline\r\n                = SDPUtil.parseMLine(localSDP.media[mid].split('\\r\\n')[0]);\r\n\r\n            if (cands.length > 0) {\r\n                const ice\r\n                    = SDPUtil.iceparams(localSDP.media[mid], localSDP.session);\r\n\r\n                ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';\r\n                cand.c('content', {\r\n                    creator: this.initiatorJid === this.localJid\r\n                        ? 'initiator' : 'responder',\r\n                    name: cands[0].sdpMid ? cands[0].sdpMid : mline.media\r\n                }).c('transport', ice);\r\n                for (let i = 0; i < cands.length; i++) {\r\n                    const candidate\r\n                        = SDPUtil.candidateToJingle(cands[i].candidate);\r\n\r\n                    // Mangle ICE candidate if 'failICE' test option is enabled\r\n\r\n                    if (this.failICE) {\r\n                        candidate.ip = '1.1.1.1';\r\n                    }\r\n                    cand.c('candidate', candidate).up();\r\n                }\r\n\r\n                // add fingerprint\r\n                const fingerprintLine\r\n                    = SDPUtil.findLine(\r\n                        localSDP.media[mid],\r\n                        'a=fingerprint:', localSDP.session);\r\n\r\n                if (fingerprintLine) {\r\n                    const tmp = SDPUtil.parseFingerprint(fingerprintLine);\r\n\r\n                    tmp.required = true;\r\n                    cand.c(\r\n                        'fingerprint',\r\n                        { xmlns: 'urn:xmpp:jingle:apps:dtls:0' })\r\n                        .t(tmp.fingerprint);\r\n                    delete tmp.fingerprint;\r\n                    cand.attrs(tmp);\r\n                    cand.up();\r\n                }\r\n                cand.up(); // transport\r\n                cand.up(); // content\r\n            }\r\n        }\r\n\r\n        // might merge last-candidate notification into this, but it is called\r\n        // a lot later. See webrtc issue #2340\r\n        // logger.log('was this the last candidate', this.lasticecandidate);\r\n        this.connection.sendIQ(\r\n            cand, null, this.newJingleErrorHandler(cand), IQ_TIMEOUT);\r\n    }\r\n\r\n    /**\r\n     * Sends Jingle 'session-info' message which includes custom QHSense Meet\r\n     * 'ice-state' element with the text value 'failed' to let Jicofo know\r\n     * that the ICE connection has entered the failed state. It can then\r\n     * choose to re-create JVB channels and send 'transport-replace' to\r\n     * retry the connection.\r\n     */\r\n    sendIceFailedNotification() {\r\n        const sessionInfo\r\n            = $iq({\r\n                to: this.remoteJid,\r\n                type: 'set' })\r\n            .c('jingle', { xmlns: 'urn:xmpp:jingle:1',\r\n                action: 'session-info',\r\n                initiator: this.initiatorJid,\r\n                sid: this.sid })\r\n            .c('ice-state', { xmlns: 'http://jitsi.org/protocol/focus' })\r\n            .t('failed')\r\n            .up();\r\n\r\n        this._bridgeSessionId\r\n            && sessionInfo.c(\r\n                'bridge-session', {\r\n                    xmlns: 'http://jitsi.org/protocol/focus',\r\n                    id: this._bridgeSessionId\r\n                });\r\n\r\n        this.connection.sendIQ(\r\n            sessionInfo,\r\n            null,\r\n            this.newJingleErrorHandler(sessionInfo),\r\n            /*\r\n             * This message will be often sent when there are connectivity\r\n             * issues, so make it slightly longer than Prosody's default BOSH\r\n             * inactivity timeout of 60 seconds.\r\n             */ 65);\r\n    }\r\n\r\n    /**\r\n     * {@inheritDoc}\r\n     */\r\n    addIceCandidates(elem) {\r\n        if (this.peerconnection.signalingState === 'closed') {\r\n            logger.warn('Ignored add ICE candidate when in closed state');\r\n\r\n            return;\r\n        }\r\n\r\n        const iceCandidates = [];\r\n\r\n        elem.find('>content>transport>candidate')\r\n            .each((idx, candidate) => {\r\n                let line = SDPUtil.candidateFromJingle(candidate);\r\n\r\n                line = line.replace('\\r\\n', '').replace('a=', '');\r\n\r\n                // FIXME this code does not care to handle\r\n                // non-bundle transport\r\n                const rtcCandidate = new RTCIceCandidate({\r\n                    sdpMLineIndex: 0,\r\n\r\n                    // FF comes up with more complex names like audio-23423,\r\n                    // Given that it works on both Chrome and FF without\r\n                    // providing it, let's leave it like this for the time\r\n                    // being...\r\n                    // sdpMid: 'audio',\r\n                    sdpMid: '',\r\n                    candidate: line\r\n                });\r\n\r\n                iceCandidates.push(rtcCandidate);\r\n            });\r\n\r\n        if (!iceCandidates.length) {\r\n            logger.error(\r\n                'No ICE candidates to add ?', elem[0] && elem[0].outerHTML);\r\n\r\n            return;\r\n        }\r\n\r\n        // We want to have this task queued, so that we know it is executed,\r\n        // after the initial sRD/sLD offer/answer cycle was done (based on\r\n        // the assumption that candidates are spawned after the offer/answer\r\n        // and XMPP preserves order).\r\n        const workFunction = finishedCallback => {\r\n            for (const iceCandidate of iceCandidates) {\r\n                this.peerconnection.addIceCandidate(iceCandidate)\r\n                    .then(\r\n                        () => logger.debug('addIceCandidate ok!'),\r\n                        err => logger.error('addIceCandidate failed!', err));\r\n            }\r\n\r\n            finishedCallback();\r\n        };\r\n\r\n        logger.debug(\r\n            `Queued add (${iceCandidates.length}) ICE candidates task...`);\r\n        this.modificationQueue.push(workFunction);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param contents\r\n     */\r\n    readSsrcInfo(contents) {\r\n        const ssrcs\r\n            = $(contents).find(\r\n                '>description>'\r\n                    + 'source[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]');\r\n\r\n        ssrcs.each((i, ssrcElement) => {\r\n            const ssrc = Number(ssrcElement.getAttribute('ssrc'));\r\n\r\n            if (this.isP2P) {\r\n                // In P2P all SSRCs are owner by the remote peer\r\n                this.signalingLayer.setSSRCOwner(\r\n                    ssrc, Strophe.getResourceFromJid(this.remoteJid));\r\n            } else {\r\n                $(ssrcElement)\r\n                    .find('>ssrc-info[xmlns=\"http://jitsi.org/jitmeet\"]')\r\n                    .each((i3, ssrcInfoElement) => {\r\n                        const owner = ssrcInfoElement.getAttribute('owner');\r\n\r\n                        if (owner && owner.length) {\r\n                            if (isNaN(ssrc) || ssrc < 0) {\r\n                                logger.warn(\r\n                                    `Invalid SSRC ${ssrc} value received`\r\n                                        + ` for ${owner}`);\r\n                            } else {\r\n                                this.signalingLayer.setSSRCOwner(\r\n                                    ssrc,\r\n                                    Strophe.getResourceFromJid(owner));\r\n                            }\r\n                        }\r\n                    });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Makes the underlying TraceablePeerConnection generate new SSRC for\r\n     * the recvonly video stream.\r\n     * @deprecated\r\n     */\r\n    generateRecvonlySsrc() {\r\n        if (this.peerconnection) {\r\n            this.peerconnection.generateRecvonlySsrc();\r\n        } else {\r\n            logger.error(\r\n                'Unable to generate recvonly SSRC - no peerconnection');\r\n        }\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n    /**\r\n     * Accepts incoming Jingle 'session-initiate' and should send\r\n     * 'session-accept' in result.\r\n     * @param jingleOffer jQuery selector pointing to the jingle element of\r\n     * the offer IQ\r\n     * @param success callback called when we accept incoming session\r\n     * successfully and receive RESULT packet to 'session-accept' sent.\r\n     * @param failure function(error) called if for any reason we fail to accept\r\n     * the incoming offer. 'error' argument can be used to log some details\r\n     * about the error.\r\n     * @param {Array<QHSenseLocalTrack>} [localTracks] the optional list of\r\n     * the local tracks that will be added, before the offer/answer cycle\r\n     * executes. We allow the localTracks to optionally be passed in so that\r\n     * the addition of the local tracks and the processing of the initial offer\r\n     * can all be done atomically. We want to make sure that any other\r\n     * operations which originate in the XMPP Jingle messages related with\r\n     * this session to be executed with an assumption that the initial\r\n     * offer/answer cycle has been executed already.\r\n     */\r\n    acceptOffer(jingleOffer, success, failure, localTracks) {\r\n        this.setOfferAnswerCycle(\r\n            jingleOffer,\r\n            () => {\r\n                // FIXME we may not care about RESULT packet for session-accept\r\n                // then we should either call 'success' here immediately or\r\n                // modify sendSessionAccept method to do that\r\n                this.sendSessionAccept(success, failure);\r\n            },\r\n            failure,\r\n            localTracks);\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Creates an offer and sends Jingle 'session-initiate' to the remote peer.\r\n     * @param {Array<QHSenseLocalTrack>} localTracks the local tracks that will be\r\n     * added, before the offer/answer cycle executes (for the local track\r\n     * addition to be an atomic operation together with the offer/answer).\r\n     */\r\n    invite(localTracks) {\r\n        if (!this.isInitiator) {\r\n            throw new Error('Trying to invite from the responder session');\r\n        }\r\n        const workFunction = finishedCallback => {\r\n            for (const localTrack of localTracks) {\r\n                this.peerconnection.addTrack(localTrack);\r\n            }\r\n            this.peerconnection.createOffer(this.mediaConstraints)\r\n                .then(offerSdp => {\r\n                    this.peerconnection.setLocalDescription(offerSdp)\r\n                        .then(() => {\r\n                            // NOTE that the offer is obtained from\r\n                            // the localDescription getter as it needs to go\r\n                            // though the transformation chain.\r\n                            this.sendSessionInitiate(\r\n                                this.peerconnection.localDescription.sdp);\r\n                            finishedCallback();\r\n                        }, error => {\r\n                            logger.error(\r\n                                'Failed to set local SDP', error, offerSdp);\r\n                            finishedCallback(error);\r\n                        });\r\n                }, error => {\r\n                    logger.error(\r\n                        'Failed to create an offer',\r\n                        error,\r\n                        this.mediaConstraints);\r\n                    finishedCallback(error);\r\n                });\r\n        };\r\n\r\n        this.modificationQueue.push(\r\n            workFunction,\r\n            error => {\r\n                if (error) {\r\n                    logger.error('invite error', error);\r\n                } else {\r\n                    logger.debug('invite executed - OK');\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Sends 'session-initiate' to the remote peer.\r\n     *\r\n     * NOTE this method is synchronous and we're not waiting for the RESULT\r\n     * response which would delay the startup process.\r\n     *\r\n     * @param {string} offerSdp  - The local session description which will be\r\n     * used to generate an offer.\r\n     * @private\r\n     */\r\n    sendSessionInitiate(offerSdp) {\r\n        let init = $iq({\r\n            to: this.remoteJid,\r\n            type: 'set'\r\n        }).c('jingle', {\r\n            xmlns: 'urn:xmpp:jingle:1',\r\n            action: 'session-initiate',\r\n            initiator: this.initiatorJid,\r\n            sid: this.sid\r\n        });\r\n\r\n        new SDP(offerSdp).toJingle(\r\n            init,\r\n            this.isInitiator ? 'initiator' : 'responder');\r\n        init = init.tree();\r\n        logger.info('Session-initiate: ', init);\r\n        this.connection.sendIQ(init,\r\n            () => {\r\n                logger.info('Got RESULT for \"session-initiate\"');\r\n            },\r\n            error => {\r\n                logger.error('\"session-initiate\" error', error);\r\n            },\r\n            IQ_TIMEOUT);\r\n    }\r\n\r\n    /**\r\n     * Sets the answer received from the remote peer.\r\n     * @param jingleAnswer\r\n     */\r\n    setAnswer(jingleAnswer) {\r\n        if (!this.isInitiator) {\r\n            throw new Error('Trying to set an answer on the responder session');\r\n        }\r\n        this.setOfferAnswerCycle(\r\n            jingleAnswer,\r\n            () => {\r\n                logger.info('setAnswer - succeeded');\r\n            },\r\n            error => {\r\n                logger.error('setAnswer failed: ', error);\r\n            });\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n    /**\r\n     * This is a setRemoteDescription/setLocalDescription cycle which starts at\r\n     * converting Strophe Jingle IQ into remote offer SDP. Once converted\r\n     * setRemoteDescription, createAnswer and setLocalDescription calls follow.\r\n     * @param jingleOfferAnswerIq jQuery selector pointing to the jingle element\r\n     *        of the offer (or answer) IQ\r\n     * @param success callback called when sRD/sLD cycle finishes successfully.\r\n     * @param failure callback called with an error object as an argument if we\r\n     *        fail at any point during setRD, createAnswer, setLD.\r\n     * @param {Array<QHSenseLocalTrack>} [localTracks] the optional list of\r\n     * the local tracks that will be added, before the offer/answer cycle\r\n     * executes (for the local track addition to be an atomic operation together\r\n     * with the offer/answer).\r\n     */\r\n    setOfferAnswerCycle(jingleOfferAnswerIq, success, failure, localTracks) {\r\n        const workFunction = finishedCallback => {\r\n\r\n            if (localTracks) {\r\n                for (const track of localTracks) {\r\n                    this.peerconnection.addTrack(track);\r\n                }\r\n            }\r\n\r\n            const newRemoteSdp\r\n                = this._processNewJingleOfferIq(jingleOfferAnswerIq);\r\n            const oldLocalSdp\r\n                = this.peerconnection.localDescription.sdp;\r\n\r\n            const bridgeSession\r\n                = $(jingleOfferAnswerIq)\r\n                    .find('>bridge-session['\r\n                        + 'xmlns=\"http://jitsi.org/protocol/focus\"]');\r\n            const bridgeSessionId = bridgeSession.attr('id');\r\n\r\n            if (bridgeSessionId !== this._bridgeSessionId) {\r\n                this._bridgeSessionId = bridgeSessionId;\r\n            }\r\n\r\n            this._renegotiate(newRemoteSdp.raw)\r\n                .then(() => {\r\n                    if (this.state === JingleSessionState.PENDING) {\r\n                        this.state = JingleSessionState.ACTIVE;\r\n\r\n                        // Sync up video transfer active/inactive only after\r\n                        // the initial O/A cycle. We want to adjust the video\r\n                        // media direction only in the local SDP and the Jingle\r\n                        // contents direction included in the initial\r\n                        // offer/answer is mapped to the remote SDP. Jingle\r\n                        // 'content-modify' IQ is processed in a way that it\r\n                        // will only modify local SDP when remote peer is no\r\n                        // longer interested in receiving video content.\r\n                        // Changing media direction in the remote SDP will mess\r\n                        // up our SDP translation chain (simulcast, video mute,\r\n                        // RTX etc.)\r\n                        if (this.isP2P && !this._localVideoActive) {\r\n                            this.sendContentModify(this._localVideoActive);\r\n                        }\r\n                    }\r\n\r\n                    // Old local SDP will be available when we're setting answer\r\n                    // for the first time, but not when offer and it's fine\r\n                    // since we're generating an answer now it will contain all\r\n                    // our SSRCs\r\n                    if (oldLocalSdp) {\r\n                        const newLocalSdp\r\n                            = new SDP(this.peerconnection.localDescription.sdp);\r\n\r\n                        this.notifyMySSRCUpdate(\r\n                            new SDP(oldLocalSdp), newLocalSdp);\r\n                    }\r\n\r\n                    finishedCallback();\r\n                }, error => {\r\n                    logger.error(\r\n                        `Error renegotiating after setting new remote ${\r\n                            this.isInitiator ? 'answer: ' : 'offer: '}${error}`,\r\n                        newRemoteSdp);\r\n\r\n                    finishedCallback(error);\r\n                });\r\n        };\r\n\r\n        this.modificationQueue.push(\r\n            workFunction,\r\n            error => {\r\n                error ? failure(error) : success();\r\n            });\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Although it states \"replace transport\" it does accept full Jingle offer\r\n     * which should contain new ICE transport details.\r\n     * @param jingleOfferElem an element Jingle IQ that contains new offer and\r\n     *        transport info.\r\n     * @param success callback called when we succeed to accept new offer.\r\n     * @param failure function(error) called when we fail to accept new offer.\r\n     */\r\n    replaceTransport(jingleOfferElem, success, failure) {\r\n        this.room.eventEmitter.emit(XMPPEvents.ICE_RESTARTING, this);\r\n\r\n        // We need to first reject the 'data' section to have the SCTP stack\r\n        // cleaned up to signal the known data channel is now invalid. After\r\n        // that the original offer is set to have the SCTP connection\r\n        // established with the new bridge.\r\n        const originalOffer = jingleOfferElem.clone();\r\n\r\n        jingleOfferElem\r\n            .find('>content[name=\\'data\\']')\r\n            .attr('senders', 'rejected');\r\n\r\n        // Remove all remote sources in order to reset the client's state\r\n        // for the remote MediaStreams. When a conference is moved to\r\n        // another bridge it will start streaming with a sequence number\r\n        // that is not in sync with the most recently seen by the client.\r\n        // The symptoms include frozen or black video and lots of \"failed to\r\n        // unprotect SRTP packets\" in Chrome logs.\r\n        jingleOfferElem\r\n            .find('>content>description>source')\r\n            .remove();\r\n        jingleOfferElem\r\n            .find('>content>description>ssrc-group')\r\n            .remove();\r\n\r\n        // First set an offer with a rejected 'data' section\r\n        this.setOfferAnswerCycle(\r\n            jingleOfferElem,\r\n            () => {\r\n                // Now set the original offer(with the 'data' section)\r\n                this.setOfferAnswerCycle(\r\n                    originalOffer,\r\n                    () => {\r\n                        const localSDP\r\n                            = new SDP(this.peerconnection.localDescription.sdp);\r\n\r\n                        this.sendTransportAccept(localSDP, success, failure);\r\n\r\n                        this.room.eventEmitter.emit(\r\n                            XMPPEvents.ICE_RESTART_SUCCESS,\r\n                            this,\r\n                            originalOffer);\r\n                    },\r\n                    failure);\r\n            },\r\n            failure\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sends Jingle 'session-accept' message.\r\n     * @param {function()} success callback called when we receive 'RESULT'\r\n     *        packet for the 'session-accept'\r\n     * @param {function(error)} failure called when we receive an error response\r\n     *        or when the request has timed out.\r\n     * @private\r\n     */\r\n    sendSessionAccept(success, failure) {\r\n        // NOTE: since we're just reading from it, we don't need to be within\r\n        //  the modification queue to access the local description\r\n        const localSDP = new SDP(this.peerconnection.localDescription.sdp);\r\n        let accept = $iq({ to: this.remoteJid,\r\n            type: 'set' })\r\n            .c('jingle', { xmlns: 'urn:xmpp:jingle:1',\r\n                action: 'session-accept',\r\n                initiator: this.initiatorJid,\r\n                responder: this.responderJid,\r\n                sid: this.sid });\r\n\r\n        if (this.webrtcIceTcpDisable) {\r\n            localSDP.removeTcpCandidates = true;\r\n        }\r\n        if (this.webrtcIceUdpDisable) {\r\n            localSDP.removeUdpCandidates = true;\r\n        }\r\n        if (this.failICE) {\r\n            localSDP.failICE = true;\r\n        }\r\n        localSDP.toJingle(\r\n            accept,\r\n            this.initiatorJid === this.localJid ? 'initiator' : 'responder',\r\n            null);\r\n\r\n        // Calling tree() to print something useful\r\n        accept = accept.tree();\r\n        logger.info('Sending session-accept', accept);\r\n        this.connection.sendIQ(accept,\r\n            success,\r\n            this.newJingleErrorHandler(accept, error => {\r\n                failure(error);\r\n\r\n                // 'session-accept' is a critical timeout and we'll\r\n                // have to restart\r\n                this.room.eventEmitter.emit(\r\n                    XMPPEvents.SESSION_ACCEPT_TIMEOUT, this);\r\n            }),\r\n            IQ_TIMEOUT);\r\n\r\n        // XXX Videobridge needs WebRTC's answer (ICE ufrag and pwd, DTLS\r\n        // fingerprint and setup) ASAP in order to start the connection\r\n        // establishment.\r\n        //\r\n        // FIXME Flushing the connection at this point triggers an issue with\r\n        // BOSH request handling in Prosody on slow connections.\r\n        //\r\n        // The problem is that this request will be quite large and it may take\r\n        // time before it reaches Prosody. In the meantime Strophe may decide\r\n        // to send the next one. And it was observed that a small request with\r\n        // 'transport-info' usually follows this one. It does reach Prosody\r\n        // before the previous one was completely received. 'rid' on the server\r\n        // is increased and Prosody ignores the request with 'session-accept'.\r\n        // It will never reach Jicofo and everything in the request table is\r\n        // lost. Removing the flush does not guarantee it will never happen, but\r\n        // makes it much less likely('transport-info' is bundled with\r\n        // 'session-accept' and any immediate requests).\r\n        //\r\n        // this.connection.flush();\r\n    }\r\n\r\n    /**\r\n     * Will send 'content-modify' IQ in order to ask the remote peer to\r\n     * either stop or resume sending video media.\r\n     * @param {boolean} videoTransferActive <tt>false</tt> to let the other peer\r\n     * know that we're not sending nor interested in receiving video contents.\r\n     * When set to <tt>true</tt> remote peer will be asked to resume video\r\n     * transfer.\r\n     * @private\r\n     */\r\n    sendContentModify(videoTransferActive) {\r\n        const newSendersValue = videoTransferActive ? 'both' : 'none';\r\n\r\n        const sessionModify\r\n            = $iq({\r\n                to: this.remoteJid,\r\n                type: 'set'\r\n            })\r\n                .c('jingle', {\r\n                    xmlns: 'urn:xmpp:jingle:1',\r\n                    action: 'content-modify',\r\n                    initiator: this.initiatorJid,\r\n                    sid: this.sid\r\n                })\r\n                .c('content', {\r\n                    name: 'video',\r\n                    senders: newSendersValue\r\n                });\r\n\r\n        logger.info(\r\n            `Sending content-modify, video senders: ${newSendersValue}`);\r\n\r\n        this.connection.sendIQ(\r\n            sessionModify,\r\n            null,\r\n            this.newJingleErrorHandler(sessionModify),\r\n            IQ_TIMEOUT);\r\n    }\r\n\r\n    /**\r\n     * Sends Jingle 'transport-accept' message which is a response to\r\n     * 'transport-replace'.\r\n     * @param localSDP the 'SDP' object with local session description\r\n     * @param success callback called when we receive 'RESULT' packet for\r\n     *        'transport-replace'\r\n     * @param failure function(error) called when we receive an error response\r\n     *        or when the request has timed out.\r\n     * @private\r\n     */\r\n    sendTransportAccept(localSDP, success, failure) {\r\n        let transportAccept = $iq({ to: this.remoteJid,\r\n            type: 'set' })\r\n            .c('jingle', {\r\n                xmlns: 'urn:xmpp:jingle:1',\r\n                action: 'transport-accept',\r\n                initiator: this.initiatorJid,\r\n                sid: this.sid\r\n            });\r\n\r\n        localSDP.media.forEach((medialines, idx) => {\r\n            const mline = SDPUtil.parseMLine(medialines.split('\\r\\n')[0]);\r\n\r\n            transportAccept.c('content',\r\n                {\r\n                    creator:\r\n                        this.initiatorJid === this.localJid\r\n                            ? 'initiator'\r\n                            : 'responder',\r\n                    name: mline.media\r\n                }\r\n            );\r\n            localSDP.transportToJingle(idx, transportAccept);\r\n            transportAccept.up();\r\n        });\r\n\r\n        // Calling tree() to print something useful to the logger\r\n        transportAccept = transportAccept.tree();\r\n        logger.info('Sending transport-accept: ', transportAccept);\r\n\r\n        this.connection.sendIQ(transportAccept,\r\n            success,\r\n            this.newJingleErrorHandler(transportAccept, failure),\r\n            IQ_TIMEOUT);\r\n    }\r\n\r\n    /**\r\n     * Sends Jingle 'transport-reject' message which is a response to\r\n     * 'transport-replace'.\r\n     * @param success callback called when we receive 'RESULT' packet for\r\n     *        'transport-replace'\r\n     * @param failure function(error) called when we receive an error response\r\n     *        or when the request has timed out.\r\n     *\r\n     * FIXME method should be marked as private, but there's some spaghetti that\r\n     *       needs to be fixed prior doing that\r\n     */\r\n    sendTransportReject(success, failure) {\r\n        // Send 'transport-reject', so that the focus will\r\n        // know that we've failed\r\n        let transportReject = $iq({ to: this.remoteJid,\r\n            type: 'set' })\r\n            .c('jingle', {\r\n                xmlns: 'urn:xmpp:jingle:1',\r\n                action: 'transport-reject',\r\n                initiator: this.initiatorJid,\r\n                sid: this.sid\r\n            });\r\n\r\n        transportReject = transportReject.tree();\r\n        logger.info('Sending \\'transport-reject', transportReject);\r\n\r\n        this.connection.sendIQ(transportReject,\r\n            success,\r\n            this.newJingleErrorHandler(transportReject, failure),\r\n            IQ_TIMEOUT);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    terminate(success, failure, options) {\r\n        if (this.state === JingleSessionState.ENDED) {\r\n            return;\r\n        }\r\n\r\n        if (!options || Boolean(options.sendSessionTerminate)) {\r\n            let sessionTerminate\r\n                = $iq({\r\n                    to: this.remoteJid,\r\n                    type: 'set'\r\n                })\r\n                    .c('jingle', {\r\n                        xmlns: 'urn:xmpp:jingle:1',\r\n                        action: 'session-terminate',\r\n                        initiator: this.initiatorJid,\r\n                        sid: this.sid\r\n                    })\r\n                    .c('reason')\r\n                    .c((options && options.reason) || 'success');\r\n\r\n            if (options && options.reasonDescription) {\r\n                sessionTerminate.up()\r\n                    .c('text')\r\n                    .t(options.reasonDescription);\r\n            }\r\n\r\n            // Calling tree() to print something useful\r\n            sessionTerminate = sessionTerminate.tree();\r\n            logger.info('Sending session-terminate', sessionTerminate);\r\n            this.connection.sendIQ(\r\n                sessionTerminate,\r\n                success,\r\n                this.newJingleErrorHandler(sessionTerminate, failure),\r\n                IQ_TIMEOUT);\r\n        } else {\r\n            logger.info(`Skipped sending session-terminate for ${this}`);\r\n        }\r\n\r\n        // this should result in 'onTerminated' being called by strope.jingle.js\r\n        this.connection.jingle.terminate(this.sid);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param reasonCondition\r\n     * @param reasonText\r\n     */\r\n    onTerminated(reasonCondition, reasonText) {\r\n        // Do something with reason and reasonCondition when we start to care\r\n        // this.reasonCondition = reasonCondition;\r\n        // this.reasonText = reasonText;\r\n        logger.info(`Session terminated ${this}`, reasonCondition, reasonText);\r\n\r\n        this.close();\r\n    }\r\n\r\n    /**\r\n     * Parse the information from the xml sourceAddElem and translate it\r\n     *  into sdp lines\r\n     * @param {jquery xml element} sourceAddElem the source-add\r\n     *  element from jingle\r\n     * @param {SDP object} currentRemoteSdp the current remote\r\n     *  sdp (as of this new source-add)\r\n     * @returns {list} a list of SDP line strings that should\r\n     *  be added to the remote SDP\r\n     */\r\n    _parseSsrcInfoFromSourceAdd(sourceAddElem, currentRemoteSdp) {\r\n        const addSsrcInfo = [];\r\n\r\n        $(sourceAddElem).each((i1, content) => {\r\n            const name = $(content).attr('name');\r\n            let lines = '';\r\n\r\n            $(content)\r\n                .find('ssrc-group[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]')\r\n                .each(function() {\r\n                    // eslint-disable-next-line no-invalid-this\r\n                    const semantics = this.getAttribute('semantics');\r\n                    const ssrcs\r\n                        = $(this) // eslint-disable-line no-invalid-this\r\n                            .find('>source')\r\n                            .map(function() {\r\n                                // eslint-disable-next-line no-invalid-this\r\n                                return this.getAttribute('ssrc');\r\n                            })\r\n                            .get();\r\n\r\n                    if (ssrcs.length) {\r\n                        lines\r\n                            += `a=ssrc-group:${semantics} ${\r\n                                ssrcs.join(' ')}\\r\\n`;\r\n                    }\r\n                });\r\n\r\n            // handles both >source and >description>source\r\n            const tmp\r\n                = $(content).find(\r\n                    'source[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]');\r\n\r\n            /* eslint-disable no-invalid-this */\r\n            tmp.each(function() {\r\n                const ssrc = $(this).attr('ssrc');\r\n\r\n                if (currentRemoteSdp.containsSSRC(ssrc)) {\r\n                    logger.warn(\r\n                        `Source-add request for existing SSRC: ${ssrc}`);\r\n\r\n                    return;\r\n                }\r\n\r\n                // eslint-disable-next-line newline-per-chained-call\r\n                $(this).find('>parameter').each(function() {\r\n                    lines += `a=ssrc:${ssrc} ${$(this).attr('name')}`;\r\n                    if ($(this).attr('value') && $(this).attr('value').length) {\r\n                        lines += `:${$(this).attr('value')}`;\r\n                    }\r\n                    lines += '\\r\\n';\r\n                });\r\n            });\r\n\r\n            /* eslint-enable no-invalid-this */\r\n            currentRemoteSdp.media.forEach((media, i2) => {\r\n                if (!SDPUtil.findLine(media, `a=mid:${name}`)) {\r\n                    return;\r\n                }\r\n                if (!addSsrcInfo[i2]) {\r\n                    addSsrcInfo[i2] = '';\r\n                }\r\n                addSsrcInfo[i2] += lines;\r\n            });\r\n        });\r\n\r\n        return addSsrcInfo;\r\n    }\r\n\r\n    /**\r\n     * Handles a Jingle source-add message for this Jingle session.\r\n     * @param elem An array of Jingle \"content\" elements.\r\n     */\r\n    addRemoteStream(elem) {\r\n        this._addOrRemoveRemoteStream(true /* add */, elem);\r\n    }\r\n\r\n    /**\r\n     * Handles a Jingle source-remove message for this Jingle session.\r\n     * @param elem An array of Jingle \"content\" elements.\r\n     */\r\n    removeRemoteStream(elem) {\r\n        this._addOrRemoveRemoteStream(false /* remove */, elem);\r\n    }\r\n\r\n    /**\r\n     * Handles either Jingle 'source-add' or 'source-remove' message for this\r\n     * Jingle session.\r\n     * @param {boolean} isAdd <tt>true</tt> for 'source-add' or <tt>false</tt>\r\n     * otherwise.\r\n     * @param {Array<Element>} elem an array of Jingle \"content\" elements.\r\n     * @private\r\n     */\r\n    _addOrRemoveRemoteStream(isAdd, elem) {\r\n        const logPrefix = isAdd ? 'addRemoteStream' : 'removeRemoteStream';\r\n\r\n        if (isAdd) {\r\n            this.readSsrcInfo(elem);\r\n        }\r\n\r\n        const workFunction = finishedCallback => {\r\n            if (!this.peerconnection.localDescription\r\n                || !this.peerconnection.localDescription.sdp) {\r\n                const errMsg = `${logPrefix} - localDescription not ready yet`;\r\n\r\n                logger.error(errMsg);\r\n                finishedCallback(errMsg);\r\n\r\n                return;\r\n            }\r\n\r\n            logger.log(`Processing ${logPrefix}`);\r\n            logger.log(\r\n                'ICE connection state: ',\r\n                this.peerconnection.iceConnectionState);\r\n\r\n            const oldLocalSdp\r\n                = new SDP(this.peerconnection.localDescription.sdp);\r\n            const sdp = new SDP(this.peerconnection.remoteDescription.sdp);\r\n            const addOrRemoveSsrcInfo\r\n                = isAdd\r\n                    ? this._parseSsrcInfoFromSourceAdd(elem, sdp)\r\n                    : this._parseSsrcInfoFromSourceRemove(elem, sdp);\r\n            const newRemoteSdp\r\n                = isAdd\r\n                    ? this._processRemoteAddSource(addOrRemoveSsrcInfo)\r\n                    : this._processRemoteRemoveSource(addOrRemoveSsrcInfo);\r\n\r\n            this._renegotiate(newRemoteSdp.raw)\r\n                .then(() => {\r\n                    const newLocalSdp\r\n                        = new SDP(this.peerconnection.localDescription.sdp);\r\n\r\n                    logger.log(\r\n                        `${logPrefix} - OK, SDPs: `, oldLocalSdp, newLocalSdp);\r\n                    this.notifyMySSRCUpdate(oldLocalSdp, newLocalSdp);\r\n                    finishedCallback();\r\n                }, error => {\r\n                    logger.error(`${logPrefix} failed:`, error);\r\n                    finishedCallback(error);\r\n                });\r\n        };\r\n\r\n        // Queue and execute\r\n        this.modificationQueue.push(workFunction);\r\n    }\r\n\r\n    /**\r\n     * Takes in a jingle offer iq, returns the new sdp offer\r\n     * @param {jquery xml element} offerIq the incoming offer\r\n     * @returns {SDP object} the jingle offer translated to SDP\r\n     */\r\n    _processNewJingleOfferIq(offerIq) {\r\n        const remoteSdp = new SDP('');\r\n\r\n        if (this.webrtcIceTcpDisable) {\r\n            remoteSdp.removeTcpCandidates = true;\r\n        }\r\n        if (this.webrtcIceUdpDisable) {\r\n            remoteSdp.removeUdpCandidates = true;\r\n        }\r\n        if (this.failICE) {\r\n            remoteSdp.failICE = true;\r\n        }\r\n\r\n        remoteSdp.fromJingle(offerIq);\r\n        this.readSsrcInfo($(offerIq).find('>content'));\r\n\r\n        return remoteSdp;\r\n    }\r\n\r\n    /**\r\n     * Remove the given ssrc lines from the current remote sdp\r\n     * @param {list} removeSsrcInfo a list of SDP line strings that\r\n     *  should be removed from the remote SDP\r\n     * @returns type {SDP Object} the new remote SDP (after removing the lines\r\n     *  in removeSsrcInfo\r\n     */\r\n    _processRemoteRemoveSource(removeSsrcInfo) {\r\n        const remoteSdp = new SDP(this.peerconnection.remoteDescription.sdp);\r\n\r\n        removeSsrcInfo.forEach((lines, idx) => {\r\n            // eslint-disable-next-line no-param-reassign\r\n            lines = lines.split('\\r\\n');\r\n            lines.pop(); // remove empty last element;\r\n            lines.forEach(line => {\r\n                remoteSdp.media[idx]\r\n                    = remoteSdp.media[idx].replace(`${line}\\r\\n`, '');\r\n            });\r\n        });\r\n        remoteSdp.raw = remoteSdp.session + remoteSdp.media.join('');\r\n\r\n        return remoteSdp;\r\n    }\r\n\r\n    /**\r\n     * Add the given ssrc lines to the current remote sdp\r\n     * @param {list} addSsrcInfo a list of SDP line strings that\r\n     *  should be added to the remote SDP\r\n     * @returns type {SDP Object} the new remote SDP (after removing the lines\r\n     *  in removeSsrcInfo\r\n     */\r\n    _processRemoteAddSource(addSsrcInfo) {\r\n        const remoteSdp = new SDP(this.peerconnection.remoteDescription.sdp);\r\n\r\n        addSsrcInfo.forEach((lines, idx) => {\r\n            remoteSdp.media[idx] += lines;\r\n        });\r\n        remoteSdp.raw = remoteSdp.session + remoteSdp.media.join('');\r\n\r\n        return remoteSdp;\r\n    }\r\n\r\n    /**\r\n     * Do a new o/a flow using the existing remote description\r\n     * @param {string} [optionalRemoteSdp] optional, raw remote sdp\r\n     *  to use.  If not provided, the remote sdp from the\r\n     *  peerconnection will be used\r\n     * @returns {Promise} promise which resolves when the\r\n     *  o/a flow is complete with no arguments or\r\n     *  rejects with an error {string}\r\n     */\r\n    _renegotiate(optionalRemoteSdp) {\r\n        if (this.peerconnection.signalingState === 'closed') {\r\n            const error = new Error('Attempted to renegotiate in state closed');\r\n\r\n            this.room.eventEmitter.emit(XMPPEvents.RENEGOTIATION_FAILED, error, this);\r\n\r\n            return Promise.reject(error);\r\n        }\r\n\r\n        const remoteSdp\r\n            = optionalRemoteSdp || this.peerconnection.remoteDescription.sdp;\r\n\r\n        if (!remoteSdp) {\r\n            const error = new Error(`Can not renegotiate without remote description, current state: ${this.state}`);\r\n\r\n            this.room.eventEmitter.emit(XMPPEvents.RENEGOTIATION_FAILED, error, this);\r\n\r\n            return Promise.reject(error);\r\n        }\r\n\r\n        const remoteDescription = new RTCSessionDescription({\r\n            type: this.isInitiator ? 'answer' : 'offer',\r\n            sdp: remoteSdp\r\n        });\r\n\r\n        if (this.isInitiator) {\r\n            return this._initiatorRenegotiate(remoteDescription);\r\n        }\r\n\r\n        return this._responderRenegotiate(remoteDescription);\r\n    }\r\n\r\n    /**\r\n     * Renegotiate cycle implementation for the responder case.\r\n     * @param {object} remoteDescription the SDP object as defined by the WebRTC\r\n     * which will be used as remote description in the cycle.\r\n     * @private\r\n     */\r\n    _responderRenegotiate(remoteDescription) {\r\n        logger.debug('Renegotiate: setting remote description');\r\n\r\n        return this.peerconnection.setRemoteDescription(remoteDescription)\r\n            .then(() => {\r\n                logger.debug('Renegotiate: creating answer');\r\n\r\n                return this.peerconnection.createAnswer(this.mediaConstraints)\r\n                    .then(answer => {\r\n                        logger.debug('Renegotiate: setting local description');\r\n\r\n                        return this.peerconnection.setLocalDescription(answer);\r\n                    });\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Renegotiate cycle implementation for the initiator's case.\r\n     * @param {object} remoteDescription the SDP object as defined by the WebRTC\r\n     * which will be used as remote description in the cycle.\r\n     * @private\r\n     */\r\n    _initiatorRenegotiate(remoteDescription) {\r\n        if (this.peerconnection.signalingState === 'have-local-offer') {\r\n            // Skip createOffer and setLocalDescription or FF will fail\r\n            logger.debug(\r\n                'Renegotiate: setting remote description');\r\n\r\n            /* eslint-disable arrow-body-style */\r\n\r\n            return this.peerconnection.setRemoteDescription(remoteDescription)\r\n                .then(() => {\r\n                    // In case when the answer is being set for the first time,\r\n                    // full sRD/sLD cycle is required to have the local\r\n                    // description updated and SSRCs synchronized correctly.\r\n                    // Otherwise SSRCs for streams added after invite, but\r\n                    // before the answer was accepted will not be detected.\r\n                    // The reason for that is that renegotiate can not be called\r\n                    // when adding tracks and they will not be reflected in\r\n                    // the local SDP.\r\n                    return this._initiatorRenegotiate(remoteDescription);\r\n                });\r\n            /* eslint-enable arrow-body-style */\r\n        }\r\n\r\n        logger.debug('Renegotiate: creating offer');\r\n\r\n        return this.peerconnection.createOffer(this.mediaConstraints)\r\n            .then(offer => {\r\n                logger.debug('Renegotiate: setting local description');\r\n\r\n                return this.peerconnection.setLocalDescription(offer)\r\n                    .then(() => {\r\n                        logger.debug(\r\n                            'Renegotiate: setting remote description');\r\n\r\n                        // eslint-disable-next-line max-len\r\n                        return this.peerconnection.setRemoteDescription(remoteDescription);\r\n                    });\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Replaces <tt>oldTrack</tt> with <tt>newTrack</tt> and performs a single\r\n     * offer/answer cycle after both operations are done. Either\r\n     * <tt>oldTrack</tt> or <tt>newTrack</tt> can be null; replacing a valid\r\n     * <tt>oldTrack</tt> with a null <tt>newTrack</tt> effectively just removes\r\n     * <tt>oldTrack</tt>\r\n     * @param {QHSenseLocalTrack|null} oldTrack the current track in use to be\r\n     * replaced\r\n     * @param {QHSenseLocalTrack|null} newTrack the new track to use\r\n     * @returns {Promise} which resolves once the replacement is complete\r\n     *  with no arguments or rejects with an error {string}\r\n     */\r\n    replaceTrack(oldTrack, newTrack) {\r\n        const workFunction = finishedCallback => {\r\n            const oldLocalSdp = this.peerconnection.localDescription.sdp;\r\n\r\n            // NOTE the code below assumes that no more than 1 video track\r\n            // can be added to the peer connection.\r\n            // Transition from no video to video (possibly screen sharing)\r\n            if (!oldTrack && newTrack && newTrack.isVideoTrack()) {\r\n                // Clearing current primary SSRC will make\r\n                // the SdpConsistency generate a new one which will result\r\n                // with:\r\n                // 1. source-remove for the recvonly\r\n                // 2. source-add for the new video stream\r\n                this.peerconnection.clearRecvonlySsrc();\r\n\r\n            // Transition from video to no video\r\n            } else if (oldTrack && oldTrack.isVideoTrack() && !newTrack) {\r\n                // Clearing current primary SSRC and generating the recvonly\r\n                // will result in:\r\n                // 1. source-remove for the old video stream\r\n                // 2. source-add for the recvonly stream\r\n                this.peerconnection.clearRecvonlySsrc();\r\n                this.peerconnection.generateRecvonlySsrc();\r\n            }\r\n\r\n            this.peerconnection.replaceTrack(oldTrack, newTrack)\r\n            .then(shouldRenegotiate => {\r\n                if (shouldRenegotiate\r\n                    && (oldTrack || newTrack)\r\n                    && this.state === JingleSessionState.ACTIVE) {\r\n                    this._renegotiate()\r\n                        .then(() => {\r\n                            const newLocalSDP\r\n                                = new SDP(\r\n                                    this.peerconnection.localDescription.sdp);\r\n\r\n                            this.notifyMySSRCUpdate(\r\n                                new SDP(oldLocalSdp), newLocalSDP);\r\n                            finishedCallback();\r\n                        },\r\n                        finishedCallback /* will be called with en error */);\r\n                } else {\r\n                    finishedCallback();\r\n                }\r\n            });\r\n        };\r\n\r\n        return new Promise((resolve, reject) => {\r\n            this.modificationQueue.push(\r\n                workFunction,\r\n                error => {\r\n                    if (error) {\r\n                        logger.error('Replace track error:', error);\r\n                        reject(error);\r\n                    } else {\r\n                        logger.info('Replace track done!');\r\n                        resolve();\r\n                    }\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Parse the information from the xml sourceRemoveElem and translate it\r\n     *  into sdp lines\r\n     * @param {jquery xml element} sourceRemoveElem the source-remove\r\n     *  element from jingle\r\n     * @param {SDP object} currentRemoteSdp the current remote\r\n     *  sdp (as of this new source-remove)\r\n     * @returns {list} a list of SDP line strings that should\r\n     *  be removed from the remote SDP\r\n     */\r\n    _parseSsrcInfoFromSourceRemove(sourceRemoveElem, currentRemoteSdp) {\r\n        const removeSsrcInfo = [];\r\n\r\n        $(sourceRemoveElem).each((i1, content) => {\r\n            const name = $(content).attr('name');\r\n            let lines = '';\r\n\r\n            $(content)\r\n                .find('ssrc-group[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]')\r\n                .each(function() {\r\n                    /* eslint-disable no-invalid-this */\r\n                    const semantics = this.getAttribute('semantics');\r\n                    const ssrcs\r\n                        = $(this)\r\n                            .find('>source')\r\n                            .map(function() {\r\n                                return this.getAttribute('ssrc');\r\n                            })\r\n                            .get();\r\n\r\n                    if (ssrcs.length) {\r\n                        lines\r\n                            += `a=ssrc-group:${semantics} ${\r\n                                ssrcs.join(' ')}\\r\\n`;\r\n                    }\r\n\r\n                    /* eslint-enable no-invalid-this */\r\n                });\r\n            const ssrcs = [];\r\n\r\n            // handles both >source and >description>source versions\r\n            const tmp\r\n                = $(content).find(\r\n                    'source[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]');\r\n\r\n            tmp.each(function() {\r\n                // eslint-disable-next-line no-invalid-this\r\n                const ssrc = $(this).attr('ssrc');\r\n\r\n                ssrcs.push(ssrc);\r\n            });\r\n            currentRemoteSdp.media.forEach((media, i2) => {\r\n                if (!SDPUtil.findLine(media, `a=mid:${name}`)) {\r\n                    return;\r\n                }\r\n                if (!removeSsrcInfo[i2]) {\r\n                    removeSsrcInfo[i2] = '';\r\n                }\r\n                ssrcs.forEach(ssrc => {\r\n                    const ssrcLines\r\n                        = SDPUtil.findLines(media, `a=ssrc:${ssrc}`);\r\n\r\n                    if (ssrcLines.length) {\r\n                        removeSsrcInfo[i2] += `${ssrcLines.join('\\r\\n')}\\r\\n`;\r\n                    }\r\n                });\r\n                removeSsrcInfo[i2] += lines;\r\n            });\r\n        });\r\n\r\n        return removeSsrcInfo;\r\n    }\r\n\r\n    /**\r\n     * Will print an error if there is any difference, between the SSRCs given\r\n     * in the <tt>oldSDP</tt> and the ones currently described in\r\n     * the peerconnection's local description.\r\n     * @param {string} operationName the operation's name which will be printed\r\n     * in the error message.\r\n     * @param {SDP} oldSDP the old local SDP which will be compared with\r\n     * the current one.\r\n     * @return {boolean} <tt>true</tt> if there was any change or <tt>false</tt>\r\n     * otherwise.\r\n     * @private\r\n     */\r\n    _verifyNoSSRCChanged(operationName, oldSDP) {\r\n        const currentLocalSDP\r\n            = new SDP(this.peerconnection.localDescription.sdp);\r\n        let sdpDiff = new SDPDiffer(oldSDP, currentLocalSDP);\r\n        const addedMedia = sdpDiff.getNewMedia();\r\n\r\n        if (Object.keys(addedMedia).length) {\r\n            logger.error(\r\n                `${this} - some SSRC were added on ${operationName}`,\r\n                addedMedia);\r\n\r\n            return false;\r\n        }\r\n\r\n        sdpDiff = new SDPDiffer(currentLocalSDP, oldSDP);\r\n        const removedMedia = sdpDiff.getNewMedia();\r\n\r\n        if (Object.keys(removedMedia).length) {\r\n            logger.error(\r\n                `${this} - some SSRCs were removed on ${operationName}`,\r\n                removedMedia);\r\n\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Adds local track back to this session, as part of the unmute operation.\r\n     * @param {QHSenseLocalTrack} track\r\n     * @return {Promise} a promise that will resolve once the local track is\r\n     * added back to this session and renegotiation succeeds. Will be rejected\r\n     * with a <tt>string</tt> that provides some error details in case something\r\n     * goes wrong.\r\n     */\r\n    addTrackAsUnmute(track) {\r\n        return this._addRemoveTrackAsMuteUnmute(\r\n            false /* add as unmute */, track);\r\n    }\r\n\r\n    /**\r\n     * Remove local track as part of the mute operation.\r\n     * @param {QHSenseLocalTrack} track the local track to be removed\r\n     * @return {Promise} a promise which will be resolved once the local track\r\n     * is removed from this session and the renegotiation is performed.\r\n     * The promise will be rejected with a <tt>string</tt> that the describes\r\n     * the error if anything goes wrong.\r\n     */\r\n    removeTrackAsMute(track) {\r\n        return this._addRemoveTrackAsMuteUnmute(\r\n            true /* remove as mute */, track);\r\n    }\r\n\r\n    /**\r\n     * See {@link addTrackAsUnmute} and {@link removeTrackAsMute}.\r\n     * @param {boolean} isMute <tt>true</tt> for \"remove as mute\" or\r\n     * <tt>false</tt> for \"add as unmute\".\r\n     * @param {QHSenseLocalTrack} track the track that will be added/removed\r\n     * @private\r\n     */\r\n    _addRemoveTrackAsMuteUnmute(isMute, track) {\r\n        if (!track) {\r\n            return Promise.reject('invalid \"track\" argument value');\r\n        }\r\n        const operationName = isMute ? 'removeTrackMute' : 'addTrackUnmute';\r\n        const workFunction = finishedCallback => {\r\n            const tpc = this.peerconnection;\r\n\r\n            if (!tpc) {\r\n                finishedCallback(\r\n                    `Error:  tried ${operationName} track with no active peer`\r\n                        + 'connection');\r\n\r\n                return;\r\n            }\r\n            const oldLocalSDP = tpc.localDescription.sdp;\r\n            const tpcOperation\r\n                = isMute\r\n                    ? tpc.removeTrackMute.bind(tpc, track)\r\n                    : tpc.addTrackUnmute.bind(tpc, track);\r\n\r\n            if (!tpcOperation()) {\r\n                finishedCallback(`${operationName} failed!`);\r\n            } else if (!oldLocalSDP || !tpc.remoteDescription.sdp) {\r\n                finishedCallback();\r\n            } else {\r\n                this._renegotiate()\r\n                    .then(() => {\r\n                        // The results are ignored, as this check failure is not\r\n                        // enough to fail the whole operation. It will log\r\n                        // an error inside.\r\n                        this._verifyNoSSRCChanged(\r\n                            operationName, new SDP(oldLocalSDP));\r\n                        finishedCallback();\r\n                    },\r\n                    finishedCallback /* will be called with an error */);\r\n            }\r\n        };\r\n\r\n        return new Promise((resolve, reject) => {\r\n            this.modificationQueue.push(\r\n                workFunction,\r\n                error => {\r\n                    if (error) {\r\n                        reject(error);\r\n                    } else {\r\n                        resolve();\r\n                    }\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Resumes or suspends media transfer over the underlying peer connection.\r\n     * @param {boolean} audioActive <tt>true</tt> to enable audio media\r\n     * transfer or <tt>false</tt> to suspend audio media transmission.\r\n     * @param {boolean} videoActive <tt>true</tt> to enable video media\r\n     * transfer or <tt>false</tt> to suspend video media transmission.\r\n     * @return {Promise} a <tt>Promise</tt> which will resolve once\r\n     * the operation is done. It will be rejected with an error description as\r\n     * a string in case anything goes wrong.\r\n     */\r\n    setMediaTransferActive(audioActive, videoActive) {\r\n        if (!this.peerconnection) {\r\n            return Promise.reject(\r\n                'Can not modify transfer active state,'\r\n                    + ' before \"initialize\" is called');\r\n        }\r\n\r\n        const logAudioStr = audioActive ? 'audio active' : 'audio inactive';\r\n        const logVideoStr = videoActive ? 'video active' : 'video inactive';\r\n\r\n        logger.info(`Queued make ${logVideoStr}, ${logAudioStr} task...`);\r\n\r\n        const workFunction = finishedCallback => {\r\n            const isSessionActive = this.state === JingleSessionState.ACTIVE;\r\n\r\n            // Because the value is modified on the queue it's impossible to\r\n            // check it's final value reliably prior to submitting the task.\r\n            // The rule here is that the last submitted state counts.\r\n            // Check the values here to avoid unnecessary renegotiation cycle.\r\n            const audioActiveChanged\r\n                = this.peerconnection.setAudioTransferActive(audioActive);\r\n\r\n            if (this._localVideoActive !== videoActive) {\r\n                this._localVideoActive = videoActive;\r\n\r\n                // Do only for P2P - Jicofo will reply with 'bad-request'\r\n                // We don't want to send 'content-modify', before the initial\r\n                // O/A (state === JingleSessionState.ACTIVE), because that will\r\n                // mess up video media direction in the remote SDP.\r\n                // 'content-modify' when processed only affects the media\r\n                // direction in the local SDP. We're doing that, because setting\r\n                // 'inactive' on video media in remote SDP will mess up our SDP\r\n                // translation chain (simulcast, RTX, video mute etc.).\r\n                if (this.isP2P && isSessionActive) {\r\n                    this.sendContentModify(videoActive);\r\n                }\r\n            }\r\n\r\n            const pcVideoActiveChanged\r\n                = this.peerconnection.setVideoTransferActive(\r\n                    this._localVideoActive && this._remoteVideoActive);\r\n\r\n            // Will do the sRD/sLD cycle to update SDPs and adjust the media\r\n            // direction\r\n            if (isSessionActive\r\n                    && (audioActiveChanged || pcVideoActiveChanged)) {\r\n                this._renegotiate()\r\n                    .then(\r\n                        finishedCallback,\r\n                        finishedCallback /* will be called with an error */);\r\n            } else {\r\n                finishedCallback();\r\n            }\r\n        };\r\n\r\n        return new Promise((resolve, reject) => {\r\n            this.modificationQueue.push(\r\n                workFunction,\r\n                error => {\r\n                    if (error) {\r\n                        reject(error);\r\n                    } else {\r\n                        resolve();\r\n                    }\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Will put and execute on the queue a session modify task. Currently it\r\n     * only checks the senders attribute of the video content in order to figure\r\n     * out if the remote peer has video in the inactive state (stored locally\r\n     * in {@link _remoteVideoActive} - see field description for more info).\r\n     * @param {jQuery} jingleContents jQuery selector pointing to the jingle\r\n     * element of the session modify IQ.\r\n     * @see {@link _remoteVideoActive}\r\n     * @see {@link _localVideoActive}\r\n     */\r\n    modifyContents(jingleContents) {\r\n        const newVideoSenders\r\n            = JingleSessionPC.parseVideoSenders(jingleContents);\r\n\r\n        if (newVideoSenders === null) {\r\n            logger.error(\r\n                `${this} - failed to parse video \"senders\" attribute in`\r\n                    + '\"content-modify\" action');\r\n\r\n            return;\r\n        }\r\n\r\n        const workFunction = finishedCallback => {\r\n            if (this._assertNotEnded('content-modify')\r\n                    && this._modifyRemoteVideoActive(newVideoSenders)) {\r\n                // Will do the sRD/sLD cycle to update SDPs and adjust\r\n                // the media direction\r\n                this._renegotiate()\r\n                    .then(finishedCallback, finishedCallback /* (error) */);\r\n            } else {\r\n                finishedCallback();\r\n            }\r\n        };\r\n\r\n        logger.debug(\r\n            `${this} queued \"content-modify\" task`\r\n                + `(video senders=\"${newVideoSenders}\")`);\r\n\r\n        this.modificationQueue.push(\r\n            workFunction,\r\n            error => {\r\n                if (error) {\r\n                    logger.error('\"content-modify\" failed', error);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Processes new value of remote video \"senders\" Jingle attribute and tries\r\n     * to apply it for {@link _remoteVideoActive}.\r\n     * @param {string} remoteVideoSenders the value of \"senders\" attribute of\r\n     * Jingle video content element advertised by remote peer.\r\n     * @return {boolean} <tt>true</tt> if the change affected state of\r\n     * the underlying peerconnection and renegotiation is required for\r\n     * the changes to take effect.\r\n     * @private\r\n     */\r\n    _modifyRemoteVideoActive(remoteVideoSenders) {\r\n        const isRemoteVideoActive\r\n            = remoteVideoSenders === 'both'\r\n                || (remoteVideoSenders === 'initiator' && this.isInitiator)\r\n                || (remoteVideoSenders === 'responder' && !this.isInitiator);\r\n\r\n        if (isRemoteVideoActive !== this._remoteVideoActive) {\r\n            logger.debug(\r\n                `${this} new remote video active: ${isRemoteVideoActive}`);\r\n            this._remoteVideoActive = isRemoteVideoActive;\r\n        }\r\n\r\n        return this.peerconnection.setVideoTransferActive(\r\n            this._localVideoActive && this._remoteVideoActive);\r\n    }\r\n\r\n    /**\r\n     * Figures out added/removed ssrcs and send update IQs.\r\n     * @param oldSDP SDP object for old description.\r\n     * @param newSDP SDP object for new description.\r\n     */\r\n    notifyMySSRCUpdate(oldSDP, newSDP) {\r\n\r\n        if (this.state !== JingleSessionState.ACTIVE) {\r\n            logger.warn(`Skipping SSRC update in '${this.state} ' state.`);\r\n\r\n            return;\r\n        }\r\n\r\n        // send source-remove IQ.\r\n        let sdpDiffer = new SDPDiffer(newSDP, oldSDP);\r\n        const remove = $iq({ to: this.remoteJid,\r\n            type: 'set' })\r\n            .c('jingle', {\r\n                xmlns: 'urn:xmpp:jingle:1',\r\n                action: 'source-remove',\r\n                initiator: this.initiatorJid,\r\n                sid: this.sid\r\n            }\r\n            );\r\n        const removedAnySSRCs = sdpDiffer.toJingle(remove);\r\n\r\n        if (removedAnySSRCs) {\r\n            logger.info('Sending source-remove', remove.tree());\r\n            this.connection.sendIQ(\r\n                remove, null,\r\n                this.newJingleErrorHandler(remove), IQ_TIMEOUT);\r\n        } else {\r\n            logger.log('removal not necessary');\r\n        }\r\n\r\n        // send source-add IQ.\r\n        sdpDiffer = new SDPDiffer(oldSDP, newSDP);\r\n        const add = $iq({ to: this.remoteJid,\r\n            type: 'set' })\r\n            .c('jingle', {\r\n                xmlns: 'urn:xmpp:jingle:1',\r\n                action: 'source-add',\r\n                initiator: this.initiatorJid,\r\n                sid: this.sid\r\n            }\r\n            );\r\n\r\n        const containsNewSSRCs = sdpDiffer.toJingle(add);\r\n\r\n        if (containsNewSSRCs) {\r\n            logger.info('Sending source-add', add.tree());\r\n            this.connection.sendIQ(\r\n                add, null, this.newJingleErrorHandler(add), IQ_TIMEOUT);\r\n        } else {\r\n            logger.log('addition not necessary');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method returns function(errorResponse) which is a callback to be passed\r\n     * to Strophe connection.sendIQ method. An 'error' structure is created that\r\n     * is passed as 1st argument to given <tt>failureCb</tt>. The format of this\r\n     * structure is as follows:\r\n     * {\r\n     *  code: {XMPP error response code}\r\n     *  reason: {the name of XMPP error reason element or 'timeout' if the\r\n      *          request has timed out within <tt>IQ_TIMEOUT</tt> milliseconds}\r\n     *  source: {request.tree() that provides original request}\r\n     *  session: {this JingleSessionPC.toString()}\r\n     * }\r\n     * @param request Strophe IQ instance which is the request to be dumped into\r\n     *        the error structure\r\n     * @param failureCb function(error) called when error response was returned\r\n     *        or when a timeout has occurred.\r\n     * @returns {function(this:JingleSessionPC)}\r\n     */\r\n    newJingleErrorHandler(request, failureCb) {\r\n        return errResponse => {\r\n\r\n            const error = {};\r\n\r\n            // Get XMPP error code and condition(reason)\r\n            const errorElSel = $(errResponse).find('error');\r\n\r\n            if (errorElSel.length) {\r\n                error.code = errorElSel.attr('code');\r\n                const errorReasonSel = $(errResponse).find('error :first');\r\n\r\n                if (errorReasonSel.length) {\r\n                    error.reason = errorReasonSel[0].tagName;\r\n                }\r\n\r\n                const errorMsgSel = errorElSel.find('>text');\r\n\r\n                if (errorMsgSel.length) {\r\n                    error.msg = errorMsgSel.text();\r\n                }\r\n            }\r\n\r\n            if (!errResponse) {\r\n                error.reason = 'timeout';\r\n            }\r\n\r\n            error.session = this.toString();\r\n\r\n            if (failureCb) {\r\n                failureCb(error);\r\n            } else if (this.state === JingleSessionState.ENDED\r\n                        && error.reason === 'item-not-found') {\r\n                // When remote peer decides to terminate the session, but it\r\n                // still have few messages on the queue for processing,\r\n                // it will first send us 'session-terminate' (we enter ENDED)\r\n                // and then follow with 'item-not-found' for the queued requests\r\n                // We don't want to have that logged on error level.\r\n                logger.debug(`Jingle error: ${JSON.stringify(error)}`);\r\n            } else {\r\n                GlobalOnErrorHandler.callErrorHandler(\r\n                    new Error(\r\n                        `Jingle error: ${JSON.stringify(error)}`));\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the ice connection state for the peer connection.\r\n     * @returns the ice connection state for the peer connection.\r\n     */\r\n    getIceConnectionState() {\r\n        return this.peerconnection.iceConnectionState;\r\n    }\r\n\r\n    /**\r\n     * Closes the peerconnection.\r\n     */\r\n    close() {\r\n        this.state = JingleSessionState.ENDED;\r\n        this.establishmentDuration = undefined;\r\n\r\n        this.peerconnection.onicecandidate = null;\r\n        this.peerconnection.oniceconnectionstatechange = null;\r\n        this.peerconnection.onnegotiationneeded = null;\r\n        this.peerconnection.onsignalingstatechange = null;\r\n\r\n        // Remove any pending tasks from the queue\r\n        this.modificationQueue.clear();\r\n\r\n        this.modificationQueue.push(finishCallback => {\r\n            // The signaling layer will remove it's listeners\r\n            this.signalingLayer.setChatRoom(null);\r\n\r\n            // do not try to close if already closed.\r\n            this.peerconnection && this.peerconnection.close();\r\n            finishCallback();\r\n        });\r\n\r\n        // No more tasks can go in after the close task\r\n        this.modificationQueue.shutdown();\r\n    }\r\n\r\n    /**\r\n     * Converts to string with minor summary.\r\n     * @return {string}\r\n     */\r\n    toString() {\r\n        return `JingleSessionPC[p2p=${this.isP2P},`\r\n                    + `initiator=${this.isInitiator},sid=${this.sid}]`;\r\n    }\r\n\r\n    /**\r\n     * If the A/B test for suspend video is disabled according to the room's\r\n     * configuration, returns undefined. Otherwise returns a boolean which\r\n     * indicates whether the suspend video option should be enabled or disabled.\r\n     * @param {JingleSessionPCOptions} options - The config options.\r\n     */\r\n    _abtestSuspendVideoEnabled({ abTesting }) {\r\n        if (!abTesting || !abTesting.enableSuspendVideoTest) {\r\n            return;\r\n        }\r\n\r\n        // We want the two participants in a P2P call to agree on the value of\r\n        // the \"suspend\" option. We use the JID of the initiator, because it is\r\n        // both randomly selected and agreed upon by both participants.\r\n        const jid = this._getInitiatorJid();\r\n\r\n        return integerHash(jid) % 2 === 0;\r\n    }\r\n}\r\n","/**\r\n * The events for the media devices.\r\n */\r\n\r\n/**\r\n * Indicates that the list of available media devices has been changed. The\r\n * event provides the following parameters to its listeners:\r\n *\r\n * @param {MediaDeviceInfo[]} devices - array of MediaDeviceInfo or\r\n *  MediaDeviceInfo-like objects that are currently connected.\r\n *  @see https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo\r\n */\r\nexport const DEVICE_LIST_CHANGED = 'mediaDevices.devicechange';\r\n\r\n/**\r\n * Indicates that the environment is currently showing permission prompt to\r\n * access camera and/or microphone. The event provides the following\r\n * parameters to its listeners:\r\n *\r\n * @param {'chrome'|'opera'|'firefox'|'safari'|'nwjs'\r\n *  |'react-native'|'android'} environmentType - type of browser or\r\n *  other execution environment.\r\n */\r\nexport const PERMISSION_PROMPT_IS_SHOWN\r\n    = 'mediaDevices.permissionPromptIsShown';\r\n","/*!\n * Bowser - a browser detector\n * https://github.com/ded/bowser\n * MIT License | (c) Dustin Diaz 2015\n */\n\n!function (root, name, definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports = definition()\n  else if (typeof define == 'function' && define.amd) define(name, definition)\n  else root[name] = definition()\n}(this, 'bowser', function () {\n  /**\n    * See useragents.js for examples of navigator.userAgent\n    */\n\n  var t = true\n\n  function detect(ua) {\n\n    function getFirstMatch(regex) {\n      var match = ua.match(regex);\n      return (match && match.length > 1 && match[1]) || '';\n    }\n\n    function getSecondMatch(regex) {\n      var match = ua.match(regex);\n      return (match && match.length > 1 && match[2]) || '';\n    }\n\n    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()\n      , likeAndroid = /like android/i.test(ua)\n      , android = !likeAndroid && /android/i.test(ua)\n      , nexusMobile = /nexus\\s*[0-6]\\s*/i.test(ua)\n      , nexusTablet = !nexusMobile && /nexus\\s*[0-9]+/i.test(ua)\n      , chromeos = /CrOS/.test(ua)\n      , silk = /silk/i.test(ua)\n      , sailfish = /sailfish/i.test(ua)\n      , tizen = /tizen/i.test(ua)\n      , webos = /(web|hpw)os/i.test(ua)\n      , windowsphone = /windows phone/i.test(ua)\n      , samsungBrowser = /SamsungBrowser/i.test(ua)\n      , windows = !windowsphone && /windows/i.test(ua)\n      , mac = !iosdevice && !silk && /macintosh/i.test(ua)\n      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)\n      , edgeVersion = getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.\\d+)?)/i)\n      , versionIdentifier = getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i)\n      , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)\n      , mobile = !tablet && /[^-]mobi/i.test(ua)\n      , xbox = /xbox/i.test(ua)\n      , result\n\n    if (/opera/i.test(ua)) {\n      //  an old Opera\n      result = {\n        name: 'Opera'\n      , opera: t\n      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    } else if (/opr\\/|opios/i.test(ua)) {\n      // a new Opera\n      result = {\n        name: 'Opera'\n        , opera: t\n        , version: getFirstMatch(/(?:opr|opios)[\\s\\/](\\d+(\\.\\d+)?)/i) || versionIdentifier\n      }\n    }\n    else if (/SamsungBrowser/i.test(ua)) {\n      result = {\n        name: 'Samsung Internet for Android'\n        , samsungBrowser: t\n        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/coast/i.test(ua)) {\n      result = {\n        name: 'Opera Coast'\n        , coast: t\n        , version: versionIdentifier || getFirstMatch(/(?:coast)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/yabrowser/i.test(ua)) {\n      result = {\n        name: 'Yandex Browser'\n      , yandexbrowser: t\n      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/ucbrowser/i.test(ua)) {\n      result = {\n          name: 'UC Browser'\n        , ucbrowser: t\n        , version: getFirstMatch(/(?:ucbrowser)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/mxios/i.test(ua)) {\n      result = {\n        name: 'Maxthon'\n        , maxthon: t\n        , version: getFirstMatch(/(?:mxios)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/epiphany/i.test(ua)) {\n      result = {\n        name: 'Epiphany'\n        , epiphany: t\n        , version: getFirstMatch(/(?:epiphany)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/puffin/i.test(ua)) {\n      result = {\n        name: 'Puffin'\n        , puffin: t\n        , version: getFirstMatch(/(?:puffin)[\\s\\/](\\d+(?:\\.\\d+)?)/i)\n      }\n    }\n    else if (/sleipnir/i.test(ua)) {\n      result = {\n        name: 'Sleipnir'\n        , sleipnir: t\n        , version: getFirstMatch(/(?:sleipnir)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/k-meleon/i.test(ua)) {\n      result = {\n        name: 'K-Meleon'\n        , kMeleon: t\n        , version: getFirstMatch(/(?:k-meleon)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (windowsphone) {\n      result = {\n        name: 'Windows Phone'\n      , osname: 'Windows Phone'\n      , windowsphone: t\n      }\n      if (edgeVersion) {\n        result.msedge = t\n        result.version = edgeVersion\n      }\n      else {\n        result.msie = t\n        result.version = getFirstMatch(/iemobile\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/msie|trident/i.test(ua)) {\n      result = {\n        name: 'Internet Explorer'\n      , msie: t\n      , version: getFirstMatch(/(?:msie |rv:)(\\d+(\\.\\d+)?)/i)\n      }\n    } else if (chromeos) {\n      result = {\n        name: 'Chrome'\n      , osname: 'Chrome OS'\n      , chromeos: t\n      , chromeBook: t\n      , chrome: t\n      , version: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i)\n      }\n    } else if (/edg([ea]|ios)/i.test(ua)) {\n      result = {\n        name: 'Microsoft Edge'\n      , msedge: t\n      , version: edgeVersion\n      }\n    }\n    else if (/vivaldi/i.test(ua)) {\n      result = {\n        name: 'Vivaldi'\n        , vivaldi: t\n        , version: getFirstMatch(/vivaldi\\/(\\d+(\\.\\d+)?)/i) || versionIdentifier\n      }\n    }\n    else if (sailfish) {\n      result = {\n        name: 'Sailfish'\n      , osname: 'Sailfish OS'\n      , sailfish: t\n      , version: getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/seamonkey\\//i.test(ua)) {\n      result = {\n        name: 'SeaMonkey'\n      , seamonkey: t\n      , version: getFirstMatch(/seamonkey\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/firefox|iceweasel|fxios/i.test(ua)) {\n      result = {\n        name: 'Firefox'\n      , firefox: t\n      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \\/](\\d+(\\.\\d+)?)/i)\n      }\n      if (/\\((mobile|tablet);[^\\)]*rv:[\\d\\.]+\\)/i.test(ua)) {\n        result.firefoxos = t\n        result.osname = 'Firefox OS'\n      }\n    }\n    else if (silk) {\n      result =  {\n        name: 'Amazon Silk'\n      , silk: t\n      , version : getFirstMatch(/silk\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/phantom/i.test(ua)) {\n      result = {\n        name: 'PhantomJS'\n      , phantom: t\n      , version: getFirstMatch(/phantomjs\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/slimerjs/i.test(ua)) {\n      result = {\n        name: 'SlimerJS'\n        , slimer: t\n        , version: getFirstMatch(/slimerjs\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/blackberry|\\bbb\\d+/i.test(ua) || /rim\\stablet/i.test(ua)) {\n      result = {\n        name: 'BlackBerry'\n      , osname: 'BlackBerry OS'\n      , blackberry: t\n      , version: versionIdentifier || getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (webos) {\n      result = {\n        name: 'WebOS'\n      , osname: 'WebOS'\n      , webos: t\n      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\\/(\\d+(\\.\\d+)?)/i)\n      };\n      /touchpad\\//i.test(ua) && (result.touchpad = t)\n    }\n    else if (/bada/i.test(ua)) {\n      result = {\n        name: 'Bada'\n      , osname: 'Bada'\n      , bada: t\n      , version: getFirstMatch(/dolfin\\/(\\d+(\\.\\d+)?)/i)\n      };\n    }\n    else if (tizen) {\n      result = {\n        name: 'Tizen'\n      , osname: 'Tizen'\n      , tizen: t\n      , version: getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.\\d+)?)/i) || versionIdentifier\n      };\n    }\n    else if (/qupzilla/i.test(ua)) {\n      result = {\n        name: 'QupZilla'\n        , qupzilla: t\n        , version: getFirstMatch(/(?:qupzilla)[\\s\\/](\\d+(?:\\.\\d+)+)/i) || versionIdentifier\n      }\n    }\n    else if (/chromium/i.test(ua)) {\n      result = {\n        name: 'Chromium'\n        , chromium: t\n        , version: getFirstMatch(/(?:chromium)[\\s\\/](\\d+(?:\\.\\d+)?)/i) || versionIdentifier\n      }\n    }\n    else if (/chrome|crios|crmo/i.test(ua)) {\n      result = {\n        name: 'Chrome'\n        , chrome: t\n        , version: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (android) {\n      result = {\n        name: 'Android'\n        , version: versionIdentifier\n      }\n    }\n    else if (/safari|applewebkit/i.test(ua)) {\n      result = {\n        name: 'Safari'\n      , safari: t\n      }\n      if (versionIdentifier) {\n        result.version = versionIdentifier\n      }\n    }\n    else if (iosdevice) {\n      result = {\n        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'\n      }\n      // WTF: version is not part of user agent in web apps\n      if (versionIdentifier) {\n        result.version = versionIdentifier\n      }\n    }\n    else if(/googlebot/i.test(ua)) {\n      result = {\n        name: 'Googlebot'\n      , googlebot: t\n      , version: getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i) || versionIdentifier\n      }\n    }\n    else {\n      result = {\n        name: getFirstMatch(/^(.*)\\/(.*) /),\n        version: getSecondMatch(/^(.*)\\/(.*) /)\n     };\n   }\n\n    // set webkit or gecko flag for browsers based on these engines\n    if (!result.msedge && /(apple)?webkit/i.test(ua)) {\n      if (/(apple)?webkit\\/537\\.36/i.test(ua)) {\n        result.name = result.name || \"Blink\"\n        result.blink = t\n      } else {\n        result.name = result.name || \"Webkit\"\n        result.webkit = t\n      }\n      if (!result.version && versionIdentifier) {\n        result.version = versionIdentifier\n      }\n    } else if (!result.opera && /gecko\\//i.test(ua)) {\n      result.name = result.name || \"Gecko\"\n      result.gecko = t\n      result.version = result.version || getFirstMatch(/gecko\\/(\\d+(\\.\\d+)?)/i)\n    }\n\n    // set OS flags for platforms that have multiple browsers\n    if (!result.windowsphone && (android || result.silk)) {\n      result.android = t\n      result.osname = 'Android'\n    } else if (!result.windowsphone && iosdevice) {\n      result[iosdevice] = t\n      result.ios = t\n      result.osname = 'iOS'\n    } else if (mac) {\n      result.mac = t\n      result.osname = 'macOS'\n    } else if (xbox) {\n      result.xbox = t\n      result.osname = 'Xbox'\n    } else if (windows) {\n      result.windows = t\n      result.osname = 'Windows'\n    } else if (linux) {\n      result.linux = t\n      result.osname = 'Linux'\n    }\n\n    function getWindowsVersion (s) {\n      switch (s) {\n        case 'NT': return 'NT'\n        case 'XP': return 'XP'\n        case 'NT 5.0': return '2000'\n        case 'NT 5.1': return 'XP'\n        case 'NT 5.2': return '2003'\n        case 'NT 6.0': return 'Vista'\n        case 'NT 6.1': return '7'\n        case 'NT 6.2': return '8'\n        case 'NT 6.3': return '8.1'\n        case 'NT 10.0': return '10'\n        default: return undefined\n      }\n    }\n\n    // OS version extraction\n    var osVersion = '';\n    if (result.windows) {\n      osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i))\n    } else if (result.windowsphone) {\n      osVersion = getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i);\n    } else if (result.mac) {\n      osVersion = getFirstMatch(/Mac OS X (\\d+([_\\.\\s]\\d+)*)/i);\n      osVersion = osVersion.replace(/[_\\s]/g, '.');\n    } else if (iosdevice) {\n      osVersion = getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i);\n      osVersion = osVersion.replace(/[_\\s]/g, '.');\n    } else if (android) {\n      osVersion = getFirstMatch(/android[ \\/-](\\d+(\\.\\d+)*)/i);\n    } else if (result.webos) {\n      osVersion = getFirstMatch(/(?:web|hpw)os\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.blackberry) {\n      osVersion = getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i);\n    } else if (result.bada) {\n      osVersion = getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.tizen) {\n      osVersion = getFirstMatch(/tizen[\\/\\s](\\d+(\\.\\d+)*)/i);\n    }\n    if (osVersion) {\n      result.osversion = osVersion;\n    }\n\n    // device type extraction\n    var osMajorVersion = !result.windows && osVersion.split('.')[0];\n    if (\n         tablet\n      || nexusTablet\n      || iosdevice == 'ipad'\n      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))\n      || result.silk\n    ) {\n      result.tablet = t\n    } else if (\n         mobile\n      || iosdevice == 'iphone'\n      || iosdevice == 'ipod'\n      || android\n      || nexusMobile\n      || result.blackberry\n      || result.webos\n      || result.bada\n    ) {\n      result.mobile = t\n    }\n\n    // Graded Browser Support\n    // http://developer.yahoo.com/yui/articles/gbs\n    if (result.msedge ||\n        (result.msie && result.version >= 10) ||\n        (result.yandexbrowser && result.version >= 15) ||\n\t\t    (result.vivaldi && result.version >= 1.0) ||\n        (result.chrome && result.version >= 20) ||\n        (result.samsungBrowser && result.version >= 4) ||\n        (result.firefox && result.version >= 20.0) ||\n        (result.safari && result.version >= 6) ||\n        (result.opera && result.version >= 10.0) ||\n        (result.ios && result.osversion && result.osversion.split(\".\")[0] >= 6) ||\n        (result.blackberry && result.version >= 10.1)\n        || (result.chromium && result.version >= 20)\n        ) {\n      result.a = t;\n    }\n    else if ((result.msie && result.version < 10) ||\n        (result.chrome && result.version < 20) ||\n        (result.firefox && result.version < 20.0) ||\n        (result.safari && result.version < 6) ||\n        (result.opera && result.version < 10.0) ||\n        (result.ios && result.osversion && result.osversion.split(\".\")[0] < 6)\n        || (result.chromium && result.version < 20)\n        ) {\n      result.c = t\n    } else result.x = t\n\n    return result\n  }\n\n  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')\n\n  bowser.test = function (browserList) {\n    for (var i = 0; i < browserList.length; ++i) {\n      var browserItem = browserList[i];\n      if (typeof browserItem=== 'string') {\n        if (browserItem in bowser) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get version precisions count\n   *\n   * @example\n   *   getVersionPrecision(\"1.10.3\") // 3\n   *\n   * @param  {string} version\n   * @return {number}\n   */\n  function getVersionPrecision(version) {\n    return version.split(\".\").length;\n  }\n\n  /**\n   * Array::map polyfill\n   *\n   * @param  {Array} arr\n   * @param  {Function} iterator\n   * @return {Array}\n   */\n  function map(arr, iterator) {\n    var result = [], i;\n    if (Array.prototype.map) {\n      return Array.prototype.map.call(arr, iterator);\n    }\n    for (i = 0; i < arr.length; i++) {\n      result.push(iterator(arr[i]));\n    }\n    return result;\n  }\n\n  /**\n   * Calculate browser version weight\n   *\n   * @example\n   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1\n   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1\n   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0\n   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1\n   *\n   * @param  {Array<String>} versions versions to compare\n   * @return {Number} comparison result\n   */\n  function compareVersions(versions) {\n    // 1) get common precision for both versions, for example for \"10.0\" and \"9\" it should be 2\n    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));\n    var chunks = map(versions, function (version) {\n      var delta = precision - getVersionPrecision(version);\n\n      // 2) \"9\" -> \"9.0\" (for precision = 2)\n      version = version + new Array(delta + 1).join(\".0\");\n\n      // 3) \"9.0\" -> [\"000000000\"\", \"000000009\"]\n      return map(version.split(\".\"), function (chunk) {\n        return new Array(20 - chunk.length).join(\"0\") + chunk;\n      }).reverse();\n    });\n\n    // iterate in reverse order by reversed chunks array\n    while (--precision >= 0) {\n      // 4) compare: \"000000009\" > \"000000010\" = false (but \"9\" > \"10\" = true)\n      if (chunks[0][precision] > chunks[1][precision]) {\n        return 1;\n      }\n      else if (chunks[0][precision] === chunks[1][precision]) {\n        if (precision === 0) {\n          // all version chunks are same\n          return 0;\n        }\n      }\n      else {\n        return -1;\n      }\n    }\n  }\n\n  /**\n   * Check if browser is unsupported\n   *\n   * @example\n   *   bowser.isUnsupportedBrowser({\n   *     msie: \"10\",\n   *     firefox: \"23\",\n   *     chrome: \"29\",\n   *     safari: \"5.1\",\n   *     opera: \"16\",\n   *     phantom: \"534\"\n   *   });\n   *\n   * @param  {Object}  minVersions map of minimal version to browser\n   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map\n   * @param  {String}  [ua] user agent string\n   * @return {Boolean}\n   */\n  function isUnsupportedBrowser(minVersions, strictMode, ua) {\n    var _bowser = bowser;\n\n    // make strictMode param optional with ua param usage\n    if (typeof strictMode === 'string') {\n      ua = strictMode;\n      strictMode = void(0);\n    }\n\n    if (strictMode === void(0)) {\n      strictMode = false;\n    }\n    if (ua) {\n      _bowser = detect(ua);\n    }\n\n    var version = \"\" + _bowser.version;\n    for (var browser in minVersions) {\n      if (minVersions.hasOwnProperty(browser)) {\n        if (_bowser[browser]) {\n          if (typeof minVersions[browser] !== 'string') {\n            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));\n          }\n\n          // browser version and min supported version.\n          return compareVersions([version, minVersions[browser]]) < 0;\n        }\n      }\n    }\n\n    return strictMode; // not found\n  }\n\n  /**\n   * Check if browser is supported\n   *\n   * @param  {Object} minVersions map of minimal version to browser\n   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map\n   * @param  {String}  [ua] user agent string\n   * @return {Boolean}\n   */\n  function check(minVersions, strictMode, ua) {\n    return !isUnsupportedBrowser(minVersions, strictMode, ua);\n  }\n\n  bowser.isUnsupportedBrowser = isUnsupportedBrowser;\n  bowser.compareVersions = compareVersions;\n  bowser.check = check;\n\n  /*\n   * Set our detect method to the main bowser object so we can\n   * reuse it to test other user agents.\n   * This is needed to implement future tests.\n   */\n  bowser._detect = detect;\n\n  /*\n   * Set our detect public method to the main bowser object\n   * This is needed to implement bowser in server side\n   */\n  bowser.detect = detect;\n  return bowser\n});\n","import SDPUtil from './SDPUtil';\r\n\r\n// this could be useful in Array.prototype.\r\n/**\r\n *\r\n * @param array1\r\n * @param array2\r\n */\r\nfunction arrayEquals(array1, array2) {\r\n    // if the other array is a falsy value, return\r\n    if (!array2) {\r\n        return false;\r\n    }\r\n\r\n    // compare lengths - can save a lot of time\r\n    if (array1.length !== array2.length) {\r\n        return false;\r\n    }\r\n\r\n    for (let i = 0, l = array1.length; i < l; i++) {\r\n        // Check if we have nested arrays\r\n        if (array1[i] instanceof Array && array2[i] instanceof Array) {\r\n            // recurse into the nested arrays\r\n            if (!array1[i].equals(array2[i])) {\r\n                return false;\r\n            }\r\n        } else if (array1[i] !== array2[i]) {\r\n            // Warning - two different object instances will never be\r\n            // equal: {x:20} != {x:20}\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n *\r\n * @param mySDP\r\n * @param otherSDP\r\n */\r\nexport default function SDPDiffer(mySDP, otherSDP) {\r\n    this.mySDP = mySDP;\r\n    this.otherSDP = otherSDP;\r\n    if (!mySDP) {\r\n        throw new Error('\"mySDP\" is undefined!');\r\n    } else if (!otherSDP) {\r\n        throw new Error('\"otherSDP\" is undefined!');\r\n    }\r\n}\r\n\r\n/**\r\n * Returns map of MediaChannel that contains media contained in\r\n * 'mySDP', but not contained in 'otherSdp'. Mapped by channel idx.\r\n */\r\nSDPDiffer.prototype.getNewMedia = function() {\r\n\r\n    const myMedias = this.mySDP.getMediaSsrcMap();\r\n    const othersMedias = this.otherSDP.getMediaSsrcMap();\r\n    const newMedia = {};\r\n\r\n    Object.keys(othersMedias).forEach(othersMediaIdx => {\r\n        const myMedia = myMedias[othersMediaIdx];\r\n        const othersMedia = othersMedias[othersMediaIdx];\r\n\r\n        if (!myMedia && othersMedia) {\r\n            // Add whole channel\r\n            newMedia[othersMediaIdx] = othersMedia;\r\n\r\n            return;\r\n        }\r\n\r\n        // Look for new ssrcs across the channel\r\n        Object.keys(othersMedia.ssrcs).forEach(ssrc => {\r\n            if (Object.keys(myMedia.ssrcs).indexOf(ssrc) === -1) {\r\n                // Allocate channel if we've found ssrc that doesn't exist in\r\n                // our channel\r\n                if (!newMedia[othersMediaIdx]) {\r\n                    newMedia[othersMediaIdx] = {\r\n                        mediaindex: othersMedia.mediaindex,\r\n                        mid: othersMedia.mid,\r\n                        ssrcs: {},\r\n                        ssrcGroups: []\r\n                    };\r\n                }\r\n                newMedia[othersMediaIdx].ssrcs[ssrc] = othersMedia.ssrcs[ssrc];\r\n            } else if (othersMedia.ssrcs[ssrc].lines\r\n                        && myMedia.ssrcs[ssrc].lines) {\r\n                // we want to detect just changes in adding/removing msid\r\n                const myContainMsid = myMedia.ssrcs[ssrc].lines.find(\r\n                    line => line.indexOf('msid') !== -1) !== undefined;\r\n                const newContainMsid = othersMedia.ssrcs[ssrc].lines.find(\r\n                    line => line.indexOf('msid') !== -1) !== undefined;\r\n\r\n                if (myContainMsid !== newContainMsid) {\r\n                    if (!newMedia[othersMediaIdx]) {\r\n                        newMedia[othersMediaIdx] = {\r\n                            mediaindex: othersMedia.mediaindex,\r\n                            mid: othersMedia.mid,\r\n                            ssrcs: {},\r\n                            ssrcGroups: []\r\n                        };\r\n                    }\r\n                    newMedia[othersMediaIdx].ssrcs[ssrc]\r\n                        = othersMedia.ssrcs[ssrc];\r\n                }\r\n            }\r\n        });\r\n\r\n        // Look for new ssrc groups across the channels\r\n        othersMedia.ssrcGroups.forEach(otherSsrcGroup => {\r\n\r\n            // try to match the other ssrc-group with an ssrc-group of ours\r\n            let matched = false;\r\n\r\n            for (let i = 0; i < myMedia.ssrcGroups.length; i++) {\r\n                const mySsrcGroup = myMedia.ssrcGroups[i];\r\n\r\n                if (otherSsrcGroup.semantics === mySsrcGroup.semantics\r\n                    && arrayEquals(otherSsrcGroup.ssrcs, mySsrcGroup.ssrcs)) {\r\n\r\n                    matched = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!matched) {\r\n                // Allocate channel if we've found an ssrc-group that doesn't\r\n                // exist in our channel\r\n\r\n                if (!newMedia[othersMediaIdx]) {\r\n                    newMedia[othersMediaIdx] = {\r\n                        mediaindex: othersMedia.mediaindex,\r\n                        mid: othersMedia.mid,\r\n                        ssrcs: {},\r\n                        ssrcGroups: []\r\n                    };\r\n                }\r\n                newMedia[othersMediaIdx].ssrcGroups.push(otherSsrcGroup);\r\n            }\r\n        });\r\n    });\r\n\r\n    return newMedia;\r\n};\r\n\r\n/**\r\n * TODO: document!\r\n */\r\nSDPDiffer.prototype.toJingle = function(modify) {\r\n    const sdpMediaSsrcs = this.getNewMedia();\r\n\r\n    let modified = false;\r\n\r\n    Object.keys(sdpMediaSsrcs).forEach(mediaindex => {\r\n        modified = true;\r\n        const media = sdpMediaSsrcs[mediaindex];\r\n\r\n        modify.c('content', { name: media.mid });\r\n\r\n        modify.c('description',\r\n            { xmlns: 'urn:xmpp:jingle:apps:rtp:1',\r\n                media: media.mid });\r\n\r\n        // FIXME: not completely sure this operates on blocks and / or handles\r\n        // different ssrcs correctly\r\n        // generate sources from lines\r\n        Object.keys(media.ssrcs).forEach(ssrcNum => {\r\n            const mediaSsrc = media.ssrcs[ssrcNum];\r\n\r\n            modify.c('source', { xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\r\n            modify.attrs({ ssrc: mediaSsrc.ssrc });\r\n\r\n            // iterate over ssrc lines\r\n            mediaSsrc.lines.forEach(line => {\r\n                const idx = line.indexOf(' ');\r\n                const kv = line.substr(idx + 1);\r\n\r\n                modify.c('parameter');\r\n                if (kv.indexOf(':') === -1) {\r\n                    modify.attrs({ name: kv });\r\n                } else {\r\n                    const nv = kv.split(':', 2);\r\n                    const name = nv[0];\r\n                    const value = SDPUtil.filterSpecialChars(nv[1]);\r\n\r\n                    modify.attrs({ name });\r\n                    modify.attrs({ value });\r\n                }\r\n                modify.up(); // end of parameter\r\n            });\r\n            modify.up(); // end of source\r\n        });\r\n\r\n        // generate source groups from lines\r\n        media.ssrcGroups.forEach(ssrcGroup => {\r\n            if (ssrcGroup.ssrcs.length) {\r\n\r\n                modify.c('ssrc-group', {\r\n                    semantics: ssrcGroup.semantics,\r\n                    xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'\r\n                });\r\n\r\n                ssrcGroup.ssrcs.forEach(ssrc => {\r\n                    modify.c('source', { ssrc })\r\n                        .up(); // end of source\r\n                });\r\n                modify.up(); // end of ssrc-group\r\n            }\r\n        });\r\n\r\n        modify.up(); // end of description\r\n        modify.up(); // end of content\r\n    });\r\n\r\n    return modified;\r\n};\r\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/**\r\n * Indicates that the end-to-end round-trip-time for a participant has changed.\r\n */\r\nexport const E2E_RTT_CHANGED = 'e2eping.e2e_rtt_changed';\r\n","/**\r\n * Provides statistics for the local stream.\r\n */\r\n\r\n/**\r\n * Size of the webaudio analyzer buffer.\r\n * @type {number}\r\n */\r\nconst WEBAUDIO_ANALYZER_FFT_SIZE = 2048;\r\n\r\n/**\r\n * Value of the webaudio analyzer smoothing time parameter.\r\n * @type {number}\r\n */\r\nconst WEBAUDIO_ANALYZER_SMOOTING_TIME = 0.8;\r\n\r\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\r\n\r\nlet context = null;\r\n\r\nif (window.AudioContext) {\r\n    context = new AudioContext();\r\n\r\n    // XXX Not all browsers define a suspend method on AudioContext. As the\r\n    // invocation is at the (ES6 module) global execution level, it breaks the\r\n    // loading of the lib-qhsense-meet library in such browsers and, consequently,\r\n    // the loading of the very Web app that uses the lib-qhsense-meet library. For\r\n    // example, Google Chrome 40 on Android does not define the method but we\r\n    // still want to be able to load the lib-qhsense-meet library there and\r\n    // display a page which notifies the user that the Web app is not supported\r\n    // there.\r\n    context.suspend && context.suspend();\r\n}\r\n\r\n/**\r\n * Converts time domain data array to audio level.\r\n * @param samples the time domain data array.\r\n * @returns {number} the audio level\r\n */\r\nfunction timeDomainDataToAudioLevel(samples) {\r\n\r\n    let maxVolume = 0;\r\n\r\n    const length = samples.length;\r\n\r\n    for (let i = 0; i < length; i++) {\r\n        if (maxVolume < samples[i]) {\r\n            maxVolume = samples[i];\r\n        }\r\n    }\r\n\r\n    return parseFloat(((maxVolume - 127) / 128).toFixed(3));\r\n}\r\n\r\n/**\r\n * Animates audio level change\r\n * @param newLevel the new audio level\r\n * @param lastLevel the last audio level\r\n * @returns {Number} the audio level to be set\r\n */\r\nfunction animateLevel(newLevel, lastLevel) {\r\n    let value = 0;\r\n    const diff = lastLevel - newLevel;\r\n\r\n    if (diff > 0.2) {\r\n        value = lastLevel - 0.2;\r\n    } else if (diff < -0.4) {\r\n        value = lastLevel + 0.4;\r\n    } else {\r\n        value = newLevel;\r\n    }\r\n\r\n    return parseFloat(value.toFixed(3));\r\n}\r\n\r\n\r\n/**\r\n * <tt>LocalStatsCollector</tt> calculates statistics for the local stream.\r\n *\r\n * @param stream the local stream\r\n * @param interval stats refresh interval given in ms.\r\n * @param callback function that receives the audio levels.\r\n * @constructor\r\n */\r\nexport default function LocalStatsCollector(stream, interval, callback) {\r\n    this.stream = stream;\r\n    this.intervalId = null;\r\n    this.intervalMilis = interval;\r\n    this.audioLevel = 0;\r\n    this.callback = callback;\r\n}\r\n\r\n/**\r\n * Starts the collecting the statistics.\r\n */\r\nLocalStatsCollector.prototype.start = function() {\r\n    if (!LocalStatsCollector.isLocalStatsSupported()) {\r\n        return;\r\n    }\r\n    context.resume();\r\n    const analyser = context.createAnalyser();\r\n\r\n    analyser.smoothingTimeConstant = WEBAUDIO_ANALYZER_SMOOTING_TIME;\r\n    analyser.fftSize = WEBAUDIO_ANALYZER_FFT_SIZE;\r\n\r\n    const source = context.createMediaStreamSource(this.stream);\r\n\r\n    source.connect(analyser);\r\n\r\n\r\n    const self = this;\r\n\r\n    this.intervalId = setInterval(\r\n        () => {\r\n            const array = new Uint8Array(analyser.frequencyBinCount);\r\n\r\n            analyser.getByteTimeDomainData(array);\r\n            const audioLevel = timeDomainDataToAudioLevel(array);\r\n\r\n            if (audioLevel !== self.audioLevel) {\r\n                self.audioLevel = animateLevel(audioLevel, self.audioLevel);\r\n                self.callback(self.audioLevel);\r\n            }\r\n        },\r\n        this.intervalMilis\r\n    );\r\n};\r\n\r\n/**\r\n * Stops collecting the statistics.\r\n */\r\nLocalStatsCollector.prototype.stop = function() {\r\n    if (this.intervalId) {\r\n        clearInterval(this.intervalId);\r\n        this.intervalId = null;\r\n    }\r\n};\r\n\r\n/**\r\n * Checks if the environment has the necessary conditions to support\r\n * collecting stats from local streams.\r\n *\r\n * @returns {boolean}\r\n */\r\nLocalStatsCollector.isLocalStatsSupported = function() {\r\n    return Boolean(context);\r\n};\r\n","const currentExecutingScript = require('current-executing-script');\r\n\r\n/* eslint-disable max-params */\r\n\r\n/**\r\n * Implements utility functions which facilitate the dealing with scripts such\r\n * as the download and execution of a JavaScript file.\r\n */\r\nconst ScriptUtil = {\r\n    /**\r\n     * Loads a script from a specific source.\r\n     *\r\n     * @param src the source from the which the script is to be (down)loaded\r\n     * @param async true to asynchronously load the script or false to\r\n     * synchronously load the script\r\n     * @param prepend true to schedule the loading of the script as soon as\r\n     * possible or false to schedule the loading of the script at the end of the\r\n     * scripts known at the time\r\n     * @param relativeURL whether we need load the library from url relative\r\n     * to the url that lib-qhsense-meet was loaded. Useful when sourcing the\r\n     * library from different location than the app that is using it\r\n     * @param loadCallback on load callback function\r\n     * @param errorCallback callback to be called on error loading the script\r\n     */\r\n    loadScript(\r\n            src,\r\n            async,\r\n            prepend,\r\n            relativeURL,\r\n            loadCallback,\r\n            errorCallback) {\r\n        const d = document;\r\n        const tagName = 'script';\r\n        const script = d.createElement(tagName);\r\n        const referenceNode = d.getElementsByTagName(tagName)[0];\r\n\r\n        script.async = async;\r\n\r\n        if (relativeURL) {\r\n            // finds the src url of the current loaded script\r\n            // and use it as base of the src supplied argument\r\n            const scriptEl = currentExecutingScript();\r\n\r\n            if (scriptEl) {\r\n                const scriptSrc = scriptEl.src;\r\n                const baseScriptSrc\r\n                    = scriptSrc.substring(0, scriptSrc.lastIndexOf('/') + 1);\r\n\r\n                if (scriptSrc && baseScriptSrc) {\r\n                    // eslint-disable-next-line no-param-reassign\r\n                    src = baseScriptSrc + src;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (loadCallback) {\r\n            script.onload = loadCallback;\r\n        }\r\n        if (errorCallback) {\r\n            script.onerror = errorCallback;\r\n        }\r\n\r\n        script.src = src;\r\n        if (prepend) {\r\n            referenceNode.parentNode.insertBefore(script, referenceNode);\r\n        } else {\r\n            referenceNode.parentNode.appendChild(script);\r\n        }\r\n    }\r\n};\r\n\r\n/* eslint-enable max-params */\r\n\r\nmodule.exports = ScriptUtil;\r\n","/**\r\n * The transciption is on.\r\n *\r\n * @type {String}\r\n */\r\nexport const ON = 'on';\r\n\r\n/**\r\n * The transciption is off.\r\n *\r\n * @type {String}\r\n */\r\nexport const OFF = 'off';\r\n","/* global __filename, module */\r\nimport EventEmitter from 'events';\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport * as QHSenseTrackEvents from '../../QHSenseTrackEvents';\r\nimport * as MediaType from '../../service/RTC/MediaType';\r\nimport RTCUtils from './RTCUtils';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Maps our handler types to MediaStreamTrack properties.\r\n */\r\nconst trackHandler2Prop = {\r\n    'track_mute': 'onmute', // Not supported on FF\r\n    'track_unmute': 'onunmute',\r\n    'track_ended': 'onended'\r\n};\r\n\r\n/**\r\n * Adds onended/oninactive handler to a MediaStream.\r\n * @param mediaStream a MediaStream to attach onended/oninactive handler\r\n * @param handler the handler\r\n */\r\nfunction addMediaStreamInactiveHandler(mediaStream, handler) {\r\n    mediaStream.oninactive = handler;\r\n}\r\n\r\n/**\r\n * Represents a single media track (either audio or video).\r\n */\r\nexport default class QHSenseTrack extends EventEmitter {\r\n    /* eslint-disable max-params */\r\n    /**\r\n     * Represents a single media track (either audio or video).\r\n     * @constructor\r\n     * @param conference the rtc instance\r\n     * @param stream the WebRTC MediaStream instance\r\n     * @param track the WebRTC MediaStreamTrack instance, must be part of\r\n     * the given <tt>stream</tt>.\r\n     * @param streamInactiveHandler the function that will handle\r\n     *        onended/oninactive events of the stream.\r\n     * @param trackMediaType the media type of the QHSenseTrack\r\n     * @param videoType the VideoType for this track if any\r\n     */\r\n    constructor(\r\n            conference,\r\n            stream,\r\n            track,\r\n            streamInactiveHandler,\r\n            trackMediaType,\r\n            videoType) {\r\n        super();\r\n\r\n        // aliases for addListener/removeListener\r\n        this.addEventListener = this.addListener;\r\n        this.removeEventListener = this.off = this.removeListener;\r\n\r\n        /**\r\n         * Array with the HTML elements that are displaying the streams.\r\n         * @type {Array}\r\n         */\r\n        this.containers = [];\r\n        this.conference = conference;\r\n        this.audioLevel = -1;\r\n        this.type = trackMediaType;\r\n        this.track = track;\r\n        this.videoType = videoType;\r\n        this.handlers = new Map();\r\n\r\n        /**\r\n         * Indicates whether this QHSenseTrack has been disposed. If true, this\r\n         * QHSenseTrack is to be considered unusable and operations involving it\r\n         * are to fail (e.g. {@link QHSenseConference#addTrack(QHSenseTrack)},\r\n         * {@link QHSenseConference#removeTrack(QHSenseTrack)}).\r\n         * @type {boolean}\r\n         */\r\n        this.disposed = false;\r\n\r\n        /**\r\n         * The inactive handler which will be triggered when the underlying\r\n         * <tt>MediaStream</tt> ends.\r\n         *\r\n         * @private\r\n         * @type {Function}\r\n         */\r\n        this._streamInactiveHandler = streamInactiveHandler;\r\n\r\n        this._setStream(stream);\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Sets handler to the WebRTC MediaStream or MediaStreamTrack object\r\n     * depending on the passed type.\r\n     * @param {string} type the type of the handler that is going to be set\r\n     * @param {Function} handler the handler.\r\n     */\r\n    _setHandler(type, handler) {\r\n        if (!trackHandler2Prop.hasOwnProperty(type)) {\r\n            logger.error(`Invalid handler type ${type}`);\r\n\r\n            return;\r\n        }\r\n        if (handler) {\r\n            this.handlers.set(type, handler);\r\n        } else {\r\n            this.handlers.delete(type);\r\n        }\r\n\r\n        if (this.stream) {\r\n            for (const track of this.stream.getTracks()) {\r\n                track[trackHandler2Prop[type]] = handler;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unregisters all event handlers bound to the underlying media stream/track\r\n     * @private\r\n     */\r\n    _unregisterHandlers() {\r\n        if (!this.stream) {\r\n            logger.warn(\r\n                `${this}: unable to unregister handlers - no stream object`);\r\n\r\n            return;\r\n        }\r\n\r\n        for (const type of this.handlers.keys()) {\r\n            // FIXME Why only video tracks?\r\n            for (const videoTrack of this.stream.getVideoTracks()) {\r\n                videoTrack[trackHandler2Prop[type]] = undefined;\r\n            }\r\n        }\r\n        if (this._streamInactiveHandler) {\r\n            addMediaStreamInactiveHandler(this.stream, undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the stream property of QHSenseTrack object and sets all stored\r\n     * handlers to it.\r\n     *\r\n     * @param {MediaStream} stream the new stream.\r\n     * @protected\r\n     */\r\n    _setStream(stream) {\r\n        if (this.stream === stream) {\r\n            return;\r\n        }\r\n\r\n        this.stream = stream;\r\n\r\n        // TODO Practically, that's like the opposite of _unregisterHandlers\r\n        // i.e. may be abstracted into a function/method called\r\n        // _registerHandlers for clarity and easing the maintenance of the two\r\n        // pieces of source code.\r\n        if (this.stream) {\r\n            for (const type of this.handlers.keys()) {\r\n                this._setHandler(type, this.handlers.get(type));\r\n            }\r\n            if (this._streamInactiveHandler) {\r\n                addMediaStreamInactiveHandler(\r\n                    this.stream, this._streamInactiveHandler);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the type (audio or video) of this track.\r\n     */\r\n    getType() {\r\n        return this.type;\r\n    }\r\n\r\n    /**\r\n     * Check if this is an audio track.\r\n     */\r\n    isAudioTrack() {\r\n        return this.getType() === MediaType.AUDIO;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the underlying WebRTC <tt>MediaStreamTrack</tt> is muted\r\n     * according to it's 'muted' field status.\r\n     * @return {boolean} <tt>true</tt> if the underlying\r\n     * <tt>MediaStreamTrack</tt> is muted or <tt>false</tt> otherwise.\r\n     */\r\n    isWebRTCTrackMuted() {\r\n        return this.track && this.track.muted;\r\n    }\r\n\r\n    /**\r\n     * Check if this is a video track.\r\n     */\r\n    isVideoTrack() {\r\n        return this.getType() === MediaType.VIDEO;\r\n    }\r\n\r\n    /**\r\n     * Checks whether this is a local track.\r\n     * @abstract\r\n     * @return {boolean} 'true' if it's a local track or 'false' otherwise.\r\n     */\r\n    isLocal() {\r\n        throw new Error('Not implemented by subclass');\r\n    }\r\n\r\n    /**\r\n     * Returns the WebRTC MediaStream instance.\r\n     */\r\n    getOriginalStream() {\r\n        return this.stream;\r\n    }\r\n\r\n    /**\r\n     * Returns the ID of the underlying WebRTC Media Stream(if any)\r\n     * @returns {String|null}\r\n     */\r\n    getStreamId() {\r\n        return this.stream ? this.stream.id : null;\r\n    }\r\n\r\n    /**\r\n     * Return the underlying WebRTC MediaStreamTrack\r\n     * @returns {MediaStreamTrack}\r\n     */\r\n    getTrack() {\r\n        return this.track;\r\n    }\r\n\r\n    /**\r\n     * Returns the ID of the underlying WebRTC MediaStreamTrack(if any)\r\n     * @returns {String|null}\r\n     */\r\n    getTrackId() {\r\n        return this.track ? this.track.id : null;\r\n    }\r\n\r\n    /**\r\n     * Return meaningful usage label for this track depending on it's media and\r\n     * eventual video type.\r\n     * @returns {string}\r\n     */\r\n    getUsageLabel() {\r\n        if (this.isAudioTrack()) {\r\n            return 'mic';\r\n        }\r\n\r\n        return this.videoType ? this.videoType : 'default';\r\n    }\r\n\r\n    /**\r\n     * Eventually will trigger RTCEvents.TRACK_ATTACHED event.\r\n     * @param container the video/audio container to which this stream is\r\n     *        attached and for which event will be fired.\r\n     * @private\r\n     */\r\n    _maybeFireTrackAttached(container) {\r\n        if (this.conference && container) {\r\n            this.conference._onTrackAttach(this, container);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attaches the MediaStream of this track to an HTML container.\r\n     * Adds the container to the list of containers that are displaying the\r\n     * track.\r\n     *\r\n     * @param container the HTML container which can be 'video' or 'audio'\r\n     * element.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    attach(container) {\r\n        if (this.stream) {\r\n            RTCUtils.attachMediaStream(container, this.stream);\r\n        }\r\n        this.containers.push(container);\r\n        this._maybeFireTrackAttached(container);\r\n        this._attachTTFMTracker(container);\r\n    }\r\n\r\n    /**\r\n     * Removes this QHSenseTrack from the passed HTML container.\r\n     *\r\n     * @param container the HTML container to detach from this QHSenseTrack. If\r\n     * <tt>null</tt> or <tt>undefined</tt>, all containers are removed. A\r\n     * container can be a 'video', 'audio' or 'object' HTML element instance to\r\n     * which this QHSenseTrack is currently attached.\r\n     */\r\n    detach(container) {\r\n        for (let cs = this.containers, i = cs.length - 1; i >= 0; --i) {\r\n            const c = cs[i];\r\n\r\n            if (!container) {\r\n                RTCUtils.attachMediaStream(c, null);\r\n            }\r\n            if (!container || c === container) {\r\n                cs.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        if (container) {\r\n            RTCUtils.attachMediaStream(container, null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach time to first media tracker only if there is conference and only\r\n     * for the first element.\r\n     *\r\n     * @param {HTMLElement} container the HTML container which can be 'video' or\r\n     * 'audio' element.\r\n     * @private\r\n     */\r\n    _attachTTFMTracker(container) { // eslint-disable-line no-unused-vars\r\n        // Should be defined by the classes that are extending QHSenseTrack\r\n    }\r\n\r\n    /**\r\n     * Removes attached event listeners.\r\n     *\r\n     * @returns {Promise}\r\n     */\r\n    dispose() {\r\n        this.removeAllListeners();\r\n\r\n        this.disposed = true;\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Returns true if this is a video track and the source of the video is a\r\n     * screen capture as opposed to a camera.\r\n     */\r\n    isScreenSharing() {\r\n        // FIXME: Should be fixed or removed.\r\n    }\r\n\r\n    /**\r\n     * Returns id of the track.\r\n     * @returns {string|null} id of the track or null if this is fake track.\r\n     */\r\n    getId() {\r\n        if (this.stream) {\r\n            return RTCUtils.getStreamID(this.stream);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the MediaStream is active/not ended.\r\n     * When there is no check for active we don't have information and so\r\n     * will return that stream is active (in case of FF).\r\n     * @returns {boolean} whether MediaStream is active.\r\n     */\r\n    isActive() {\r\n        if (typeof this.stream.active !== 'undefined') {\r\n            return this.stream.active;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sets the audio level for the stream\r\n     * @param {number} audioLevel value between 0 and 1\r\n     * @param {TraceablePeerConnection} [tpc] the peerconnection instance which\r\n     * is source for the audio level. It can be <tt>undefined</tt> for\r\n     * a local track if the audio level was measured outside of the\r\n     * peerconnection (see /modules/statistics/LocalStatsCollector.js).\r\n     */\r\n    setAudioLevel(audioLevel, tpc) {\r\n        if (this.audioLevel !== audioLevel) {\r\n            this.audioLevel = audioLevel;\r\n            this.emit(\r\n                QHSenseTrackEvents.TRACK_AUDIO_LEVEL_CHANGED,\r\n                audioLevel,\r\n                tpc);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the msid of the stream attached to the QHSenseTrack object or null\r\n     * if no stream is attached.\r\n     */\r\n    getMSID() {\r\n        const streamId = this.getStreamId();\r\n        const trackId = this.getTrackId();\r\n\r\n        return streamId && trackId ? `${streamId} ${trackId}` : null;\r\n    }\r\n\r\n    /**\r\n     * Sets new audio output device for track's DOM elements. Video tracks are\r\n     * ignored.\r\n     * @param {string} audioOutputDeviceId - id of 'audiooutput' device from\r\n     *      navigator.mediaDevices.enumerateDevices(), '' for default device\r\n     * @emits QHSenseTrackEvents.TRACK_AUDIO_OUTPUT_CHANGED\r\n     * @returns {Promise}\r\n     */\r\n    setAudioOutput(audioOutputDeviceId) {\r\n        if (!RTCUtils.isDeviceChangeAvailable('output')) {\r\n            return Promise.reject(\r\n                new Error('Audio output device change is not supported'));\r\n        }\r\n\r\n        // All audio communication is done through audio tracks, so ignore\r\n        // changing audio output for video tracks at all.\r\n        if (this.isVideoTrack()) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return (\r\n            Promise.all(\r\n                this.containers.map(\r\n                    element =>\r\n                        element.setSinkId(audioOutputDeviceId)\r\n                            .catch(error => {\r\n                                logger.warn(\r\n                                    'Failed to change audio output device on'\r\n                                        + ' element. Default or previously set'\r\n                                        + ' audio output device will be used.',\r\n                                    element,\r\n                                    error);\r\n                                throw error;\r\n                            }))\r\n            )\r\n                .then(() => {\r\n                    this.emit(\r\n                        QHSenseTrackEvents.TRACK_AUDIO_OUTPUT_CHANGED,\r\n                        audioOutputDeviceId);\r\n                }));\r\n    }\r\n}\r\n","\r\n\r\n/**\r\n * The method will increase the given number by 1. If the given counter is equal\r\n * or greater to {@link Number.MAX_SAFE_INTEGER} then it will be rolled back to\r\n * 1.\r\n * @param {number} number - An integer counter value to be incremented.\r\n * @return {number} the next counter value increased by 1 (see the description\r\n * above for exception).\r\n */\r\nexport function safeCounterIncrement(number) {\r\n    let nextValue = number;\r\n\r\n    if (number >= Number.MAX_SAFE_INTEGER) {\r\n        nextValue = 0;\r\n    }\r\n\r\n    return nextValue + 1;\r\n}\r\n","/**\r\n * A model for keeping track of each user's total\r\n * time as a dominant speaker. The model also\r\n * keeps track of the user's last known name\r\n * in case the user has left the meeting,\r\n * which is also tracked.\r\n */\r\nclass SpeakerStats {\r\n    /**\r\n     * Initializes a new SpeakerStats instance.\r\n     *\r\n     * @constructor\r\n     * @param {string} userId - The id of the user being tracked.\r\n     * @param {string} displayName - The name of the user being tracked.\r\n     * @param {boolean} isLocalStats - True if the stats model tracks\r\n     * the local user.\r\n     * @returns {void}\r\n     */\r\n    constructor(userId, displayName, isLocalStats) {\r\n        this._userId = userId;\r\n        this.setDisplayName(displayName);\r\n        this._isLocalStats = isLocalStats || false;\r\n        this.setDominantSpeaker(false);\r\n        this.totalDominantSpeakerTime = 0;\r\n        this._dominantSpeakerStart = 0;\r\n        this._hasLeft = false;\r\n    }\r\n\r\n    /**\r\n     * Get the user id being tracked.\r\n     *\r\n     * @returns {string} The user id.\r\n     */\r\n    getUserId() {\r\n        return this._userId;\r\n    }\r\n\r\n    /**\r\n     * Get the name of the user being tracked.\r\n     *\r\n     * @returns {string} The user name.\r\n     */\r\n    getDisplayName() {\r\n        return this.displayName;\r\n    }\r\n\r\n    /**\r\n     * Updates the last known name of the user being tracked.\r\n     *\r\n     * @param {string} - The user name.\r\n     * @returns {void}\r\n     */\r\n    setDisplayName(newName) {\r\n        this.displayName = newName;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the stats are tracking the local user.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    isLocalStats() {\r\n        return this._isLocalStats;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the tracked user is currently a dominant speaker.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    isDominantSpeaker() {\r\n        return this._dominantSpeakerStart > 0;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the tracked user is currently a dominant speaker.\r\n     *\r\n     * @param {boolean} - If true, the user will being accumulating time\r\n     * as dominant speaker. If false, the user will not accumulate time\r\n     * and will record any time accumulated since starting as dominant speaker.\r\n     * @returns {void}\r\n     */\r\n    setDominantSpeaker(isNowDominantSpeaker) {\r\n        if (!this.isDominantSpeaker() && isNowDominantSpeaker) {\r\n            this._dominantSpeakerStart = Date.now();\r\n        } else if (this.isDominantSpeaker() && !isNowDominantSpeaker) {\r\n            const now = Date.now();\r\n            const timeElapsed = now - this._dominantSpeakerStart;\r\n\r\n            this.totalDominantSpeakerTime += timeElapsed;\r\n            this._dominantSpeakerStart = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get how long the tracked user has been dominant speaker.\r\n     *\r\n     * @returns {number} - The speaker time in milliseconds.\r\n     */\r\n    getTotalDominantSpeakerTime() {\r\n        let total = this.totalDominantSpeakerTime;\r\n\r\n        if (this.isDominantSpeaker()) {\r\n            total += Date.now() - this._dominantSpeakerStart;\r\n        }\r\n\r\n        return total;\r\n    }\r\n\r\n    /**\r\n     * Get whether or not the user is still in the meeting.\r\n     *\r\n     * @returns {boolean} True if the user is no longer in the meeting.\r\n     */\r\n    hasLeft() {\r\n        return this._hasLeft;\r\n    }\r\n\r\n    /**\r\n     * Set the user as having left the meeting.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    markAsHasLeft() {\r\n        this._hasLeft = true;\r\n        this.setDominantSpeaker(false);\r\n    }\r\n}\r\n\r\nmodule.exports = SpeakerStats;\r\n","module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n","const AuthenticationEvents = {\r\n    /**\r\n     * Event callback arguments:\r\n     * function(authenticationEnabled, userIdentity)\r\n     * authenticationEnabled - indicates whether authentication has been enabled\r\n     *                         in this session\r\n     * userIdentity - if user has been logged in then it contains user name. If\r\n     *                contains 'null' or 'undefined' then user is not logged in.\r\n     */\r\n    IDENTITY_UPDATED: 'authentication.identity_updated'\r\n};\r\n\r\nmodule.exports = AuthenticationEvents;\r\n","/* global __filename, Promise */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport QHSenseTrack from './QHSenseTrack';\r\nimport QHSenseTrackError from '../../QHSenseTrackError';\r\nimport {\r\n    TRACK_IS_DISPOSED,\r\n    TRACK_NO_STREAM_FOUND\r\n} from '../../QHSenseTrackErrors';\r\nimport {\r\n    LOCAL_TRACK_STOPPED,\r\n    NO_DATA_FROM_SOURCE,\r\n    TRACK_MUTE_CHANGED\r\n} from '../../QHSenseTrackEvents';\r\nimport browser from '../browser';\r\nimport RTCUtils from './RTCUtils';\r\nimport CameraFacingMode from '../../service/RTC/CameraFacingMode';\r\nimport * as MediaType from '../../service/RTC/MediaType';\r\nimport RTCEvents from '../../service/RTC/RTCEvents';\r\nimport VideoType from '../../service/RTC/VideoType';\r\nimport {\r\n    NO_BYTES_SENT,\r\n    TRACK_UNMUTED,\r\n    createNoDataFromSourceEvent\r\n} from '../../service/statistics/AnalyticsEvents';\r\nimport Statistics from '../statistics/statistics';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Represents a single media track(either audio or video).\r\n * One <tt>QHSenseLocalTrack</tt> corresponds to one WebRTC MediaStreamTrack.\r\n */\r\nexport default class QHSenseLocalTrack extends QHSenseTrack {\r\n    /**\r\n     * Constructs new QHSenseLocalTrack instance.\r\n     *\r\n     * @constructor\r\n     * @param {Object} trackInfo\r\n     * @param {number} trackInfo.rtcId the ID assigned by the RTC module\r\n     * @param trackInfo.stream WebRTC MediaStream, parent of the track\r\n     * @param trackInfo.track underlying WebRTC MediaStreamTrack for new\r\n     * QHSenseRemoteTrack\r\n     * @param trackInfo.mediaType the MediaType of the QHSenseRemoteTrack\r\n     * @param trackInfo.videoType the VideoType of the QHSenseRemoteTrack\r\n     * @param trackInfo.effects the effects array contains the effect instance to use\r\n     * @param trackInfo.resolution the video resolution if it's a video track\r\n     * @param trackInfo.deviceId the ID of the local device for this track\r\n     * @param trackInfo.facingMode the camera facing mode used in getUserMedia\r\n     * call\r\n     * @param {sourceId} trackInfo.sourceId - The id of the desktop sharing\r\n     * source. NOTE: defined for desktop sharing tracks only.\r\n     */\r\n    constructor({\r\n        deviceId,\r\n        facingMode,\r\n        mediaType,\r\n        resolution,\r\n        rtcId,\r\n        sourceId,\r\n        sourceType,\r\n        stream,\r\n        track,\r\n        videoType,\r\n        effects = []\r\n    }) {\r\n        super(\r\n            /* conference */ null,\r\n            stream,\r\n            track,\r\n            /* streamInactiveHandler */ () => this.emit(LOCAL_TRACK_STOPPED),\r\n            mediaType,\r\n            videoType);\r\n\r\n        this._setEffectInProgress = false;\r\n        const effect = effects.find(e => e.isEnabled(this));\r\n\r\n        if (effect) {\r\n            this._startStreamEffect(effect);\r\n        }\r\n\r\n        /**\r\n         * The ID assigned by the RTC module on instance creation.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.rtcId = rtcId;\r\n        this.sourceId = sourceId;\r\n        this.sourceType = sourceType;\r\n\r\n        if (browser.usesNewGumFlow()) {\r\n            // Get the resolution from the track itself because it cannot be\r\n            // certain which resolution webrtc has fallen back to using.\r\n            this.resolution = track.getSettings().height;\r\n\r\n            // Cache the constraints of the track in case of any this track\r\n            // model needs to call getUserMedia again, such as when unmuting.\r\n            this._constraints = track.getConstraints();\r\n        } else {\r\n            // FIXME Currently, Firefox is ignoring our constraints about\r\n            // resolutions so we do not store it, to avoid wrong reporting of\r\n            // local track resolution.\r\n            this.resolution = browser.isFirefox() ? null : resolution;\r\n        }\r\n\r\n        this.deviceId = deviceId;\r\n\r\n        /**\r\n         * The <tt>Promise</tt> which represents the progress of a previously\r\n         * queued/scheduled {@link _setMuted} (from the point of view of\r\n         * {@link _queueSetMuted}).\r\n         *\r\n         * @private\r\n         * @type {Promise}\r\n         */\r\n        this._prevSetMuted = Promise.resolve();\r\n\r\n        /**\r\n         * The facing mode of the camera from which this QHSenseLocalTrack\r\n         * instance was obtained.\r\n         *\r\n         * @private\r\n         * @type {CameraFacingMode|undefined}\r\n         */\r\n        this._facingMode = facingMode;\r\n\r\n        // Currently there is no way to know the MediaStreamTrack ended due to\r\n        // to device disconnect in Firefox through e.g. \"readyState\" property.\r\n        // Instead we will compare current track's label with device labels from\r\n        // enumerateDevices() list.\r\n        this._trackEnded = false;\r\n\r\n        /**\r\n         * Indicates whether data has been sent or not.\r\n         */\r\n        this._hasSentData = false;\r\n\r\n        /**\r\n         * Used only for detection of audio problems. We want to check only once\r\n         * whether the track is sending data ot not. This flag is set to false\r\n         * after the check.\r\n         */\r\n        this._testDataSent = true;\r\n\r\n        // Currently there is no way to determine with what device track was\r\n        // created (until getConstraints() support), however we can associate\r\n        // tracks with real devices obtained from enumerateDevices() call as\r\n        // soon as it's called.\r\n        // NOTE: this.deviceId corresponds to the device id specified in GUM constraints and this._realDeviceId seems to\r\n        // correspond to the id of a matching device from the available device list.\r\n        this._realDeviceId = this.deviceId === '' ? undefined : this.deviceId;\r\n\r\n        this._trackMutedTS = 0;\r\n\r\n        this._onDeviceListWillChange = devices => {\r\n            const oldRealDeviceId = this._realDeviceId;\r\n\r\n            this._setRealDeviceIdFromDeviceList(devices);\r\n\r\n            if (\r\n                // Mark track as ended for those browsers that do not support\r\n                // \"readyState\" property. We do not touch tracks created with\r\n                // default device ID \"\".\r\n                (typeof this.getTrack().readyState === 'undefined'\r\n                    && typeof this._realDeviceId !== 'undefined'\r\n                    && !devices.find(d => d.deviceId === this._realDeviceId))\r\n\r\n                // If there was an associated realDeviceID and after the device change the realDeviceId is undefined\r\n                // then the associated device has been disconnected and the _trackEnded flag needs to be set. In\r\n                // addition on some Chrome versions the readyState property is set after the device change event is\r\n                // triggered which causes issues in QHSense-meet with the selection of a new device because we don't\r\n                // detect that the old one was removed.\r\n                || (typeof oldRealDeviceId !== 'undefined' && typeof this._realDeviceId === 'undefined')\r\n            ) {\r\n                this._trackEnded = true;\r\n            }\r\n        };\r\n\r\n        // Subscribe each created local audio track to\r\n        // RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED event. This is different from\r\n        // handling this event for remote tracks (which are handled in RTC.js),\r\n        // because there might be local tracks not attached to a conference.\r\n        if (this.isAudioTrack() && RTCUtils.isDeviceChangeAvailable('output')) {\r\n            this._onAudioOutputDeviceChanged = this.setAudioOutput.bind(this);\r\n            RTCUtils.addListener(\r\n                RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED,\r\n                this._onAudioOutputDeviceChanged);\r\n        }\r\n\r\n        RTCUtils.addListener(RTCEvents.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange);\r\n\r\n        this._initNoDataFromSourceHandlers();\r\n    }\r\n\r\n    /**\r\n     * Returns if associated MediaStreamTrack is in the 'ended' state\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    isEnded() {\r\n        if (this.isVideoTrack() && this.isMuted()) {\r\n            // If a video track is muted the readyState will be ended, that's why we need to rely only on the\r\n            // _trackEnded flag.\r\n            return this._trackEnded;\r\n        }\r\n\r\n        return this.getTrack().readyState === 'ended' || this._trackEnded;\r\n    }\r\n\r\n    /**\r\n     * Sets handlers to the MediaStreamTrack object that will detect camera\r\n     * issues.\r\n     */\r\n    _initNoDataFromSourceHandlers() {\r\n        if (!this._isNoDataFromSourceEventsEnabled()) {\r\n            return;\r\n        }\r\n\r\n        this._setHandler('track_mute', () => {\r\n            this._trackMutedTS = window.performance.now();\r\n            this._fireNoDataFromSourceEvent();\r\n        });\r\n\r\n        this._setHandler('track_unmute', () => {\r\n            this._fireNoDataFromSourceEvent();\r\n            Statistics.sendAnalyticsAndLog(\r\n                TRACK_UNMUTED,\r\n                {\r\n                    'media_type': this.getType(),\r\n                    'track_type': 'local',\r\n                    value: window.performance.now() - this._trackMutedTS\r\n                });\r\n        });\r\n\r\n        if (this.isVideoTrack() && this.videoType === VideoType.CAMERA) {\r\n            this._setHandler('track_ended', () => {\r\n                if (!this.isReceivingData()) {\r\n                    this._fireNoDataFromSourceEvent();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if no data from source events are enabled for this QHSenseLocalTrack and false otherwise.\r\n     *\r\n     * @returns {boolean} - True if no data from source events are enabled for this QHSenseLocalTrack and false otherwise.\r\n     */\r\n    _isNoDataFromSourceEventsEnabled() {\r\n        // Disable the events for screen sharing.\r\n        return !this.isVideoTrack() || this.videoType !== VideoType.DESKTOP;\r\n    }\r\n\r\n    /**\r\n     * Fires NO_DATA_FROM_SOURCE event and logs it to analytics and callstats.\r\n     */\r\n    _fireNoDataFromSourceEvent() {\r\n        const value = !this.isReceivingData();\r\n\r\n        this.emit(NO_DATA_FROM_SOURCE, value);\r\n\r\n        // FIXME: Should we report all of those events\r\n        Statistics.sendAnalytics(createNoDataFromSourceEvent(this.getType(), value));\r\n        Statistics.sendLog(JSON.stringify({\r\n            name: NO_DATA_FROM_SOURCE,\r\n            log: value\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Sets real device ID by comparing track information with device\r\n     * information. This is temporary solution until getConstraints() method\r\n     * will be implemented in browsers.\r\n     *\r\n     * @param {MediaDeviceInfo[]} devices - list of devices obtained from\r\n     * enumerateDevices() call\r\n     */\r\n    _setRealDeviceIdFromDeviceList(devices) {\r\n        const track = this.getTrack();\r\n        const kind = `${track.kind}input`;\r\n        let device = devices.find(d => d.kind === kind && d.label === track.label);\r\n\r\n        if (!device && this._realDeviceId === 'default') { // the default device has been changed.\r\n            // If the default device was 'A' and the default device is changed to 'B' the label for the track will\r\n            // remain 'Default - A' but the label for the device in the device list will be updated to 'A'. That's\r\n            // why in order to match it we need to remove the 'Default - ' part.\r\n            const label = (track.label || '').replace('Default - ', '');\r\n\r\n            device = devices.find(d => d.kind === kind && d.label === label);\r\n        }\r\n\r\n        if (device) {\r\n            this._realDeviceId = device.deviceId;\r\n        } else {\r\n            this._realDeviceId = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the stream property of QHSenseLocalTrack object and sets all stored\r\n     * handlers to it.\r\n     *\r\n     * @param {MediaStream} stream the new stream.\r\n     * @protected\r\n     */\r\n    _setStream(stream) {\r\n        super._setStream(stream);\r\n\r\n        if (stream) {\r\n            // Store the MSID for video mute/unmute purposes.\r\n            this.storedMSID = this.getMSID();\r\n            logger.debug(`Setting new MSID: ${this.storedMSID} on ${this}`);\r\n        } else {\r\n            logger.debug(`Setting 'null' stream on ${this}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the effect process and returns the modified stream.\r\n     *\r\n     * @private\r\n     * @param {*} effect - Represents effect instance\r\n     * @returns {void}\r\n     */\r\n    _startStreamEffect(effect) {\r\n        this._streamEffect = effect;\r\n        this._originalStream = this.stream;\r\n        this._setStream(this._streamEffect.startEffect(this._originalStream));\r\n    }\r\n\r\n    /**\r\n     * Stops the effect process and returns the original stream.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _stopStreamEffect() {\r\n        if (this._streamEffect) {\r\n            this._streamEffect.stopEffect();\r\n            this._setStream(this._originalStream);\r\n            this._originalStream = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the currently used effect (if there is one) and starts the passed effect (if there is one).\r\n     *\r\n     * @param {Object|undefined} effect - The new effect to be set.\r\n     */\r\n    _switchStreamEffect(effect) {\r\n        if (this._streamEffect) {\r\n            this._stopStreamEffect();\r\n            this._streamEffect = undefined;\r\n        }\r\n        if (effect) {\r\n            this._startStreamEffect(effect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the effect and switches between the modified stream and original one.\r\n     *\r\n     * @param {Object} effect - Represents the effect instance to be used.\r\n     * @returns {Promise}\r\n     */\r\n    setEffect(effect) {\r\n        if (typeof this._streamEffect === 'undefined' && typeof effect === 'undefined') {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (typeof effect !== 'undefined' && !effect.isEnabled(this)) {\r\n            return Promise.reject(new Error('Incompatible effect instance!'));\r\n        }\r\n\r\n        if (this._setEffectInProgress === true) {\r\n            return Promise.reject(new Error('setEffect already in progress!'));\r\n        }\r\n\r\n        if (this.isMuted()) {\r\n            this._streamEffect = effect;\r\n\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const conference = this.conference;\r\n\r\n        if (!conference) {\r\n            this._switchStreamEffect(effect);\r\n\r\n            return Promise.resolve();\r\n        }\r\n\r\n        this._setEffectInProgress = true;\r\n\r\n        // TODO: Create new JingleSessionPC method for replacing a stream in QHSenseLocalTrack without offer answer.\r\n        return conference.removeTrack(this)\r\n            .then(() => {\r\n                this._switchStreamEffect(effect);\r\n                if (this.isVideoTrack()) {\r\n                    this.containers.forEach(cont => RTCUtils.attachMediaStream(cont, this.stream));\r\n                }\r\n\r\n                return conference.addTrack(this);\r\n            })\r\n            .then(() => {\r\n                this._setEffectInProgress = false;\r\n            })\r\n            .catch(error => {\r\n                // Any error will be not recovarable and will trigger CONFERENCE_FAILED event. But let's try to cleanup\r\n                // everyhting related to the effect functionality.\r\n                this._setEffectInProgress = false;\r\n                this._switchStreamEffect();\r\n                logger.error('Failed to switch to the new stream!', error);\r\n                throw error;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Asynchronously mutes this track.\r\n     *\r\n     * @returns {Promise}\r\n     */\r\n    mute() {\r\n        return this._queueSetMuted(true);\r\n    }\r\n\r\n    /**\r\n     * Asynchronously unmutes this track.\r\n     *\r\n     * @returns {Promise}\r\n     */\r\n    unmute() {\r\n        return this._queueSetMuted(false);\r\n    }\r\n\r\n    /**\r\n     * Initializes a new Promise to execute {@link #_setMuted}. May be called\r\n     * multiple times in a row and the invocations of {@link #_setMuted} and,\r\n     * consequently, {@link #mute} and/or {@link #unmute} will be resolved in a\r\n     * serialized fashion.\r\n     *\r\n     * @param {boolean} muted - The value to invoke <tt>_setMuted</tt> with.\r\n     * @returns {Promise}\r\n     */\r\n    _queueSetMuted(muted) {\r\n        const setMuted = this._setMuted.bind(this, muted);\r\n\r\n        this._prevSetMuted = this._prevSetMuted.then(setMuted, setMuted);\r\n\r\n        return this._prevSetMuted;\r\n    }\r\n\r\n    /**\r\n     * Mutes / unmutes this track.\r\n     *\r\n     * @param {boolean} muted - If <tt>true</tt>, this track will be muted;\r\n     * otherwise, this track will be unmuted.\r\n     * @private\r\n     * @returns {Promise}\r\n     */\r\n    _setMuted(muted) {\r\n        if (this.isMuted() === muted) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this.disposed) {\r\n            return Promise.reject(new QHSenseTrackError(TRACK_IS_DISPOSED));\r\n        }\r\n\r\n        let promise = Promise.resolve();\r\n\r\n        // A function that will print info about muted status transition\r\n        const logMuteInfo = () => logger.info(`Mute ${this}: ${muted}`);\r\n\r\n        if (this.isAudioTrack()\r\n                || this.videoType === VideoType.DESKTOP\r\n                || !browser.doesVideoMuteByStreamRemove()) {\r\n            logMuteInfo();\r\n            if (this.track) {\r\n                this.track.enabled = !muted;\r\n            }\r\n        } else if (muted) {\r\n            promise = new Promise((resolve, reject) => {\r\n                logMuteInfo();\r\n                this._removeStreamFromConferenceAsMute(\r\n                    () => {\r\n                        if (this._streamEffect) {\r\n                            this._stopStreamEffect();\r\n                        }\r\n\r\n                        // FIXME: Maybe here we should set the SRC for the\r\n                        // containers to something\r\n                        // We don't want any events to be fired on this stream\r\n                        this._unregisterHandlers();\r\n                        this.stopStream();\r\n                        this._setStream(null);\r\n                        resolve();\r\n                    },\r\n                    reject);\r\n            });\r\n        } else {\r\n            logMuteInfo();\r\n\r\n            // This path is only for camera.\r\n            const streamOptions = {\r\n                cameraDeviceId: this.getDeviceId(),\r\n                devices: [ MediaType.VIDEO ],\r\n                effects: this._streamEffect ? [ this._streamEffect ] : [],\r\n                facingMode: this.getCameraFacingMode()\r\n            };\r\n\r\n            if (browser.usesNewGumFlow()) {\r\n                promise\r\n                    = RTCUtils.newObtainAudioAndVideoPermissions(Object.assign(\r\n                        {},\r\n                        streamOptions,\r\n                        { constraints: { video: this._constraints } }));\r\n            } else {\r\n                if (this.resolution) {\r\n                    streamOptions.resolution = this.resolution;\r\n                }\r\n\r\n                promise\r\n                    = RTCUtils.obtainAudioAndVideoPermissions(streamOptions);\r\n            }\r\n\r\n            promise.then(streamsInfo => {\r\n                const mediaType = this.getType();\r\n                const streamInfo\r\n                    = browser.usesNewGumFlow()\r\n                        ? streamsInfo.find(\r\n                            info => info.track.kind === mediaType)\r\n                        : streamsInfo.find(\r\n                            info => info.mediaType === mediaType);\r\n\r\n                if (streamInfo) {\r\n                    this._setStream(streamInfo.stream);\r\n                    this.track = streamInfo.track;\r\n\r\n                    // This is not good when video type changes after\r\n                    // unmute, but let's not crash here\r\n                    if (this.videoType !== streamInfo.videoType) {\r\n                        logger.warn(\r\n                            `${this}: video type has changed after unmute!`,\r\n                            this.videoType, streamInfo.videoType);\r\n                        this.videoType = streamInfo.videoType;\r\n                    }\r\n                } else {\r\n                    throw new QHSenseTrackError(TRACK_NO_STREAM_FOUND);\r\n                }\r\n\r\n                if (this._streamEffect) {\r\n                    this._startStreamEffect(this._streamEffect);\r\n                }\r\n\r\n                this.containers.map(\r\n                    cont => RTCUtils.attachMediaStream(cont, this.stream));\r\n\r\n                return this._addStreamToConferenceAsUnmute();\r\n            });\r\n        }\r\n\r\n        return promise\r\n            .then(() => this._sendMuteStatus(muted))\r\n            .then(() => this.emit(TRACK_MUTE_CHANGED, this));\r\n    }\r\n\r\n    /**\r\n     * Adds stream to conference and marks it as \"unmute\" operation.\r\n     *\r\n     * @private\r\n     * @returns {Promise}\r\n     */\r\n    _addStreamToConferenceAsUnmute() {\r\n        if (!this.conference) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // FIXME it would be good to not included conference as part of this\r\n        // process. Only TraceablePeerConnections to which the track is attached\r\n        // should care about this action. The TPCs to which the track is not\r\n        // attached can sync up when track is re-attached.\r\n        // A problem with that is that the \"modify sources\" queue is part of\r\n        // the JingleSessionPC and it would be excluded from the process. One\r\n        // solution would be to extract class between TPC and JingleSessionPC\r\n        // which would contain the queue and would notify the signaling layer\r\n        // when local SSRCs are changed. This would help to separate XMPP from\r\n        // the RTC module.\r\n        return new Promise((resolve, reject) => {\r\n            this.conference._addLocalTrackAsUnmute(this)\r\n                .then(resolve, error => reject(new Error(error)));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes stream from conference and marks it as \"mute\" operation.\r\n     *\r\n     * @param {Function} successCallback will be called on success\r\n     * @param {Function} errorCallback will be called on error\r\n     * @private\r\n     */\r\n    _removeStreamFromConferenceAsMute(successCallback, errorCallback) {\r\n        if (!this.conference) {\r\n            successCallback();\r\n\r\n            return;\r\n        }\r\n        this.conference._removeLocalTrackAsMute(this).then(\r\n            successCallback,\r\n            error => errorCallback(new Error(error)));\r\n    }\r\n\r\n    /**\r\n     * Sends mute status for a track to conference if any.\r\n     *\r\n     * @param {boolean} mute - If track is muted.\r\n     * @private\r\n     * @returns {Promise}\r\n     */\r\n    _sendMuteStatus(mute) {\r\n        if (!this.conference || !this.conference.room) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return new Promise(resolve => {\r\n            this.conference.room[\r\n                this.isAudioTrack()\r\n                    ? 'setAudioMute'\r\n                    : 'setVideoMute'](mute, resolve);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     *\r\n     * Stops sending the media track. And removes it from the HTML.\r\n     * NOTE: Works for local tracks only.\r\n     *\r\n     * @extends QHSenseTrack#dispose\r\n     * @returns {Promise}\r\n     */\r\n    dispose() {\r\n        this._switchStreamEffect();\r\n\r\n        let promise = Promise.resolve();\r\n\r\n        if (this.conference) {\r\n            promise = this.conference.removeTrack(this);\r\n        }\r\n\r\n        if (this.stream) {\r\n            this.stopStream();\r\n            this.detach();\r\n        }\r\n\r\n        RTCUtils.removeListener(RTCEvents.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange);\r\n\r\n        if (this._onAudioOutputDeviceChanged) {\r\n            RTCUtils.removeListener(RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED,\r\n                this._onAudioOutputDeviceChanged);\r\n        }\r\n\r\n        return promise.then(() => super.dispose());\r\n    }\r\n\r\n    /**\r\n     * Returns <tt>true</tt> - if the stream is muted and <tt>false</tt>\r\n     * otherwise.\r\n     *\r\n     * @returns {boolean} <tt>true</tt> - if the stream is muted and\r\n     * <tt>false</tt> otherwise.\r\n     */\r\n    isMuted() {\r\n        // this.stream will be null when we mute local video on Chrome\r\n        if (!this.stream) {\r\n            return true;\r\n        }\r\n        if (this.isVideoTrack() && !this.isActive()) {\r\n            return true;\r\n        }\r\n\r\n        return !this.track || !this.track.enabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the QHSenseConference object associated with the track. This is temp\r\n     * solution.\r\n     *\r\n     * @param conference the QHSenseConference object\r\n     */\r\n    _setConference(conference) {\r\n        this.conference = conference;\r\n\r\n        // We want to keep up with postponed events which should have been fired\r\n        // on \"attach\" call, but for local track we not always have the\r\n        // conference before attaching. However this may result in duplicated\r\n        // events if they have been triggered on \"attach\" already.\r\n        for (let i = 0; i < this.containers.length; i++) {\r\n            this._maybeFireTrackAttached(this.containers[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns <tt>true</tt>.\r\n     *\r\n     * @returns {boolean} <tt>true</tt>\r\n     */\r\n    isLocal() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns device id associated with track.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    getDeviceId() {\r\n        return this._realDeviceId || this.deviceId;\r\n    }\r\n\r\n    /**\r\n     * Returns the participant id which owns the track.\r\n     *\r\n     * @returns {string} the id of the participants. It corresponds to the\r\n     * Colibri endpoint id/MUC nickname in case of QHSense-meet.\r\n     */\r\n    getParticipantId() {\r\n        return this.conference && this.conference.myUserId();\r\n    }\r\n\r\n    /**\r\n     * Handles bytes sent statistics.\r\n     *\r\n     * @param {TraceablePeerConnection} tpc the source of the \"bytes sent\" stat\r\n     * @param {number} bytesSent the new value\r\n     * NOTE: used only for audio tracks to detect audio issues.\r\n     */\r\n    _onByteSentStatsReceived(tpc, bytesSent) {\r\n        if (bytesSent > 0) {\r\n            this._hasSentData = true;\r\n        }\r\n        const iceConnectionState = tpc.getConnectionState();\r\n\r\n        if (this._testDataSent && iceConnectionState === 'connected') {\r\n            setTimeout(() => {\r\n                if (!this._hasSentData) {\r\n                    logger.warn(`${this} 'bytes sent' <= 0: \\\r\n                        ${bytesSent}`);\r\n\r\n                    Statistics.analytics.sendEvent(NO_BYTES_SENT, { 'media_type': this.getType() });\r\n                }\r\n            }, 3000);\r\n            this._testDataSent = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns facing mode for video track from camera. For other cases (e.g.\r\n     * audio track or 'desktop' video track) returns undefined.\r\n     *\r\n     * @returns {CameraFacingMode|undefined}\r\n     */\r\n    getCameraFacingMode() {\r\n        if (this.isVideoTrack() && this.videoType === VideoType.CAMERA) {\r\n            // MediaStreamTrack#getSettings() is not implemented in many\r\n            // browsers, so we need feature checking here. Progress on the\r\n            // respective browser's implementation can be tracked at\r\n            // https://bugs.chromium.org/p/webrtc/issues/detail?id=2481 for\r\n            // Chromium and https://bugzilla.mozilla.org/show_bug.cgi?id=1213517\r\n            // for Firefox. Even if a browser implements getSettings() already,\r\n            // it might still not return anything for 'facingMode'.\r\n            let trackSettings;\r\n\r\n            try {\r\n                trackSettings = this.track.getSettings();\r\n            } catch (e) {\r\n                // XXX React-native-webrtc, for example, defines\r\n                // MediaStreamTrack#getSettings() but the implementation throws\r\n                // a \"Not implemented\" Error.\r\n            }\r\n            if (trackSettings && 'facingMode' in trackSettings) {\r\n                return trackSettings.facingMode;\r\n            }\r\n\r\n            if (typeof this._facingMode !== 'undefined') {\r\n                return this._facingMode;\r\n            }\r\n\r\n            // In most cases we are showing a webcam. So if we've gotten here,\r\n            // it should be relatively safe to assume that we are probably\r\n            // showing the user-facing camera.\r\n            return CameraFacingMode.USER;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Stops the associated MediaStream.\r\n     */\r\n    stopStream() {\r\n        /**\r\n         * Indicates that we are executing {@link #stopStream} i.e.\r\n         * {@link RTCUtils#stopMediaStream} for the <tt>MediaStream</tt>\r\n         * associated with this <tt>QHSenseTrack</tt> instance.\r\n         *\r\n         * @private\r\n         * @type {boolean}\r\n         */\r\n        this._stopStreamInProgress = true;\r\n\r\n        try {\r\n            RTCUtils.stopMediaStream(this.stream);\r\n        } finally {\r\n            this._stopStreamInProgress = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switches the camera facing mode if the WebRTC implementation supports the\r\n     * custom MediaStreamTrack._switchCamera method. Currently, the method in\r\n     * question is implemented in react-native-webrtc only. When such a WebRTC\r\n     * implementation is executing, the method is the preferred way to switch\r\n     * between the front/user-facing and the back/environment-facing cameras\r\n     * because it will likely be (as is the case of react-native-webrtc)\r\n     * noticeably faster that creating a new MediaStreamTrack via a new\r\n     * getUserMedia call with the switched facingMode constraint value.\r\n     * Moreover, the approach with a new getUserMedia call may not even work:\r\n     * WebRTC on Android and iOS is either very slow to open the camera a second\r\n     * time or plainly freezes attempting to do that.\r\n     */\r\n    _switchCamera() {\r\n        if (this.isVideoTrack()\r\n                && this.videoType === VideoType.CAMERA\r\n                && typeof this.track._switchCamera === 'function') {\r\n            this.track._switchCamera();\r\n\r\n            this._facingMode\r\n                = this._facingMode === CameraFacingMode.ENVIRONMENT\r\n                    ? CameraFacingMode.USER\r\n                    : CameraFacingMode.ENVIRONMENT;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether the attached MediaStream is receiving data from source or\r\n     * not. If the stream property is null(because of mute or another reason)\r\n     * this method will return false.\r\n     * NOTE: This method doesn't indicate problem with the streams directly.\r\n     * For example in case of video mute the method will return false or if the\r\n     * user has disposed the track.\r\n     *\r\n     * @returns {boolean} true if the stream is receiving data and false\r\n     * this otherwise.\r\n     */\r\n    isReceivingData() {\r\n        if (this.isVideoTrack()\r\n            && (this.isMuted() || this._stopStreamInProgress || this.videoType === VideoType.DESKTOP)) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.stream) {\r\n            return false;\r\n        }\r\n\r\n        // In older version of the spec there is no muted property and\r\n        // readyState can have value muted. In the latest versions\r\n        // readyState can have values \"live\" and \"ended\" and there is\r\n        // muted boolean property. If the stream is muted that means that\r\n        // we aren't receiving any data from the source. We want to notify\r\n        // the users for error if the stream is muted or ended on it's\r\n        // creation.\r\n\r\n        // For video blur enabled use the original video stream\r\n        const stream = this._effectEnabled ? this._originalStream : this.stream;\r\n\r\n        return stream.getTracks().some(track =>\r\n            (!('readyState' in track) || track.readyState === 'live')\r\n                && (!('muted' in track) || track.muted !== true));\r\n    }\r\n\r\n    /**\r\n     * Creates a text representation of this local track instance.\r\n     *\r\n     * @return {string}\r\n     */\r\n    toString() {\r\n        return `LocalTrack[${this.rtcId},${this.getType()}]`;\r\n    }\r\n}\r\n","import { $iq } from 'strophe.js';\r\n\r\nimport recordingXMLUtils from './recordingXMLUtils';\r\n\r\n/**\r\n * Represents a recording session.\r\n */\r\nexport default class JibriSession {\r\n    /**\r\n     * Initializes a new JibriSession instance.\r\n     *\r\n     * @constructor\r\n     */\r\n    constructor(options = {}) {\r\n        this._connection = options.connection;\r\n        this._mode = options.mode;\r\n\r\n        this._setSessionID(options.sessionID);\r\n        this.setStatus(options.status);\r\n    }\r\n\r\n    /**\r\n     * Returns the error related to the session instance, if any.\r\n     *\r\n     * @returns {string|undefined}\r\n     */\r\n    getError() {\r\n        return this._error;\r\n    }\r\n\r\n    /**\r\n     * Returns the session ID of the session instance.\r\n     *\r\n     * @returns {string|undefined}\r\n     */\r\n    getID() {\r\n        return this._sessionID;\r\n    }\r\n\r\n    /**\r\n     * Returns the streaming URL of the session.\r\n     *\r\n     * @returns {string|undefined}\r\n     */\r\n    getLiveStreamViewURL() {\r\n        return this._liveStreamViewURL;\r\n    }\r\n\r\n    /**\r\n     * Returns the current status of the session.\r\n     *\r\n     * @returns {string|undefined}\r\n     */\r\n    getStatus() {\r\n        return this._status;\r\n    }\r\n\r\n    /**\r\n     * Returns the current recording mode of the session, such as \"file\".\r\n     *\r\n     * @returns {string}\r\n     */\r\n    getMode() {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * Sets the last known error message related to the session.\r\n     *\r\n     * @param {string} error - The error string explaining why the session\r\n     * entered an error state.\r\n     * @returns {void}\r\n     */\r\n    setError(error) {\r\n        this._error = error;\r\n    }\r\n\r\n    /**\r\n     * Sets the last live stream URL for the session instance. Usually this is\r\n     * a YouTube URL and usually this is only set for \"stream\" sessions.\r\n     *\r\n     * @param {string} url - The live stream URL associated with the session.\r\n     * @returns {void}\r\n     */\r\n    setLiveStreamViewURL(url) {\r\n        this._liveStreamViewURL = url;\r\n    }\r\n\r\n    /**\r\n     * Sets the last known status for this recording session.\r\n     *\r\n     * @param {string} status - The new status to set.\r\n     * @returns {void}\r\n     */\r\n    setStatus(status) {\r\n        this._status = status;\r\n    }\r\n\r\n    /**\r\n     * Sends a message to start the actual recording.\r\n     *\r\n     * @param {Object} options - Additional arguments for starting the\r\n     * recording.\r\n     * @param {string} [options.appData] - Data specific to the app/service that\r\n     * the result file will be uploaded.\r\n     * @param {string} [options.broadcastId] - The broadcast ID of an\r\n     * associated YouTube stream, used for knowing the URL from which the stream\r\n     * can be viewed.\r\n     * @param {string} options.focusMucJid - The JID of the focus participant\r\n     * that controls recording.\r\n     * @param {streamId} options.streamId - Necessary for live streaming, this\r\n     * is the the stream key needed to start a live streaming session with the\r\n     * streaming service provider.\r\n     * @returns Promise\r\n     */\r\n    start({ appData, broadcastId, focusMucJid, streamId }) {\r\n        return new Promise((resolve, reject) => {\r\n            this._connection.sendIQ(\r\n                this._createIQ({\r\n                    action: 'start',\r\n                    appData,\r\n                    focusMucJid,\r\n                    broadcastId,\r\n                    streamId\r\n                }),\r\n                result => {\r\n                    // All users will eventually receive the 'pending' status\r\n                    // from the backend, but for the user initiating the session\r\n                    // it's better to give some instant feedback that recording\r\n                    // is starting so fire 'pending' here manually.\r\n                    this.setStatus('pending');\r\n                    this._setSessionID(\r\n                        recordingXMLUtils.getSessionIdFromIq(result));\r\n\r\n                    resolve();\r\n                },\r\n                error => {\r\n                    this._setErrorFromIq(error);\r\n\r\n                    reject(error);\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sends a message to actually stop the recording session.\r\n     *\r\n     * @param {Object} options - Additional arguments for stopping the\r\n     * recording.\r\n     * @param {Object} options.focusMucJid - The JID of the focus participant\r\n     * that controls recording.\r\n     * @returns Promise\r\n     */\r\n    stop({ focusMucJid }) {\r\n        return new Promise((resolve, reject) => {\r\n            this._connection.sendIQ(\r\n                this._createIQ({\r\n                    action: 'stop',\r\n                    focusMucJid\r\n                }),\r\n                resolve,\r\n                reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates the message to change the status of the recording session.\r\n     *\r\n     * @param {string} status - The new status to which the recording session\r\n     * should transition.\r\n     * @param {string} [options.appData] - Data specific to the app/service that\r\n     * the result file will be uploaded.\r\n     * @param {string} [options.broadcastId] - The broadcast ID of an\r\n     * associated YouTube stream, used for knowing the URL from which the stream\r\n     * can be viewed.\r\n     * @param {string} options.focusMucJid - The JID of the focus participant\r\n     * that controls recording.\r\n     * @param {streamId} options.streamId - Necessary for live streaming, this\r\n     * is the the stream key needed to start a live streaming session with the\r\n     * streaming service provider.\r\n     * @returns Object - The XMPP IQ message.\r\n     */\r\n    _createIQ({ action, appData, broadcastId, focusMucJid, streamId }) {\r\n        return $iq({\r\n            to: focusMucJid,\r\n            type: 'set'\r\n        })\r\n        .c('jibri', {\r\n            'xmlns': 'http://jitsi.org/protocol/jibri',\r\n            'action': action,\r\n            'app_data': appData,\r\n            'recording_mode': this._mode,\r\n            'streamid': streamId,\r\n            'you_tube_broadcast_id': broadcastId\r\n        })\r\n        .up();\r\n    }\r\n\r\n    /**\r\n     * Handles the error from an iq and stores the error.\r\n     *\r\n     * @param {Node} errorIq - The error response from an Iq.\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _setErrorFromIq(errorIq) {\r\n        const error = errorIq.getElementsByTagName('error')[0];\r\n\r\n        this.setError(error.children[0].tagName);\r\n    }\r\n\r\n    /**\r\n     * Sets the known session ID for this recording session.\r\n     *\r\n     * @param {string} sessionID\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _setSessionID(sessionID) {\r\n        this._sessionID = sessionID;\r\n    }\r\n}\r\n","import EventEmitter from 'events';\r\n\r\nimport * as MediaType from './service/RTC/MediaType';\r\nimport browser from './modules/browser';\r\nimport RTC from './modules/RTC/RTC';\r\nimport RTCEvents from './service/RTC/RTCEvents';\r\nimport Statistics from './modules/statistics/statistics';\r\n\r\nimport * as QHSenseMediaDevicesEvents from './QHSenseMediaDevicesEvents';\r\n\r\nconst AUDIO_PERMISSION_NAME = 'microphone';\r\nconst PERMISSION_GRANTED_STATUS = 'granted';\r\nconst VIDEO_PERMISSION_NAME = 'camera';\r\n\r\n/**\r\n * Media devices utilities for QHSense.\r\n */\r\nclass QHSenseMediaDevices {\r\n    /**\r\n     * Initializes a {@code QHSenseMediaDevices} object. There will be a single\r\n     * instance of this class.\r\n     */\r\n    constructor() {\r\n        this._eventEmitter = new EventEmitter();\r\n        this._grantedPermissions = {};\r\n\r\n        RTC.addListener(\r\n            RTCEvents.DEVICE_LIST_CHANGED,\r\n            devices =>\r\n                this._eventEmitter.emit(\r\n                    QHSenseMediaDevicesEvents.DEVICE_LIST_CHANGED,\r\n                    devices));\r\n        RTC.addListener(\r\n            RTCEvents.DEVICE_LIST_AVAILABLE,\r\n            devices =>\r\n                this._logOutputDevice(\r\n                    this.getAudioOutputDevice(),\r\n                    devices));\r\n        RTC.addListener(\r\n            RTCEvents.GRANTED_PERMISSIONS,\r\n            grantedPermissions =>\r\n                this._handleGrantedPermissions(grantedPermissions));\r\n\r\n        // Test if the W3C Permissions API is implemented and the 'camera' and\r\n        // 'microphone' permissions are implemented. (Testing for at least one\r\n        // of them seems sufficient).\r\n        this._permissionsApiSupported = new Promise(resolve => {\r\n            if (!navigator.permissions) {\r\n                resolve(false);\r\n\r\n                return;\r\n            }\r\n\r\n            navigator.permissions.query({ name: VIDEO_PERMISSION_NAME })\r\n                .then(() => resolve(true), () => resolve(false));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updated the local granted permissions cache. A permissions might be\r\n     * granted, denied, or undefined. This is represented by having its media\r\n     * type key set to {@code true} or {@code false} respectively.\r\n     *\r\n     * @param {Object} grantedPermissions - Array with the permissions\r\n     * which were granted.\r\n     */\r\n    _handleGrantedPermissions(grantedPermissions) {\r\n        this._grantedPermissions = {\r\n            ...this._grantedPermissions,\r\n            ...grantedPermissions\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gathers data and sends it to statistics.\r\n     * @param deviceID the device id to log\r\n     * @param devices list of devices\r\n     */\r\n    _logOutputDevice(deviceID, devices) {\r\n        const device\r\n            = devices.find(\r\n                d => d.kind === 'audiooutput' && d.deviceId === deviceID);\r\n\r\n        if (device) {\r\n            Statistics.sendActiveDeviceListEvent(\r\n                RTC.getEventDataForActiveDevice(device));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executes callback with list of media devices connected.\r\n     * @param {function} callback\r\n     */\r\n    enumerateDevices(callback) {\r\n        RTC.enumerateDevices(callback);\r\n    }\r\n\r\n    /**\r\n     * Checks if its possible to enumerate available cameras/micropones.\r\n     * @returns {Promise<boolean>} a Promise which will be resolved only once\r\n     * the WebRTC stack is ready, either with true if the device listing is\r\n     * available available or with false otherwise.\r\n     */\r\n    isDeviceListAvailable() {\r\n        return RTC.isDeviceListAvailable();\r\n    }\r\n\r\n    /**\r\n     * Returns true if changing the input (camera / microphone) or output\r\n     * (audio) device is supported and false if not.\r\n     * @param {string} [deviceType] - type of device to change. Default is\r\n     *      undefined or 'input', 'output' - for audio output device change.\r\n     * @returns {boolean} true if available, false otherwise.\r\n     */\r\n    isDeviceChangeAvailable(deviceType) {\r\n        return RTC.isDeviceChangeAvailable(deviceType);\r\n    }\r\n\r\n    /**\r\n     * Checks if the permission for the given device was granted.\r\n     *\r\n     * @param {'audio'|'video'} [type] - type of devices to check,\r\n     *      undefined stands for both 'audio' and 'video' together\r\n     * @returns {Promise<boolean>}\r\n     */\r\n    isDevicePermissionGranted(type) {\r\n        return new Promise(resolve => {\r\n            // Shortcut: first check if we already know the permission was\r\n            // granted.\r\n            if (type in this._grantedPermissions) {\r\n                resolve(this._grantedPermissions[type]);\r\n\r\n                return;\r\n            }\r\n\r\n            // Check using the Permissions API.\r\n            this._permissionsApiSupported.then(supported => {\r\n                if (!supported) {\r\n                    resolve(false);\r\n\r\n                    return;\r\n                }\r\n\r\n                const promises = [];\r\n\r\n                switch (type) {\r\n                case MediaType.VIDEO:\r\n                    promises.push(\r\n                        navigator.permissions.query({\r\n                            name: VIDEO_PERMISSION_NAME\r\n                        }));\r\n                    break;\r\n                case MediaType.AUDIO:\r\n                    promises.push(\r\n                        navigator.permissions.query({\r\n                            name: AUDIO_PERMISSION_NAME\r\n                        }));\r\n                    break;\r\n                default:\r\n                    promises.push(\r\n                        navigator.permissions.query({\r\n                            name: VIDEO_PERMISSION_NAME\r\n                        }));\r\n                    promises.push(\r\n                        navigator.permissions.query({\r\n                            name: AUDIO_PERMISSION_NAME\r\n                        }));\r\n                }\r\n\r\n                Promise.all(promises).then(\r\n                    results => resolve(results.every(permissionStatus => {\r\n                        // The status attribute is deprecated, and state\r\n                        // should be used instead, but check both for now\r\n                        // for backwards compatibility.\r\n                        const grantStatus = permissionStatus.state\r\n                            || permissionStatus.status;\r\n\r\n                        return grantStatus === PERMISSION_GRANTED_STATUS;\r\n                    })),\r\n                    () => resolve(false)\r\n                );\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns true if it is possible to be simultaneously capturing audio\r\n     * from more than one device.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    isMultipleAudioInputSupported() {\r\n        return !browser.isFirefox();\r\n    }\r\n\r\n    /**\r\n     * Returns currently used audio output device id, 'default' stands\r\n     * for default device\r\n     * @returns {string}\r\n     */\r\n    getAudioOutputDevice() {\r\n        return RTC.getAudioOutputDevice();\r\n    }\r\n\r\n    /**\r\n     * Sets current audio output device.\r\n     * @param {string} deviceId - id of 'audiooutput' device from\r\n     *      navigator.mediaDevices.enumerateDevices(), 'default' is for\r\n     *      default device\r\n     * @returns {Promise} - resolves when audio output is changed, is rejected\r\n     *      otherwise\r\n     */\r\n    setAudioOutputDevice(deviceId) {\r\n        const availableDevices = RTC.getCurrentlyAvailableMediaDevices();\r\n\r\n        if (availableDevices && availableDevices.length > 0) {\r\n            // if we have devices info report device to stats\r\n            // normally this will not happen on startup as this method is called\r\n            // too early. This will happen only on user selection of new device\r\n            this._logOutputDevice(\r\n                deviceId, RTC.getCurrentlyAvailableMediaDevices());\r\n        }\r\n\r\n        return RTC.setAudioOutputDevice(deviceId);\r\n    }\r\n\r\n    /**\r\n     * Adds an event handler.\r\n     * @param {string} event - event name\r\n     * @param {function} handler - event handler\r\n     */\r\n    addEventListener(event, handler) {\r\n        this._eventEmitter.addListener(event, handler);\r\n    }\r\n\r\n    /**\r\n     * Removes event handler.\r\n     * @param {string} event - event name\r\n     * @param {function} handler - event handler\r\n     */\r\n    removeEventListener(event, handler) {\r\n        this._eventEmitter.removeListener(event, handler);\r\n    }\r\n\r\n    /**\r\n     * Emits an event.\r\n     * @param {string} event - event name\r\n     */\r\n    emitEvent(event, ...args) {\r\n        this._eventEmitter.emit(event, ...args);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the current browser can support capturing video,\r\n     * be it camera or desktop, and displaying received video.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    supportsVideo() {\r\n        // Defer to the browser capabilities to allow exposure of the api to the\r\n        // consumer but prevent other files from having to import\r\n        // QHSenseMediaDevices.\r\n        return browser.supportsVideo();\r\n    }\r\n}\r\n\r\nexport default new QHSenseMediaDevices();\r\n","/* Copyright @ 2015 Atlassian Pty Ltd\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * Ordered log levels.\r\n */\r\nvar levels = {\r\n    \"trace\": 0,\r\n    \"debug\": 1,\r\n    \"info\": 2,\r\n    \"log\": 3,\r\n    \"warn\": 4,\r\n    \"error\": 5\r\n};\r\n\r\n/**\r\n * The default transport - console\r\n * @type LoggerTransport\r\n */\r\nLogger.consoleTransport = console;\r\n\r\n/**\r\n * The array which stores currently registered global transports.\r\n * @type {[LoggerTransport]}\r\n */\r\nvar globalTransports = [ Logger.consoleTransport ];\r\n\r\n/**\r\n * Adds given {@link LoggerTransport} instance to the list of global\r\n * transports which means that it'll be used by all {@link Logger}s\r\n * @param {LoggerTransport} transport\r\n */\r\nLogger.addGlobalTransport = function(transport) {\r\n    if (globalTransports.indexOf(transport) === -1) {\r\n        globalTransports.push(transport);\r\n    }\r\n};\r\n\r\n/**\r\n * Removes given {@link LoggerTransport} instance from the list of global\r\n * transports\r\n * @param {LoggerTransport} transport\r\n */\r\nLogger.removeGlobalTransport = function(transport) {\r\n    var transportIdx = globalTransports.indexOf(transport);\r\n    if (transportIdx !== -1) {\r\n        globalTransports.splice(transportIdx, 1);\r\n    }\r\n};\r\n\r\n/**\r\n * Parses Error's object stack trace and extracts information about the last\r\n * caller before the log method was called.\r\n * @returns JS object with info about the caller - method name, file location,\r\n * line and column.\r\n */\r\nfunction getCallerInfo() {\r\n    var callerInfo = {\r\n        methodName: \"\",\r\n        fileLocation: \"\",\r\n        line: null,\r\n        column: null\r\n    };\r\n    //gets the part of the stack without the logger wrappers\r\n    var error = new Error();\r\n    var stack = error.stack? error.stack.split(\"\\n\") : [];\r\n    if(!stack || stack.length < 1) {\r\n        return callerInfo;\r\n    }\r\n    var m = null;\r\n    if(stack[3]) {\r\n        m = stack[3].match(/\\s*at\\s*(.+?)\\s*\\((\\S*)\\s*:(\\d*)\\s*:(\\d*)\\)/);\r\n    }\r\n    if(!m || m.length <= 4) {\r\n        //Firefox && Safari\r\n        if(stack[2].indexOf(\"log@\") === 0){\r\n            //Safari\r\n            callerInfo.methodName = stack[3].substr(0, stack[3].indexOf(\"@\"));\r\n        } else {\r\n            //Firefox\r\n            callerInfo.methodName = stack[2].substr(0, stack[2].indexOf(\"@\"));\r\n        }\r\n        return callerInfo;\r\n    }\r\n\r\n    callerInfo.methodName = m[1];\r\n    callerInfo.fileLocation = m[2];\r\n    callerInfo.line = m[3];\r\n    callerInfo.column = m[4];\r\n    return callerInfo;\r\n}\r\n\r\n/**\r\n * Logs messages using the transports and level from the logger.\r\n * @param logger a logger instance.\r\n * @param level the log level of the message. See the levels variable.\r\n * @param arguments array with arguments that will be logged.\r\n */\r\nfunction log() {\r\n    var logger = arguments[0], level = arguments[1],\r\n        args = Array.prototype.slice.call(arguments, 2);\r\n    if(levels[level] < logger.level) {\r\n        return;\r\n    }\r\n\r\n    var callerInfo = getCallerInfo();\r\n    var transports = globalTransports.concat(logger.transports);\r\n    for(var i = 0; i < transports.length; i++) {\r\n        var t = transports[i];\r\n        var l = t[level];\r\n        if(l && typeof(l) === \"function\") {\r\n            l.bind(t, logger.id? \"[\" + logger.id + \"]\" : \"\", \"<\" + callerInfo.methodName + \">: \")\r\n                .apply(t, args);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * Constructs new logger object.\r\n * @param level the logging level for the new logger\r\n * @param id optional identifier for the logger instance.\r\n * @param {LoggerTransport} transports optional list of handlers(objects) for\r\n * the logs. The handlers must support - log, warn, error, debug, info, trace.\r\n * @param format optional (NOT implemented) string.\r\n */\r\nfunction Logger(level, id, transports, format) {\r\n    this.id = id;\r\n    this.format = format;\r\n    this.transports = transports;\r\n    if(!this.transports) {\r\n        this.transports = [];\r\n    }\r\n    this.level = levels[level];\r\n    var methods = Object.keys(levels);\r\n    for(var i = 0; i < methods.length; i++){\r\n        this[methods[i]] =\r\n            log.bind(null, this, methods[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Sets the log level for the logger.\r\n * @param level the new log level.\r\n */\r\nLogger.prototype.setLevel = function (level) {\r\n    this.level = levels[level];\r\n};\r\nmodule.exports = Logger;\r\n\r\n/**\r\n * Enum for the supported log levels.\r\n */\r\nLogger.levels = {\r\n    TRACE: \"trace\",\r\n    DEBUG: \"debug\",\r\n    INFO: \"info\",\r\n    LOG: \"log\",\r\n    WARN: \"warn\",\r\n    ERROR: \"error\"\r\n};\r\n","/* eslint-env node */\n'use strict';\n\n// SDP helpers.\nvar SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(function(line) {\n    return line.trim();\n  });\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  var parts = blob.split('\\nm=');\n  return parts.map(function(part, index) {\n    return (index > 0 ? 'm=' + part : part).trim() + '\\r\\n';\n  });\n};\n\n// returns the session description.\nSDPUtils.getDescription = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(function(line) {\n    return line.indexOf(prefix) === 0;\n  });\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\nSDPUtils.parseCandidate = function(line) {\n  var parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  var candidate = {\n    foundation: parts[0],\n    component: parseInt(parts[1], 10),\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4], // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n\n  for (var i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compability.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag\n        candidate[parts[i]] = parts[i + 1];\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\nSDPUtils.writeCandidate = function(candidate) {\n  var sdp = [];\n  sdp.push(candidate.foundation);\n  sdp.push(candidate.component);\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n\n  var type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n};\n\n// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  var parts = line.substr(9).split(' ');\n  var parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generate an a=rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  var channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses an a=extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n};\n\n// Generates a=extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n        ? '/' + headerExtension.direction\n        : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses an ftmp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  var parsed = {};\n  var kv;\n  var parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (var j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  var line = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    var params = [];\n    Object.keys(codec.parameters).forEach(function(param) {\n      if (codec.parameters[param]) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  var parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  var lines = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(function(fb) {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses an RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  var sp = line.indexOf(' ');\n  var parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  var colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\nSDPUtils.parseSsrcGroup = function(line) {\n  var parts = line.substr(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(function(ssrc) {\n      return parseInt(ssrc, 10);\n    })\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n};\n\nSDPUtils.parseFingerprint = function(line) {\n  var parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1]\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role.\n  // Note2: 'algorithm' is not case sensitive except in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  var sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(function(fp) {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n\n// Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\nSDPUtils.parseCryptoLine = function(line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3),\n  };\n};\n\nSDPUtils.writeCryptoLine = function(parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' +\n    parameters.cryptoSuite + ' ' +\n    (typeof parameters.keyParams === 'object'\n      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)\n      : parameters.keyParams) +\n    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +\n    '\\r\\n';\n};\n\n// Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\nSDPUtils.parseCryptoKeyParams = function(keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n  var parts = keyParams.substr(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,\n  };\n};\n\nSDPUtils.writeCryptoKeyParams = function(keyParams) {\n  return keyParams.keyMethod + ':'\n    + keyParams.keySalt +\n    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +\n    (keyParams.mkiValue && keyParams.mkiLength\n      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength\n      : '');\n};\n\n// Extracts all SDES paramters.\nSDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n};\n\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  // Search in session part, too.\n  lines = lines.concat(SDPUtils.splitLines(sessionpart));\n  var iceParameters = {\n    usernameFragment: lines.filter(function(line) {\n      return line.indexOf('a=ice-ufrag:') === 0;\n    })[0].substr(12),\n    password: lines.filter(function(line) {\n      return line.indexOf('a=ice-pwd:') === 0;\n    })[0].substr(10)\n  };\n  return iceParameters;\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  var description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    var pt = mline[i];\n    var rtpmapline = SDPUtils.matchPrefix(\n      mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      var codec = SDPUtils.parseRtpMap(rtpmapline);\n      var fmtps = SDPUtils.matchPrefix(\n        mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  var sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(function(codec) {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(function(codec) {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  var maxptime = 0;\n  caps.codecs.forEach(function(codec) {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  sdp += 'a=rtcp-mux\\r\\n';\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(function(extension) {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  var encodingParameters = [];\n  var description = SDPUtils.parseRtpParameters(mediaSection);\n  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(function(line) {\n      return SDPUtils.parseSsrcMedia(line);\n    })\n    .filter(function(parts) {\n      return parts.attribute === 'cname';\n    });\n  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  var secondarySsrc;\n\n  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n    .map(function(line) {\n      var parts = line.substr(17).split(' ');\n      return parts.map(function(part) {\n        return parseInt(part, 10);\n      });\n    });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(function(codec) {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      var encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10)\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(function(params) {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  var rtcpParameters = {};\n\n  // Gets the first SSRC. Note tha with RTX there might be multiple\n  // SSRCs.\n  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(function(line) {\n      return SDPUtils.parseSsrcMedia(line);\n    })\n    .filter(function(obj) {\n      return obj.attribute === 'cname';\n    })[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrbute.\n  // Note that Edge does not support unmuxed RTCP.\n  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  var parts;\n  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(function(line) {\n      return SDPUtils.parseSsrcMedia(line);\n    })\n    .filter(function(msidParts) {\n      return msidParts.attribute === 'msid';\n    });\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\nSDPUtils.parseSctpDescription = function(mediaSection) {\n  var mline = SDPUtils.parseMLine(mediaSection);\n  var maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  var maxMessageSize;\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);\n  }\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n  var sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substr(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize: maxMessageSize\n    };\n  }\n  var sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n  if (sctpMapLines.length > 0) {\n    var parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0]\n      .substr(10)\n      .split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize: maxMessageSize\n    };\n  }\n};\n\n// SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\nSDPUtils.writeSctpDescription = function(media, sctp) {\n  var output = [];\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctp-port:' + sctp.port + '\\r\\n'\n    ];\n  } else {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'\n    ];\n  }\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n  return output.join('');\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boilder plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n  var sessionId;\n  var version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  var user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=' + user + ' ' + sessionId + ' ' + version +\n        ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\nSDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n    transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n    transceiver.dtlsTransport.getLocalParameters(),\n    type === 'offer' ? 'actpass' : 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.direction) {\n    sdp += 'a=' + transceiver.direction + '\\r\\n';\n  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    // spec.\n    var msid = 'msid:' + stream.id + ' ' +\n        transceiver.rtpSender.track.id + '\\r\\n';\n    sdp += 'a=' + msid;\n\n    // for Chrome.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  var lines = SDPUtils.splitLines(mediaSection);\n  for (var i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  var parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5]\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function(blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  var lines = SDPUtils.splitLines(blob);\n  for (var i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n  return true;\n};\n\n// Expose public methods.\nif (typeof module === 'object') {\n  module.exports = SDPUtils;\n}\n","var grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{ //o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  //k: [{}], // outdated thing ignored\n  t: [{ //t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{ //c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{ //b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w\\/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [\n    { //a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-\\.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding) ?\n          'rtpmap:%d %s/%s/%s':\n          o.rate ?\n          'rtpmap:%d %s/%s':\n          'rtpmap:%d %s';\n      }\n    },\n    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      //a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    },\n    { //a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    },\n    { //a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null) ?\n          'rtcp:%d %s IP%d %s':\n          'rtcp:%d';\n      }\n    },\n    { //a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%d trr-int %d'\n    },\n    { //a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null) ?\n          'rtcp-fb:%s %s %s':\n          'rtcp-fb:%s %s';\n      }\n    },\n    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      //a=extmap:1/recvonly URI-gps-string\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'uri', 'config'],\n      format: function (o) {\n        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + ' %s' + (o.config ? ' %s' : '');\n      }\n    },\n    { //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null) ?\n          'crypto:%d %s %s %s':\n          'crypto:%d %s %s';\n      }\n    },\n    { //a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    },\n    { //a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    },\n    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: 'msid:%s'\n    },\n    { //a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*)/,\n      format: 'ptime:%d'\n    },\n    { //a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*)/,\n      format: 'maxptime:%d'\n    },\n    { //a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    { //a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    { //a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    },\n    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    },\n    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    },\n    { //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n\n        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\n\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n\n        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\n        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\n        return str;\n      }\n    },\n    { //a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    },\n    { //a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    },\n    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    },\n    { //a=ssrc-group:FEC 1 2\n      //a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    },\n    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    },\n    { //a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    },\n    { //a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    { //a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    { //a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_\\/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return (o.maxMessageSize != null) ?\n          'sctpmap:%s %s %s' :\n          'sctpmap:%s %s';\n      }\n    },\n    { //a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    },\n    { //a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    },\n    { //a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      //a=imageattr:* send [x=800,y=640] recv *\n      //a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n        //a=imageattr:97\n        '^imageattr:(\\\\d+|\\\\*)' +\n        //send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n        '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n        //recv [x=330,y=250]\n        '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\n      ),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    { //a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      //a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n        //a=simulcast:\n        '^simulcast:' +\n        //send 1,2,3;~4,~5\n        '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n        //space + recv 6;~7,~8\n        '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n        //end\n        '$'\n      ),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    { //Old simulcast draft 03 (implemented by Firefox)\n      //  https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      //a=simulcast: recv pt=97;98 send pt=97\n      //a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    },\n    {\n      //a=framerate:25\n      //a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    },\n    { // any a= that we don't understand is kepts verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n","/* global MediaRecorder, MediaStream */\r\n\r\nconst RecordingResult = require('./recordingResult');\r\n\r\n/**\r\n * Possible audio formats MIME types\r\n */\r\nconst AUDIO_WEBM = 'audio/webm'; // Supported in chrome\r\nconst AUDIO_OGG = 'audio/ogg'; // Supported in firefox\r\n\r\n/**\r\n * A TrackRecorder object holds all the information needed for recording a\r\n * single QHSenseTrack (either remote or local)\r\n * @param track The QHSenseTrack the object is going to hold\r\n */\r\nconst TrackRecorder = function(track) {\r\n    // The QHSenseTrack holding the stream\r\n    this.track = track;\r\n\r\n    // The MediaRecorder recording the stream\r\n    this.recorder = null;\r\n\r\n    // The array of data chunks recorded from the stream\r\n    // acts as a buffer until the data is stored on disk\r\n    this.data = null;\r\n\r\n    // the name of the person of the QHSenseTrack. This can be undefined and/or\r\n    // not unique\r\n    this.name = null;\r\n\r\n    // the time of the start of the recording\r\n    this.startTime = null;\r\n};\r\n\r\n/**\r\n * Starts the recording of a QHSenseTrack in a TrackRecorder object.\r\n * This will also define the timestamp and try to update the name\r\n * @param trackRecorder the TrackRecorder to start\r\n */\r\nfunction startRecorder(trackRecorder) {\r\n    if (trackRecorder.recorder === undefined) {\r\n        throw new Error('Passed an object to startRecorder which is not a '\r\n            + 'TrackRecorder object');\r\n    }\r\n    trackRecorder.recorder.start();\r\n    trackRecorder.startTime = new Date();\r\n}\r\n\r\n/**\r\n * Stops the recording of a QHSenseTrack in a TrackRecorder object.\r\n * This will also try to update the name\r\n * @param trackRecorder the TrackRecorder to stop\r\n */\r\nfunction stopRecorder(trackRecorder) {\r\n    if (trackRecorder.recorder === undefined) {\r\n        throw new Error('Passed an object to stopRecorder which is not a '\r\n            + 'TrackRecorder object');\r\n    }\r\n    trackRecorder.recorder.stop();\r\n}\r\n\r\n/**\r\n * Determines which kind of audio recording the browser supports\r\n * chrome supports \"audio/webm\" and firefox supports \"audio/ogg\"\r\n */\r\nfunction determineCorrectFileType() {\r\n    if (MediaRecorder.isTypeSupported(AUDIO_WEBM)) {\r\n        return AUDIO_WEBM;\r\n    } else if (MediaRecorder.isTypeSupported(AUDIO_OGG)) {\r\n        return AUDIO_OGG;\r\n    }\r\n    throw new Error(\r\n        'unable to create a MediaRecorder with the right mimetype!');\r\n}\r\n\r\n/**\r\n * main exported object of the file, holding all\r\n * relevant functions and variables for the outside world\r\n * @param qhsenseConference the qhsenseConference which this object\r\n * is going to record\r\n */\r\nfunction AudioRecorder(qhsenseConference) {\r\n    // array of TrackRecorders, where each trackRecorder\r\n    // holds the QHSenseTrack, MediaRecorder and recorder data\r\n    this.recorders = [];\r\n\r\n    // get which file type is supported by the current browser\r\n    this.fileType = determineCorrectFileType();\r\n\r\n    // boolean flag for active recording\r\n    this.isRecording = false;\r\n\r\n    // the qhsenseconference the object is recording\r\n    this.qhsenseConference = qhsenseConference;\r\n}\r\n\r\n/**\r\n * Add the the exported module so that it can be accessed by other files\r\n */\r\nAudioRecorder.determineCorrectFileType = determineCorrectFileType;\r\n\r\n/**\r\n * Adds a new TrackRecorder object to the array.\r\n *\r\n * @param track the track potentially holding an audio stream\r\n */\r\nAudioRecorder.prototype.addTrack = function(track) {\r\n    if (track.isAudioTrack()) {\r\n        // create the track recorder\r\n        const trackRecorder = this.instantiateTrackRecorder(track);\r\n\r\n        // push it to the local array of all recorders\r\n\r\n        this.recorders.push(trackRecorder);\r\n\r\n        // update the name of the trackRecorders\r\n        this.updateNames();\r\n\r\n        // If we're already recording, immediately start recording this new\r\n        // track.\r\n        if (this.isRecording) {\r\n            startRecorder(trackRecorder);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Creates a TrackRecorder object. Also creates the MediaRecorder and\r\n * data array for the trackRecorder.\r\n * @param track the QHSenseTrack holding the audio MediaStream(s)\r\n */\r\nAudioRecorder.prototype.instantiateTrackRecorder = function(track) {\r\n    const trackRecorder = new TrackRecorder(track);\r\n\r\n    // Create a new stream which only holds the audio track\r\n    const originalStream = trackRecorder.track.getOriginalStream();\r\n    const stream = createEmptyStream();\r\n\r\n    originalStream.getAudioTracks().forEach(t => stream.addTrack(t));\r\n\r\n    // Create the MediaRecorder\r\n    trackRecorder.recorder = new MediaRecorder(stream,\r\n        { mimeType: this.fileType });\r\n\r\n    // array for holding the recorder data. Resets it when\r\n    // audio already has been recorder once\r\n    trackRecorder.data = [];\r\n\r\n    // function handling a dataEvent, e.g the stream gets new data\r\n    trackRecorder.recorder.ondataavailable = function(dataEvent) {\r\n        if (dataEvent.data.size > 0) {\r\n            trackRecorder.data.push(dataEvent.data);\r\n        }\r\n    };\r\n\r\n    return trackRecorder;\r\n};\r\n\r\n/**\r\n * Notifies the module that a specific track has stopped, e.g participant left\r\n * the conference.\r\n * if the recording has not started yet, the TrackRecorder will be removed from\r\n * the array. If the recording has started, the recorder will stop recording\r\n * but not removed from the array so that the recorded stream can still be\r\n * accessed\r\n *\r\n * @param {QHSenseTrack} track the QHSenseTrack to remove from the recording session\r\n */\r\nAudioRecorder.prototype.removeTrack = function(track) {\r\n    if (track.isVideoTrack()) {\r\n        return;\r\n    }\r\n\r\n    const array = this.recorders;\r\n    let i;\r\n\r\n    for (i = 0; i < array.length; i++) {\r\n        if (array[i].track.getParticipantId() === track.getParticipantId()) {\r\n            const recorderToRemove = array[i];\r\n\r\n            if (this.isRecording) {\r\n                stopRecorder(recorderToRemove);\r\n            } else {\r\n                // remove the TrackRecorder from the array\r\n                array.splice(i, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    // make sure the names are up to date\r\n    this.updateNames();\r\n};\r\n\r\n/**\r\n * Tries to update the name value of all TrackRecorder in the array.\r\n * If it hasn't changed,it will keep the exiting name. If it changes to a\r\n * undefined value, the old value will also be kept.\r\n */\r\nAudioRecorder.prototype.updateNames = function() {\r\n    const conference = this.qhsenseConference;\r\n\r\n    this.recorders.forEach(trackRecorder => {\r\n        if (trackRecorder.track.isLocal()) {\r\n            trackRecorder.name = 'the transcriber';\r\n        } else {\r\n            const id = trackRecorder.track.getParticipantId();\r\n            const participant = conference.getParticipantById(id);\r\n            const newName = participant.getDisplayName();\r\n\r\n            if (newName !== 'undefined') {\r\n                trackRecorder.name = newName;\r\n            }\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * Starts the audio recording of every local and remote track\r\n */\r\nAudioRecorder.prototype.start = function() {\r\n    if (this.isRecording) {\r\n        throw new Error('audiorecorder is already recording');\r\n    }\r\n\r\n    // set boolean isRecording flag to true so if new participants join the\r\n    // conference, that track can instantly start recording as well\r\n    this.isRecording = true;\r\n\r\n    // start all the mediaRecorders\r\n    this.recorders.forEach(trackRecorder => startRecorder(trackRecorder));\r\n\r\n    // log that recording has started\r\n    console.log(\r\n        `Started the recording of the audio. There are currently ${\r\n            this.recorders.length} recorders active.`);\r\n};\r\n\r\n/**\r\n * Stops the audio recording of every local and remote track\r\n */\r\nAudioRecorder.prototype.stop = function() {\r\n    // set the boolean flag to false\r\n    this.isRecording = false;\r\n\r\n    // stop all recorders\r\n    this.recorders.forEach(trackRecorder => stopRecorder(trackRecorder));\r\n    console.log('stopped recording');\r\n};\r\n\r\n/**\r\n * link hacking to download all recorded audio streams\r\n */\r\nAudioRecorder.prototype.download = function() {\r\n    this.recorders.forEach(trackRecorder => {\r\n        const blob = new Blob(trackRecorder.data, { type: this.fileType });\r\n        const url = URL.createObjectURL(blob);\r\n        const a = document.createElement('a');\r\n\r\n        document.body.appendChild(a);\r\n        a.style = 'display: none';\r\n        a.href = url;\r\n        a.download = `test.${this.fileType.split('/')[1]}`;\r\n        a.click();\r\n        window.URL.revokeObjectURL(url);\r\n    });\r\n};\r\n\r\n/**\r\n * returns the audio files of all recorders as an array of objects,\r\n * which include the name of the owner of the track and the starting time stamp\r\n * @returns {Array} an array of RecordingResult objects\r\n */\r\nAudioRecorder.prototype.getRecordingResults = function() {\r\n    if (this.isRecording) {\r\n        throw new Error(\r\n            'cannot get blobs because the AudioRecorder is still recording!');\r\n    }\r\n\r\n    // make sure the names are up to date before sending them off\r\n    this.updateNames();\r\n\r\n    const array = [];\r\n\r\n    this.recorders.forEach(\r\n        recorder =>\r\n            array.push(\r\n                new RecordingResult(\r\n                    new Blob(recorder.data, { type: this.fileType }),\r\n                    recorder.name,\r\n                    recorder.startTime)));\r\n\r\n    return array;\r\n};\r\n\r\n/**\r\n * Gets the mime type of the recorder audio\r\n * @returns {String} the mime type of the recorder audio\r\n */\r\nAudioRecorder.prototype.getFileType = function() {\r\n    return this.fileType;\r\n};\r\n\r\n/**\r\n * Creates a empty MediaStream object which can be used\r\n * to add MediaStreamTracks to\r\n * @returns MediaStream\r\n */\r\nfunction createEmptyStream() {\r\n    if (typeof MediaStream !== 'undefined') {\r\n        return new MediaStream();\r\n    }\r\n    throw new Error('cannot create a clean mediaStream');\r\n}\r\n\r\n/**\r\n * export the main object AudioRecorder\r\n */\r\nmodule.exports = AudioRecorder;\r\n","const AuthUtil = {\r\n    /**\r\n     * Creates the URL pointing to JWT token authentication service. It is\r\n     * formatted from the 'urlPattern' argument which can contain the following\r\n     * constants:\r\n     * '{room}' - name of the conference room passed as <tt>roomName</tt>\r\n     * argument to this method.\r\n     * '{roleUpgrade}' - will contain 'true' if the URL will be used for\r\n     * the role upgrade scenario, where user connects from anonymous domain and\r\n     * then gets upgraded to the moderator by logging-in from the popup window.\r\n     *\r\n     * @param urlPattern a URL pattern pointing to the login service\r\n     * @param roomName the name of the conference room for which the user will\r\n     * be authenticated\r\n     * @param {bool} roleUpgrade <tt>true</tt> if the URL will be used for role\r\n     * upgrade scenario, where the user logs-in from the popup window in order\r\n     * to have the moderator rights granted\r\n     *\r\n     * @returns {string|null} the URL pointing to JWT login service or\r\n     * <tt>null</tt> if 'urlPattern' is not a string and the URL can not be\r\n     * constructed.\r\n     */\r\n    getTokenAuthUrl(urlPattern, roomName, roleUpgrade) {\r\n        const url = urlPattern;\r\n\r\n        if (typeof url !== 'string') {\r\n            return null;\r\n        }\r\n\r\n        return url.replace('{room}', roomName)\r\n            .replace('{roleUpgrade}', roleUpgrade === true);\r\n    }\r\n};\r\n\r\nmodule.exports = AuthUtil;\r\n","import {\r\n    CONNECTION_DISCONNECTED as ANALYTICS_CONNECTION_DISCONNECTED,\r\n    createConnectionFailedEvent\r\n} from './service/statistics/AnalyticsEvents';\r\nimport QHSenseConference from './QHSenseConference';\r\nimport * as QHSenseConnectionEvents from './QHSenseConnectionEvents';\r\nimport Statistics from './modules/statistics/statistics';\r\nimport XMPP from './modules/xmpp/xmpp';\r\n\r\n/**\r\n * Creates a new connection object for the QHSense Meet server side video\r\n * conferencing service. Provides access to the QHSenseConference interface.\r\n * @param appID identification for the provider of QHSense Meet video conferencing\r\n * services.\r\n * @param token the JWT token used to authenticate with the server(optional)\r\n * @param options Object with properties / settings related to connection with\r\n * the server.\r\n * @constructor\r\n */\r\nexport default function QHSenseConnection(appID, token, options) {\r\n    this.appID = appID;\r\n    this.token = token;\r\n    this.options = options;\r\n    this.xmpp = new XMPP(options, token);\r\n\r\n    /* eslint-disable max-params */\r\n    this.addEventListener(QHSenseConnectionEvents.CONNECTION_FAILED,\r\n        (errType, msg, credentials, details) => {\r\n            Statistics.sendAnalyticsAndLog(\r\n                createConnectionFailedEvent(errType, msg, details));\r\n        });\r\n    /* eslint-enable max-params */\r\n\r\n    this.addEventListener(QHSenseConnectionEvents.CONNECTION_DISCONNECTED,\r\n        msg => {\r\n            // we can see disconnects from normal tab closing of the browser\r\n            // and then there are no msgs, but we want to log only disconnects\r\n            // when there is real error\r\n            // XXX Do we need the difference in handling between the log and\r\n            // analytics event here?\r\n            if (msg) {\r\n                Statistics.sendAnalytics(\r\n                    ANALYTICS_CONNECTION_DISCONNECTED,\r\n                    { message: msg });\r\n            }\r\n            Statistics.sendLog(\r\n                JSON.stringify(\r\n                    {\r\n                        id: ANALYTICS_CONNECTION_DISCONNECTED,\r\n                        msg\r\n                    }));\r\n        });\r\n}\r\n\r\n/**\r\n * Connect the client with the server.\r\n * @param options {object} connecting options\r\n * (for example authentications parameters).\r\n */\r\nQHSenseConnection.prototype.connect = function(options = {}) {\r\n    this.xmpp.connect(options.id, options.password);\r\n};\r\n\r\n/**\r\n * Attach to existing connection. Can be used for optimizations. For example:\r\n * if the connection is created on the server we can attach to it and start\r\n * using it.\r\n *\r\n * @param options {object} connecting options - rid, sid and jid.\r\n */\r\nQHSenseConnection.prototype.attach = function(options) {\r\n    this.xmpp.attach(options);\r\n};\r\n\r\n/**\r\n * Disconnect the client from the server.\r\n * @returns {Promise} - Resolves when the disconnect process is finished or rejects with an error.\r\n */\r\nQHSenseConnection.prototype.disconnect = function(...args) {\r\n    // XXX Forward any arguments passed to QHSenseConnection.disconnect to\r\n    // XMPP.disconnect. For example, the caller of QHSenseConnection.disconnect\r\n    // may optionally pass the event which triggered the disconnect in order to\r\n    // provide the implementation with finer-grained context.\r\n    return this.xmpp.disconnect(...args);\r\n};\r\n\r\n/**\r\n * Returns the jid of the participant associated with the XMPP connection.\r\n *\r\n * @returns {string} The jid of the participant.\r\n */\r\nQHSenseConnection.prototype.getJid = function() {\r\n    return this.xmpp.getJid();\r\n};\r\n\r\n/**\r\n * This method allows renewal of the tokens if they are expiring.\r\n * @param token the new token.\r\n */\r\nQHSenseConnection.prototype.setToken = function(token) {\r\n    this.token = token;\r\n};\r\n\r\n/**\r\n * Creates and joins new conference.\r\n * @param name the name of the conference; if null - a generated name will be\r\n * provided from the api\r\n * @param options Object with properties / settings related to the conference\r\n * that will be created.\r\n * @returns {QHSenseConference} returns the new conference object.\r\n */\r\nQHSenseConnection.prototype.initQHSenseConference = function(name, options) {\r\n    return new QHSenseConference({\r\n        name,\r\n        config: options,\r\n        connection: this\r\n    });\r\n};\r\n\r\n/**\r\n * Subscribes the passed listener to the event.\r\n * @param event {QHSenseConnectionEvents} the connection event.\r\n * @param listener {Function} the function that will receive the event\r\n */\r\nQHSenseConnection.prototype.addEventListener = function(event, listener) {\r\n    this.xmpp.addListener(event, listener);\r\n};\r\n\r\n/**\r\n * Unsubscribes the passed handler.\r\n * @param event {QHSenseConnectionEvents} the connection event.\r\n * @param listener {Function} the function that will receive the event\r\n */\r\nQHSenseConnection.prototype.removeEventListener = function(event, listener) {\r\n    this.xmpp.removeListener(event, listener);\r\n};\r\n\r\n/**\r\n * Returns measured connectionTimes.\r\n */\r\nQHSenseConnection.prototype.getConnectionTimes = function() {\r\n    return this.xmpp.connectionTimes;\r\n};\r\n\r\n/**\r\n * Adds new feature to the list of supported features for the local\r\n * participant.\r\n * @param {String} feature the name of the feature.\r\n * @param {boolean} submit if true - the new list of features will be\r\n * immediately submitted to the others.\r\n */\r\nQHSenseConnection.prototype.addFeature = function(feature, submit = false) {\r\n    return this.xmpp.caps.addFeature(feature, submit);\r\n};\r\n\r\n/**\r\n * Removes a feature from the list of supported features for the local\r\n * participant\r\n * @param {String} feature the name of the feature.\r\n * @param {boolean} submit if true - the new list of features will be\r\n * immediately submitted to the others.\r\n */\r\nQHSenseConnection.prototype.removeFeature = function(feature, submit = false) {\r\n    return this.xmpp.caps.removeFeature(feature, submit);\r\n};\r\n","/* global __filename, $, Promise */\r\nimport { Strophe } from 'strophe.js';\r\n\r\nimport EventEmitter from 'events';\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport isEqual from 'lodash.isequal';\r\n\r\nimport * as QHSenseConferenceErrors from './QHSenseConferenceErrors';\r\nimport QHSenseConferenceEventManager from './QHSenseConferenceEventManager';\r\nimport * as QHSenseConferenceEvents from './QHSenseConferenceEvents';\r\nimport QHSenseParticipant from './QHSenseParticipant';\r\nimport QHSenseTrackError from './QHSenseTrackError';\r\nimport * as QHSenseTrackErrors from './QHSenseTrackErrors';\r\nimport * as QHSenseTrackEvents from './QHSenseTrackEvents';\r\nimport authenticateAndUpgradeRole from './authenticateAndUpgradeRole';\r\nimport QHSenseDTMFManager from './modules/DTMF/QHSenseDTMFManager';\r\nimport P2PDominantSpeakerDetection from './modules/P2PDominantSpeakerDetection';\r\nimport RTC from './modules/RTC/RTC';\r\nimport TalkMutedDetection from './modules/TalkMutedDetection';\r\nimport browser from './modules/browser';\r\nimport ConnectionQuality from './modules/connectivity/ConnectionQuality';\r\nimport IceFailedNotification\r\n    from './modules/connectivity/IceFailedNotification';\r\nimport ParticipantConnectionStatusHandler\r\n    from './modules/connectivity/ParticipantConnectionStatus';\r\nimport E2ePing from './modules/e2eping/e2eping';\r\nimport Jvb121EventGenerator from './modules/event/Jvb121EventGenerator';\r\nimport RecordingManager from './modules/recording/RecordingManager';\r\nimport RttMonitor from './modules/rttmonitor/rttmonitor';\r\nimport AvgRTPStatsReporter from './modules/statistics/AvgRTPStatsReporter';\r\nimport SpeakerStatsCollector from './modules/statistics/SpeakerStatsCollector';\r\nimport Statistics from './modules/statistics/statistics';\r\nimport Transcriber from './modules/transcription/transcriber';\r\nimport GlobalOnErrorHandler from './modules/util/GlobalOnErrorHandler';\r\nimport RandomUtil from './modules/util/RandomUtil';\r\nimport ComponentsVersions from './modules/version/ComponentsVersions';\r\nimport VideoSIPGW from './modules/videosipgw/VideoSIPGW';\r\nimport * as VideoSIPGWConstants from './modules/videosipgw/VideoSIPGWConstants';\r\nimport { QHSENSE_MEET_MUC_TYPE } from './modules/xmpp/xmpp';\r\nimport * as MediaType from './service/RTC/MediaType';\r\nimport * as RTCEvents from './service/RTC/RTCEvents';\r\nimport VideoType from './service/RTC/VideoType';\r\nimport {\r\n    ACTION_JINGLE_RESTART,\r\n    ACTION_JINGLE_SI_RECEIVED,\r\n    ACTION_JINGLE_SI_TIMEOUT,\r\n    ACTION_JINGLE_TERMINATE,\r\n    ACTION_P2P_ESTABLISHED,\r\n    ACTION_P2P_FAILED,\r\n    ACTION_P2P_SWITCH_TO_JVB,\r\n    ICE_ESTABLISHMENT_DURATION_DIFF,\r\n    createJingleEvent,\r\n    createP2PEvent\r\n} from './service/statistics/AnalyticsEvents';\r\nimport * as XMPPEvents from './service/xmpp/XMPPEvents';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * How long since Jicofo is supposed to send a session-initiate, before\r\n * {@link ACTION_JINGLE_SI_TIMEOUT} analytics event is sent (in ms).\r\n * @type {number}\r\n */\r\nconst JINGLE_SI_TIMEOUT = 5000;\r\n\r\n/**\r\n * Creates a QHSenseConference object with the given name and properties.\r\n * Note: this constructor is not a part of the public API (objects should be\r\n * created using QHSenseConnection.createConference).\r\n * @param options.config properties / settings related to the conference that\r\n * will be created.\r\n * @param options.name the name of the conference\r\n * @param options.connection the QHSenseConnection object for this\r\n * QHSenseConference.\r\n * @param {number} [options.config.avgRtpStatsN=15] how many samples are to be\r\n * collected by {@link AvgRTPStatsReporter}, before arithmetic mean is\r\n * calculated and submitted to the analytics module.\r\n * @param {boolean} [options.config.p2p.enabled] when set to <tt>true</tt>\r\n * the peer to peer mode will be enabled. It means that when there are only 2\r\n * participants in the conference an attempt to make direct connection will be\r\n * made. If the connection succeeds the conference will stop sending data\r\n * through the JVB connection and will use the direct one instead.\r\n * @param {number} [options.config.p2p.backToP2PDelay=5] a delay given in\r\n * seconds, before the conference switches back to P2P, after the 3rd\r\n * participant has left the room.\r\n * @param {number} [options.config.channelLastN=-1] The requested amount of\r\n * videos are going to be delivered after the value is in effect. Set to -1 for\r\n * unlimited or all available videos.\r\n * @param {number} [options.config.forceJVB121Ratio]\r\n * \"Math.random() < forceJVB121Ratio\" will determine whether a 2 people\r\n * conference should be moved to the JVB instead of P2P. The decision is made on\r\n * the responder side, after ICE succeeds on the P2P connection.\r\n * @param {*} [options.config.openBridgeChannel] Which kind of communication to\r\n * open with the videobridge. Values can be \"datachannel\", \"websocket\", true\r\n * (treat it as \"datachannel\"), undefined (treat it as \"datachannel\") and false\r\n * (don't open any channel).\r\n * @constructor\r\n *\r\n * FIXME Make all methods which are called from lib-internal classes\r\n *       to non-public (use _). To name a few:\r\n *       {@link QHSenseConference.onLocalRoleChanged}\r\n *       {@link QHSenseConference.onUserRoleChanged}\r\n *       {@link QHSenseConference.onMemberLeft}\r\n *       and so on...\r\n */\r\nexport default function QHSenseConference(options) {\r\n    if (!options.name || options.name.toLowerCase() !== options.name) {\r\n        const errmsg\r\n            = 'Invalid conference name (no conference name passed or it '\r\n                + 'contains invalid characters like capital letters)!';\r\n\r\n        logger.error(errmsg);\r\n        throw new Error(errmsg);\r\n    }\r\n    this.eventEmitter = new EventEmitter();\r\n    this.options = options;\r\n    this.eventManager = new QHSenseConferenceEventManager(this);\r\n    this.participants = {};\r\n    this._init(options);\r\n    this.componentsVersions = new ComponentsVersions(this);\r\n\r\n    /**\r\n     * Jingle session instance for the JVB connection.\r\n     * @type {JingleSessionPC}\r\n     */\r\n    this.jvbJingleSession = null;\r\n    this.lastDominantSpeaker = null;\r\n    this.dtmfManager = null;\r\n    this.somebodySupportsDTMF = false;\r\n    this.authEnabled = false;\r\n    this.startAudioMuted = false;\r\n    this.startVideoMuted = false;\r\n    this.startMutedPolicy = {\r\n        audio: false,\r\n        video: false\r\n    };\r\n    this.isMutedByFocus = false;\r\n\r\n    // when muted by focus we receive the jid of the initiator of the mute\r\n    this.mutedByFocusActor = null;\r\n\r\n    // Flag indicates if the 'onCallEnded' method was ever called on this\r\n    // instance. Used to log extra analytics event for debugging purpose.\r\n    // We need to know if the potential issue happened before or after\r\n    // the restart.\r\n    this.wasStopped = false;\r\n\r\n    // Conference properties, maintained by jicofo.\r\n    this.properties = {};\r\n\r\n    /**\r\n     * The object which monitors local and remote connection statistics (e.g.\r\n     * sending bitrate) and calculates a number which represents the connection\r\n     * quality.\r\n     */\r\n    this.connectionQuality\r\n        = new ConnectionQuality(this, this.eventEmitter, options);\r\n\r\n    /**\r\n     * Reports average RTP statistics to the analytics module.\r\n     * @type {AvgRTPStatsReporter}\r\n     */\r\n    this.avgRtpStatsReporter\r\n        = new AvgRTPStatsReporter(this, options.config.avgRtpStatsN || 15);\r\n\r\n    /**\r\n     * Indicates whether the connection is interrupted or not.\r\n     */\r\n    this.isJvbConnectionInterrupted = false;\r\n\r\n    /**\r\n     * The object which tracks active speaker times\r\n     */\r\n    this.speakerStatsCollector = new SpeakerStatsCollector(this);\r\n\r\n    /* P2P related fields below: */\r\n\r\n    /**\r\n     * Stores reference to deferred start P2P task. It's created when 3rd\r\n     * participant leaves the room in order to avoid ping pong effect (it\r\n     * could be just a page reload).\r\n     * @type {number|null}\r\n     */\r\n    this.deferredStartP2PTask = null;\r\n\r\n    const delay\r\n        = parseInt(options.config.p2p && options.config.p2p.backToP2PDelay, 10);\r\n\r\n    /**\r\n     * A delay given in seconds, before the conference switches back to P2P\r\n     * after the 3rd participant has left.\r\n     * @type {number}\r\n     */\r\n    this.backToP2PDelay = isNaN(delay) ? 5 : delay;\r\n    logger.info(`backToP2PDelay: ${this.backToP2PDelay}`);\r\n\r\n    /**\r\n     * If set to <tt>true</tt> it means the P2P ICE is no longer connected.\r\n     * When <tt>false</tt> it means that P2P ICE (media) connection is up\r\n     * and running.\r\n     * @type {boolean}\r\n     */\r\n    this.isP2PConnectionInterrupted = false;\r\n\r\n    /**\r\n     * Flag set to <tt>true</tt> when P2P session has been established\r\n     * (ICE has been connected) and this conference is currently in the peer to\r\n     * peer mode (P2P connection is the active one).\r\n     * @type {boolean}\r\n     */\r\n    this.p2p = false;\r\n\r\n    /**\r\n     * A JingleSession for the direct peer to peer connection.\r\n     * @type {JingleSessionPC}\r\n     */\r\n    this.p2pJingleSession = null;\r\n\r\n    this.videoSIPGWHandler = new VideoSIPGW(this.room);\r\n    this.recordingManager = new RecordingManager(this.room);\r\n}\r\n\r\n// FIXME convert QHSenseConference to ES6 - ASAP !\r\nQHSenseConference.prototype.constructor = QHSenseConference;\r\n\r\n/**\r\n * Create a resource for the a jid. We use the room nickname (the resource part\r\n * of the occupant JID, see XEP-0045) as the endpoint ID in colibri. We require\r\n * endpoint IDs to be 8 hex digits because in some cases they get serialized\r\n * into a 32bit field.\r\n *\r\n * @param {string} jid - The id set onto the XMPP connection.\r\n * @param {boolean} isAuthenticatedUser - Whether or not the user has connected\r\n * to the XMPP service with a password.\r\n * @returns {string}\r\n * @static\r\n */\r\nQHSenseConference.resourceCreator = function(jid, isAuthenticatedUser) {\r\n    let mucNickname;\r\n\r\n    if (isAuthenticatedUser) {\r\n        // For authenticated users generate a random ID.\r\n        mucNickname = RandomUtil.randomHexString(8).toLowerCase();\r\n    } else {\r\n        // We try to use the first part of the node (which for anonymous users\r\n        // on prosody is a UUID) to match the previous behavior (and maybe make\r\n        // debugging easier).\r\n        mucNickname = Strophe.getNodeFromJid(jid).substr(0, 8)\r\n            .toLowerCase();\r\n\r\n        // But if this doesn't have the required format we just generate a new\r\n        // random nickname.\r\n        const re = /[0-9a-f]{8}/g;\r\n\r\n        if (!re.test(mucNickname)) {\r\n            mucNickname = RandomUtil.randomHexString(8).toLowerCase();\r\n        }\r\n    }\r\n\r\n    return mucNickname;\r\n};\r\n\r\n/**\r\n * Initializes the conference object properties\r\n * @param options {object}\r\n * @param options.connection {QHSenseConnection} overrides this.connection\r\n */\r\nQHSenseConference.prototype._init = function(options = {}) {\r\n    // Override connection and xmpp properties (Useful if the connection\r\n    // reloaded)\r\n    if (options.connection) {\r\n        this.connection = options.connection;\r\n        this.xmpp = this.connection.xmpp;\r\n\r\n        // Setup XMPP events only if we have new connection object.\r\n        this.eventManager.setupXMPPListeners();\r\n    }\r\n\r\n    const { config } = this.options;\r\n\r\n    this.room = this.xmpp.createRoom(\r\n        this.options.name,\r\n        config,\r\n        QHSenseConference.resourceCreator\r\n    );\r\n\r\n    // Connection interrupted/restored listeners\r\n    this._onIceConnectionInterrupted\r\n        = this._onIceConnectionInterrupted.bind(this);\r\n    this.room.addListener(\r\n        XMPPEvents.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted);\r\n\r\n    this._onIceConnectionRestored = this._onIceConnectionRestored.bind(this);\r\n    this.room.addListener(\r\n        XMPPEvents.CONNECTION_RESTORED, this._onIceConnectionRestored);\r\n\r\n    this._onIceConnectionEstablished\r\n        = this._onIceConnectionEstablished.bind(this);\r\n    this.room.addListener(\r\n        XMPPEvents.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished);\r\n\r\n    this._updateProperties = this._updateProperties.bind(this);\r\n    this.room.addListener(XMPPEvents.CONFERENCE_PROPERTIES_CHANGED,\r\n        this._updateProperties);\r\n\r\n    this.rttMonitor = new RttMonitor(config.rttMonitor || {});\r\n\r\n    this.e2eping = new E2ePing(\r\n        this,\r\n        config,\r\n        (message, to) => {\r\n            try {\r\n                this.sendMessage(\r\n                    message, to, true /* sendThroughVideobridge */);\r\n            } catch (error) {\r\n                logger.warn('Failed to send a ping request or response.');\r\n            }\r\n        });\r\n\r\n    if (!this.rtc) {\r\n        this.rtc = new RTC(this, options);\r\n        this.eventManager.setupRTCListeners();\r\n    }\r\n\r\n    this.participantConnectionStatus\r\n        = new ParticipantConnectionStatusHandler(\r\n            this.rtc,\r\n            this,\r\n            {\r\n                // Both these options are not public API, leaving it here only\r\n                // as an entry point through config for tuning up purposes.\r\n                // Default values should be adjusted as soon as optimal values\r\n                // are discovered.\r\n                rtcMuteTimeout: config._peerConnStatusRtcMuteTimeout,\r\n                outOfLastNTimeout: config._peerConnStatusOutOfLastNTimeout\r\n            });\r\n    this.participantConnectionStatus.init();\r\n\r\n    if (!this.statistics) {\r\n        let callStatsAliasName = this.myUserId();\r\n\r\n        if (config.enableDisplayNameInStats && config.displayName) {\r\n            callStatsAliasName = config.displayName;\r\n        }\r\n\r\n        this.statistics = new Statistics(this.xmpp, {\r\n            callStatsAliasName,\r\n            confID: config.confID || `${this.connection.options.hosts.domain}/${this.options.name}`,\r\n            customScriptUrl: config.callStatsCustomScriptUrl,\r\n            callStatsID: config.callStatsID,\r\n            callStatsSecret: config.callStatsSecret,\r\n            swapUserNameAndAlias: config.enableStatsID,\r\n            applicationName: config.applicationName,\r\n            getWiFiStatsMethod: config.getWiFiStatsMethod\r\n        });\r\n    }\r\n\r\n    this.eventManager.setupChatRoomListeners();\r\n\r\n    // Always add listeners because on reload we are executing leave and the\r\n    // listeners are removed from statistics module.\r\n    this.eventManager.setupStatisticsListeners();\r\n\r\n    if (config.enableTalkWhileMuted) {\r\n        // eslint-disable-next-line no-new\r\n        new TalkMutedDetection(\r\n            this,\r\n            () =>\r\n                this.eventEmitter.emit(QHSenseConferenceEvents.TALK_WHILE_MUTED));\r\n    }\r\n\r\n    if ('channelLastN' in config) {\r\n        this.setLastN(config.channelLastN);\r\n    }\r\n\r\n    /**\r\n     * Emits {@link QHSenseConferenceEvents.JVB121_STATUS}.\r\n     * @type {Jvb121EventGenerator}\r\n     */\r\n    this.jvb121Status = new Jvb121EventGenerator(this);\r\n\r\n    // creates dominant speaker detection that works only in p2p mode\r\n    this.p2pDominantSpeakerDetection = new P2PDominantSpeakerDetection(this);\r\n\r\n    if (config && config.deploymentInfo && config.deploymentInfo.userRegion) {\r\n        this.setLocalParticipantProperty(\r\n            'region', config.deploymentInfo.userRegion);\r\n    }\r\n};\r\n\r\n/**\r\n * Joins the conference.\r\n * @param password {string} the password\r\n */\r\nQHSenseConference.prototype.join = function(password) {\r\n    if (this.room) {\r\n        this.room.join(password).then(() => this._maybeSetSITimeout());\r\n    }\r\n};\r\n\r\n/**\r\n * Authenticates and upgrades the role of the local participant/user.\r\n *\r\n * @returns {Object} A <tt>thenable</tt> which (1) settles when the process of\r\n * authenticating and upgrading the role of the local participant/user finishes\r\n * and (2) has a <tt>cancel</tt> method that allows the caller to interrupt the\r\n * process.\r\n */\r\nQHSenseConference.prototype.authenticateAndUpgradeRole = function(options) {\r\n    return authenticateAndUpgradeRole.call(this, {\r\n        ...options,\r\n        onCreateResource: QHSenseConference.resourceCreator\r\n    });\r\n};\r\n\r\n/**\r\n * Check if joined to the conference.\r\n */\r\nQHSenseConference.prototype.isJoined = function() {\r\n    return this.room && this.room.joined;\r\n};\r\n\r\n/**\r\n * Tells whether or not the P2P mode is enabled in the configuration.\r\n * @return {boolean}\r\n */\r\nQHSenseConference.prototype.isP2PEnabled = function() {\r\n    return Boolean(this.options.config.p2p && this.options.config.p2p.enabled)\r\n\r\n        // FIXME: remove once we have a default config template. -saghul\r\n        || typeof this.options.config.p2p === 'undefined';\r\n};\r\n\r\n/**\r\n * When in P2P test mode, the conference will not automatically switch to P2P\r\n * when there 2 participants.\r\n * @return {boolean}\r\n */\r\nQHSenseConference.prototype.isP2PTestModeEnabled = function() {\r\n    return Boolean(this.options.config.testing\r\n        && this.options.config.testing.p2pTestMode);\r\n};\r\n\r\n/**\r\n * Leaves the conference.\r\n * @returns {Promise}\r\n */\r\nQHSenseConference.prototype.leave = function() {\r\n    if (this.participantConnectionStatus) {\r\n        this.participantConnectionStatus.dispose();\r\n        this.participantConnectionStatus = null;\r\n    }\r\n    if (this.avgRtpStatsReporter) {\r\n        this.avgRtpStatsReporter.dispose();\r\n        this.avgRtpStatsReporter = null;\r\n    }\r\n\r\n    if (this.rttMonitor) {\r\n        this.rttMonitor.stop();\r\n        this.rttMonitor = null;\r\n    }\r\n\r\n    if (this.e2eping) {\r\n        this.e2eping.stop();\r\n        this.e2eping = null;\r\n    }\r\n\r\n    this.getLocalTracks().forEach(track => this.onLocalTrackRemoved(track));\r\n\r\n    this.rtc.closeBridgeChannel();\r\n    if (this.statistics) {\r\n        this.statistics.dispose();\r\n    }\r\n\r\n    this._delayedIceFailed && this._delayedIceFailed.cancel();\r\n\r\n    // Close both JVb and P2P JingleSessions\r\n    if (this.jvbJingleSession) {\r\n        this.jvbJingleSession.close();\r\n        this.jvbJingleSession = null;\r\n    }\r\n    if (this.p2pJingleSession) {\r\n        this.p2pJingleSession.close();\r\n        this.p2pJingleSession = null;\r\n    }\r\n\r\n    // leave the conference\r\n    if (this.room) {\r\n        const room = this.room;\r\n\r\n        // Unregister connection state listeners\r\n        room.removeListener(\r\n            XMPPEvents.CONNECTION_INTERRUPTED,\r\n            this._onIceConnectionInterrupted);\r\n        room.removeListener(\r\n            XMPPEvents.CONNECTION_RESTORED,\r\n            this._onIceConnectionRestored);\r\n        room.removeListener(\r\n            XMPPEvents.CONNECTION_ESTABLISHED,\r\n            this._onIceConnectionEstablished);\r\n\r\n        room.removeListener(\r\n            XMPPEvents.CONFERENCE_PROPERTIES_CHANGED,\r\n            this._updateProperties);\r\n\r\n        this.eventManager.removeXMPPListeners();\r\n\r\n        this.room = null;\r\n\r\n        return room.leave()\r\n            .then(() => {\r\n                if (this.rtc) {\r\n                    this.rtc.destroy();\r\n                }\r\n            })\r\n            .catch(error => {\r\n                // remove all participants because currently the conference\r\n                // won't be usable anyway. This is done on success automatically\r\n                // by the ChatRoom instance.\r\n                this.getParticipants().forEach(\r\n                    participant => this.onMemberLeft(participant.getJid()));\r\n\r\n                throw error;\r\n            });\r\n    }\r\n\r\n    // If this.room == null we are calling second time leave().\r\n    return Promise.reject(\r\n        new Error('The conference is has been already left'));\r\n};\r\n\r\n/**\r\n * Returns name of this conference.\r\n */\r\nQHSenseConference.prototype.getName = function() {\r\n    return this.options.name;\r\n};\r\n\r\n/**\r\n * Returns the {@link QHSenseConnection} used by this this conference.\r\n */\r\nQHSenseConference.prototype.getConnection = function() {\r\n    return this.connection;\r\n};\r\n\r\n/**\r\n * Check if authentication is enabled for this conference.\r\n */\r\nQHSenseConference.prototype.isAuthEnabled = function() {\r\n    return this.authEnabled;\r\n};\r\n\r\n/**\r\n * Check if user is logged in.\r\n */\r\nQHSenseConference.prototype.isLoggedIn = function() {\r\n    return Boolean(this.authIdentity);\r\n};\r\n\r\n/**\r\n * Get authorized login.\r\n */\r\nQHSenseConference.prototype.getAuthLogin = function() {\r\n    return this.authIdentity;\r\n};\r\n\r\n/**\r\n * Check if external authentication is enabled for this conference.\r\n */\r\nQHSenseConference.prototype.isExternalAuthEnabled = function() {\r\n    return this.room && this.room.moderator.isExternalAuthEnabled();\r\n};\r\n\r\n/**\r\n * Get url for external authentication.\r\n * @param {boolean} [urlForPopup] if true then return url for login popup,\r\n *                                else url of login page.\r\n * @returns {Promise}\r\n */\r\nQHSenseConference.prototype.getExternalAuthUrl = function(urlForPopup) {\r\n    return new Promise((resolve, reject) => {\r\n        if (!this.isExternalAuthEnabled()) {\r\n            reject();\r\n\r\n            return;\r\n        }\r\n        if (urlForPopup) {\r\n            this.room.moderator.getPopupLoginUrl(resolve, reject);\r\n        } else {\r\n            this.room.moderator.getLoginUrl(resolve, reject);\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * Returns the local tracks of the given media type, or all local tracks if no\r\n * specific type is given.\r\n * @param {MediaType} [mediaType] Optional media type (audio or video).\r\n */\r\nQHSenseConference.prototype.getLocalTracks = function(mediaType) {\r\n    let tracks = [];\r\n\r\n    if (this.rtc) {\r\n        tracks = this.rtc.getLocalTracks(mediaType);\r\n    }\r\n\r\n    return tracks;\r\n};\r\n\r\n/**\r\n * Obtains local audio track.\r\n * @return {QHSenseLocalTrack|null}\r\n */\r\nQHSenseConference.prototype.getLocalAudioTrack = function() {\r\n    return this.rtc ? this.rtc.getLocalAudioTrack() : null;\r\n};\r\n\r\n/**\r\n * Obtains local video track.\r\n * @return {QHSenseLocalTrack|null}\r\n */\r\nQHSenseConference.prototype.getLocalVideoTrack = function() {\r\n    return this.rtc ? this.rtc.getLocalVideoTrack() : null;\r\n};\r\n\r\n/**\r\n * Attaches a handler for events(For example - \"participant joined\".) in the\r\n * conference. All possible event are defined in QHSenseConferenceEvents.\r\n * @param eventId the event ID.\r\n * @param handler handler for the event.\r\n *\r\n * Note: consider adding eventing functionality by extending an EventEmitter\r\n * impl, instead of rolling ourselves\r\n */\r\nQHSenseConference.prototype.on = function(eventId, handler) {\r\n    if (this.eventEmitter) {\r\n        this.eventEmitter.on(eventId, handler);\r\n    }\r\n};\r\n\r\n/**\r\n * Removes event listener\r\n * @param eventId the event ID.\r\n * @param [handler] optional, the specific handler to unbind\r\n *\r\n * Note: consider adding eventing functionality by extending an EventEmitter\r\n * impl, instead of rolling ourselves\r\n */\r\nQHSenseConference.prototype.off = function(eventId, handler) {\r\n    if (this.eventEmitter) {\r\n        this.eventEmitter.removeListener(eventId, handler);\r\n    }\r\n};\r\n\r\n// Common aliases for event emitter\r\nQHSenseConference.prototype.addEventListener = QHSenseConference.prototype.on;\r\nQHSenseConference.prototype.removeEventListener = QHSenseConference.prototype.off;\r\n\r\n/**\r\n * Receives notifications from other participants about commands / custom events\r\n * (sent by sendCommand or sendCommandOnce methods).\r\n * @param command {String} the name of the command\r\n * @param handler {Function} handler for the command\r\n */\r\nQHSenseConference.prototype.addCommandListener = function(command, handler) {\r\n    if (this.room) {\r\n        this.room.addPresenceListener(command, handler);\r\n    }\r\n};\r\n\r\n/**\r\n  * Removes command  listener\r\n  * @param command {String} the name of the command\r\n  */\r\nQHSenseConference.prototype.removeCommandListener = function(command) {\r\n    if (this.room) {\r\n        this.room.removePresenceListener(command);\r\n    }\r\n};\r\n\r\n/**\r\n * Sends text message to the other participants in the conference\r\n * @param message the text message.\r\n * @param elementName the element name to encapsulate the message.\r\n * @deprecated Use 'sendMessage' instead. TODO: this should be private.\r\n */\r\nQHSenseConference.prototype.sendTextMessage = function(\r\n        message, elementName = 'body') {\r\n    if (this.room) {\r\n        this.room.sendMessage(message, elementName);\r\n    }\r\n};\r\n\r\n/**\r\n * Send private text message to another participant of the conference\r\n * @param id the id of the participant to send a private message.\r\n * @param message the text message.\r\n * @param elementName the element name to encapsulate the message.\r\n * @deprecated Use 'sendMessage' instead. TODO: this should be private.\r\n */\r\nQHSenseConference.prototype.sendPrivateTextMessage = function(\r\n        id, message, elementName = 'body') {\r\n    if (this.room) {\r\n        this.room.sendPrivateMessage(id, message, elementName);\r\n    }\r\n};\r\n\r\n/**\r\n * Send presence command.\r\n * @param name {String} the name of the command.\r\n * @param values {Object} with keys and values that will be sent.\r\n **/\r\nQHSenseConference.prototype.sendCommand = function(name, values) {\r\n    if (this.room) {\r\n        this.room.addToPresence(name, values);\r\n        this.room.sendPresence();\r\n    } else {\r\n        logger.warn('Not sending a command, room not initialized.');\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Send presence command one time.\r\n * @param name {String} the name of the command.\r\n * @param values {Object} with keys and values that will be sent.\r\n **/\r\nQHSenseConference.prototype.sendCommandOnce = function(name, values) {\r\n    this.sendCommand(name, values);\r\n    this.removeCommand(name);\r\n};\r\n\r\n/**\r\n * Removes presence command.\r\n * @param name {String} the name of the command.\r\n **/\r\nQHSenseConference.prototype.removeCommand = function(name) {\r\n    if (this.room) {\r\n        this.room.removeFromPresence(name);\r\n    }\r\n};\r\n\r\n/**\r\n * Sets the display name for this conference.\r\n * @param name the display name to set\r\n */\r\nQHSenseConference.prototype.setDisplayName = function(name) {\r\n    if (this.room) {\r\n        // remove previously set nickname\r\n        this.room.removeFromPresence('nick');\r\n\r\n        this.room.addToPresence('nick', {\r\n            attributes: { xmlns: 'http://jabber.org/protocol/nick' },\r\n            value: name\r\n        });\r\n        this.room.sendPresence();\r\n    }\r\n};\r\n\r\n/**\r\n * Set new subject for this conference. (available only for moderator)\r\n * @param {string} subject new subject\r\n */\r\nQHSenseConference.prototype.setSubject = function(subject) {\r\n    if (this.room && this.isModerator()) {\r\n        this.room.setSubject(subject);\r\n    }\r\n};\r\n\r\n/**\r\n * Get a transcriber object for all current participants in this conference\r\n * @return {Transcriber} the transcriber object\r\n */\r\nQHSenseConference.prototype.getTranscriber = function() {\r\n    if (this.transcriber === undefined) {\r\n        this.transcriber = new Transcriber();\r\n\r\n        // add all existing local audio tracks to the transcriber\r\n        const localAudioTracks = this.getLocalTracks(MediaType.AUDIO);\r\n\r\n        for (const localAudio of localAudioTracks) {\r\n            this.transcriber.addTrack(localAudio);\r\n        }\r\n\r\n        // and all remote audio tracks\r\n        const remoteAudioTracks = this.rtc.getRemoteTracks(MediaType.AUDIO);\r\n\r\n        for (const remoteTrack of remoteAudioTracks) {\r\n            this.transcriber.addTrack(remoteTrack);\r\n        }\r\n    }\r\n\r\n    return this.transcriber;\r\n};\r\n\r\n/**\r\n * Returns the transcription status.\r\n *\r\n * @returns {String} \"on\" or \"off\".\r\n */\r\nQHSenseConference.prototype.getTranscriptionStatus = function() {\r\n    return this.room.transcriptionStatus;\r\n};\r\n\r\n/**\r\n * Adds QHSenseLocalTrack object to the conference.\r\n * @param track the QHSenseLocalTrack object.\r\n * @returns {Promise<QHSenseLocalTrack>}\r\n * @throws {Error} if the specified track is a video track and there is already\r\n * another video track in the conference.\r\n */\r\nQHSenseConference.prototype.addTrack = function(track) {\r\n    if (track.isVideoTrack()) {\r\n        // Ensure there's exactly 1 local video track in the conference.\r\n        const localVideoTrack = this.rtc.getLocalVideoTrack();\r\n\r\n        if (localVideoTrack) {\r\n            // Don't be excessively harsh and severe if the API client happens\r\n            // to attempt to add the same local video track twice.\r\n            if (track === localVideoTrack) {\r\n                return Promise.resolve(track);\r\n            }\r\n\r\n            return Promise.reject(new Error(\r\n                'cannot add second video track to the conference'));\r\n\r\n        }\r\n    }\r\n\r\n    return this.replaceTrack(null, track);\r\n};\r\n\r\n/**\r\n * Fires TRACK_AUDIO_LEVEL_CHANGED change conference event (for local tracks).\r\n * @param {number} audioLevel the audio level\r\n * @param {TraceablePeerConnection} [tpc]\r\n */\r\nQHSenseConference.prototype._fireAudioLevelChangeEvent = function(\r\n        audioLevel,\r\n        tpc) {\r\n    const activeTpc = this.getActivePeerConnection();\r\n\r\n    // There will be no TraceablePeerConnection if audio levels do not come from\r\n    // a peerconnection. LocalStatsCollector.js measures audio levels using Web\r\n    // Audio Analyser API and emits local audio levels events through\r\n    // QHSenseTrack.setAudioLevel, but does not provide TPC instance which is\r\n    // optional.\r\n    if (!tpc || activeTpc === tpc) {\r\n        this.eventEmitter.emit(\r\n            QHSenseConferenceEvents.TRACK_AUDIO_LEVEL_CHANGED,\r\n            this.myUserId(), audioLevel);\r\n    }\r\n};\r\n\r\n/**\r\n * Fires TRACK_MUTE_CHANGED change conference event.\r\n * @param track the QHSenseTrack object related to the event.\r\n */\r\nQHSenseConference.prototype._fireMuteChangeEvent = function(track) {\r\n    // check if track was muted by focus and now is unmuted by user\r\n    if (this.isMutedByFocus && track.isAudioTrack() && !track.isMuted()) {\r\n        this.isMutedByFocus = false;\r\n\r\n        // unmute local user on server\r\n        this.room.muteParticipant(this.room.myroomjid, false);\r\n    }\r\n\r\n    let actorParticipant;\r\n\r\n    if (this.mutedByFocusActor) {\r\n        const actorId = Strophe.getResourceFromJid(this.mutedByFocusActor);\r\n\r\n        actorParticipant = this.participants[actorId];\r\n    }\r\n\r\n    this.eventEmitter.emit(QHSenseConferenceEvents.TRACK_MUTE_CHANGED, track, actorParticipant);\r\n};\r\n\r\n/**\r\n * Clear QHSenseLocalTrack properties and listeners.\r\n * @param track the QHSenseLocalTrack object.\r\n */\r\nQHSenseConference.prototype.onLocalTrackRemoved = function(track) {\r\n    track._setConference(null);\r\n    this.rtc.removeLocalTrack(track);\r\n    track.removeEventListener(QHSenseTrackEvents.TRACK_MUTE_CHANGED,\r\n        track.muteHandler);\r\n    track.removeEventListener(QHSenseTrackEvents.TRACK_AUDIO_LEVEL_CHANGED,\r\n        track.audioLevelHandler);\r\n\r\n    // send event for stopping screen sharing\r\n    // FIXME: we assume we have only one screen sharing track\r\n    // if we change this we need to fix this check\r\n    if (track.isVideoTrack() && track.videoType === VideoType.DESKTOP) {\r\n        this.statistics.sendScreenSharingEvent(false);\r\n    }\r\n\r\n    this.eventEmitter.emit(QHSenseConferenceEvents.TRACK_REMOVED, track);\r\n};\r\n\r\n/**\r\n * Removes QHSenseLocalTrack from the conference and performs\r\n * a new offer/answer cycle.\r\n * @param {QHSenseLocalTrack} track\r\n * @returns {Promise}\r\n */\r\nQHSenseConference.prototype.removeTrack = function(track) {\r\n    return this.replaceTrack(track, null);\r\n};\r\n\r\n/**\r\n * Replaces oldTrack with newTrack and performs a single offer/answer\r\n *  cycle after both operations are done.  Either oldTrack or newTrack\r\n *  can be null; replacing a valid 'oldTrack' with a null 'newTrack'\r\n *  effectively just removes 'oldTrack'\r\n * @param {QHSenseLocalTrack} oldTrack the current stream in use to be replaced\r\n * @param {QHSenseLocalTrack} newTrack the new stream to use\r\n * @returns {Promise} resolves when the replacement is finished\r\n */\r\nQHSenseConference.prototype.replaceTrack = function(oldTrack, newTrack) {\r\n    // First do the removal of the oldTrack at the QHSenseConference level\r\n    if (oldTrack) {\r\n        if (oldTrack.disposed) {\r\n            return Promise.reject(\r\n                new QHSenseTrackError(QHSenseTrackErrors.TRACK_IS_DISPOSED));\r\n        }\r\n    }\r\n    if (newTrack) {\r\n        if (newTrack.disposed) {\r\n            return Promise.reject(\r\n                new QHSenseTrackError(QHSenseTrackErrors.TRACK_IS_DISPOSED));\r\n        }\r\n    }\r\n\r\n    // Now replace the stream at the lower levels\r\n    return this._doReplaceTrack(oldTrack, newTrack)\r\n        .then(() => {\r\n            if (oldTrack) {\r\n                this.onLocalTrackRemoved(oldTrack);\r\n            }\r\n            if (newTrack) {\r\n                // Now handle the addition of the newTrack at the\r\n                // QHSenseConference level\r\n                this._setupNewTrack(newTrack);\r\n            }\r\n\r\n            return Promise.resolve();\r\n        }, error => Promise.reject(new Error(error)));\r\n};\r\n\r\n/**\r\n * Replaces the tracks at the lower level by going through the Jingle session\r\n * and WebRTC peer connection. The method will resolve immediately if there is\r\n * currently no JingleSession started.\r\n * @param {QHSenseLocalTrack|null} oldTrack the track to be removed during\r\n * the process or <tt>null</t> if the method should act as \"add track\"\r\n * @param {QHSenseLocalTrack|null} newTrack the new track to be added or\r\n * <tt>null</tt> if the method should act as \"remove track\"\r\n * @return {Promise} resolved when the process is done or rejected with a string\r\n * which describes the error.\r\n * @private\r\n */\r\nQHSenseConference.prototype._doReplaceTrack = function(oldTrack, newTrack) {\r\n    const replaceTrackPromises = [];\r\n\r\n    if (this.jvbJingleSession) {\r\n        replaceTrackPromises.push(\r\n            this.jvbJingleSession.replaceTrack(oldTrack, newTrack));\r\n    } else {\r\n        logger.info('_doReplaceTrack - no JVB JingleSession');\r\n    }\r\n\r\n    if (this.p2pJingleSession) {\r\n        replaceTrackPromises.push(\r\n            this.p2pJingleSession.replaceTrack(oldTrack, newTrack));\r\n    } else {\r\n        logger.info('_doReplaceTrack - no P2P JingleSession');\r\n    }\r\n\r\n    return Promise.all(replaceTrackPromises);\r\n};\r\n\r\n/**\r\n * Operations related to creating a new track\r\n * @param {QHSenseLocalTrack} newTrack the new track being created\r\n */\r\nQHSenseConference.prototype._setupNewTrack = function(newTrack) {\r\n    if (newTrack.isAudioTrack() || (newTrack.isVideoTrack()\r\n            && newTrack.videoType !== VideoType.DESKTOP)) {\r\n        // Report active device to statistics\r\n        const devices = RTC.getCurrentlyAvailableMediaDevices();\r\n        const device\r\n            = devices.find(\r\n                d =>\r\n                    d.kind === `${newTrack.getTrack().kind}input`\r\n                        && d.label === newTrack.getTrack().label);\r\n\r\n        if (device) {\r\n            Statistics.sendActiveDeviceListEvent(\r\n                RTC.getEventDataForActiveDevice(device));\r\n        }\r\n    }\r\n    if (newTrack.isVideoTrack()) {\r\n        this.removeCommand('videoType');\r\n        this.sendCommand('videoType', {\r\n            value: newTrack.videoType,\r\n            attributes: {\r\n                xmlns: 'http://QHSense.org/jitmeet/video'\r\n            }\r\n        });\r\n    }\r\n    this.rtc.addLocalTrack(newTrack);\r\n\r\n    // ensure that we're sharing proper \"is muted\" state\r\n    if (newTrack.isAudioTrack()) {\r\n        this.room.setAudioMute(newTrack.isMuted());\r\n    } else {\r\n        this.room.setVideoMute(newTrack.isMuted());\r\n    }\r\n\r\n    newTrack.muteHandler = this._fireMuteChangeEvent.bind(this, newTrack);\r\n    newTrack.audioLevelHandler = this._fireAudioLevelChangeEvent.bind(this);\r\n    newTrack.addEventListener(\r\n        QHSenseTrackEvents.TRACK_MUTE_CHANGED,\r\n        newTrack.muteHandler);\r\n    newTrack.addEventListener(\r\n        QHSenseTrackEvents.TRACK_AUDIO_LEVEL_CHANGED,\r\n        newTrack.audioLevelHandler);\r\n\r\n    newTrack._setConference(this);\r\n\r\n    this.eventEmitter.emit(QHSenseConferenceEvents.TRACK_ADDED, newTrack);\r\n};\r\n\r\n/**\r\n * Method called by the {@link QHSenseLocalTrack} (a video one) in order to add\r\n * back the underlying WebRTC MediaStream to the PeerConnection (which has\r\n * removed on video mute).\r\n * @param {QHSenseLocalTrack} track the local track that will be added as part of\r\n * the unmute operation.\r\n * @return {Promise} resolved when the process is done or rejected with a string\r\n * which describes the error.\r\n */\r\nQHSenseConference.prototype._addLocalTrackAsUnmute = function(track) {\r\n    const addAsUnmutePromises = [];\r\n\r\n    if (this.jvbJingleSession) {\r\n        addAsUnmutePromises.push(this.jvbJingleSession.addTrackAsUnmute(track));\r\n    } else {\r\n        logger.info(\r\n            'Add local MediaStream as unmute -'\r\n                + ' no JVB Jingle session started yet');\r\n    }\r\n\r\n    if (this.p2pJingleSession) {\r\n        addAsUnmutePromises.push(this.p2pJingleSession.addTrackAsUnmute(track));\r\n    } else {\r\n        logger.info(\r\n            'Add local MediaStream as unmute -'\r\n                + ' no P2P Jingle session started yet');\r\n    }\r\n\r\n    return Promise.all(addAsUnmutePromises);\r\n};\r\n\r\n/**\r\n * Method called by the {@link QHSenseLocalTrack} (a video one) in order to remove\r\n * the underlying WebRTC MediaStream from the PeerConnection. The purpose of\r\n * that is to stop sending any data and turn off the HW camera device.\r\n * @param {QHSenseLocalTrack} track the local track that will be removed.\r\n * @return {Promise}\r\n */\r\nQHSenseConference.prototype._removeLocalTrackAsMute = function(track) {\r\n    const removeAsMutePromises = [];\r\n\r\n    if (this.jvbJingleSession) {\r\n        removeAsMutePromises.push(\r\n            this.jvbJingleSession.removeTrackAsMute(track));\r\n    } else {\r\n        logger.info(\r\n            'Remove local MediaStream - no JVB JingleSession started yet');\r\n    }\r\n    if (this.p2pJingleSession) {\r\n        removeAsMutePromises.push(\r\n            this.p2pJingleSession.removeTrackAsMute(track));\r\n    } else {\r\n        logger.info(\r\n            'Remove local MediaStream - no P2P JingleSession started yet');\r\n    }\r\n\r\n    return Promise.all(removeAsMutePromises);\r\n};\r\n\r\n/**\r\n * Get role of the local user.\r\n * @returns {string} user role: 'moderator' or 'none'\r\n */\r\nQHSenseConference.prototype.getRole = function() {\r\n    return this.room.role;\r\n};\r\n\r\n/**\r\n * Returns whether or not the current conference has been joined as a hidden\r\n * user.\r\n *\r\n * @returns {boolean|null} True if hidden, false otherwise. Will return null if\r\n * no connection is active.\r\n */\r\nQHSenseConference.prototype.isHidden = function() {\r\n    if (!this.connection) {\r\n        return null;\r\n    }\r\n\r\n    return Strophe.getDomainFromJid(this.connection.getJid())\r\n        === this.options.config.hiddenDomain;\r\n};\r\n\r\n/**\r\n * Check if local user is moderator.\r\n * @returns {boolean|null} true if local user is moderator, false otherwise. If\r\n * we're no longer in the conference room then <tt>null</tt> is returned.\r\n */\r\nQHSenseConference.prototype.isModerator = function() {\r\n    return this.room ? this.room.isModerator() : null;\r\n};\r\n\r\n/**\r\n * Set password for the room.\r\n * @param {string} password new password for the room.\r\n * @returns {Promise}\r\n */\r\nQHSenseConference.prototype.lock = function(password) {\r\n    if (!this.isModerator()) {\r\n        return Promise.reject(new Error('You are not moderator.'));\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n        this.room.lockRoom(\r\n            password || '',\r\n            () => resolve(),\r\n            err => reject(err),\r\n            () => reject(QHSenseConferenceErrors.PASSWORD_NOT_SUPPORTED));\r\n    });\r\n};\r\n\r\n/**\r\n * Remove password from the room.\r\n * @returns {Promise}\r\n */\r\nQHSenseConference.prototype.unlock = function() {\r\n    return this.lock();\r\n};\r\n\r\n/**\r\n * Elects the participant with the given id to be the selected participant in\r\n * order to receive higher video quality (if simulcast is enabled).\r\n * Or cache it if channel is not created and send it once channel is available.\r\n * @param participantId the identifier of the participant\r\n * @throws NetworkError or InvalidStateError or Error if the operation fails.\r\n * @returns {void}\r\n */\r\nQHSenseConference.prototype.selectParticipant = function(participantId) {\r\n    this.selectParticipants([ participantId ]);\r\n};\r\n\r\n/*\r\n * Elects participants with given ids to be the selected participants in order\r\n * to receive higher video quality (if simulcast is enabled). The argument\r\n * should be an array of participant id strings or an empty array; an error will\r\n * be thrown if a non-array is passed in. The error is thrown as a layer of\r\n * protection against passing an invalid argument, as the error will happen in\r\n * the bridge and may not be visible in the client.\r\n *\r\n * @param {Array<strings>} participantIds - An array of identifiers for\r\n * participants.\r\n * @returns {void}\r\n */\r\nQHSenseConference.prototype.selectParticipants = function(participantIds) {\r\n    if (!Array.isArray(participantIds)) {\r\n        throw new Error('Invalid argument; participantIds must be an array.');\r\n    }\r\n\r\n    this.rtc.selectEndpoints(participantIds);\r\n};\r\n\r\n/**\r\n * Elects the participant with the given id to be the pinned participant in\r\n * order to always receive video for this participant (even when last n is\r\n * enabled).\r\n * @param participantId the identifier of the participant\r\n * @throws NetworkError or InvalidStateError or Error if the operation fails.\r\n */\r\nQHSenseConference.prototype.pinParticipant = function(participantId) {\r\n    this.rtc.pinEndpoint(participantId);\r\n};\r\n\r\n/**\r\n * Obtains the current value for \"lastN\". See {@link setLastN} for more info.\r\n * @returns {number}\r\n */\r\nQHSenseConference.prototype.getLastN = function() {\r\n    return this.rtc.getLastN();\r\n};\r\n\r\n/**\r\n * Selects a new value for \"lastN\". The requested amount of videos are going\r\n * to be delivered after the value is in effect. Set to -1 for unlimited or\r\n * all available videos.\r\n * @param lastN the new number of videos the user would like to receive.\r\n * @throws Error or RangeError if the given value is not a number or is smaller\r\n * than -1.\r\n */\r\nQHSenseConference.prototype.setLastN = function(lastN) {\r\n    if (!Number.isInteger(lastN) && !Number.parseInt(lastN, 10)) {\r\n        throw new Error(`Invalid value for lastN: ${lastN}`);\r\n    }\r\n    const n = Number(lastN);\r\n\r\n    if (n < -1) {\r\n        throw new RangeError('lastN cannot be smaller than -1');\r\n    }\r\n    this.rtc.setLastN(n);\r\n\r\n    // If the P2P session is not fully established yet, we wait until it gets\r\n    // established.\r\n    if (this.p2pJingleSession) {\r\n        const isVideoActive = n !== 0;\r\n\r\n        this.p2pJingleSession\r\n            .setMediaTransferActive(true, isVideoActive)\r\n            .catch(error => {\r\n                logger.error(\r\n                    `Failed to adjust video transfer status (${isVideoActive})`,\r\n                    error);\r\n            });\r\n    }\r\n};\r\n\r\n/**\r\n * Checks if the participant given by participantId is currently included in\r\n * the last N.\r\n * @param {string} participantId the identifier of the participant we would\r\n * like to check.\r\n * @return {boolean} true if the participant with id is in the last N set or\r\n * if there's no last N set, false otherwise.\r\n * @deprecated this method should never be used to figure out the UI, but\r\n * {@link ParticipantConnectionStatus} should be used instead.\r\n */\r\nQHSenseConference.prototype.isInLastN = function(participantId) {\r\n    return this.rtc.isInLastN(participantId);\r\n};\r\n\r\n/**\r\n * @return Array<QHSenseParticipant> an array of all participants in this\r\n * conference.\r\n */\r\nQHSenseConference.prototype.getParticipants = function() {\r\n    return Object.keys(this.participants).map(function(key) {\r\n        return this.participants[key];\r\n    }, this);\r\n};\r\n\r\n/**\r\n * Returns the number of participants in the conference, including the local\r\n * participant.\r\n * @param countHidden {boolean} Whether or not to include hidden participants\r\n * in the count. Default: false.\r\n **/\r\nQHSenseConference.prototype.getParticipantCount\r\n    = function(countHidden = false) {\r\n\r\n        let participants = this.getParticipants();\r\n\r\n        if (!countHidden) {\r\n            participants = participants.filter(p => !p.isHidden());\r\n        }\r\n\r\n        // Add one for the local participant.\r\n        return participants.length + 1;\r\n    };\r\n\r\n/**\r\n * @returns {QHSenseParticipant} the participant in this conference with the\r\n * specified id (or undefined if there isn't one).\r\n * @param id the id of the participant.\r\n */\r\nQHSenseConference.prototype.getParticipantById = function(id) {\r\n    return this.participants[id];\r\n};\r\n\r\n/**\r\n * Kick participant from this conference.\r\n * @param {string} id id of the participant to kick\r\n */\r\nQHSenseConference.prototype.kickParticipant = function(id) {\r\n    const participant = this.getParticipantById(id);\r\n\r\n    if (!participant) {\r\n        return;\r\n    }\r\n    this.room.kick(participant.getJid());\r\n};\r\n\r\n/**\r\n * Maybe clears the timeout which emits {@link ACTION_JINGLE_SI_TIMEOUT}\r\n * analytics event.\r\n * @private\r\n */\r\nQHSenseConference.prototype._maybeClearSITimeout = function() {\r\n    if (this._sessionInitiateTimeout\r\n            && (this.jvbJingleSession || this.getParticipantCount() < 2)) {\r\n        window.clearTimeout(this._sessionInitiateTimeout);\r\n        this._sessionInitiateTimeout = null;\r\n    }\r\n};\r\n\r\n/**\r\n * Sets a timeout which will emit {@link ACTION_JINGLE_SI_TIMEOUT} analytics\r\n * event.\r\n * @private\r\n */\r\nQHSenseConference.prototype._maybeSetSITimeout = function() {\r\n    // Jicofo is supposed to invite if there are at least 2 participants\r\n    if (!this.jvbJingleSession\r\n            && this.getParticipantCount() >= 2\r\n            && !this._sessionInitiateTimeout) {\r\n        this._sessionInitiateTimeout = window.setTimeout(() => {\r\n            this._sessionInitiateTimeout = null;\r\n            Statistics.sendAnalytics(createJingleEvent(\r\n                ACTION_JINGLE_SI_TIMEOUT,\r\n                {\r\n                    p2p: false,\r\n                    value: JINGLE_SI_TIMEOUT\r\n                }));\r\n        }, JINGLE_SI_TIMEOUT);\r\n    }\r\n};\r\n\r\n/**\r\n * Mutes a participant.\r\n * @param {string} id The id of the participant to mute.\r\n */\r\nQHSenseConference.prototype.muteParticipant = function(id) {\r\n    const participant = this.getParticipantById(id);\r\n\r\n    if (!participant) {\r\n        return;\r\n    }\r\n    this.room.muteParticipant(participant.getJid(), true);\r\n};\r\n\r\n/* eslint-disable max-params */\r\n\r\n/**\r\n * Notifies this QHSenseConference that a new member has joined its chat room.\r\n *\r\n * FIXME This should NOT be exposed!\r\n *\r\n * @param jid the jid of the participant in the MUC\r\n * @param nick the display name of the participant\r\n * @param role the role of the participant in the MUC\r\n * @param isHidden indicates if this is a hidden participant (system\r\n * participant for example a recorder).\r\n * @param statsID the participant statsID (optional)\r\n * @param status the initial status if any\r\n * @param identity the member identity, if any\r\n * @param botType the member botType, if any\r\n */\r\nQHSenseConference.prototype.onMemberJoined = function(\r\n        jid, nick, role, isHidden, statsID, status, identity, botType) {\r\n    const id = Strophe.getResourceFromJid(jid);\r\n\r\n    if (id === 'focus' || this.myUserId() === id) {\r\n        return;\r\n    }\r\n\r\n    const participant\r\n        = new QHSenseParticipant(jid, this, nick, isHidden, statsID, status, identity);\r\n\r\n    participant._role = role;\r\n    participant._botType = botType;\r\n    this.participants[id] = participant;\r\n    this.eventEmitter.emit(\r\n        QHSenseConferenceEvents.USER_JOINED,\r\n        id,\r\n        participant);\r\n\r\n    this._updateFeatures(participant);\r\n\r\n    this._maybeStartOrStopP2P();\r\n    this._maybeSetSITimeout();\r\n};\r\n\r\n/* eslint-enable max-params */\r\n\r\n/**\r\n * Updates features for a participant.\r\n * @param {QHSenseParticipant} participant - The participant to query for features.\r\n * @returns {void}\r\n * @private\r\n */\r\nQHSenseConference.prototype._updateFeatures = function(participant) {\r\n    participant.getFeatures()\r\n        .then(features => {\r\n            participant._supportsDTMF = features.has('urn:xmpp:jingle:dtmf:0');\r\n            this.updateDTMFSupport();\r\n\r\n            if (features.has('http://QHSense.org/protocol/jigasi')) {\r\n                participant.setProperty('features_jigasi', true);\r\n            }\r\n        })\r\n        .catch(() => false);\r\n};\r\n\r\n/**\r\n * Get notified when member bot type had changed.\r\n * @param jid the member jid\r\n * @param botType the new botType value\r\n * @private\r\n */\r\nQHSenseConference.prototype._onMemberBotTypeChanged = function(jid, botType) {\r\n\r\n    // find the participant and mark it as non bot, as the real one will join\r\n    // in a moment\r\n    const peers = this.getParticipants();\r\n    const botParticipant = peers.find(p => p.getJid() === jid);\r\n\r\n    if (botParticipant) {\r\n        botParticipant._botType = botType;\r\n        const id = Strophe.getResourceFromJid(jid);\r\n\r\n        this.eventEmitter.emit(\r\n            QHSenseConferenceEvents.BOT_TYPE_CHANGED,\r\n            id,\r\n            botType);\r\n    }\r\n\r\n    // if botType changed to undefined, botType was removed, in case of\r\n    // poltergeist mode this is the moment when the poltergeist had exited and\r\n    // the real participant had already replaced it.\r\n    // In this case we can check and try p2p\r\n    if (!botParticipant._botType) {\r\n        this._maybeStartOrStopP2P();\r\n    }\r\n};\r\n\r\nQHSenseConference.prototype.onMemberLeft = function(jid) {\r\n    const id = Strophe.getResourceFromJid(jid);\r\n\r\n    if (id === 'focus' || this.myUserId() === id) {\r\n        return;\r\n    }\r\n\r\n    const participant = this.participants[id];\r\n\r\n    delete this.participants[id];\r\n\r\n    const removedTracks = this.rtc.removeRemoteTracks(id);\r\n\r\n    removedTracks.forEach(\r\n        track =>\r\n            this.eventEmitter.emit(QHSenseConferenceEvents.TRACK_REMOVED, track));\r\n\r\n    // there can be no participant in case the member that left is focus\r\n    if (participant) {\r\n        this.eventEmitter.emit(\r\n            QHSenseConferenceEvents.USER_LEFT, id, participant);\r\n    }\r\n\r\n    this._maybeStartOrStopP2P(true /* triggered by user left event */);\r\n    this._maybeClearSITimeout();\r\n};\r\n\r\n/**\r\n * Designates an event indicating that we were kicked from the XMPP MUC.\r\n * @param {boolean} isSelfPresence - whether it is for local participant\r\n * or another participant.\r\n * @param {string} actorId - the id of the participant who was initiator\r\n * of the kick.\r\n * @param {string?} kickedParticipantId - when it is not a kick for local participant,\r\n * this is the id of the participant which was kicked.\r\n */\r\nQHSenseConference.prototype.onMemberKicked = function(isSelfPresence, actorId, kickedParticipantId) {\r\n    const actorParticipant = this.participants[actorId];\r\n\r\n    if (isSelfPresence) {\r\n        this.eventEmitter.emit(\r\n            QHSenseConferenceEvents.KICKED, actorParticipant);\r\n\r\n        this.leave();\r\n\r\n        return;\r\n    }\r\n\r\n    const kickedParticipant = this.participants[kickedParticipantId];\r\n\r\n    this.eventEmitter.emit(\r\n        QHSenseConferenceEvents.PARTICIPANT_KICKED, actorParticipant, kickedParticipant);\r\n};\r\n\r\n/**\r\n * Method called on local MUC role change.\r\n * @param {string} role the name of new user's role as defined by XMPP MUC.\r\n */\r\nQHSenseConference.prototype.onLocalRoleChanged = function(role) {\r\n    // Emit role changed for local  JID\r\n    this.eventEmitter.emit(\r\n        QHSenseConferenceEvents.USER_ROLE_CHANGED, this.myUserId(), role);\r\n};\r\n\r\nQHSenseConference.prototype.onUserRoleChanged = function(jid, role) {\r\n    const id = Strophe.getResourceFromJid(jid);\r\n    const participant = this.getParticipantById(id);\r\n\r\n    if (!participant) {\r\n        return;\r\n    }\r\n    participant._role = role;\r\n    this.eventEmitter.emit(QHSenseConferenceEvents.USER_ROLE_CHANGED, id, role);\r\n};\r\n\r\nQHSenseConference.prototype.onDisplayNameChanged = function(jid, displayName) {\r\n    const id = Strophe.getResourceFromJid(jid);\r\n    const participant = this.getParticipantById(id);\r\n\r\n    if (!participant) {\r\n        return;\r\n    }\r\n\r\n    if (participant._displayName === displayName) {\r\n        return;\r\n    }\r\n\r\n    participant._displayName = displayName;\r\n    this.eventEmitter.emit(\r\n        QHSenseConferenceEvents.DISPLAY_NAME_CHANGED,\r\n        id,\r\n        displayName);\r\n};\r\n\r\n/**\r\n * Notifies this QHSenseConference that a QHSenseRemoteTrack was added into\r\n * the conference.\r\n *\r\n * @param {QHSenseRemoteTrack} track the QHSenseRemoteTrack which was added to this\r\n * QHSenseConference\r\n */\r\nQHSenseConference.prototype.onRemoteTrackAdded = function(track) {\r\n    if (track.isP2P && !this.isP2PActive()) {\r\n        logger.info(\r\n            'Trying to add remote P2P track, when not in P2P - IGNORED');\r\n\r\n        return;\r\n    } else if (!track.isP2P && this.isP2PActive()) {\r\n        logger.info(\r\n            'Trying to add remote JVB track, when in P2P - IGNORED');\r\n\r\n        return;\r\n    }\r\n\r\n    const id = track.getParticipantId();\r\n    const participant = this.getParticipantById(id);\r\n\r\n    if (!participant) {\r\n        logger.error(`No participant found for id: ${id}`);\r\n\r\n        return;\r\n    }\r\n\r\n    // Add track to QHSenseParticipant.\r\n    participant._tracks.push(track);\r\n\r\n    if (this.transcriber) {\r\n        this.transcriber.addTrack(track);\r\n    }\r\n\r\n    const emitter = this.eventEmitter;\r\n\r\n    track.addEventListener(\r\n        QHSenseTrackEvents.TRACK_MUTE_CHANGED,\r\n        () => emitter.emit(QHSenseConferenceEvents.TRACK_MUTE_CHANGED, track));\r\n    track.addEventListener(\r\n        QHSenseTrackEvents.TRACK_AUDIO_LEVEL_CHANGED,\r\n        (audioLevel, tpc) => {\r\n            const activeTPC = this.getActivePeerConnection();\r\n\r\n            if (activeTPC === tpc) {\r\n                emitter.emit(\r\n                    QHSenseConferenceEvents.TRACK_AUDIO_LEVEL_CHANGED,\r\n                    id,\r\n                    audioLevel);\r\n            }\r\n        }\r\n    );\r\n\r\n    emitter.emit(QHSenseConferenceEvents.TRACK_ADDED, track);\r\n};\r\n\r\n/**\r\n * Callback called by the Jingle plugin when 'session-answer' is received.\r\n * @param {JingleSessionPC} session the Jingle session for which an answer was\r\n * received.\r\n * @param {jQuery} answer a jQuery selector pointing to 'jingle' IQ element\r\n */\r\n// eslint-disable-next-line no-unused-vars\r\nQHSenseConference.prototype.onCallAccepted = function(session, answer) {\r\n    if (this.p2pJingleSession === session) {\r\n        logger.info('P2P setAnswer');\r\n        this.p2pJingleSession.setAnswer(answer);\r\n    }\r\n};\r\n\r\n/**\r\n * Callback called by the Jingle plugin when 'transport-info' is received.\r\n * @param {JingleSessionPC} session the Jingle session for which the IQ was\r\n * received\r\n * @param {jQuery} transportInfo a jQuery selector pointing to 'jingle' IQ\r\n * element\r\n */\r\n// eslint-disable-next-line no-unused-vars\r\nQHSenseConference.prototype.onTransportInfo = function(session, transportInfo) {\r\n    if (this.p2pJingleSession === session) {\r\n        logger.info('P2P addIceCandidates');\r\n        this.p2pJingleSession.addIceCandidates(transportInfo);\r\n    }\r\n};\r\n\r\n/**\r\n * Notifies this QHSenseConference that a QHSenseRemoteTrack was removed from\r\n * the conference.\r\n *\r\n * @param {QHSenseRemoteTrack} removedTrack\r\n */\r\nQHSenseConference.prototype.onRemoteTrackRemoved = function(removedTrack) {\r\n    this.getParticipants().forEach(participant => {\r\n        const tracks = participant.getTracks();\r\n\r\n        for (let i = 0; i < tracks.length; i++) {\r\n            if (tracks[i] === removedTrack) {\r\n                // Since the tracks have been compared and are\r\n                // considered equal the result of splice can be ignored.\r\n                participant._tracks.splice(i, 1);\r\n\r\n                this.eventEmitter.emit(\r\n                    QHSenseConferenceEvents.TRACK_REMOVED, removedTrack);\r\n\r\n                if (this.transcriber) {\r\n                    this.transcriber.removeTrack(removedTrack);\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n    }, this);\r\n};\r\n\r\n/**\r\n * Handles an incoming call event for the P2P jingle session.\r\n */\r\nQHSenseConference.prototype._onIncomingCallP2P = function(\r\n        jingleSession,\r\n        jingleOffer) {\r\n\r\n    let rejectReason;\r\n\r\n    if (!browser.supportsP2P()) {\r\n        rejectReason = {\r\n            reason: 'unsupported-applications',\r\n            reasonDescription: 'P2P not supported',\r\n            errorMsg: 'This client does not support P2P connections'\r\n        };\r\n    } else if (!this.isP2PEnabled() && !this.isP2PTestModeEnabled()) {\r\n        rejectReason = {\r\n            reason: 'decline',\r\n            reasonDescription: 'P2P disabled',\r\n            errorMsg: 'P2P mode disabled in the configuration'\r\n        };\r\n    } else if (this.p2pJingleSession) {\r\n        // Reject incoming P2P call (already in progress)\r\n        rejectReason = {\r\n            reason: 'busy',\r\n            reasonDescription: 'P2P already in progress',\r\n            errorMsg: 'Duplicated P2P \"session-initiate\"'\r\n        };\r\n    }\r\n\r\n    if (rejectReason) {\r\n        this._rejectIncomingCall(jingleSession, rejectReason);\r\n    } else {\r\n        this._acceptP2PIncomingCall(jingleSession, jingleOffer);\r\n    }\r\n};\r\n\r\n/**\r\n * Handles an incoming call event.\r\n */\r\nQHSenseConference.prototype.onIncomingCall = function(\r\n        jingleSession,\r\n        jingleOffer,\r\n        now) {\r\n    // Handle incoming P2P call\r\n    if (jingleSession.isP2P) {\r\n        this._onIncomingCallP2P(jingleSession, jingleOffer);\r\n    } else {\r\n        if (!this.room.isFocus(jingleSession.remoteJid)) {\r\n            const description = 'Rejecting session-initiate from non-focus.';\r\n\r\n            this._rejectIncomingCall(\r\n                jingleSession, {\r\n                    reason: 'security-error',\r\n                    reasonDescription: description,\r\n                    errorMsg: description\r\n                });\r\n\r\n            return;\r\n        }\r\n        this._acceptJvbIncomingCall(jingleSession, jingleOffer, now);\r\n    }\r\n};\r\n\r\n/**\r\n * Accepts an incoming call event for the JVB jingle session.\r\n */\r\nQHSenseConference.prototype._acceptJvbIncomingCall = function(\r\n        jingleSession,\r\n        jingleOffer,\r\n        now) {\r\n\r\n    // Accept incoming call\r\n    this.jvbJingleSession = jingleSession;\r\n    this.room.connectionTimes['session.initiate'] = now;\r\n\r\n    if (this.wasStopped) {\r\n        Statistics.sendAnalyticsAndLog(\r\n            createJingleEvent(ACTION_JINGLE_RESTART, { p2p: false }));\r\n    }\r\n\r\n    const serverRegion\r\n        = $(jingleOffer)\r\n            .find('>bridge-session[xmlns=\"http://QHSense.org/protocol/focus\"]')\r\n            .attr('region');\r\n\r\n    this.eventEmitter.emit(\r\n        QHSenseConferenceEvents.SERVER_REGION_CHANGED,\r\n        serverRegion);\r\n\r\n    this._maybeClearSITimeout();\r\n    Statistics.sendAnalytics(createJingleEvent(\r\n        ACTION_JINGLE_SI_RECEIVED,\r\n        {\r\n            p2p: false,\r\n            value: now\r\n        }));\r\n    try {\r\n        jingleSession.initialize(this.room, this.rtc, this.options.config);\r\n    } catch (error) {\r\n        GlobalOnErrorHandler.callErrorHandler(error);\r\n    }\r\n\r\n    // Open a channel with the videobridge.\r\n    this._setBridgeChannel(jingleOffer, jingleSession.peerconnection);\r\n\r\n    // Add local tracks to the session\r\n    try {\r\n        jingleSession.acceptOffer(\r\n            jingleOffer,\r\n            () => {\r\n                // If for any reason invite for the JVB session arrived after\r\n                // the P2P has been established already the media transfer needs\r\n                // to be turned off here.\r\n                if (this.isP2PActive() && this.jvbJingleSession) {\r\n                    this._suspendMediaTransferForJvbConnection();\r\n                }\r\n            },\r\n            error => {\r\n                GlobalOnErrorHandler.callErrorHandler(error);\r\n                logger.error(\r\n                    'Failed to accept incoming Jingle session', error);\r\n            },\r\n            this.getLocalTracks()\r\n        );\r\n\r\n        // Start callstats as soon as peerconnection is initialized,\r\n        // do not wait for XMPPEvents.PEERCONNECTION_READY, as it may never\r\n        // happen in case if user doesn't have or denied permission to\r\n        // both camera and microphone.\r\n        logger.info('Starting CallStats for JVB connection...');\r\n        this.statistics.startCallStats(\r\n            this.jvbJingleSession.peerconnection,\r\n            'QHSense' /* Remote user ID for JVB is 'QHSense' */);\r\n        this.statistics.startRemoteStats(this.jvbJingleSession.peerconnection);\r\n    } catch (e) {\r\n        GlobalOnErrorHandler.callErrorHandler(e);\r\n        logger.error(e);\r\n    }\r\n};\r\n\r\n/**\r\n * Sets the BridgeChannel.\r\n *\r\n * @param {jQuery} offerIq a jQuery selector pointing to the jingle element of\r\n * the offer IQ which may carry the WebSocket URL for the 'websocket'\r\n * BridgeChannel mode.\r\n * @param {TraceablePeerConnection} pc the peer connection which will be used\r\n * to listen for new WebRTC Data Channels (in the 'datachannel' mode).\r\n */\r\nQHSenseConference.prototype._setBridgeChannel = function(offerIq, pc) {\r\n    let wsUrl = null;\r\n    const webSocket\r\n        = $(offerIq)\r\n            .find('>content>transport>web-socket')\r\n            .first();\r\n\r\n    if (webSocket.length === 1) {\r\n        wsUrl = webSocket[0].getAttribute('url');\r\n    }\r\n\r\n    let bridgeChannelType;\r\n\r\n    switch (this.options.config.openBridgeChannel) {\r\n    case 'datachannel':\r\n    case true:\r\n    case undefined:\r\n        bridgeChannelType = 'datachannel';\r\n        break;\r\n    case 'websocket':\r\n        bridgeChannelType = 'websocket';\r\n        break;\r\n    }\r\n\r\n    if (bridgeChannelType === 'datachannel'\r\n        && !browser.supportsDataChannels()) {\r\n        bridgeChannelType = 'websocket';\r\n    }\r\n\r\n    if (bridgeChannelType === 'datachannel') {\r\n        this.rtc.initializeBridgeChannel(pc, null);\r\n    } else if (bridgeChannelType === 'websocket' && wsUrl) {\r\n        this.rtc.initializeBridgeChannel(null, wsUrl);\r\n    }\r\n};\r\n\r\n/**\r\n * Rejects incoming Jingle call.\r\n * @param {JingleSessionPC} jingleSession the session instance to be rejected.\r\n * @param {object} [options]\r\n * @param {string} options.reason the name of the reason element as defined\r\n * by Jingle\r\n * @param {string} options.reasonDescription the reason description which will\r\n * be included in Jingle 'session-terminate' message.\r\n * @param {string} options.errorMsg an error message to be logged on global\r\n * error handler\r\n * @private\r\n */\r\nQHSenseConference.prototype._rejectIncomingCall = function(\r\n        jingleSession,\r\n        options) {\r\n    if (options && options.errorMsg) {\r\n        GlobalOnErrorHandler.callErrorHandler(new Error(options.errorMsg));\r\n    }\r\n\r\n    // Terminate the jingle session with a reason\r\n    jingleSession.terminate(\r\n        null /* success callback => we don't care */,\r\n        error => {\r\n            logger.warn(\r\n                'An error occurred while trying to terminate'\r\n                    + ' invalid Jingle session', error);\r\n        }, {\r\n            reason: options && options.reason,\r\n            reasonDescription: options && options.reasonDescription,\r\n            sendSessionTerminate: true\r\n        });\r\n};\r\n\r\n/**\r\n * Handles the call ended event.\r\n * XXX is this due to the remote side terminating the Jingle session?\r\n *\r\n * @param {JingleSessionPC} jingleSession the jingle session which has been\r\n * terminated.\r\n * @param {String} reasonCondition the Jingle reason condition.\r\n * @param {String|null} reasonText human readable reason text which may provide\r\n * more details about why the call has been terminated.\r\n */\r\nQHSenseConference.prototype.onCallEnded = function(\r\n        jingleSession,\r\n        reasonCondition,\r\n        reasonText) {\r\n    logger.info(\r\n        `Call ended: ${reasonCondition} - ${reasonText} P2P ?${\r\n            jingleSession.isP2P}`);\r\n    if (jingleSession === this.jvbJingleSession) {\r\n        this.wasStopped = true;\r\n\r\n        Statistics.sendAnalytics(\r\n            createJingleEvent(ACTION_JINGLE_TERMINATE, { p2p: false }));\r\n\r\n        // Stop the stats\r\n        if (this.statistics) {\r\n            this.statistics.stopRemoteStats(\r\n                this.jvbJingleSession.peerconnection);\r\n            logger.info('Stopping JVB CallStats');\r\n            this.statistics.stopCallStats(\r\n                this.jvbJingleSession.peerconnection);\r\n        }\r\n\r\n        // Current JVB JingleSession is no longer valid, so set it to null\r\n        this.jvbJingleSession = null;\r\n\r\n        // Let the RTC service do any cleanups\r\n        this.rtc.onCallEnded();\r\n    } else if (jingleSession === this.p2pJingleSession) {\r\n        // It's the responder who decides to enforce JVB mode, so that both\r\n        // initiator and responder are aware if it was intentional.\r\n        if (reasonCondition === 'decline' && reasonText === 'force JVB121') {\r\n            logger.info('In forced JVB 121 mode...');\r\n            Statistics.analytics.addPermanentProperties({ forceJvb121: true });\r\n        } else if (reasonCondition === 'connectivity-error'\r\n            && reasonText === 'ICE FAILED') {\r\n            // It can happen that the other peer detects ICE failed and\r\n            // terminates the session, before we get the event on our side.\r\n            // But we are able to parse the reason and mark it here.\r\n            Statistics.analytics.addPermanentProperties({ p2pFailed: true });\r\n        }\r\n        this._stopP2PSession();\r\n    } else {\r\n        logger.error(\r\n            'Received onCallEnded for invalid session',\r\n            jingleSession.sid,\r\n            jingleSession.remoteJid,\r\n            reasonCondition,\r\n            reasonText);\r\n    }\r\n};\r\n\r\n/**\r\n * Handles the suspend detected event. Leaves the room and fires suspended.\r\n * @param {JingleSessionPC} jingleSession\r\n */\r\nQHSenseConference.prototype.onSuspendDetected = function(jingleSession) {\r\n    if (!jingleSession.isP2P) {\r\n        this.leave();\r\n        this.eventEmitter.emit(QHSenseConferenceEvents.SUSPEND_DETECTED);\r\n    }\r\n};\r\n\r\nQHSenseConference.prototype.updateDTMFSupport = function() {\r\n    let somebodySupportsDTMF = false;\r\n    const participants = this.getParticipants();\r\n\r\n    // check if at least 1 participant supports DTMF\r\n    for (let i = 0; i < participants.length; i += 1) {\r\n        if (participants[i].supportsDTMF()) {\r\n            somebodySupportsDTMF = true;\r\n            break;\r\n        }\r\n    }\r\n    if (somebodySupportsDTMF !== this.somebodySupportsDTMF) {\r\n        this.somebodySupportsDTMF = somebodySupportsDTMF;\r\n        this.eventEmitter.emit(\r\n            QHSenseConferenceEvents.DTMF_SUPPORT_CHANGED,\r\n            somebodySupportsDTMF);\r\n    }\r\n};\r\n\r\n/**\r\n * Allows to check if there is at least one user in the conference\r\n * that supports DTMF.\r\n * @returns {boolean} true if somebody supports DTMF, false otherwise\r\n */\r\nQHSenseConference.prototype.isDTMFSupported = function() {\r\n    return this.somebodySupportsDTMF;\r\n};\r\n\r\n/**\r\n * Returns the local user's ID\r\n * @return {string} local user's ID\r\n */\r\nQHSenseConference.prototype.myUserId = function() {\r\n    return (\r\n        this.room && this.room.myroomjid\r\n            ? Strophe.getResourceFromJid(this.room.myroomjid)\r\n            : null);\r\n};\r\n\r\nQHSenseConference.prototype.sendTones = function(tones, duration, pause) {\r\n    if (!this.dtmfManager) {\r\n        const peerConnection = this.getActivePeerConnection();\r\n\r\n        if (!peerConnection) {\r\n            logger.warn('cannot sendTones: no peer connection');\r\n\r\n            return;\r\n        }\r\n\r\n        const localAudio = this.getLocalAudioTrack();\r\n\r\n        if (!localAudio) {\r\n            logger.warn('cannot sendTones: no local audio stream');\r\n\r\n            return;\r\n        }\r\n        this.dtmfManager = new QHSenseDTMFManager(localAudio, peerConnection);\r\n    }\r\n\r\n    this.dtmfManager.sendTones(tones, duration, pause);\r\n};\r\n\r\n/**\r\n * Starts recording the current conference.\r\n *\r\n * @param {Object} options - Configuration for the recording. See\r\n * {@link Chatroom#startRecording} for more info.\r\n * @returns {Promise} See {@link Chatroom#startRecording} for more info.\r\n */\r\nQHSenseConference.prototype.startRecording = function(options) {\r\n    if (this.room) {\r\n        return this.recordingManager.startRecording(options);\r\n    }\r\n\r\n    return Promise.reject(new Error('The conference is not created yet!'));\r\n};\r\n\r\n/**\r\n * Stop a recording session.\r\n *\r\n * @param {string} sessionID - The ID of the recording session that\r\n * should be stopped.\r\n * @returns {Promise} See {@link Chatroom#stopRecording} for more info.\r\n */\r\nQHSenseConference.prototype.stopRecording = function(sessionID) {\r\n    if (this.room) {\r\n        return this.recordingManager.stopRecording(sessionID);\r\n    }\r\n\r\n    return Promise.reject(new Error('The conference is not created yet!'));\r\n};\r\n\r\n/**\r\n * Returns true if the SIP calls are supported and false otherwise\r\n */\r\nQHSenseConference.prototype.isSIPCallingSupported = function() {\r\n    if (this.room) {\r\n        return this.room.isSIPCallingSupported();\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * Dials a number.\r\n * @param number the number\r\n */\r\nQHSenseConference.prototype.dial = function(number) {\r\n    if (this.room) {\r\n        return this.room.dial(number);\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n        reject(new Error('The conference is not created yet!'));\r\n    });\r\n};\r\n\r\n/**\r\n * Hangup an existing call\r\n */\r\nQHSenseConference.prototype.hangup = function() {\r\n    if (this.room) {\r\n        return this.room.hangup();\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n        reject(new Error('The conference is not created yet!'));\r\n    });\r\n};\r\n\r\n/**\r\n * Starts the transcription service.\r\n */\r\nQHSenseConference.prototype.startTranscriber = function() {\r\n    return this.dial('QHSense_meet_transcribe');\r\n};\r\n\r\n\r\n/**\r\n * Stops the transcription service.\r\n */\r\nQHSenseConference.prototype.stopTranscriber = QHSenseConference.prototype.hangup;\r\n\r\n/**\r\n * Returns the phone number for joining the conference.\r\n */\r\nQHSenseConference.prototype.getPhoneNumber = function() {\r\n    if (this.room) {\r\n        return this.room.getPhoneNumber();\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the pin for joining the conference with phone.\r\n */\r\nQHSenseConference.prototype.getPhonePin = function() {\r\n    if (this.room) {\r\n        return this.room.getPhonePin();\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Will return P2P or JVB <tt>TraceablePeerConnection</tt> depending on\r\n * which connection is currently active.\r\n *\r\n * @return {TraceablePeerConnection|null} null if there isn't any active\r\n * <tt>TraceablePeerConnection</tt> currently available.\r\n * @public (FIXME how to make package local ?)\r\n */\r\nQHSenseConference.prototype.getActivePeerConnection = function() {\r\n    if (this.isP2PActive()) {\r\n        return this.p2pJingleSession.peerconnection;\r\n    }\r\n\r\n    return this.jvbJingleSession ? this.jvbJingleSession.peerconnection : null;\r\n};\r\n\r\n/**\r\n * Returns the connection state for the current room. Its ice connection state\r\n * for its session.\r\n * NOTE that \"completed\" ICE state which can appear on the P2P connection will\r\n * be converted to \"connected\".\r\n * @return {string|null} ICE state name or <tt>null</tt> if there is no active\r\n * peer connection at this time.\r\n */\r\nQHSenseConference.prototype.getConnectionState = function() {\r\n    const peerConnection = this.getActivePeerConnection();\r\n\r\n    return peerConnection ? peerConnection.getConnectionState() : null;\r\n};\r\n\r\n/**\r\n * Make all new participants mute their audio/video on join.\r\n * @param policy {Object} object with 2 boolean properties for video and audio:\r\n * @param {boolean} audio if audio should be muted.\r\n * @param {boolean} video if video should be muted.\r\n */\r\nQHSenseConference.prototype.setStartMutedPolicy = function(policy) {\r\n    if (!this.isModerator()) {\r\n        return;\r\n    }\r\n    this.startMutedPolicy = policy;\r\n    this.room.removeFromPresence('startmuted');\r\n    this.room.addToPresence('startmuted', {\r\n        attributes: {\r\n            audio: policy.audio,\r\n            video: policy.video,\r\n            xmlns: 'http://QHSense.org/jitmeet/start-muted'\r\n        }\r\n    });\r\n    this.room.sendPresence();\r\n};\r\n\r\n/**\r\n * Returns current start muted policy\r\n * @returns {Object} with 2 properties - audio and video.\r\n */\r\nQHSenseConference.prototype.getStartMutedPolicy = function() {\r\n    return this.startMutedPolicy;\r\n};\r\n\r\n/**\r\n * Check if audio is muted on join.\r\n */\r\nQHSenseConference.prototype.isStartAudioMuted = function() {\r\n    return this.startAudioMuted;\r\n};\r\n\r\n/**\r\n * Check if video is muted on join.\r\n */\r\nQHSenseConference.prototype.isStartVideoMuted = function() {\r\n    return this.startVideoMuted;\r\n};\r\n\r\n/**\r\n * Get object with internal logs.\r\n */\r\nQHSenseConference.prototype.getLogs = function() {\r\n    const data = this.xmpp.getJingleLog();\r\n\r\n    const metadata = {};\r\n\r\n    metadata.time = new Date();\r\n    metadata.url = window.location.href;\r\n    metadata.ua = navigator.userAgent;\r\n\r\n    const log = this.xmpp.getXmppLog();\r\n\r\n    if (log) {\r\n        metadata.xmpp = log;\r\n    }\r\n\r\n    data.metadata = metadata;\r\n\r\n    return data;\r\n};\r\n\r\n/**\r\n * Returns measured connectionTimes.\r\n */\r\nQHSenseConference.prototype.getConnectionTimes = function() {\r\n    return this.room.connectionTimes;\r\n};\r\n\r\n/**\r\n * Sets a property for the local participant.\r\n */\r\nQHSenseConference.prototype.setLocalParticipantProperty = function(name, value) {\r\n    this.sendCommand(`QHSense_participant_${name}`, { value });\r\n};\r\n\r\n/**\r\n *  Removes a property for the local participant and sends the updated presence.\r\n */\r\nQHSenseConference.prototype.removeLocalParticipantProperty = function(name) {\r\n    this.removeCommand(`QHSense_participant_${name}`);\r\n    this.room.sendPresence();\r\n};\r\n\r\n/**\r\n * Gets a local participant property.\r\n *\r\n * @return value of the local participant property if the tagName exists in the\r\n * list of properties, otherwise returns undefined.\r\n */\r\nQHSenseConference.prototype.getLocalParticipantProperty = function(name) {\r\n    const property = this.room.presMap.nodes.find(prop =>\r\n        prop.tagName === `QHSense_participant_${name}`\r\n    );\r\n\r\n    return property ? property.value : undefined;\r\n};\r\n\r\n/**\r\n * Sends the given feedback through CallStats if enabled.\r\n *\r\n * @param overallFeedback an integer between 1 and 5 indicating the\r\n * user feedback\r\n * @param detailedFeedback detailed feedback from the user. Not yet used\r\n */\r\nQHSenseConference.prototype.sendFeedback = function(\r\n        overallFeedback,\r\n        detailedFeedback) {\r\n    this.statistics.sendFeedback(overallFeedback, detailedFeedback);\r\n};\r\n\r\n/**\r\n * Returns true if the callstats integration is enabled, otherwise returns\r\n * false.\r\n *\r\n * @returns true if the callstats integration is enabled, otherwise returns\r\n * false.\r\n */\r\nQHSenseConference.prototype.isCallstatsEnabled = function() {\r\n    return this.statistics.isCallstatsEnabled();\r\n};\r\n\r\n\r\n/**\r\n * Handles track attached to container (Calls associateStreamWithVideoTag method\r\n * from statistics module)\r\n * @param {QHSenseLocalTrack|QHSenseRemoteTrack} track the track\r\n * @param container the container\r\n */\r\nQHSenseConference.prototype._onTrackAttach = function(track, container) {\r\n    const isLocal = track.isLocal();\r\n    let ssrc = null;\r\n    const isP2P = track.isP2P;\r\n    const remoteUserId = isP2P ? track.getParticipantId() : 'QHSense';\r\n    const peerConnection\r\n        = isP2P\r\n            ? this.p2pJingleSession && this.p2pJingleSession.peerconnection\r\n            : this.jvbJingleSession && this.jvbJingleSession.peerconnection;\r\n\r\n    if (isLocal) {\r\n        // Local tracks have SSRC stored on per peer connection basis\r\n        if (peerConnection) {\r\n            ssrc = peerConnection.getLocalSSRC(track);\r\n        }\r\n    } else {\r\n        ssrc = track.getSSRC();\r\n    }\r\n    if (!container.id || !ssrc || !peerConnection) {\r\n        return;\r\n    }\r\n\r\n    this.statistics.associateStreamWithVideoTag(\r\n        peerConnection,\r\n        ssrc,\r\n        isLocal,\r\n        remoteUserId,\r\n        track.getUsageLabel(),\r\n        container.id);\r\n};\r\n\r\n/**\r\n * Logs an \"application log\" message.\r\n * @param message {string} The message to log. Note that while this can be a\r\n * generic string, the convention used by lib-QHSense-meet and QHSense-meet is to\r\n * log valid JSON strings, with an \"id\" field used for distinguishing between\r\n * message types. E.g.: {id: \"recorder_status\", status: \"off\"}\r\n */\r\nQHSenseConference.prototype.sendApplicationLog = function(message) {\r\n    Statistics.sendLog(message);\r\n};\r\n\r\n/**\r\n * Checks if the user identified by given <tt>mucJid</tt> is the conference\r\n * focus.\r\n * @param mucJid the full MUC address of the user to be checked.\r\n * @returns {boolean|null} <tt>true</tt> if MUC user is the conference focus,\r\n * <tt>false</tt> when is not. <tt>null</tt> if we're not in the MUC anymore and\r\n * are unable to figure out the status or if given <tt>mucJid</tt> is invalid.\r\n */\r\nQHSenseConference.prototype._isFocus = function(mucJid) {\r\n    return this.room ? this.room.isFocus(mucJid) : null;\r\n};\r\n\r\n/**\r\n * Fires CONFERENCE_FAILED event with INCOMPATIBLE_SERVER_VERSIONS parameter\r\n */\r\nQHSenseConference.prototype._fireIncompatibleVersionsEvent = function() {\r\n    this.eventEmitter.emit(QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n        QHSenseConferenceErrors.INCOMPATIBLE_SERVER_VERSIONS);\r\n};\r\n\r\n/**\r\n * Sends a message via the data channel.\r\n * @param to {string} the id of the endpoint that should receive the message.\r\n * If \"\" the message will be sent to all participants.\r\n * @param payload {object} the payload of the message.\r\n * @throws NetworkError or InvalidStateError or Error if the operation fails.\r\n * @deprecated Use 'sendMessage' instead. TODO: this should be private.\r\n */\r\nQHSenseConference.prototype.sendEndpointMessage = function(to, payload) {\r\n    this.rtc.sendChannelMessage(to, payload);\r\n};\r\n\r\n/**\r\n * Sends a broadcast message via the data channel.\r\n * @param payload {object} the payload of the message.\r\n * @throws NetworkError or InvalidStateError or Error if the operation fails.\r\n * @deprecated Use 'sendMessage' instead. TODO: this should be private.\r\n */\r\nQHSenseConference.prototype.broadcastEndpointMessage = function(payload) {\r\n    this.sendEndpointMessage('', payload);\r\n};\r\n\r\n/**\r\n * Sends a message to a given endpoint (if 'to' is a non-empty string), or\r\n * broadcasts it to all endpoints in the conference.\r\n * @param {string} to The ID of the endpoint/participant which is to receive\r\n * the message, or '' to broadcast the message to all endpoints in the\r\n * conference.\r\n * @param {string|object} message the message to send. If this is of type\r\n * 'string' it will be sent as a chat message. If it is of type 'object', it\r\n * will be encapsulated in a format recognized by QHSense-meet and converted to\r\n * JSON before being sent.\r\n * @param {boolean} sendThroughVideobridge Whether to send the message through\r\n * QHSense-videobridge (via the COLIBRI data channel or web socket), or through\r\n * the XMPP MUC. Currently only objects can be sent through QHSense-videobridge.\r\n */\r\nQHSenseConference.prototype.sendMessage = function(\r\n        message,\r\n        to = '',\r\n        sendThroughVideobridge = false) {\r\n    const messageType = typeof message;\r\n\r\n    // Through videobridge we support only objects. Through XMPP we support\r\n    // objects (encapsulated in a specific JSON format) and strings (i.e.\r\n    // regular chat messages).\r\n    if (messageType !== 'object'\r\n            && (sendThroughVideobridge || messageType !== 'string')) {\r\n        logger.error(`Can not send a message of type ${messageType}`);\r\n\r\n        return;\r\n    }\r\n\r\n    if (sendThroughVideobridge) {\r\n        this.sendEndpointMessage(to, message);\r\n    } else {\r\n        let messageToSend = message;\r\n\r\n        // Name of packet extension of message stanza to send the required\r\n        // message in.\r\n        let elementName = 'body';\r\n\r\n        if (messageType === 'object') {\r\n            elementName = 'json-message';\r\n\r\n            // Mark as valid JSON message if not already\r\n            if (!messageToSend.hasOwnProperty(QHSENSE_MEET_MUC_TYPE)) {\r\n                messageToSend[QHSENSE_MEET_MUC_TYPE] = '';\r\n            }\r\n\r\n            try {\r\n                messageToSend = JSON.stringify(messageToSend);\r\n            } catch (e) {\r\n                logger.error('Can not send a message, stringify failed: ', e);\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (to) {\r\n            this.sendPrivateTextMessage(to, messageToSend, elementName);\r\n        } else {\r\n            // Broadcast\r\n            this.sendTextMessage(messageToSend, elementName);\r\n        }\r\n    }\r\n\r\n};\r\n\r\nQHSenseConference.prototype.isConnectionInterrupted = function() {\r\n    return this.isP2PActive()\r\n        ? this.isP2PConnectionInterrupted : this.isJvbConnectionInterrupted;\r\n};\r\n\r\n/**\r\n * Handles {@link XMPPEvents.CONNECTION_INTERRUPTED}\r\n * @param {JingleSessionPC} session\r\n * @private\r\n */\r\nQHSenseConference.prototype._onIceConnectionInterrupted = function(session) {\r\n    if (session.isP2P) {\r\n        this.isP2PConnectionInterrupted = true;\r\n    } else {\r\n        this.isJvbConnectionInterrupted = true;\r\n    }\r\n    if (session.isP2P === this.isP2PActive()) {\r\n        this.eventEmitter.emit(QHSenseConferenceEvents.CONNECTION_INTERRUPTED);\r\n    }\r\n};\r\n\r\n/**\r\n * Handles {@link XMPPEvents.CONNECTION_ICE_FAILED}\r\n * @param {JingleSessionPC} session\r\n * @private\r\n */\r\nQHSenseConference.prototype._onIceConnectionFailed = function(session) {\r\n    // We do nothing for the JVB connection, because it's up to the Jicofo to\r\n    // eventually come up with the new offer (at least for the time being).\r\n    if (session.isP2P) {\r\n        // Add p2pFailed property to analytics to distinguish, between \"good\"\r\n        // and \"bad\" connection\r\n        Statistics.analytics.addPermanentProperties({ p2pFailed: true });\r\n\r\n        if (this.p2pJingleSession) {\r\n            Statistics.sendAnalyticsAndLog(\r\n                createP2PEvent(\r\n                    ACTION_P2P_FAILED,\r\n                    {\r\n                        initiator: this.p2pJingleSession.isInitiator\r\n                    }));\r\n\r\n        }\r\n        this._stopP2PSession('connectivity-error', 'ICE FAILED');\r\n    } else if (session && this.jvbJingleSession === session) {\r\n        if (this.xmpp.isPingSupported()) {\r\n            this._delayedIceFailed = new IceFailedNotification(this);\r\n            this._delayedIceFailed.start(session);\r\n        } else {\r\n            // Let Jicofo know that the JVB's ICE connection has failed\r\n            logger.info('PING not supported - sending ICE failed immediately');\r\n            session.sendIceFailedNotification();\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Handles {@link XMPPEvents.CONNECTION_RESTORED}\r\n * @param {JingleSessionPC} session\r\n * @private\r\n */\r\nQHSenseConference.prototype._onIceConnectionRestored = function(session) {\r\n    if (session.isP2P) {\r\n        this.isP2PConnectionInterrupted = false;\r\n    } else {\r\n        this.isJvbConnectionInterrupted = false;\r\n        this._delayedIceFailed && this._delayedIceFailed.cancel();\r\n    }\r\n\r\n    if (session.isP2P === this.isP2PActive()) {\r\n        this.eventEmitter.emit(QHSenseConferenceEvents.CONNECTION_RESTORED);\r\n    }\r\n};\r\n\r\n/**\r\n * Accept incoming P2P Jingle call.\r\n * @param {JingleSessionPC} jingleSession the session instance\r\n * @param {jQuery} jingleOffer a jQuery selector pointing to 'jingle' IQ element\r\n * @private\r\n */\r\nQHSenseConference.prototype._acceptP2PIncomingCall = function(\r\n        jingleSession,\r\n        jingleOffer) {\r\n    this.isP2PConnectionInterrupted = false;\r\n\r\n    // Accept the offer\r\n    this.p2pJingleSession = jingleSession;\r\n\r\n    this.p2pJingleSession.initialize(this.room, this.rtc, this.options.config);\r\n\r\n    logger.info('Starting CallStats for P2P connection...');\r\n\r\n    let remoteID = Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);\r\n\r\n    if (this.options.config.enableStatsID) {\r\n        const participant = this.participants[remoteID];\r\n\r\n        if (participant) {\r\n            remoteID = participant.getStatsID() || remoteID;\r\n        }\r\n    }\r\n\r\n    this.statistics.startCallStats(\r\n        this.p2pJingleSession.peerconnection,\r\n        remoteID);\r\n\r\n    const localTracks = this.getLocalTracks();\r\n\r\n    this.p2pJingleSession.acceptOffer(\r\n        jingleOffer,\r\n        () => {\r\n            logger.debug('Got RESULT for P2P \"session-accept\"');\r\n        },\r\n        error => {\r\n            logger.error(\r\n                'Failed to accept incoming P2P Jingle session', error);\r\n        },\r\n        localTracks);\r\n};\r\n\r\n/**\r\n * Adds remote tracks to the conference associated with the JVB session.\r\n * @private\r\n */\r\nQHSenseConference.prototype._addRemoteJVBTracks = function() {\r\n    this._addRemoteTracks(\r\n        'JVB', this.jvbJingleSession.peerconnection.getRemoteTracks());\r\n};\r\n\r\n/**\r\n * Adds remote tracks to the conference associated with the P2P session.\r\n * @private\r\n */\r\nQHSenseConference.prototype._addRemoteP2PTracks = function() {\r\n    this._addRemoteTracks(\r\n        'P2P', this.p2pJingleSession.peerconnection.getRemoteTracks());\r\n};\r\n\r\n/**\r\n * Generates fake \"remote track added\" events for given Jingle session.\r\n * @param {string} logName the session's nickname which will appear in log\r\n * messages.\r\n * @param {Array<QHSenseRemoteTrack>} remoteTracks the tracks that will be added\r\n * @private\r\n */\r\nQHSenseConference.prototype._addRemoteTracks = function(logName, remoteTracks) {\r\n    for (const track of remoteTracks) {\r\n        logger.info(`Adding remote ${logName} track: ${track}`);\r\n        this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_ADDED, track);\r\n    }\r\n};\r\n\r\n/**\r\n * Called when {@link XMPPEvents.CONNECTION_ESTABLISHED} event is\r\n * triggered for a {@link JingleSessionPC}. Switches the conference to use\r\n * the P2P connection if the event comes from the P2P session.\r\n * @param {JingleSessionPC} jingleSession the session instance.\r\n * @private\r\n */\r\nQHSenseConference.prototype._onIceConnectionEstablished = function(\r\n        jingleSession) {\r\n    if (this.p2pJingleSession !== null) {\r\n        // store the establishment time of the p2p session as a field of the\r\n        // QHSenseConference because the p2pJingleSession might get disposed (thus\r\n        // the value is lost).\r\n        this.p2pEstablishmentDuration\r\n            = this.p2pJingleSession.establishmentDuration;\r\n    }\r\n\r\n    if (this.jvbJingleSession !== null) {\r\n        this.jvbEstablishmentDuration\r\n            = this.jvbJingleSession.establishmentDuration;\r\n    }\r\n\r\n    let done = false;\r\n    const forceJVB121Ratio = this.options.config.forceJVB121Ratio;\r\n\r\n    // We don't care about the JVB case, there's nothing to be done\r\n    if (!jingleSession.isP2P) {\r\n        done = true;\r\n    } else if (this.p2pJingleSession !== jingleSession) {\r\n        logger.error('CONNECTION_ESTABLISHED - wrong P2P session instance ?!');\r\n\r\n        done = true;\r\n    } else if (!jingleSession.isInitiator\r\n        && typeof forceJVB121Ratio === 'number'\r\n        && Math.random() < forceJVB121Ratio) {\r\n        logger.info(`Forcing JVB 121 mode (ratio=${forceJVB121Ratio})...`);\r\n        Statistics.analytics.addPermanentProperties({ forceJvb121: true });\r\n        this._stopP2PSession('decline', 'force JVB121');\r\n\r\n        done = true;\r\n    }\r\n\r\n    if (!isNaN(this.p2pEstablishmentDuration)\r\n        && !isNaN(this.jvbEstablishmentDuration)) {\r\n        const establishmentDurationDiff\r\n            = this.p2pEstablishmentDuration - this.jvbEstablishmentDuration;\r\n\r\n        Statistics.sendAnalytics(\r\n            ICE_ESTABLISHMENT_DURATION_DIFF,\r\n            { value: establishmentDurationDiff });\r\n    }\r\n\r\n    if (jingleSession.isP2P === this.isP2PActive()) {\r\n        this.eventEmitter.emit(QHSenseConferenceEvents.CONNECTION_ESTABLISHED);\r\n    }\r\n\r\n    if (done) {\r\n\r\n        return;\r\n    }\r\n\r\n    // Update P2P status and emit events\r\n    this._setP2PStatus(true);\r\n\r\n    // Remove remote tracks\r\n    if (this.jvbJingleSession) {\r\n        this._removeRemoteJVBTracks();\r\n    } else {\r\n        logger.info('Not removing remote JVB tracks - no session yet');\r\n    }\r\n\r\n    this._addRemoteP2PTracks();\r\n\r\n    // Stop media transfer over the JVB connection\r\n    if (this.jvbJingleSession) {\r\n        this._suspendMediaTransferForJvbConnection();\r\n    }\r\n\r\n    logger.info('Starting remote stats with p2p connection');\r\n    this.statistics.startRemoteStats(this.p2pJingleSession.peerconnection);\r\n\r\n    Statistics.sendAnalyticsAndLog(\r\n        createP2PEvent(\r\n            ACTION_P2P_ESTABLISHED,\r\n            {\r\n                initiator: this.p2pJingleSession.isInitiator\r\n            }));\r\n\r\n};\r\n\r\n/**\r\n * Called when the chat room reads a new list of properties from jicofo's\r\n * presence. The properties may have changed, but they don't have to.\r\n *\r\n * @param {Object} properties - The properties keyed by the property name\r\n * ('key').\r\n * @private\r\n */\r\nQHSenseConference.prototype._updateProperties = function(properties = {}) {\r\n    const changed = !isEqual(properties, this.properties);\r\n\r\n    this.properties = properties;\r\n    if (changed) {\r\n        this.eventEmitter.emit(\r\n            QHSenseConferenceEvents.PROPERTIES_CHANGED,\r\n            this.properties);\r\n\r\n        // Some of the properties need to be added to analytics events.\r\n        const analyticsKeys = [\r\n\r\n            // The number of QHSense-videobridge instances currently used for the\r\n            // conference.\r\n            'bridge-count',\r\n\r\n            // The conference creation time (set by jicofo).\r\n            'created-ms',\r\n            'octo-enabled'\r\n        ];\r\n\r\n        analyticsKeys.forEach(key => {\r\n            if (properties[key] !== undefined) {\r\n                Statistics.analytics.addPermanentProperties({\r\n                    [key.replace('-', '_')]: properties[key]\r\n                });\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\n/**\r\n * Gets a conference property with a given key.\r\n *\r\n * @param {string} key - The key.\r\n * @returns {*} The value\r\n */\r\nQHSenseConference.prototype.getProperty = function(key) {\r\n    return this.properties[key];\r\n};\r\n\r\n/**\r\n * Clears the deferred start P2P task if it has been scheduled.\r\n * @private\r\n */\r\nQHSenseConference.prototype._maybeClearDeferredStartP2P = function() {\r\n    if (this.deferredStartP2PTask) {\r\n        logger.info('Cleared deferred start P2P task');\r\n        clearTimeout(this.deferredStartP2PTask);\r\n        this.deferredStartP2PTask = null;\r\n    }\r\n};\r\n\r\n/**\r\n * Removes from the conference remote tracks associated with the JVB\r\n * connection.\r\n * @private\r\n */\r\nQHSenseConference.prototype._removeRemoteJVBTracks = function() {\r\n    this._removeRemoteTracks(\r\n        'JVB', this.jvbJingleSession.peerconnection.getRemoteTracks());\r\n};\r\n\r\n/**\r\n * Removes from the conference remote tracks associated with the P2P\r\n * connection.\r\n * @private\r\n */\r\nQHSenseConference.prototype._removeRemoteP2PTracks = function() {\r\n    this._removeRemoteTracks(\r\n        'P2P', this.p2pJingleSession.peerconnection.getRemoteTracks());\r\n};\r\n\r\n/**\r\n * Generates fake \"remote track removed\" events for given Jingle session.\r\n * @param {string} sessionNickname the session's nickname which will appear in\r\n * log messages.\r\n * @param {Array<QHSenseRemoteTrack>} remoteTracks the tracks that will be removed\r\n * @private\r\n */\r\nQHSenseConference.prototype._removeRemoteTracks = function(\r\n        sessionNickname,\r\n        remoteTracks) {\r\n    for (const track of remoteTracks) {\r\n        logger.info(`Removing remote ${sessionNickname} track: ${track}`);\r\n        this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_REMOVED, track);\r\n    }\r\n};\r\n\r\n/**\r\n * Resumes media transfer over the JVB connection.\r\n * @private\r\n */\r\nQHSenseConference.prototype._resumeMediaTransferForJvbConnection = function() {\r\n    logger.info('Resuming media transfer over the JVB connection...');\r\n    this.jvbJingleSession.setMediaTransferActive(true, true).then(\r\n        () => {\r\n            logger.info('Resumed media transfer over the JVB connection!');\r\n        },\r\n        error => {\r\n            logger.error(\r\n                'Failed to resume media transfer over the JVB connection:',\r\n                error);\r\n        });\r\n};\r\n\r\n/**\r\n * Sets new P2P status and updates some events/states hijacked from\r\n * the <tt>QHSenseConference</tt>.\r\n * @param {boolean} newStatus the new P2P status value, <tt>true</tt> means that\r\n * P2P is now in use, <tt>false</tt> means that the JVB connection is now in use\r\n * @private\r\n */\r\nQHSenseConference.prototype._setP2PStatus = function(newStatus) {\r\n    if (this.p2p === newStatus) {\r\n        logger.debug(`Called _setP2PStatus with the same status: ${newStatus}`);\r\n\r\n        return;\r\n    }\r\n    this.p2p = newStatus;\r\n    if (newStatus) {\r\n        logger.info('Peer to peer connection established!');\r\n\r\n        // When we end up in a valid P2P session need to reset the properties\r\n        // in case they have persisted, after session with another peer.\r\n        Statistics.analytics.addPermanentProperties({\r\n            p2pFailed: false,\r\n            forceJvb121: false\r\n        });\r\n\r\n        // Sync up video transfer active in case p2pJingleSession not existed\r\n        // when the lastN value was being adjusted.\r\n        const isVideoActive = this.rtc.getLastN() !== 0;\r\n\r\n        this.p2pJingleSession\r\n            .setMediaTransferActive(true, isVideoActive)\r\n            .catch(error => {\r\n                logger.error(\r\n                    'Failed to sync up P2P video transfer status'\r\n                        + `(${isVideoActive})`, error);\r\n            });\r\n    } else {\r\n        logger.info('Peer to peer connection closed!');\r\n    }\r\n\r\n    // Put the JVB connection on hold/resume\r\n    if (this.jvbJingleSession) {\r\n        this.statistics.sendConnectionResumeOrHoldEvent(\r\n            this.jvbJingleSession.peerconnection, !newStatus);\r\n    }\r\n\r\n    // Clear dtmfManager, so that it can be recreated with new connection\r\n    this.dtmfManager = null;\r\n\r\n    // Update P2P status\r\n    this.eventEmitter.emit(\r\n        QHSenseConferenceEvents.P2P_STATUS,\r\n        this,\r\n        this.p2p);\r\n\r\n    // Refresh connection interrupted/restored\r\n    this.eventEmitter.emit(\r\n        this.isConnectionInterrupted()\r\n            ? QHSenseConferenceEvents.CONNECTION_INTERRUPTED\r\n            : QHSenseConferenceEvents.CONNECTION_RESTORED);\r\n};\r\n\r\n/**\r\n * Starts new P2P session.\r\n * @param {string} remoteJid the JID of the remote participant\r\n * @private\r\n */\r\nQHSenseConference.prototype._startP2PSession = function(remoteJid) {\r\n    this._maybeClearDeferredStartP2P();\r\n    if (this.p2pJingleSession) {\r\n        logger.error('P2P session already started!');\r\n\r\n        return;\r\n    }\r\n\r\n    this.isP2PConnectionInterrupted = false;\r\n    this.p2pJingleSession\r\n        = this.xmpp.connection.jingle.newP2PJingleSession(\r\n            this.room.myroomjid,\r\n            remoteJid);\r\n    logger.info(\r\n        'Created new P2P JingleSession', this.room.myroomjid, remoteJid);\r\n\r\n    this.p2pJingleSession.initialize(this.room, this.rtc, this.options.config);\r\n\r\n    logger.info('Starting CallStats for P2P connection...');\r\n\r\n    let remoteID = Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);\r\n\r\n    if (this.options.config.enableStatsID) {\r\n        const participant = this.participants[remoteID];\r\n\r\n        if (participant) {\r\n            remoteID = participant.getStatsID() || remoteID;\r\n        }\r\n    }\r\n\r\n    this.statistics.startCallStats(\r\n        this.p2pJingleSession.peerconnection,\r\n        remoteID);\r\n\r\n    // NOTE one may consider to start P2P with the local tracks detached,\r\n    // but no data will be sent until ICE succeeds anyway. And we switch\r\n    // immediately once the P2P ICE connects.\r\n    const localTracks = this.getLocalTracks();\r\n\r\n    this.p2pJingleSession.invite(localTracks);\r\n};\r\n\r\n/**\r\n * Suspends media transfer over the JVB connection.\r\n * @private\r\n */\r\nQHSenseConference.prototype._suspendMediaTransferForJvbConnection = function() {\r\n    logger.info('Suspending media transfer over the JVB connection...');\r\n    this.jvbJingleSession.setMediaTransferActive(false, false).then(\r\n        () => {\r\n            logger.info('Suspended media transfer over the JVB connection !');\r\n        },\r\n        error => {\r\n            logger.error(\r\n                'Failed to suspend media transfer over the JVB connection:',\r\n                error);\r\n        });\r\n};\r\n\r\n/**\r\n * Method when called will decide whether it's the time to start or stop\r\n * the P2P session.\r\n * @param {boolean} userLeftEvent if <tt>true</tt> it means that the call\r\n * originates from the user left event.\r\n * @private\r\n */\r\nQHSenseConference.prototype._maybeStartOrStopP2P = function(userLeftEvent) {\r\n    if (!browser.supportsP2P()\r\n        || !this.isP2PEnabled()\r\n        || this.isP2PTestModeEnabled()) {\r\n        logger.info('Auto P2P disabled');\r\n\r\n        return;\r\n    }\r\n    const peers = this.getParticipants();\r\n    const peerCount = peers.length;\r\n    const isModerator = this.isModerator();\r\n    const hasBotPeer\r\n        = peers.find(p => p._botType === 'poltergeist') !== undefined;\r\n\r\n    // FIXME 1 peer and it must *support* P2P switching\r\n    const shouldBeInP2P = peerCount === 1 && !hasBotPeer;\r\n\r\n    logger.debug(\r\n        `P2P? isModerator: ${isModerator}, peerCount: ${\r\n            peerCount}, hasBotPeer: ${hasBotPeer} => ${\r\n            shouldBeInP2P}`);\r\n\r\n    // Clear deferred \"start P2P\" task\r\n    if (!shouldBeInP2P && this.deferredStartP2PTask) {\r\n        this._maybeClearDeferredStartP2P();\r\n    }\r\n\r\n    // Start peer to peer session\r\n    if (!this.p2pJingleSession && shouldBeInP2P) {\r\n        const peer = peerCount && peers[0];\r\n\r\n\r\n        const myId = this.myUserId();\r\n        const peersId = peer.getId();\r\n\r\n        if (myId > peersId) {\r\n            logger.debug(\r\n                'I\\'m the bigger peersId - '\r\n                + 'the other peer should start P2P', myId, peersId);\r\n\r\n            return;\r\n        } else if (myId === peersId) {\r\n            logger.error('The same IDs ? ', myId, peersId);\r\n\r\n            return;\r\n        }\r\n\r\n        const jid = peer.getJid();\r\n\r\n        if (userLeftEvent) {\r\n            if (this.deferredStartP2PTask) {\r\n                logger.error('Deferred start P2P task\\'s been set already!');\r\n\r\n                return;\r\n            }\r\n            logger.info(\r\n                `Will start P2P with: ${jid} after ${\r\n                    this.backToP2PDelay} seconds...`);\r\n            this.deferredStartP2PTask = setTimeout(\r\n                this._startP2PSession.bind(this, jid),\r\n                this.backToP2PDelay * 1000);\r\n        } else {\r\n            logger.info(`Will start P2P with: ${jid}`);\r\n            this._startP2PSession(jid);\r\n        }\r\n    } else if (this.p2pJingleSession && !shouldBeInP2P) {\r\n        logger.info(`Will stop P2P with: ${this.p2pJingleSession.remoteJid}`);\r\n\r\n        // Log that there will be a switch back to the JVB connection\r\n        if (this.p2pJingleSession.isInitiator && peerCount > 1) {\r\n            Statistics.sendAnalyticsAndLog(\r\n                createP2PEvent(ACTION_P2P_SWITCH_TO_JVB));\r\n        }\r\n        this._stopP2PSession();\r\n    }\r\n};\r\n\r\n/**\r\n * Stops the current P2P session.\r\n * @param {string} [reason=\"success\"] one of the Jingle \"reason\" element\r\n * names as defined by https://xmpp.org/extensions/xep-0166.html#def-reason\r\n * @param {string} [reasonDescription=\"Turing off P2P session\"] text\r\n * description that will be included in the session terminate message\r\n * @private\r\n */\r\nQHSenseConference.prototype._stopP2PSession = function(\r\n        reason,\r\n        reasonDescription) {\r\n    if (!this.p2pJingleSession) {\r\n        logger.error('No P2P session to be stopped!');\r\n\r\n        return;\r\n    }\r\n\r\n    const wasP2PEstablished = this.isP2PActive();\r\n\r\n    // Swap remote tracks, but only if the P2P has been fully established\r\n    if (wasP2PEstablished) {\r\n        if (this.jvbJingleSession) {\r\n            this._resumeMediaTransferForJvbConnection();\r\n        }\r\n\r\n        // Remove remote P2P tracks\r\n        this._removeRemoteP2PTracks();\r\n    }\r\n\r\n    // Stop P2P stats\r\n    logger.info('Stopping remote stats for P2P connection');\r\n    this.statistics.stopRemoteStats(this.p2pJingleSession.peerconnection);\r\n    logger.info('Stopping CallStats for P2P connection');\r\n    this.statistics.stopCallStats(this.p2pJingleSession.peerconnection);\r\n\r\n    this.p2pJingleSession.terminate(\r\n        () => {\r\n            logger.info('P2P session terminate RESULT');\r\n        },\r\n        error => {\r\n            // Because both initiator and responder are simultaneously\r\n            // terminating their JingleSessions in case of the 'to JVB switch'\r\n            // when 3rd participant joins, both will dispose their sessions and\r\n            // reply with 'item-not-found' (see strophe.jingle.js). We don't\r\n            // want to log this as an error since it's expected behaviour.\r\n            //\r\n            // We want them both to terminate, because in case of initiator's\r\n            // crash the responder would stay in P2P mode until ICE fails which\r\n            // could take up to 20 seconds.\r\n            //\r\n            // NOTE lack of 'reason' is considered as graceful session terminate\r\n            // where both initiator and responder terminate their sessions\r\n            // simultaneously.\r\n            if (reason) {\r\n                logger.error(\r\n                    'An error occurred while trying to terminate'\r\n                        + ' P2P Jingle session', error);\r\n            }\r\n        }, {\r\n            reason: reason ? reason : 'success',\r\n            reasonDescription: reasonDescription\r\n                ? reasonDescription : 'Turing off P2P session',\r\n            sendSessionTerminate: this.room\r\n                && this.getParticipantById(\r\n                    Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid))\r\n        });\r\n\r\n    this.p2pJingleSession = null;\r\n\r\n    // Update P2P status and other affected events/states\r\n    this._setP2PStatus(false);\r\n\r\n    if (wasP2PEstablished) {\r\n        // Add back remote JVB tracks\r\n        if (this.jvbJingleSession) {\r\n            this._addRemoteJVBTracks();\r\n        } else {\r\n            logger.info('Not adding remote JVB tracks - no session yet');\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Checks whether or not the conference is currently in the peer to peer mode.\r\n * Being in peer to peer mode means that the direct connection has been\r\n * established and the P2P connection is being used for media transmission.\r\n * @return {boolean} <tt>true</tt> if in P2P mode or <tt>false</tt> otherwise.\r\n */\r\nQHSenseConference.prototype.isP2PActive = function() {\r\n    return this.p2p;\r\n};\r\n\r\n/**\r\n * Returns the current ICE state of the P2P connection.\r\n * NOTE: method is used by the QHSense-meet-torture tests.\r\n * @return {string|null} an ICE state or <tt>null</tt> if there's currently\r\n * no P2P connection.\r\n */\r\nQHSenseConference.prototype.getP2PConnectionState = function() {\r\n    if (this.isP2PActive()) {\r\n        return this.p2pJingleSession.peerconnection.getConnectionState();\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n\r\n/**\r\n * Manually starts new P2P session (should be used only in the tests).\r\n */\r\nQHSenseConference.prototype.startP2PSession = function() {\r\n    const peers = this.getParticipants();\r\n\r\n    // Start peer to peer session\r\n    if (peers.length === 1) {\r\n        const peerJid = peers[0].getJid();\r\n\r\n        this._startP2PSession(peerJid);\r\n    } else {\r\n        throw new Error(\r\n            'There must be exactly 1 participant to start the P2P session !');\r\n    }\r\n};\r\n\r\n/**\r\n * Manually stops the current P2P session (should be used only in the tests)\r\n */\r\nQHSenseConference.prototype.stopP2PSession = function() {\r\n    this._stopP2PSession();\r\n};\r\n\r\n/**\r\n * Get a summary of how long current participants have been the dominant speaker\r\n * @returns {object}\r\n */\r\nQHSenseConference.prototype.getSpeakerStats = function() {\r\n    return this.speakerStatsCollector.getStats();\r\n};\r\n\r\n/**\r\n * Sets the maximum video size the local participant should receive from remote\r\n * participants.\r\n *\r\n * @param {number} maxFrameHeightPixels the maximum frame height, in pixels,\r\n * this receiver is willing to receive.\r\n * @returns {void}\r\n */\r\nQHSenseConference.prototype.setReceiverVideoConstraint = function(\r\n        maxFrameHeight) {\r\n    this.rtc.setReceiverVideoConstraint(maxFrameHeight);\r\n};\r\n\r\n/**\r\n * Creates a video SIP GW session and returns it if service is enabled. Before\r\n * creating a session one need to check whether video SIP GW service is\r\n * available in the system {@link QHSenseConference.isVideoSIPGWAvailable}. Even\r\n * if there are available nodes to serve this request, after creating the\r\n * session those nodes can be taken and the request about using the\r\n * created session can fail.\r\n *\r\n * @param {string} sipAddress - The sip address to be used.\r\n * @param {string} displayName - The display name to be used for this session.\r\n * @returns {QHSenseVideoSIPGWSession|Error} Returns null if conference is not\r\n * initialised and there is no room.\r\n */\r\nQHSenseConference.prototype.createVideoSIPGWSession\r\n    = function(sipAddress, displayName) {\r\n        if (!this.room) {\r\n            return new Error(VideoSIPGWConstants.ERROR_NO_CONNECTION);\r\n        }\r\n\r\n        return this.videoSIPGWHandler\r\n            .createVideoSIPGWSession(sipAddress, displayName);\r\n    };\r\n","/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n","/* global __filename */\r\nimport { Strophe } from 'strophe.js';\r\n\r\nimport {\r\n    ACTION_JINGLE_SA_TIMEOUT,\r\n    createBridgeDownEvent,\r\n    createConnectionStageReachedEvent,\r\n    createFocusLeftEvent,\r\n    createJingleEvent,\r\n    createRemotelyMutedEvent\r\n} from './service/statistics/AnalyticsEvents';\r\nimport AuthenticationEvents\r\n    from './service/authentication/AuthenticationEvents';\r\nimport EventEmitterForwarder from './modules/util/EventEmitterForwarder';\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport * as QHSenseConferenceErrors from './QHSenseConferenceErrors';\r\nimport * as QHSenseConferenceEvents from './QHSenseConferenceEvents';\r\nimport * as MediaType from './service/RTC/MediaType';\r\nimport RTCEvents from './service/RTC/RTCEvents';\r\nimport VideoType from './service/RTC/VideoType';\r\nimport Statistics from './modules/statistics/statistics';\r\nimport XMPPEvents from './service/xmpp/XMPPEvents';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Setups all event listeners related to conference\r\n * @param conference {QHSenseConference} the conference\r\n */\r\nexport default function QHSenseConferenceEventManager(conference) {\r\n    this.conference = conference;\r\n    this.xmppListeners = {};\r\n\r\n    // Listeners related to the conference only\r\n    conference.on(QHSenseConferenceEvents.TRACK_MUTE_CHANGED,\r\n        track => {\r\n            if (!track.isLocal() || !conference.statistics) {\r\n                return;\r\n            }\r\n            const session\r\n                = track.isP2P\r\n                    ? conference.p2pJingleSession : conference.jvbJingleSession;\r\n\r\n            // TPC will be null, before the conference starts, but the event\r\n            // still should be queued\r\n            const tpc = (session && session.peerconnection) || null;\r\n\r\n            conference.statistics.sendMuteEvent(\r\n                tpc,\r\n                track.isMuted(),\r\n                track.getType());\r\n        });\r\n}\r\n\r\n/**\r\n * Setups event listeners related to conference.chatRoom\r\n */\r\nQHSenseConferenceEventManager.prototype.setupChatRoomListeners = function() {\r\n    const conference = this.conference;\r\n    const chatRoom = conference.room;\r\n\r\n    this.chatRoomForwarder = new EventEmitterForwarder(chatRoom,\r\n        this.conference.eventEmitter);\r\n\r\n    chatRoom.addListener(XMPPEvents.ICE_RESTARTING, jingleSession => {\r\n        if (!jingleSession.isP2P) {\r\n            // If using DataChannel as bridge channel, it must be closed\r\n            // before ICE restart, otherwise Chrome will not trigger \"opened\"\r\n            // event for the channel established with the new bridge.\r\n            // TODO: This may be bypassed when using a WebSocket as bridge\r\n            // channel.\r\n            conference.rtc.closeBridgeChannel();\r\n        }\r\n\r\n        // else: there are no DataChannels in P2P session (at least for now)\r\n    });\r\n\r\n    chatRoom.addListener(\r\n        XMPPEvents.ICE_RESTART_SUCCESS,\r\n        (jingleSession, offerIq) => {\r\n            // The JVB data chanel needs to be reopened in case the conference\r\n            // has been moved to a new bridge.\r\n            !jingleSession.isP2P\r\n                && conference._setBridgeChannel(\r\n                    offerIq, jingleSession.peerconnection);\r\n        });\r\n\r\n\r\n    chatRoom.addListener(XMPPEvents.AUDIO_MUTED_BY_FOCUS,\r\n        actor => {\r\n            // TODO: Add a way to differentiate between commands which caused\r\n            // us to mute and those that did not change our state (i.e. we were\r\n            // already muted).\r\n            Statistics.sendAnalytics(createRemotelyMutedEvent());\r\n\r\n            conference.mutedByFocusActor = actor;\r\n\r\n            // set isMutedByFocus when setAudioMute Promise ends\r\n            conference.rtc.setAudioMute(true).then(\r\n                () => {\r\n                    conference.isMutedByFocus = true;\r\n                    conference.mutedByFocusActor = null;\r\n                })\r\n                .catch(\r\n                    error => {\r\n                        conference.mutedByFocusActor = null;\r\n                        logger.warn(\r\n                            'Error while audio muting due to focus request', error);\r\n                    });\r\n        }\r\n    );\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.SUBJECT_CHANGED,\r\n        QHSenseConferenceEvents.SUBJECT_CHANGED);\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.MUC_JOINED,\r\n        QHSenseConferenceEvents.CONFERENCE_JOINED);\r\n\r\n    // send some analytics events\r\n    chatRoom.addListener(XMPPEvents.MUC_JOINED,\r\n        () => {\r\n            this.conference.isJvbConnectionInterrupted = false;\r\n\r\n            // TODO: Move all of the 'connectionTimes' logic to its own module.\r\n            Object.keys(chatRoom.connectionTimes).forEach(key => {\r\n                const event\r\n                    = createConnectionStageReachedEvent(\r\n                        `conference_${key}`,\r\n                        { value: chatRoom.connectionTimes[key] });\r\n\r\n                Statistics.sendAnalytics(event);\r\n            });\r\n\r\n            // TODO: Move all of the 'connectionTimes' logic to its own module.\r\n            Object.keys(chatRoom.xmpp.connectionTimes).forEach(key => {\r\n                const event\r\n                    = createConnectionStageReachedEvent(\r\n                        `xmpp_${key}`,\r\n                        { value: chatRoom.xmpp.connectionTimes[key] });\r\n\r\n                Statistics.sendAnalytics(event);\r\n            });\r\n        });\r\n\r\n    chatRoom.addListener(XMPPEvents.RENEGOTIATION_FAILED, (e, session) => {\r\n        if (!session.isP2P) {\r\n            conference.eventEmitter.emit(QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n                QHSenseConferenceErrors.OFFER_ANSWER_FAILED, e);\r\n        }\r\n    });\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.ROOM_JOIN_ERROR,\r\n        QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n        QHSenseConferenceErrors.CONNECTION_ERROR);\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.ROOM_CONNECT_ERROR,\r\n        QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n        QHSenseConferenceErrors.CONNECTION_ERROR);\r\n    this.chatRoomForwarder.forward(XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR,\r\n        QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n        QHSenseConferenceErrors.NOT_ALLOWED_ERROR);\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.ROOM_MAX_USERS_ERROR,\r\n        QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n        QHSenseConferenceErrors.CONFERENCE_MAX_USERS);\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.PASSWORD_REQUIRED,\r\n        QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n        QHSenseConferenceErrors.PASSWORD_REQUIRED);\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.AUTHENTICATION_REQUIRED,\r\n        QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n        QHSenseConferenceErrors.AUTHENTICATION_REQUIRED);\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.BRIDGE_DOWN,\r\n        QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n        QHSenseConferenceErrors.VIDEOBRIDGE_NOT_AVAILABLE);\r\n    chatRoom.addListener(\r\n        XMPPEvents.BRIDGE_DOWN,\r\n        () => Statistics.sendAnalytics(createBridgeDownEvent()));\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.RESERVATION_ERROR,\r\n        QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n        QHSenseConferenceErrors.RESERVATION_ERROR);\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.GRACEFUL_SHUTDOWN,\r\n        QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n        QHSenseConferenceErrors.GRACEFUL_SHUTDOWN);\r\n\r\n    chatRoom.addListener(XMPPEvents.CONNECTION_ICE_FAILED,\r\n        jingleSession => {\r\n            conference._onIceConnectionFailed(jingleSession);\r\n        });\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.MUC_DESTROYED,\r\n        QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n        QHSenseConferenceErrors.CONFERENCE_DESTROYED);\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.CHAT_ERROR_RECEIVED,\r\n        QHSenseConferenceEvents.CONFERENCE_ERROR,\r\n        QHSenseConferenceErrors.CHAT_ERROR);\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.FOCUS_DISCONNECTED,\r\n        QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n        QHSenseConferenceErrors.FOCUS_DISCONNECTED);\r\n\r\n    chatRoom.addListener(XMPPEvents.FOCUS_LEFT,\r\n        () => {\r\n            Statistics.sendAnalytics(createFocusLeftEvent());\r\n            conference.eventEmitter.emit(\r\n                QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n                QHSenseConferenceErrors.FOCUS_LEFT);\r\n        });\r\n\r\n    chatRoom.addListener(XMPPEvents.SESSION_ACCEPT_TIMEOUT,\r\n        jingleSession => {\r\n            Statistics.sendAnalyticsAndLog(\r\n                createJingleEvent(\r\n                    ACTION_JINGLE_SA_TIMEOUT,\r\n                    { p2p: jingleSession.isP2P }));\r\n        });\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.RECORDER_STATE_CHANGED,\r\n        QHSenseConferenceEvents.RECORDER_STATE_CHANGED);\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.TRANSCRIPTION_STATUS_CHANGED,\r\n        QHSenseConferenceEvents.TRANSCRIPTION_STATUS_CHANGED);\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.VIDEO_SIP_GW_AVAILABILITY_CHANGED,\r\n        QHSenseConferenceEvents.VIDEO_SIP_GW_AVAILABILITY_CHANGED);\r\n\r\n    this.chatRoomForwarder.forward(\r\n        XMPPEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED,\r\n        QHSenseConferenceEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED);\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.PHONE_NUMBER_CHANGED,\r\n        QHSenseConferenceEvents.PHONE_NUMBER_CHANGED);\r\n\r\n    chatRoom.setParticipantPropertyListener((node, from) => {\r\n        const participant = conference.getParticipantById(from);\r\n\r\n        if (!participant) {\r\n            return;\r\n        }\r\n\r\n        participant.setProperty(\r\n            node.tagName.substring('QHSense_participant_'.length),\r\n            node.value);\r\n    });\r\n\r\n    chatRoom.addListener(XMPPEvents.KICKED,\r\n        conference.onMemberKicked.bind(conference));\r\n    chatRoom.addListener(XMPPEvents.SUSPEND_DETECTED,\r\n        conference.onSuspendDetected.bind(conference));\r\n\r\n    this.chatRoomForwarder.forward(XMPPEvents.MUC_LOCK_CHANGED,\r\n        QHSenseConferenceEvents.LOCK_STATE_CHANGED);\r\n\r\n    chatRoom.addListener(XMPPEvents.MUC_MEMBER_JOINED,\r\n        conference.onMemberJoined.bind(conference));\r\n    chatRoom.addListener(XMPPEvents.MUC_MEMBER_BOT_TYPE_CHANGED,\r\n        conference._onMemberBotTypeChanged.bind(conference));\r\n    chatRoom.addListener(XMPPEvents.MUC_MEMBER_LEFT,\r\n        conference.onMemberLeft.bind(conference));\r\n    this.chatRoomForwarder.forward(XMPPEvents.MUC_LEFT,\r\n        QHSenseConferenceEvents.CONFERENCE_LEFT);\r\n\r\n    chatRoom.addListener(XMPPEvents.DISPLAY_NAME_CHANGED,\r\n        conference.onDisplayNameChanged.bind(conference));\r\n\r\n    chatRoom.addListener(XMPPEvents.LOCAL_ROLE_CHANGED, role => {\r\n        conference.onLocalRoleChanged(role);\r\n\r\n        // log all events for the recorder operated by the moderator\r\n        if (conference.statistics && conference.isModerator()) {\r\n            conference.on(QHSenseConferenceEvents.RECORDER_STATE_CHANGED,\r\n                recorderSession => {\r\n                    const logObject = {\r\n                        error: recorderSession.getError(),\r\n                        id: 'recorder_status',\r\n                        status: recorderSession.getStatus()\r\n                    };\r\n\r\n                    Statistics.sendLog(JSON.stringify(logObject));\r\n                });\r\n        }\r\n    });\r\n\r\n    chatRoom.addListener(XMPPEvents.MUC_ROLE_CHANGED,\r\n        conference.onUserRoleChanged.bind(conference));\r\n\r\n    chatRoom.addListener(AuthenticationEvents.IDENTITY_UPDATED,\r\n        (authEnabled, authIdentity) => {\r\n            conference.authEnabled = authEnabled;\r\n            conference.authIdentity = authIdentity;\r\n            conference.eventEmitter.emit(\r\n                QHSenseConferenceEvents.AUTH_STATUS_CHANGED, authEnabled,\r\n                authIdentity);\r\n        });\r\n\r\n    chatRoom.addListener(\r\n        XMPPEvents.MESSAGE_RECEIVED,\r\n\r\n        // eslint-disable-next-line max-params\r\n        (jid, displayName, txt, myJid, ts) => {\r\n            const id = Strophe.getResourceFromJid(jid);\r\n\r\n            conference.eventEmitter.emit(\r\n                QHSenseConferenceEvents.MESSAGE_RECEIVED,\r\n                id, txt, ts);\r\n        });\r\n\r\n    chatRoom.addListener(\r\n        XMPPEvents.PRIVATE_MESSAGE_RECEIVED,\r\n\r\n        // eslint-disable-next-line max-params\r\n        (jid, displayName, txt, myJid, ts) => {\r\n            const id = Strophe.getResourceFromJid(jid);\r\n\r\n            conference.eventEmitter.emit(\r\n                QHSenseConferenceEvents.PRIVATE_MESSAGE_RECEIVED,\r\n                id, txt, ts);\r\n        });\r\n\r\n    chatRoom.addListener(XMPPEvents.PRESENCE_STATUS,\r\n        (jid, status) => {\r\n            const id = Strophe.getResourceFromJid(jid);\r\n            const participant = conference.getParticipantById(id);\r\n\r\n            if (!participant || participant._status === status) {\r\n                return;\r\n            }\r\n            participant._status = status;\r\n            conference.eventEmitter.emit(\r\n                QHSenseConferenceEvents.USER_STATUS_CHANGED, id, status);\r\n        });\r\n\r\n    chatRoom.addListener(XMPPEvents.JSON_MESSAGE_RECEIVED,\r\n        (from, payload) => {\r\n            const id = Strophe.getResourceFromJid(from);\r\n            const participant = conference.getParticipantById(id);\r\n\r\n            if (participant) {\r\n                conference.eventEmitter.emit(\r\n                    QHSenseConferenceEvents.ENDPOINT_MESSAGE_RECEIVED,\r\n                    participant, payload);\r\n            } else {\r\n                logger.warn(\r\n                    'Ignored XMPPEvents.JSON_MESSAGE_RECEIVED for not existing '\r\n                    + `participant: ${from}`,\r\n                    payload);\r\n            }\r\n        });\r\n\r\n    chatRoom.addPresenceListener('startmuted', (data, from) => {\r\n        let isModerator = false;\r\n\r\n        if (conference.myUserId() === from && conference.isModerator()) {\r\n            isModerator = true;\r\n        } else {\r\n            const participant = conference.getParticipantById(from);\r\n\r\n            if (participant && participant.isModerator()) {\r\n                isModerator = true;\r\n            }\r\n        }\r\n\r\n        if (!isModerator) {\r\n            return;\r\n        }\r\n\r\n        const startAudioMuted = data.attributes.audio === 'true';\r\n        const startVideoMuted = data.attributes.video === 'true';\r\n\r\n        let updated = false;\r\n\r\n        if (startAudioMuted !== conference.startMutedPolicy.audio) {\r\n            conference.startMutedPolicy.audio = startAudioMuted;\r\n            updated = true;\r\n        }\r\n\r\n        if (startVideoMuted !== conference.startMutedPolicy.video) {\r\n            conference.startMutedPolicy.video = startVideoMuted;\r\n            updated = true;\r\n        }\r\n\r\n        if (updated) {\r\n            conference.eventEmitter.emit(\r\n                QHSenseConferenceEvents.START_MUTED_POLICY_CHANGED,\r\n                conference.startMutedPolicy\r\n            );\r\n        }\r\n    });\r\n\r\n    if (conference.statistics) {\r\n        // FIXME ICE related events should end up in RTCEvents eventually\r\n        chatRoom.addListener(XMPPEvents.CONNECTION_ICE_FAILED,\r\n            session => {\r\n                conference.statistics.sendIceConnectionFailedEvent(\r\n                    session.peerconnection);\r\n            });\r\n\r\n        // FIXME XMPPEvents.ADD_ICE_CANDIDATE_FAILED is never emitted\r\n        chatRoom.addListener(XMPPEvents.ADD_ICE_CANDIDATE_FAILED,\r\n            (e, pc) => {\r\n                conference.statistics.sendAddIceCandidateFailed(e, pc);\r\n            });\r\n    }\r\n};\r\n\r\n/**\r\n * Setups event listeners related to conference.rtc\r\n */\r\nQHSenseConferenceEventManager.prototype.setupRTCListeners = function() {\r\n    const conference = this.conference;\r\n    const rtc = conference.rtc;\r\n\r\n    rtc.addListener(\r\n        RTCEvents.REMOTE_TRACK_ADDED,\r\n        conference.onRemoteTrackAdded.bind(conference));\r\n\r\n    rtc.addListener(\r\n        RTCEvents.REMOTE_TRACK_REMOVED,\r\n        conference.onRemoteTrackRemoved.bind(conference));\r\n\r\n    rtc.addListener(RTCEvents.DOMINANT_SPEAKER_CHANGED,\r\n        id => {\r\n            if (conference.lastDominantSpeaker !== id && conference.room) {\r\n                conference.lastDominantSpeaker = id;\r\n                conference.eventEmitter.emit(\r\n                    QHSenseConferenceEvents.DOMINANT_SPEAKER_CHANGED, id);\r\n            }\r\n            if (conference.statistics && conference.myUserId() === id) {\r\n                // We are the new dominant speaker.\r\n                conference.statistics.sendDominantSpeakerEvent(\r\n                    conference.room.roomjid);\r\n            }\r\n        });\r\n\r\n    rtc.addListener(RTCEvents.DATA_CHANNEL_OPEN, () => {\r\n        const now = window.performance.now();\r\n        const key = 'data.channel.opened';\r\n\r\n        // TODO: Move all of the 'connectionTimes' logic to its own module.\r\n        logger.log(`(TIME) ${key}`, now);\r\n        conference.room.connectionTimes[key] = now;\r\n        Statistics.sendAnalytics(\r\n            createConnectionStageReachedEvent(key, { value: now }));\r\n\r\n        conference.eventEmitter.emit(QHSenseConferenceEvents.DATA_CHANNEL_OPENED);\r\n    });\r\n\r\n    rtc.addListener(RTCEvents.ENDPOINT_MESSAGE_RECEIVED,\r\n        (from, payload) => {\r\n            const participant = conference.getParticipantById(from);\r\n\r\n            if (participant) {\r\n                conference.eventEmitter.emit(\r\n                    QHSenseConferenceEvents.ENDPOINT_MESSAGE_RECEIVED,\r\n                    participant, payload);\r\n            } else {\r\n                logger.warn(\r\n                    'Ignored ENDPOINT_MESSAGE_RECEIVED for not existing '\r\n                        + `participant: ${from}`,\r\n                    payload);\r\n            }\r\n        });\r\n\r\n    rtc.addListener(RTCEvents.LOCAL_UFRAG_CHANGED,\r\n        (tpc, ufrag) => {\r\n            if (!tpc.isP2P) {\r\n                Statistics.sendLog(\r\n                    JSON.stringify({\r\n                        id: 'local_ufrag',\r\n                        value: ufrag\r\n                    }));\r\n            }\r\n        });\r\n    rtc.addListener(RTCEvents.REMOTE_UFRAG_CHANGED,\r\n        (tpc, ufrag) => {\r\n            if (!tpc.isP2P) {\r\n                Statistics.sendLog(\r\n                    JSON.stringify({\r\n                        id: 'remote_ufrag',\r\n                        value: ufrag\r\n                    }));\r\n            }\r\n        });\r\n\r\n    rtc.addListener(RTCEvents.CREATE_ANSWER_FAILED,\r\n        (e, tpc) => {\r\n            conference.statistics.sendCreateAnswerFailed(e, tpc);\r\n            if (!tpc.isP2P) {\r\n                conference.eventEmitter.emit(QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n                    QHSenseConferenceErrors.OFFER_ANSWER_FAILED, e);\r\n            }\r\n        });\r\n\r\n    rtc.addListener(RTCEvents.CREATE_OFFER_FAILED,\r\n        (e, tpc) => {\r\n            conference.statistics.sendCreateOfferFailed(e, tpc);\r\n            if (!tpc.isP2P) {\r\n                conference.eventEmitter.emit(QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n                    QHSenseConferenceErrors.OFFER_ANSWER_FAILED, e);\r\n            }\r\n        });\r\n\r\n    rtc.addListener(RTCEvents.SET_LOCAL_DESCRIPTION_FAILED,\r\n        (e, tpc) => {\r\n            conference.statistics.sendSetLocalDescFailed(e, tpc);\r\n            if (!tpc.isP2P) {\r\n                conference.eventEmitter.emit(QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n                    QHSenseConferenceErrors.OFFER_ANSWER_FAILED, e);\r\n            }\r\n        });\r\n\r\n    rtc.addListener(RTCEvents.SET_REMOTE_DESCRIPTION_FAILED,\r\n        (e, tpc) => {\r\n            conference.statistics.sendSetRemoteDescFailed(e, tpc);\r\n            if (!tpc.isP2P) {\r\n                conference.eventEmitter.emit(QHSenseConferenceEvents.CONFERENCE_FAILED,\r\n                    QHSenseConferenceErrors.OFFER_ANSWER_FAILED, e);\r\n            }\r\n        });\r\n\r\n    rtc.addListener(RTCEvents.LOCAL_TRACK_SSRC_UPDATED,\r\n        (track, ssrc) => {\r\n            // when starting screen sharing, the track is created and when\r\n            // we do set local description and we process the ssrc we\r\n            // will be notified for it and we will report it with the event\r\n            // for screen sharing\r\n            if (track.isVideoTrack() && track.videoType === VideoType.DESKTOP) {\r\n                conference.statistics.sendScreenSharingEvent(true, ssrc);\r\n            }\r\n        });\r\n};\r\n\r\n/**\r\n * Removes event listeners related to conference.xmpp\r\n */\r\nQHSenseConferenceEventManager.prototype.removeXMPPListeners = function() {\r\n    const conference = this.conference;\r\n\r\n    conference.xmpp.caps.removeListener(\r\n        XMPPEvents.PARTCIPANT_FEATURES_CHANGED,\r\n        this.xmppListeners[XMPPEvents.PARTCIPANT_FEATURES_CHANGED]);\r\n    delete this.xmppListeners[XMPPEvents.PARTCIPANT_FEATURES_CHANGED];\r\n\r\n    Object.keys(this.xmppListeners).forEach(eventName => {\r\n        conference.xmpp.removeListener(\r\n            eventName,\r\n            this.xmppListeners[eventName]);\r\n    });\r\n    this.xmppListeners = {};\r\n};\r\n\r\n\r\n/**\r\n * Setups event listeners related to conference.xmpp\r\n */\r\nQHSenseConferenceEventManager.prototype.setupXMPPListeners = function() {\r\n    const conference = this.conference;\r\n\r\n    const featuresChangedListener = from => {\r\n        const participant\r\n            = conference.getParticipantById(\r\n            Strophe.getResourceFromJid(from));\r\n\r\n        if (participant) {\r\n            conference.eventEmitter.emit(\r\n                QHSenseConferenceEvents.PARTCIPANT_FEATURES_CHANGED,\r\n                participant);\r\n        }\r\n    };\r\n\r\n    conference.xmpp.caps.addListener(\r\n        XMPPEvents.PARTCIPANT_FEATURES_CHANGED,\r\n        featuresChangedListener);\r\n    this.xmppListeners[XMPPEvents.PARTCIPANT_FEATURES_CHANGED]\r\n        = featuresChangedListener;\r\n\r\n    this._addConferenceXMPPListener(\r\n        XMPPEvents.CALL_INCOMING,\r\n        conference.onIncomingCall.bind(conference));\r\n    this._addConferenceXMPPListener(\r\n        XMPPEvents.CALL_ACCEPTED,\r\n        conference.onCallAccepted.bind(conference));\r\n    this._addConferenceXMPPListener(\r\n        XMPPEvents.TRANSPORT_INFO,\r\n        conference.onTransportInfo.bind(conference));\r\n    this._addConferenceXMPPListener(\r\n        XMPPEvents.CALL_ENDED,\r\n        conference.onCallEnded.bind(conference));\r\n\r\n    this._addConferenceXMPPListener(XMPPEvents.START_MUTED_FROM_FOCUS,\r\n        (audioMuted, videoMuted) => {\r\n            if (conference.options.config.ignoreStartMuted) {\r\n                return;\r\n            }\r\n\r\n            conference.startAudioMuted = audioMuted;\r\n            conference.startVideoMuted = videoMuted;\r\n\r\n            // mute existing local tracks because this is initial mute from\r\n            // Jicofo\r\n            conference.getLocalTracks().forEach(track => {\r\n                switch (track.getType()) {\r\n                case MediaType.AUDIO:\r\n                    conference.startAudioMuted && track.mute();\r\n                    break;\r\n                case MediaType.VIDEO:\r\n                    conference.startVideoMuted && track.mute();\r\n                    break;\r\n                }\r\n            });\r\n\r\n            conference.eventEmitter.emit(QHSenseConferenceEvents.STARTED_MUTED);\r\n        });\r\n};\r\n\r\n/**\r\n * Add XMPP listener and save its reference for remove on leave conference.\r\n */\r\nQHSenseConferenceEventManager.prototype._addConferenceXMPPListener = function(\r\n        eventName, listener) {\r\n    this.xmppListeners[eventName] = listener;\r\n    this.conference.xmpp.addListener(eventName, listener);\r\n};\r\n\r\n/**\r\n * Setups event listeners related to conference.statistics\r\n */\r\nQHSenseConferenceEventManager.prototype.setupStatisticsListeners = function() {\r\n    const conference = this.conference;\r\n\r\n    if (!conference.statistics) {\r\n        return;\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n    conference.statistics.addAudioLevelListener((tpc, ssrc, level, isLocal) => {\r\n        conference.rtc.setAudioLevel(tpc, ssrc, level, isLocal);\r\n    });\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    // Forward the \"before stats disposed\" event\r\n    conference.statistics.addBeforeDisposedListener(() => {\r\n        conference.eventEmitter.emit(\r\n            QHSenseConferenceEvents.BEFORE_STATISTICS_DISPOSED);\r\n    });\r\n\r\n    // if we are in startSilent mode we will not be sending/receiving so nothing to detect\r\n    if (!conference.options.config.startSilent) {\r\n        conference.statistics.addByteSentStatsListener((tpc, stats) => {\r\n            conference.getLocalTracks(MediaType.AUDIO).forEach(track => {\r\n                const ssrc = tpc.getLocalSSRC(track);\r\n\r\n                if (!ssrc || !stats.hasOwnProperty(ssrc)) {\r\n                    return;\r\n                }\r\n\r\n                track._onByteSentStatsReceived(tpc, stats[ssrc]);\r\n            });\r\n        });\r\n    }\r\n};\r\n","/**\r\n * Implements utility to forward events from one eventEmitter to another.\r\n * @param src {object} instance of EventEmitter or another class that implements\r\n * addListener method which will register listener to EventEmitter instance.\r\n * @param dest {object} instance of EventEmitter or another class that\r\n * implements emit method which will emit an event.\r\n */\r\nfunction EventEmitterForwarder(src, dest) {\r\n    if (!src || !dest || typeof src.addListener !== 'function'\r\n        || typeof dest.emit !== 'function') {\r\n        throw new Error('Invalid arguments passed to EventEmitterForwarder');\r\n    }\r\n    this.src = src;\r\n    this.dest = dest;\r\n}\r\n\r\n/**\r\n * Adds event to be forwarded from src to dest.\r\n * @param srcEvent {string} the event that EventEmitterForwarder is listening\r\n * for.\r\n * @param dstEvent {string} the event that will be fired from dest.\r\n * @param arguments all other passed arguments are going to be fired with\r\n * dstEvent.\r\n */\r\nEventEmitterForwarder.prototype.forward = function(...args) {\r\n    const srcEvent = args[0];\r\n\r\n    // This will be the \"this\" value for emit function.\r\n\r\n    args[0] = this.dest;\r\n\r\n    // Using bind.apply to pass the arguments as Array-like object (\"arguments\")\r\n    this.src.addListener(\r\n        srcEvent,\r\n        Function.prototype.bind.apply(this.dest.emit, args));\r\n};\r\n\r\nmodule.exports = EventEmitterForwarder;\r\n","import {\r\n    TYPE_OPERATIONAL,\r\n    TYPE_PAGE,\r\n    TYPE_TRACK,\r\n    TYPE_UI\r\n} from '../../service/statistics/AnalyticsEvents';\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport browser from '../browser';\r\nimport Settings from '../settings/Settings';\r\n\r\nconst MAX_CACHE_SIZE = 100;\r\n\r\n// eslist-disable-line no-undef\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * This class provides an API to lib-qhsense-meet and its users for sending\r\n * analytics events. It serves as a bridge to different backend implementations\r\n * (\"analytics handlers\") and a cache for events attempted to be sent before\r\n * the analytics handlers were enabled.\r\n *\r\n * The API is designed to be an easy replacement for the previous version of\r\n * this adapter, and is meant to be extended with more convenience methods.\r\n *\r\n *\r\n * The API calls are translated to objects with the following structure, which\r\n * are then passed to the sendEvent(event) function of the underlying handlers:\r\n *\r\n * {\r\n *    type,\r\n *\r\n *    action,\r\n *    actionSubject,\r\n *    actionSubjectId,\r\n *    attributes,\r\n *    categories,\r\n *    containerId,\r\n *    containerType,\r\n *    name,\r\n *    objectId,\r\n *    objectType,\r\n *    source,\r\n *    tags\r\n * }\r\n *\r\n * The 'type' is one of 'operational', 'page', 'track' or 'ui', and some of the\r\n * other properties are considered required according to the type.\r\n *\r\n * For events with type 'page', the required properties are: name.\r\n *\r\n * For events with type 'operational' and 'ui', the required properties are:\r\n * action, actionSubject, source\r\n *\r\n * For events with type 'page', the required properties are:\r\n * action, actionSubject, source, containerType, containerId, objectType,\r\n * objectId\r\n */\r\nclass AnalyticsAdapter {\r\n    /**\r\n     * Creates new AnalyticsAdapter instance.\r\n     */\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Reset the state to the initial one.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    reset() {\r\n        /**\r\n         * Whether this AnalyticsAdapter has been disposed of or not. Once this\r\n         * is set to true, the AnalyticsAdapter is disabled and does not accept\r\n         * any more events, and it can not be re-enabled.\r\n         * @type {boolean}\r\n         */\r\n        this.disposed = false;\r\n\r\n        /**\r\n         * The set of handlers to which events will be sent.\r\n         * @type {Set<any>}\r\n         */\r\n        this.analyticsHandlers = new Set();\r\n\r\n        /**\r\n         * The cache of events which are not sent yet. The cache is enabled\r\n         * while this field is truthy, and disabled otherwise.\r\n         * @type {Array}\r\n         */\r\n        this.cache = [];\r\n\r\n        /**\r\n         * Map of properties that will be added to every event. Note that the\r\n         * keys will be prefixed with \"permanent.\".\r\n         */\r\n        this.permanentProperties = {};\r\n\r\n        /**\r\n         * The name of the conference that this AnalyticsAdapter is associated\r\n         * with.\r\n         * @type {null}\r\n         */\r\n        this.conferenceName = '';\r\n\r\n        this.addPermanentProperties({\r\n            'callstats_name': Settings.callStatsUserName,\r\n            'user_agent': navigator.userAgent,\r\n            'browser_name': browser.getName()\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose analytics. Clears all handlers.\r\n     */\r\n    dispose() {\r\n        logger.warn('Disposing of analytics adapter.');\r\n\r\n        if (this.analyticsHandlers && this.analyticsHandlers.size > 0) {\r\n            this.analyticsHandlers.forEach(handler => {\r\n                if (typeof handler.dispose === 'function') {\r\n                    handler.dispose();\r\n                }\r\n            });\r\n        }\r\n\r\n        this.setAnalyticsHandlers([]);\r\n        this.disposed = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the handlers that are going to be used to send analytics. Sends any\r\n     * cached events.\r\n     * @param {Array} handlers the handlers\r\n     */\r\n    setAnalyticsHandlers(handlers) {\r\n        if (this.disposed) {\r\n            return;\r\n        }\r\n\r\n        this.analyticsHandlers = new Set(handlers);\r\n\r\n        this._setUserProperties();\r\n\r\n        // Note that we disable the cache even if the set of handlers is empty.\r\n        const cache = this.cache;\r\n\r\n        this.cache = null;\r\n        if (cache) {\r\n            cache.forEach(event => this._sendEvent(event));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the user properties to the analytics handlers.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    _setUserProperties() {\r\n        this.analyticsHandlers.forEach(handler => {\r\n            try {\r\n                handler.setUserProperties(this.permanentProperties);\r\n            } catch (error) {\r\n                logger.warn('Error in setUserProperties method of one of the '\r\n                    + `analytics handlers: ${error}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a set of permanent properties to this this AnalyticsAdapter.\r\n     * Permanent properties will be added as \"attributes\" to events sent to\r\n     * the underlying \"analytics handlers\", and their keys will be prefixed\r\n     * by \"permanent_\", i.e. adding a permanent property {key: \"value\"} will\r\n     * result in {\"permanent_key\": \"value\"} object to be added to the\r\n     * \"attributes\" field of events.\r\n     *\r\n     * @param {Object} properties the properties to add\r\n     */\r\n    addPermanentProperties(properties) {\r\n        this.permanentProperties = {\r\n            ...this.permanentProperties,\r\n            ...properties\r\n        };\r\n\r\n        this._setUserProperties();\r\n    }\r\n\r\n    /**\r\n     * Sets the name of the conference that this AnalyticsAdapter is associated\r\n     * with.\r\n     * @param name the name to set.\r\n     */\r\n    setConferenceName(name) {\r\n        this.conferenceName = name;\r\n        this.addPermanentProperties({ 'conference_name': name });\r\n    }\r\n\r\n    /**\r\n     * Sends an event with a given name and given properties. The first\r\n     * parameter is either a string or an object. If it is a string, it is used\r\n     * as the event name and the second parameter is used at the attributes to\r\n     * attach to the event. If it is an object, it represents the whole event,\r\n     * including any desired attributes, and the second parameter is ignored.\r\n     *\r\n     * @param {String|Object} eventName either a string to be used as the name\r\n     * of the event, or an event object. If an event object is passed, the\r\n     * properties parameters is ignored.\r\n     * @param {Object} properties the properties/attributes to attach to the\r\n     * event, if eventName is a string.\r\n     */\r\n    sendEvent(eventName, properties = {}) {\r\n        if (this.disposed) {\r\n            return;\r\n        }\r\n\r\n        let event = null;\r\n\r\n        if (typeof eventName === 'string') {\r\n            event = {\r\n                type: TYPE_OPERATIONAL,\r\n                action: eventName,\r\n                actionSubject: eventName,\r\n                source: eventName,\r\n                attributes: properties\r\n            };\r\n        } else if (typeof eventName === 'object') {\r\n            event = eventName;\r\n        }\r\n\r\n        if (!this._verifyRequiredFields(event)) {\r\n            logger.error(\r\n                `Dropping a mis-formatted event: ${JSON.stringify(event)}`);\r\n\r\n            return;\r\n        }\r\n\r\n        this._sendEvent(event);\r\n    }\r\n\r\n    /**\r\n     * Checks whether an event has all of the required fields set, and tries\r\n     * to fill in some of the missing fields with reasonable default values.\r\n     * Returns true if after this operation the event has all of the required\r\n     * fields set, and false otherwise (if some of the required fields were not\r\n     * set and the attempt to fill them in with a default failed).\r\n     *\r\n     * @param event the event object.\r\n     * @return {boolean} true if the event (after the call to this function)\r\n     * contains all of the required fields, and false otherwise.\r\n     * @private\r\n     */\r\n    _verifyRequiredFields(event) {\r\n        if (!event) {\r\n            return false;\r\n        }\r\n\r\n        if (!event.type) {\r\n            event.type = TYPE_OPERATIONAL;\r\n        }\r\n\r\n        const type = event.type;\r\n\r\n        if (type !== TYPE_OPERATIONAL && type !== TYPE_PAGE\r\n            && type !== TYPE_UI && type !== TYPE_TRACK) {\r\n            logger.error(`Unknown event type: ${type}`);\r\n\r\n            return false;\r\n        }\r\n\r\n        if (type === TYPE_PAGE) {\r\n            return Boolean(event.name);\r\n        }\r\n\r\n        // Try to set some reasonable default values in case some of the\r\n        // parameters required by the handler API are missing.\r\n        event.action = event.action || event.name || event.actionSubject;\r\n        event.actionSubject = event.actionSubject || event.name || event.action;\r\n        event.source = event.source || event.name || event.action\r\n            || event.actionSubject;\r\n\r\n        if (!event.action || !event.actionSubject || !event.source) {\r\n            logger.error(\r\n                'Required field missing (action, actionSubject or source)');\r\n\r\n            return false;\r\n        }\r\n\r\n        // Track events have additional required fields.\r\n        if (type === TYPE_TRACK) {\r\n            event.objectType = event.objectType || 'generic-object-type';\r\n            event.containerType = event.containerType || 'conference';\r\n            if (event.containerType === 'conference' && !event.containerId) {\r\n                event.containerId = this.conferenceName;\r\n            }\r\n\r\n\r\n            if (!event.objectType || !event.objectId\r\n                || !event.containerType || !event.containerId) {\r\n                logger.error(\r\n                    'Required field missing (containerId, containerType, '\r\n                        + 'objectId or objectType)');\r\n\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Saves an event to the cache, if the cache is enabled.\r\n     * @param event the event to save.\r\n     * @returns {boolean} true if the event was saved, and false otherwise (i.e.\r\n     * if the cache was disabled).\r\n     * @private\r\n     */\r\n    _maybeCacheEvent(event) {\r\n        if (this.cache) {\r\n            this.cache.push(event);\r\n\r\n            // We limit the size of the cache, in case the user fails to ever\r\n            // set the analytics handlers.\r\n            if (this.cache.length > MAX_CACHE_SIZE) {\r\n                this.cache.splice(0, 1);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param event\r\n     * @private\r\n     */\r\n    _sendEvent(event) {\r\n        if (this._maybeCacheEvent(event)) {\r\n            // The event was consumed by the cache.\r\n        } else {\r\n            this.analyticsHandlers.forEach(handler => {\r\n                try {\r\n                    handler.sendEvent(event);\r\n                } catch (e) {\r\n                    logger.warn(`Error sending analytics event: ${e}`);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport default new AnalyticsAdapter();\r\n","import { getLogger } from 'qhsense-meet-logger';\r\nimport { BrowserDetection } from 'js-utils';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n// TODO: Move this code to js-utils.\r\n\r\n// NOTE: Now we are extending BrowserDetection in order to preserve\r\n// RTCBrowserType interface but maybe it worth exporting BrowserCapabilities\r\n// and BrowserDetection as separate objects in future.\r\n\r\n/**\r\n * Implements browser capabilities for lib-qhsense-meet.\r\n */\r\nexport default class BrowserCapabilities extends BrowserDetection {\r\n    /**\r\n     * Creates new BrowserCapabilities instance.\r\n     */\r\n    constructor() {\r\n        super();\r\n        logger.info(\r\n            `This appears to be ${this.getName()}, ver: ${this.getVersion()}`);\r\n    }\r\n\r\n    /**\r\n     * Tells whether or not the <tt>MediaStream/tt> is removed from\r\n     * the <tt>PeerConnection</tt> and disposed on video mute (in order to turn\r\n     * off the camera device).\r\n     * @return {boolean} <tt>true</tt> if the current browser supports this\r\n     * strategy or <tt>false</tt> otherwise.\r\n     */\r\n    doesVideoMuteByStreamRemove() {\r\n        return !(\r\n            this.isFirefox()\r\n            || this.isEdge()\r\n            || this.isReactNative()\r\n            || this.isSafariWithWebrtc()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Check whether or not the current browser support peer to peer connections\r\n     * @return {boolean} <tt>true</tt> if p2p is supported or <tt>false</tt>\r\n     * otherwise.\r\n     */\r\n    supportsP2P() {\r\n        return !this.isEdge() && !this.isFirefox();\r\n    }\r\n\r\n    /**\r\n     * Checks if the current browser is Chromium based, that is, it's either\r\n     * Chrome / Chromium or uses it as its engine, but doesn't identify as\r\n     * Chrome.\r\n     *\r\n     * This includes the following browsers:\r\n     * - Chrome and Chromium\r\n     * - Other browsers which use the Chrome engine, but are detected as Chrome,\r\n     *   such as Brave and Vivaldi\r\n     * - Browsers which are NOT Chrome but use it as their engine, and have\r\n     *   custom detection code: Opera, Electron and NW.JS\r\n     */\r\n    isChromiumBased() {\r\n        return this.isChrome()\r\n            || this.isElectron()\r\n            || this.isNWJS()\r\n            || this.isOpera();\r\n    }\r\n\r\n    /**\r\n     * Checks if current browser is a Safari and a version of Safari that\r\n     * supports native webrtc.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    isSafariWithWebrtc() {\r\n        return this.isSafari()\r\n            && !this.isVersionLessThan('11');\r\n    }\r\n\r\n    /**\r\n     * Checks if current browser is a Safari and a version of Safari that\r\n     * supports VP8.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    isSafariWithVP8() {\r\n        return this.isSafari()\r\n            && !this.isVersionLessThan('12.1');\r\n    }\r\n\r\n    /**\r\n     * Checks if the current browser is supported.\r\n     *\r\n     * @returns {boolean} true if the browser is supported, false otherwise.\r\n     */\r\n    isSupported() {\r\n        return this.isChromiumBased()\r\n            || this.isFirefox()\r\n            || this.isReactNative()\r\n            || this.isSafariWithWebrtc();\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the current environment needs a user interaction\r\n     * with the page before any unmute can occur.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    isUserInteractionRequiredForUnmute() {\r\n        return this.isFirefox() || this.isSafari();\r\n    }\r\n\r\n    /**\r\n     * Checks if the current browser triggers 'onmute'/'onunmute' events when\r\n     * user's connection is interrupted and the video stops playback.\r\n     * @returns {*|boolean} 'true' if the event is supported or 'false'\r\n     * otherwise.\r\n     */\r\n    supportsVideoMuteOnConnInterrupted() {\r\n        return this.isChromiumBased() || this.isReactNative()\r\n            || this.isSafariWithVP8();\r\n    }\r\n\r\n    /**\r\n     * Checks if the current browser reports upload and download bandwidth\r\n     * statistics.\r\n     * @return {boolean}\r\n     */\r\n    supportsBandwidthStatistics() {\r\n        // FIXME bandwidth stats are currently not implemented for FF on our\r\n        // side, but not sure if not possible ?\r\n        return !this.isFirefox() && !this.isEdge()\r\n            && !this.isSafariWithWebrtc();\r\n    }\r\n\r\n    /**\r\n     * Checks if the current browser supports WebRTC datachannels.\r\n     * @return {boolean}\r\n     */\r\n    supportsDataChannels() {\r\n        // NOTE: Edge does not yet implement DataChannel.\r\n        return !this.isEdge();\r\n    }\r\n\r\n    /**\r\n     * Checks if the current browser support the device change event.\r\n     * @return {boolean}\r\n     */\r\n    supportsDeviceChangeEvent() {\r\n        return navigator.mediaDevices\r\n            && typeof navigator.mediaDevices.ondevicechange !== 'undefined'\r\n            && typeof navigator.mediaDevices.addEventListener !== 'undefined';\r\n    }\r\n\r\n    /**\r\n     * Checks if the current browser supports RTP statictics collecting.\r\n     * Required by {@link RTPStatsCollector}.\r\n     *\r\n     * @returns {boolean} true if they are supported, false otherwise.\r\n     */\r\n    supportsRtpStatistics() {\r\n        return this.isChromiumBased()\r\n            || this.isEdge()\r\n            || this.isFirefox()\r\n            || this.isReactNative()\r\n            || this.isSafariWithWebrtc();\r\n    }\r\n\r\n    /**\r\n     * Checks if the current browser supports RTT statistics for srflx local\r\n     * candidates through the legacy getStats() API.\r\n     */\r\n    supportsLocalCandidateRttStatistics() {\r\n        return this.isChromiumBased() || this.isReactNative()\r\n            || this.isSafariWithVP8();\r\n    }\r\n\r\n    /**\r\n     * Checks if the current browser reports round trip time statistics for\r\n     * the ICE candidate pair.\r\n     * @return {boolean}\r\n     */\r\n    supportsRTTStatistics() {\r\n        // Firefox does not seem to report RTT for ICE candidate pair:\r\n        // eslint-disable-next-line max-len\r\n        // https://www.w3.org/TR/webrtc-stats/#dom-rtcicecandidatepairstats-currentroundtriptime\r\n        // It does report mozRTT for RTP streams, but at the time of this\r\n        // writing it's value does not make sense most of the time\r\n        // (is reported as 1):\r\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1241066\r\n        // For Chrome and others we rely on 'googRtt'.\r\n        return !this.isFirefox() && !this.isEdge();\r\n    }\r\n\r\n    /**\r\n     * Checks whether the browser supports RTPSender.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    supportsRtpSender() {\r\n        return this.isFirefox() || this.isSafariWithVP8();\r\n    }\r\n\r\n    /**\r\n     * Checks whether the browser supports RTX.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    supportsRtx() {\r\n        return !this.isFirefox() && !this.usesUnifiedPlan();\r\n    }\r\n\r\n    /**\r\n     * Whether qhsense-meet supports simulcast on the current browser.\r\n     * @returns {boolean}\r\n     */\r\n    supportsSimulcast() {\r\n        return this.isChromiumBased() || this.isFirefox()\r\n            || this.isSafariWithVP8() || this.isReactNative();\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the current browser can support capturing video,\r\n     * be it camera or desktop, and displaying received video.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    supportsVideo() {\r\n        // FIXME: Check if we can use supportsVideoOut and supportsVideoIn. I\r\n        // leave the old implementation here in order not to brake something.\r\n\r\n        // Older versions of Safari using webrtc/adapter do not support video\r\n        // due in part to Safari only supporting H264 and the bridge sending VP8\r\n        // Newer Safari support VP8 and other WebRTC features.\r\n        return !this.isSafariWithWebrtc()\r\n            || (this.isSafariWithVP8() && this.usesPlanB());\r\n    }\r\n\r\n    /**\r\n     * Checks if the browser uses plan B.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    usesPlanB() {\r\n        return !this.usesUnifiedPlan();\r\n    }\r\n\r\n    /**\r\n     * Checks if the browser uses unified plan.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    usesUnifiedPlan() {\r\n        if (this.isFirefox()) {\r\n            return true;\r\n        }\r\n\r\n        if (this.isSafariWithVP8()) {\r\n            // eslint-disable-next-line max-len\r\n            // https://trac.webkit.org/changeset/236144/webkit/trunk/LayoutTests/webrtc/video-addLegacyTransceiver.html\r\n            // eslint-disable-next-line no-undef\r\n            return Object.keys(RTCRtpTransceiver.prototype)\r\n                   .indexOf('currentDirection') > -1;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the current browser should be using the new\r\n     * getUserMedia flow, which utilizes the adapter shim. This method should\r\n     * be temporary and used while migrating all browsers to use adapter and\r\n     * the new getUserMedia.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    usesNewGumFlow() {\r\n        const REQUIRED_CHROME_VERSION = 61;\r\n\r\n        if (this.isChrome()) {\r\n            return !this.isVersionLessThan(REQUIRED_CHROME_VERSION);\r\n        }\r\n\r\n        if (this.isFirefox() || this.isSafariWithWebrtc()) {\r\n            return true;\r\n        }\r\n\r\n        if (this.isChromiumBased()) {\r\n            return this._getChromiumBasedVersion() >= REQUIRED_CHROME_VERSION;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the browser uses webrtc-adapter. All browsers using the new\r\n     * getUserMedia flow and Edge.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    usesAdapter() {\r\n        return this.usesNewGumFlow() || this.isEdge();\r\n    }\r\n\r\n    /**\r\n     * Checks if the browser supports getDisplayMedia.\r\n     * @returns {boolean} {@code true} if the browser supports getDisplayMedia.\r\n     */\r\n    supportsGetDisplayMedia() {\r\n        return typeof navigator.getDisplayMedia !== 'undefined'\r\n            || (typeof navigator.mediaDevices !== 'undefined'\r\n                && typeof navigator.mediaDevices.getDisplayMedia\r\n                    !== 'undefined');\r\n    }\r\n\r\n    /**\r\n     * Checks if the browser supports the \"sdpSemantics\" configuration option.\r\n     * https://webrtc.org/web-apis/chrome/unified-plan/\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    supportsSdpSemantics() {\r\n        return this.isChromiumBased() && this._getChromiumBasedVersion() >= 65;\r\n    }\r\n\r\n    /**\r\n     * Returns the version of a Chromium based browser.\r\n     *\r\n     * @returns {Number}\r\n     */\r\n    _getChromiumBasedVersion() {\r\n        if (this.isChromiumBased()) {\r\n            // NW.JS doesn't expose the Chrome version in the UA string.\r\n            if (this.isNWJS()) {\r\n                // eslint-disable-next-line no-undef\r\n                return Number.parseInt(process.versions.chromium, 10);\r\n            }\r\n\r\n            // Here we process all browsers which use the Chrome engine but\r\n            // don't necessarily identify as Chrome. We cannot use the version\r\n            // comparing functions because the Electron, Opera and NW.JS\r\n            // versions are inconsequential here, as we need to know the actual\r\n            // Chrome engine version.\r\n            const ua = navigator.userAgent;\r\n\r\n            if (ua.match(/Chrome/)) {\r\n                const version\r\n                    = Number.parseInt(ua.match(/Chrome\\/([\\d.]+)/)[1], 10);\r\n\r\n                return version;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n}\r\n","/**\n * [js-md5]{@link https://github.com/emn178/js-md5}\n *\n * @namespace md5\n * @version 0.7.3\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n(function () {\n  'use strict';\n\n  var ERROR = 'input is invalid type';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_MD5_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_MD5_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = global;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && typeof module === 'object' && module.exports;\n  var AMD = typeof define === 'function' && define.amd;\n  var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var EXTRA = [128, 32768, 8388608, -2147483648];\n  var SHIFT = [0, 8, 16, 24];\n  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer', 'base64'];\n  var BASE64_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n  var blocks = [], buffer8;\n  if (ARRAY_BUFFER) {\n    var buffer = new ArrayBuffer(68);\n    buffer8 = new Uint8Array(buffer);\n    blocks = new Uint32Array(buffer);\n  }\n\n  if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  /**\n   * @method hex\n   * @memberof md5\n   * @description Output hash as hex string\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {String} Hex string\n   * @example\n   * md5.hex('The quick brown fox jumps over the lazy dog');\n   * // equal to\n   * md5('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method digest\n   * @memberof md5\n   * @description Output hash as bytes array\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Array} Bytes array\n   * @example\n   * md5.digest('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method array\n   * @memberof md5\n   * @description Output hash as bytes array\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Array} Bytes array\n   * @example\n   * md5.array('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method arrayBuffer\n   * @memberof md5\n   * @description Output hash as ArrayBuffer\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @example\n   * md5.arrayBuffer('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method buffer\n   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.\n   * @memberof md5\n   * @description Output hash as ArrayBuffer\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @example\n   * md5.buffer('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method base64\n   * @memberof md5\n   * @description Output hash as base64 string\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {String} base64 string\n   * @example\n   * md5.base64('The quick brown fox jumps over the lazy dog');\n   */\n  var createOutputMethod = function (outputType) {\n    return function (message) {\n      return new Md5(true).update(message)[outputType]();\n    };\n  };\n\n  /**\n   * @method create\n   * @memberof md5\n   * @description Create Md5 object\n   * @returns {Md5} Md5 object.\n   * @example\n   * var hash = md5.create();\n   */\n  /**\n   * @method update\n   * @memberof md5\n   * @description Create and update Md5 object\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Md5} Md5 object.\n   * @example\n   * var hash = md5.update('The quick brown fox jumps over the lazy dog');\n   * // equal to\n   * var hash = md5.create();\n   * hash.update('The quick brown fox jumps over the lazy dog');\n   */\n  var createMethod = function () {\n    var method = createOutputMethod('hex');\n    if (NODE_JS) {\n      method = nodeWrap(method);\n    }\n    method.create = function () {\n      return new Md5();\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createOutputMethod(type);\n    }\n    return method;\n  };\n\n  var nodeWrap = function (method) {\n    var crypto = eval(\"require('crypto')\");\n    var Buffer = eval(\"require('buffer').Buffer\");\n    var nodeMethod = function (message) {\n      if (typeof message === 'string') {\n        return crypto.createHash('md5').update(message, 'utf8').digest('hex');\n      } else {\n        if (message === null || message === undefined) {\n          throw ERROR;\n        } else if (message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        }\n      }\n      if (Array.isArray(message) || ArrayBuffer.isView(message) ||\n        message.constructor === Buffer) {\n        return crypto.createHash('md5').update(new Buffer(message)).digest('hex');\n      } else {\n        return method(message);\n      }\n    };\n    return nodeMethod;\n  };\n\n  /**\n   * Md5 class\n   * @class Md5\n   * @description This is internal class.\n   * @see {@link md5.create}\n   */\n  function Md5(sharedMemory) {\n    if (sharedMemory) {\n      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n      blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n      blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      this.blocks = blocks;\n      this.buffer8 = buffer8;\n    } else {\n      if (ARRAY_BUFFER) {\n        var buffer = new ArrayBuffer(68);\n        this.buffer8 = new Uint8Array(buffer);\n        this.blocks = new Uint32Array(buffer);\n      } else {\n        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n      }\n    }\n    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n  }\n\n  /**\n   * @method update\n   * @memberof Md5\n   * @instance\n   * @description Update hash\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Md5} Md5 object.\n   * @see {@link md5.update}\n   */\n  Md5.prototype.update = function (message) {\n    if (this.finalized) {\n      return;\n    }\n\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw ERROR;\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw ERROR;\n          }\n        }\n      } else {\n        throw ERROR;\n      }\n      notString = true;\n    }\n    var code, index = 0, i, length = message.length, blocks = this.blocks;\n    var buffer8 = this.buffer8;\n\n    while (index < length) {\n      if (this.hashed) {\n        this.hashed = false;\n        blocks[0] = blocks[16];\n        blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      }\n\n      if (notString) {\n        if (ARRAY_BUFFER) {\n          for (i = this.start; index < length && i < 64; ++index) {\n            buffer8[i++] = message[index];\n          }\n        } else {\n          for (i = this.start; index < length && i < 64; ++index) {\n            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n          }\n        }\n      } else {\n        if (ARRAY_BUFFER) {\n          for (i = this.start; index < length && i < 64; ++index) {\n            code = message.charCodeAt(index);\n            if (code < 0x80) {\n              buffer8[i++] = code;\n            } else if (code < 0x800) {\n              buffer8[i++] = 0xc0 | (code >> 6);\n              buffer8[i++] = 0x80 | (code & 0x3f);\n            } else if (code < 0xd800 || code >= 0xe000) {\n              buffer8[i++] = 0xe0 | (code >> 12);\n              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);\n              buffer8[i++] = 0x80 | (code & 0x3f);\n            } else {\n              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n              buffer8[i++] = 0xf0 | (code >> 18);\n              buffer8[i++] = 0x80 | ((code >> 12) & 0x3f);\n              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);\n              buffer8[i++] = 0x80 | (code & 0x3f);\n            }\n          }\n        } else {\n          for (i = this.start; index < length && i < 64; ++index) {\n            code = message.charCodeAt(index);\n            if (code < 0x80) {\n              blocks[i >> 2] |= code << SHIFT[i++ & 3];\n            } else if (code < 0x800) {\n              blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n            } else if (code < 0xd800 || code >= 0xe000) {\n              blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n            } else {\n              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n              blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n            }\n          }\n        }\n      }\n      this.lastByteIndex = i;\n      this.bytes += i - this.start;\n      if (i >= 64) {\n        this.start = i - 64;\n        this.hash();\n        this.hashed = true;\n      } else {\n        this.start = i;\n      }\n    }\n    if (this.bytes > 4294967295) {\n      this.hBytes += this.bytes / 4294967296 << 0;\n      this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n  };\n\n  Md5.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    if (i >= 56) {\n      if (!this.hashed) {\n        this.hash();\n      }\n      blocks[0] = blocks[16];\n      blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n      blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n      blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n    }\n    blocks[14] = this.bytes << 3;\n    blocks[15] = this.hBytes << 3 | this.bytes >>> 29;\n    this.hash();\n  };\n\n  Md5.prototype.hash = function () {\n    var a, b, c, d, bc, da, blocks = this.blocks;\n\n    if (this.first) {\n      a = blocks[0] - 680876937;\n      a = (a << 7 | a >>> 25) - 271733879 << 0;\n      d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;\n      d = (d << 12 | d >>> 20) + a << 0;\n      c = (-271733879 ^ (d & (a ^ -271733879))) + blocks[2] - 1126478375;\n      c = (c << 17 | c >>> 15) + d << 0;\n      b = (a ^ (c & (d ^ a))) + blocks[3] - 1316259209;\n      b = (b << 22 | b >>> 10) + c << 0;\n    } else {\n      a = this.h0;\n      b = this.h1;\n      c = this.h2;\n      d = this.h3;\n      a += (d ^ (b & (c ^ d))) + blocks[0] - 680876936;\n      a = (a << 7 | a >>> 25) + b << 0;\n      d += (c ^ (a & (b ^ c))) + blocks[1] - 389564586;\n      d = (d << 12 | d >>> 20) + a << 0;\n      c += (b ^ (d & (a ^ b))) + blocks[2] + 606105819;\n      c = (c << 17 | c >>> 15) + d << 0;\n      b += (a ^ (c & (d ^ a))) + blocks[3] - 1044525330;\n      b = (b << 22 | b >>> 10) + c << 0;\n    }\n\n    a += (d ^ (b & (c ^ d))) + blocks[4] - 176418897;\n    a = (a << 7 | a >>> 25) + b << 0;\n    d += (c ^ (a & (b ^ c))) + blocks[5] + 1200080426;\n    d = (d << 12 | d >>> 20) + a << 0;\n    c += (b ^ (d & (a ^ b))) + blocks[6] - 1473231341;\n    c = (c << 17 | c >>> 15) + d << 0;\n    b += (a ^ (c & (d ^ a))) + blocks[7] - 45705983;\n    b = (b << 22 | b >>> 10) + c << 0;\n    a += (d ^ (b & (c ^ d))) + blocks[8] + 1770035416;\n    a = (a << 7 | a >>> 25) + b << 0;\n    d += (c ^ (a & (b ^ c))) + blocks[9] - 1958414417;\n    d = (d << 12 | d >>> 20) + a << 0;\n    c += (b ^ (d & (a ^ b))) + blocks[10] - 42063;\n    c = (c << 17 | c >>> 15) + d << 0;\n    b += (a ^ (c & (d ^ a))) + blocks[11] - 1990404162;\n    b = (b << 22 | b >>> 10) + c << 0;\n    a += (d ^ (b & (c ^ d))) + blocks[12] + 1804603682;\n    a = (a << 7 | a >>> 25) + b << 0;\n    d += (c ^ (a & (b ^ c))) + blocks[13] - 40341101;\n    d = (d << 12 | d >>> 20) + a << 0;\n    c += (b ^ (d & (a ^ b))) + blocks[14] - 1502002290;\n    c = (c << 17 | c >>> 15) + d << 0;\n    b += (a ^ (c & (d ^ a))) + blocks[15] + 1236535329;\n    b = (b << 22 | b >>> 10) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[1] - 165796510;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[6] - 1069501632;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[11] + 643717713;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[0] - 373897302;\n    b = (b << 20 | b >>> 12) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[5] - 701558691;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[10] + 38016083;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[15] - 660478335;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[4] - 405537848;\n    b = (b << 20 | b >>> 12) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[9] + 568446438;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[14] - 1019803690;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[3] - 187363961;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[8] + 1163531501;\n    b = (b << 20 | b >>> 12) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[13] - 1444681467;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[2] - 51403784;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[7] + 1735328473;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[12] - 1926607734;\n    b = (b << 20 | b >>> 12) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[5] - 378558;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[8] - 2022574463;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[11] + 1839030562;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[14] - 35309556;\n    b = (b << 23 | b >>> 9) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[1] - 1530992060;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[4] + 1272893353;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[7] - 155497632;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[10] - 1094730640;\n    b = (b << 23 | b >>> 9) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[13] + 681279174;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[0] - 358537222;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[3] - 722521979;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[6] + 76029189;\n    b = (b << 23 | b >>> 9) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[9] - 640364487;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[12] - 421815835;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[15] + 530742520;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[2] - 995338651;\n    b = (b << 23 | b >>> 9) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[0] - 198630844;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[7] + 1126891415;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[14] - 1416354905;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[5] - 57434055;\n    b = (b << 21 | b >>> 11) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[12] + 1700485571;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[3] - 1894986606;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[10] - 1051523;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[1] - 2054922799;\n    b = (b << 21 | b >>> 11) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[8] + 1873313359;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[15] - 30611744;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[6] - 1560198380;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[13] + 1309151649;\n    b = (b << 21 | b >>> 11) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[4] - 145523070;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[11] - 1120210379;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[2] + 718787259;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[9] - 343485551;\n    b = (b << 21 | b >>> 11) + c << 0;\n\n    if (this.first) {\n      this.h0 = a + 1732584193 << 0;\n      this.h1 = b - 271733879 << 0;\n      this.h2 = c - 1732584194 << 0;\n      this.h3 = d + 271733878 << 0;\n      this.first = false;\n    } else {\n      this.h0 = this.h0 + a << 0;\n      this.h1 = this.h1 + b << 0;\n      this.h2 = this.h2 + c << 0;\n      this.h3 = this.h3 + d << 0;\n    }\n  };\n\n  /**\n   * @method hex\n   * @memberof Md5\n   * @instance\n   * @description Output hash as hex string\n   * @returns {String} Hex string\n   * @see {@link md5.hex}\n   * @example\n   * hash.hex();\n   */\n  Md5.prototype.hex = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;\n\n    return HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +\n      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +\n      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +\n      HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +\n      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +\n      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +\n      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +\n      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +\n      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +\n      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +\n      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +\n      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +\n      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +\n      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +\n      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +\n      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F];\n  };\n\n  /**\n   * @method toString\n   * @memberof Md5\n   * @instance\n   * @description Output hash as hex string\n   * @returns {String} Hex string\n   * @see {@link md5.hex}\n   * @example\n   * hash.toString();\n   */\n  Md5.prototype.toString = Md5.prototype.hex;\n\n  /**\n   * @method digest\n   * @memberof Md5\n   * @instance\n   * @description Output hash as bytes array\n   * @returns {Array} Bytes array\n   * @see {@link md5.digest}\n   * @example\n   * hash.digest();\n   */\n  Md5.prototype.digest = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;\n    return [\n      h0 & 0xFF, (h0 >> 8) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 24) & 0xFF,\n      h1 & 0xFF, (h1 >> 8) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 24) & 0xFF,\n      h2 & 0xFF, (h2 >> 8) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 24) & 0xFF,\n      h3 & 0xFF, (h3 >> 8) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 24) & 0xFF\n    ];\n  };\n\n  /**\n   * @method array\n   * @memberof Md5\n   * @instance\n   * @description Output hash as bytes array\n   * @returns {Array} Bytes array\n   * @see {@link md5.array}\n   * @example\n   * hash.array();\n   */\n  Md5.prototype.array = Md5.prototype.digest;\n\n  /**\n   * @method arrayBuffer\n   * @memberof Md5\n   * @instance\n   * @description Output hash as ArrayBuffer\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @see {@link md5.arrayBuffer}\n   * @example\n   * hash.arrayBuffer();\n   */\n  Md5.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var buffer = new ArrayBuffer(16);\n    var blocks = new Uint32Array(buffer);\n    blocks[0] = this.h0;\n    blocks[1] = this.h1;\n    blocks[2] = this.h2;\n    blocks[3] = this.h3;\n    return buffer;\n  };\n\n  /**\n   * @method buffer\n   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.\n   * @memberof Md5\n   * @instance\n   * @description Output hash as ArrayBuffer\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @see {@link md5.buffer}\n   * @example\n   * hash.buffer();\n   */\n  Md5.prototype.buffer = Md5.prototype.arrayBuffer;\n\n  /**\n   * @method base64\n   * @memberof Md5\n   * @instance\n   * @description Output hash as base64 string\n   * @returns {String} base64 string\n   * @see {@link md5.base64}\n   * @example\n   * hash.base64();\n   */\n  Md5.prototype.base64 = function () {\n    var v1, v2, v3, base64Str = '', bytes = this.array();\n    for (var i = 0; i < 15;) {\n      v1 = bytes[i++];\n      v2 = bytes[i++];\n      v3 = bytes[i++];\n      base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] +\n        BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] +\n        BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] +\n        BASE64_ENCODE_CHAR[v3 & 63];\n    }\n    v1 = bytes[i];\n    base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] +\n      BASE64_ENCODE_CHAR[(v1 << 4) & 63] +\n      '==';\n    return base64Str;\n  };\n\n  var exports = createMethod();\n\n  if (COMMON_JS) {\n    module.exports = exports;\n  } else {\n    /**\n     * @method md5\b\n     * @description Md5 hash function, export to global in browsers.\n     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n     * @returns {String} md5 hashes\n     * @example\n     * md5(''); // d41d8cd98f00b204e9800998ecf8427e\n     * md5('The quick brown fox jumps over the lazy dog'); // 9e107d9d372bb6826bd81d3542a419d6\n     * md5('The quick brown fox jumps over the lazy dog.'); // e4d909c290d0fb1ca068ffaddf22cbd0\n     *\n     * // It also supports UTF-8 encoding\n     * md5(''); // a7bac2239fcdcb3a067903d8077c4a07\n     *\n     * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`\n     * md5([]); // d41d8cd98f00b204e9800998ecf8427e\n     * md5(new Uint8Array([])); // d41d8cd98f00b204e9800998ecf8427e\n     */\n    root.md5 = exports;\n    if (AMD) {\n      define(function () {\n        return exports;\n      });\n    }\n  }\n})();\n","const RandomUtil = require('./RandomUtil');\r\n\r\n/**\r\n * from faker.js - Copyright (c) 2014-2015 Matthew Bergman & Marak Squires\r\n * MIT License\r\n * http://github.com/marak/faker.js/\r\n *\r\n * @const\r\n */\r\nconst names = [\r\n    'Aaliyah', 'Aaron', 'Abagail', 'Abbey', 'Abbie', 'Abbigail', 'Abby',\r\n    'Abdiel', 'Abdul', 'Abdullah', 'Abe', 'Abel', 'Abelardo', 'Abigail',\r\n    'Abigale', 'Abigayle', 'Abner', 'Abraham', 'Ada', 'Adah', 'Adalberto',\r\n    'Adaline', 'Adam', 'Adan', 'Addie', 'Addison', 'Adela', 'Adelbert', 'Adele',\r\n    'Adelia', 'Adeline', 'Adell', 'Adella', 'Adelle', 'Aditya', 'Adolf',\r\n    'Adolfo', 'Adolph', 'Adolphus', 'Adonis', 'Adrain', 'Adrian', 'Adriana',\r\n    'Adrianna', 'Adriel', 'Adrien', 'Adrienne', 'Afton', 'Aglae', 'Agnes',\r\n    'Agustin', 'Agustina', 'Ahmad', 'Ahmed', 'Aida', 'Aidan', 'Aiden', 'Aileen',\r\n    'Aisha', 'Aiyana', 'Akeem', 'Al', 'Alaina', 'Alan', 'Alana', 'Alanis',\r\n    'Alanna', 'Alayna', 'Alba', 'Albert', 'Alberta', 'Albertha', 'Alberto',\r\n    'Albin', 'Albina', 'Alda', 'Alden', 'Alec', 'Aleen', 'Alejandra',\r\n    'Alejandrin', 'Alek', 'Alena', 'Alene', 'Alessandra', 'Alessandro',\r\n    'Alessia', 'Aletha', 'Alex', 'Alexa', 'Alexander', 'Alexandra', 'Alexandre',\r\n    'Alexandrea', 'Alexandria', 'Alexandrine', 'Alexandro', 'Alexane',\r\n    'Alexanne', 'Alexie', 'Alexis', 'Alexys', 'Alexzander', 'Alf', 'Alfonso',\r\n    'Alfonzo', 'Alford', 'Alfred', 'Alfreda', 'Alfredo', 'Ali', 'Alia', 'Alice',\r\n    'Alicia', 'Alisa', 'Alisha', 'Alison', 'Alivia', 'Aliya', 'Aliyah', 'Aliza',\r\n    'Alize', 'Allan', 'Allen', 'Allene', 'Allie', 'Allison', 'Ally', 'Alphonso',\r\n    'Alta', 'Althea', 'Alva', 'Alvah', 'Alvena', 'Alvera', 'Alverta', 'Alvina',\r\n    'Alvis', 'Alyce', 'Alycia', 'Alysa', 'Alysha', 'Alyson', 'Alysson',\r\n    'Amalia', 'Amanda', 'Amani', 'Amara', 'Amari', 'Amaya', 'Amber', 'Ambrose',\r\n    'Amelia', 'Amelie', 'Amely', 'America', 'Americo', 'Amie', 'Amina', 'Amir',\r\n    'Amira', 'Amiya', 'Amos', 'Amparo', 'Amy', 'Amya', 'Ana', 'Anabel',\r\n    'Anabelle', 'Anahi', 'Anais', 'Anastacio', 'Anastasia', 'Anderson', 'Andre',\r\n    'Andreane', 'Andreanne', 'Andres', 'Andrew', 'Andy', 'Angel', 'Angela',\r\n    'Angelica', 'Angelina', 'Angeline', 'Angelita', 'Angelo', 'Angie', 'Angus',\r\n    'Anibal', 'Anika', 'Anissa', 'Anita', 'Aniya', 'Aniyah', 'Anjali', 'Anna',\r\n    'Annabel', 'Annabell', 'Annabelle', 'Annalise', 'Annamae', 'Annamarie',\r\n    'Anne', 'Annetta', 'Annette', 'Annie', 'Ansel', 'Ansley', 'Anthony',\r\n    'Antoinette', 'Antone', 'Antonetta', 'Antonette', 'Antonia', 'Antonietta',\r\n    'Antonina', 'Antonio', 'Antwan', 'Antwon', 'Anya', 'April', 'Ara',\r\n    'Araceli', 'Aracely', 'Arch', 'Archibald', 'Ardella', 'Arden', 'Ardith',\r\n    'Arely', 'Ari', 'Ariane', 'Arianna', 'Aric', 'Ariel', 'Arielle', 'Arjun',\r\n    'Arlene', 'Arlie', 'Arlo', 'Armand', 'Armando', 'Armani', 'Arnaldo', 'Arne',\r\n    'Arno', 'Arnold', 'Arnoldo', 'Arnulfo', 'Aron', 'Art', 'Arthur', 'Arturo',\r\n    'Arvel', 'Arvid', 'Arvilla', 'Aryanna', 'Asa', 'Asha', 'Ashlee', 'Ashleigh',\r\n    'Ashley', 'Ashly', 'Ashlynn', 'Ashton', 'Ashtyn', 'Asia', 'Assunta',\r\n    'Astrid', 'Athena', 'Aubree', 'Aubrey', 'Audie', 'Audra', 'Audreanne',\r\n    'Audrey', 'August', 'Augusta', 'Augustine', 'Augustus', 'Aurelia',\r\n    'Aurelie', 'Aurelio', 'Aurore', 'Austen', 'Austin', 'Austyn', 'Autumn',\r\n    'Ava', 'Avery', 'Avis', 'Axel', 'Ayana', 'Ayden', 'Ayla', 'Aylin', 'Baby',\r\n    'Bailee', 'Bailey', 'Barbara', 'Barney', 'Baron', 'Barrett', 'Barry',\r\n    'Bart', 'Bartholome', 'Barton', 'Baylee', 'Beatrice', 'Beau', 'Beaulah',\r\n    'Bell', 'Bella', 'Belle', 'Ben', 'Benedict', 'Benjamin', 'Bennett',\r\n    'Bennie', 'Benny', 'Benton', 'Berenice', 'Bernadette', 'Bernadine',\r\n    'Bernard', 'Bernardo', 'Berneice', 'Bernhard', 'Bernice', 'Bernie',\r\n    'Berniece', 'Bernita', 'Berry', 'Bert', 'Berta', 'Bertha', 'Bertram',\r\n    'Bertrand', 'Beryl', 'Bessie', 'Beth', 'Bethany', 'Bethel', 'Betsy',\r\n    'Bette', 'Bettie', 'Betty', 'Bettye', 'Beulah', 'Beverly', 'Bianka', 'Bill',\r\n    'Billie', 'Billy', 'Birdie', 'Blair', 'Blaise', 'Blake', 'Blanca',\r\n    'Blanche', 'Blaze', 'Bo', 'Bobbie', 'Bobby', 'Bonita', 'Bonnie', 'Boris',\r\n    'Boyd', 'Brad', 'Braden', 'Bradford', 'Bradley', 'Bradly', 'Brady',\r\n    'Braeden', 'Brain', 'Brandi', 'Brando', 'Brandon', 'Brandt', 'Brandy',\r\n    'Brandyn', 'Brannon', 'Branson', 'Brant', 'Braulio', 'Braxton', 'Brayan',\r\n    'Breana', 'Breanna', 'Breanne', 'Brenda', 'Brendan', 'Brenden', 'Brendon',\r\n    'Brenna', 'Brennan', 'Brennon', 'Brent', 'Bret', 'Brett', 'Bria', 'Brian',\r\n    'Briana', 'Brianne', 'Brice', 'Bridget', 'Bridgette', 'Bridie', 'Brielle',\r\n    'Brigitte', 'Brionna', 'Brisa', 'Britney', 'Brittany', 'Brock', 'Broderick',\r\n    'Brody', 'Brook', 'Brooke', 'Brooklyn', 'Brooks', 'Brown', 'Bruce',\r\n    'Bryana', 'Bryce', 'Brycen', 'Bryon', 'Buck', 'Bud', 'Buddy', 'Buford',\r\n    'Bulah', 'Burdette', 'Burley', 'Burnice', 'Buster', 'Cade', 'Caden',\r\n    'Caesar', 'Caitlyn', 'Cale', 'Caleb', 'Caleigh', 'Cali', 'Calista',\r\n    'Callie', 'Camden', 'Cameron', 'Camila', 'Camilla', 'Camille', 'Camren',\r\n    'Camron', 'Camryn', 'Camylle', 'Candace', 'Candelario', 'Candice',\r\n    'Candida', 'Candido', 'Cara', 'Carey', 'Carissa', 'Carlee', 'Carleton',\r\n    'Carley', 'Carli', 'Carlie', 'Carlo', 'Carlos', 'Carlotta', 'Carmel',\r\n    'Carmela', 'Carmella', 'Carmelo', 'Carmen', 'Carmine', 'Carol', 'Carolanne',\r\n    'Carole', 'Carolina', 'Caroline', 'Carolyn', 'Carolyne', 'Carrie',\r\n    'Carroll', 'Carson', 'Carter', 'Cary', 'Casandra', 'Casey', 'Casimer',\r\n    'Casimir', 'Casper', 'Cassandra', 'Cassandre', 'Cassidy', 'Cassie',\r\n    'Catalina', 'Caterina', 'Catharine', 'Catherine', 'Cathrine', 'Cathryn',\r\n    'Cathy', 'Cayla', 'Ceasar', 'Cecelia', 'Cecil', 'Cecile', 'Cecilia',\r\n    'Cedrick', 'Celestine', 'Celestino', 'Celia', 'Celine', 'Cesar', 'Chad',\r\n    'Chadd', 'Chadrick', 'Chaim', 'Chance', 'Chandler', 'Chanel', 'Chanelle',\r\n    'Charity', 'Charlene', 'Charles', 'Charley', 'Charlie', 'Charlotte',\r\n    'Chase', 'Chasity', 'Chauncey', 'Chaya', 'Chaz', 'Chelsea', 'Chelsey',\r\n    'Chelsie', 'Chesley', 'Chester', 'Chet', 'Cheyanne', 'Cheyenne', 'Chloe',\r\n    'Chris', 'Christ', 'Christa', 'Christelle', 'Christian', 'Christiana',\r\n    'Christina', 'Christine', 'Christop', 'Christophe', 'Christopher',\r\n    'Christy', 'Chyna', 'Ciara', 'Cicero', 'Cielo', 'Cierra', 'Cindy',\r\n    'Citlalli', 'Clair', 'Claire', 'Clara', 'Clarabelle', 'Clare', 'Clarissa',\r\n    'Clark', 'Claud', 'Claude', 'Claudia', 'Claudie', 'Claudine', 'Clay',\r\n    'Clemens', 'Clement', 'Clementina', 'Clementine', 'Clemmie', 'Cleo',\r\n    'Cleora', 'Cleta', 'Cletus', 'Cleve', 'Cleveland', 'Clifford', 'Clifton',\r\n    'Clint', 'Clinton', 'Clotilde', 'Clovis', 'Cloyd', 'Clyde', 'Coby', 'Cody',\r\n    'Colby', 'Cole', 'Coleman', 'Colin', 'Colleen', 'Collin', 'Colt', 'Colten',\r\n    'Colton', 'Columbus', 'Concepcion', 'Conner', 'Connie', 'Connor', 'Conor',\r\n    'Conrad', 'Constance', 'Constantin', 'Consuelo', 'Cooper', 'Cora',\r\n    'Coralie', 'Corbin', 'Cordelia', 'Cordell', 'Cordia', 'Cordie', 'Corene',\r\n    'Corine', 'Cornelius', 'Cornell', 'Corrine', 'Cortez', 'Cortney', 'Cory',\r\n    'Coty', 'Courtney', 'Coy', 'Craig', 'Crawford', 'Creola', 'Cristal',\r\n    'Cristian', 'Cristina', 'Cristobal', 'Cristopher', 'Cruz', 'Crystal',\r\n    'Crystel', 'Cullen', 'Curt', 'Curtis', 'Cydney', 'Cynthia', 'Cyril',\r\n    'Cyrus', 'Dagmar', 'Dahlia', 'Daija', 'Daisha', 'Daisy', 'Dakota', 'Dale',\r\n    'Dallas', 'Dallin', 'Dalton', 'Damaris', 'Dameon', 'Damian', 'Damien',\r\n    'Damion', 'Damon', 'Dan', 'Dana', 'Dandre', 'Dane', 'D\\'angelo', 'Dangelo',\r\n    'Danial', 'Daniela', 'Daniella', 'Danielle', 'Danika', 'Dannie', 'Danny',\r\n    'Dante', 'Danyka', 'Daphne', 'Daphnee', 'Daphney', 'Darby', 'Daren',\r\n    'Darian', 'Dariana', 'Darien', 'Dario', 'Darion', 'Darius', 'Darlene',\r\n    'Daron', 'Darrel', 'Darrell', 'Darren', 'Darrick', 'Darrin', 'Darrion',\r\n    'Darron', 'Darryl', 'Darwin', 'Daryl', 'Dashawn', 'Dasia', 'Dave', 'David',\r\n    'Davin', 'Davion', 'Davon', 'Davonte', 'Dawn', 'Dawson', 'Dax', 'Dayana',\r\n    'Dayna', 'Dayne', 'Dayton', 'Dean', 'Deangelo', 'Deanna', 'Deborah',\r\n    'Declan', 'Dedric', 'Dedrick', 'Dee', 'Deion', 'Deja', 'Dejah', 'Dejon',\r\n    'Dejuan', 'Delaney', 'Delbert', 'Delfina', 'Delia', 'Delilah', 'Dell',\r\n    'Della', 'Delmer', 'Delores', 'Delpha', 'Delphia', 'Delphine', 'Delta',\r\n    'Demarco', 'Demarcus', 'Demario', 'Demetris', 'Demetrius', 'Demond', 'Dena',\r\n    'Denis', 'Dennis', 'Deon', 'Deondre', 'Deontae', 'Deonte', 'Dereck',\r\n    'Derek', 'Derick', 'Deron', 'Derrick', 'Deshaun', 'Deshawn', 'Desiree',\r\n    'Desmond', 'Dessie', 'Destany', 'Destin', 'Destinee', 'Destiney', 'Destini',\r\n    'Destiny', 'Devan', 'Devante', 'Deven', 'Devin', 'Devon', 'Devonte',\r\n    'Devyn', 'Dewayne', 'Dewitt', 'Dexter', 'Diamond', 'Diana', 'Dianna',\r\n    'Diego', 'Dillan', 'Dillon', 'Dimitri', 'Dina', 'Dino', 'Dion', 'Dixie',\r\n    'Dock', 'Dolly', 'Dolores', 'Domenic', 'Domenica', 'Domenick', 'Domenico',\r\n    'Domingo', 'Dominic', 'Dominique', 'Don', 'Donald', 'Donato', 'Donavon',\r\n    'Donna', 'Donnell', 'Donnie', 'Donny', 'Dora', 'Dorcas', 'Dorian', 'Doris',\r\n    'Dorothea', 'Dorothy', 'Dorris', 'Dortha', 'Dorthy', 'Doug', 'Douglas',\r\n    'Dovie', 'Doyle', 'Drake', 'Drew', 'Duane', 'Dudley', 'Dulce', 'Duncan',\r\n    'Durward', 'Dustin', 'Dusty', 'Dwight', 'Dylan', 'Earl', 'Earlene',\r\n    'Earline', 'Earnest', 'Earnestine', 'Easter', 'Easton', 'Ebba', 'Ebony',\r\n    'Ed', 'Eda', 'Edd', 'Eddie', 'Eden', 'Edgar', 'Edgardo', 'Edison', 'Edmond',\r\n    'Edmund', 'Edna', 'Eduardo', 'Edward', 'Edwardo', 'Edwin', 'Edwina',\r\n    'Edyth', 'Edythe', 'Effie', 'Efrain', 'Efren', 'Eileen', 'Einar', 'Eino',\r\n    'Eladio', 'Elaina', 'Elbert', 'Elda', 'Eldon', 'Eldora', 'Eldred',\r\n    'Eldridge', 'Eleanora', 'Eleanore', 'Eleazar', 'Electa', 'Elena', 'Elenor',\r\n    'Elenora', 'Eleonore', 'Elfrieda', 'Eli', 'Elian', 'Eliane', 'Elias',\r\n    'Eliezer', 'Elijah', 'Elinor', 'Elinore', 'Elisa', 'Elisabeth', 'Elise',\r\n    'Eliseo', 'Elisha', 'Elissa', 'Eliza', 'Elizabeth', 'Ella', 'Ellen',\r\n    'Ellie', 'Elliot', 'Elliott', 'Ellis', 'Ellsworth', 'Elmer', 'Elmira',\r\n    'Elmo', 'Elmore', 'Elna', 'Elnora', 'Elody', 'Eloisa', 'Eloise', 'Elouise',\r\n    'Eloy', 'Elroy', 'Elsa', 'Else', 'Elsie', 'Elta', 'Elton', 'Elva', 'Elvera',\r\n    'Elvie', 'Elvis', 'Elwin', 'Elwyn', 'Elyse', 'Elyssa', 'Elza', 'Emanuel',\r\n    'Emelia', 'Emelie', 'Emely', 'Emerald', 'Emerson', 'Emery', 'Emie', 'Emil',\r\n    'Emile', 'Emilia', 'Emiliano', 'Emilie', 'Emilio', 'Emily', 'Emma',\r\n    'Emmalee', 'Emmanuel', 'Emmanuelle', 'Emmet', 'Emmett', 'Emmie', 'Emmitt',\r\n    'Emmy', 'Emory', 'Ena', 'Enid', 'Enoch', 'Enola', 'Enos', 'Enrico',\r\n    'Enrique', 'Ephraim', 'Era', 'Eriberto', 'Eric', 'Erica', 'Erich', 'Erick',\r\n    'Ericka', 'Erik', 'Erika', 'Erin', 'Erling', 'Erna', 'Ernest', 'Ernestina',\r\n    'Ernestine', 'Ernesto', 'Ernie', 'Ervin', 'Erwin', 'Eryn', 'Esmeralda',\r\n    'Esperanza', 'Esta', 'Esteban', 'Estefania', 'Estel', 'Estell', 'Estella',\r\n    'Estelle', 'Estevan', 'Esther', 'Estrella', 'Etha', 'Ethan', 'Ethel',\r\n    'Ethelyn', 'Ethyl', 'Ettie', 'Eudora', 'Eugene', 'Eugenia', 'Eula', 'Eulah',\r\n    'Eulalia', 'Euna', 'Eunice', 'Eusebio', 'Eva', 'Evalyn', 'Evan',\r\n    'Evangeline', 'Evans', 'Eve', 'Eveline', 'Evelyn', 'Everardo', 'Everett',\r\n    'Everette', 'Evert', 'Evie', 'Ewald', 'Ewell', 'Ezekiel', 'Ezequiel',\r\n    'Ezra', 'Fabian', 'Fabiola', 'Fae', 'Fannie', 'Fanny', 'Fatima', 'Faustino',\r\n    'Fausto', 'Favian', 'Fay', 'Faye', 'Federico', 'Felicia', 'Felicita',\r\n    'Felicity', 'Felipa', 'Felipe', 'Felix', 'Felton', 'Fermin', 'Fern',\r\n    'Fernando', 'Ferne', 'Fidel', 'Filiberto', 'Filomena', 'Finn', 'Fiona',\r\n    'Flavie', 'Flavio', 'Fleta', 'Fletcher', 'Flo', 'Florence', 'Florencio',\r\n    'Florian', 'Florida', 'Florine', 'Flossie', 'Floy', 'Floyd', 'Ford',\r\n    'Forest', 'Forrest', 'Foster', 'Frances', 'Francesca', 'Francesco',\r\n    'Francis', 'Francisca', 'Francisco', 'Franco', 'Frank', 'Frankie', 'Franz',\r\n    'Fred', 'Freda', 'Freddie', 'Freddy', 'Frederic', 'Frederick', 'Frederik',\r\n    'Frederique', 'Fredrick', 'Fredy', 'Freeda', 'Freeman', 'Freida', 'Frida',\r\n    'Frieda', 'Friedrich', 'Fritz', 'Furman', 'Gabe', 'Gabriel', 'Gabriella',\r\n    'Gabrielle', 'Gaetano', 'Gage', 'Gail', 'Gardner', 'Garett', 'Garfield',\r\n    'Garland', 'Garnet', 'Garnett', 'Garret', 'Garrett', 'Garrick', 'Garrison',\r\n    'Garry', 'Garth', 'Gaston', 'Gavin', 'Gay', 'Gayle', 'Gaylord', 'Gene',\r\n    'General', 'Genesis', 'Genevieve', 'Gennaro', 'Genoveva', 'Geo', 'Geoffrey',\r\n    'George', 'Georgette', 'Georgiana', 'Georgianna', 'Geovanni', 'Geovanny',\r\n    'Geovany', 'Gerald', 'Geraldine', 'Gerard', 'Gerardo', 'Gerda', 'Gerhard',\r\n    'Germaine', 'German', 'Gerry', 'Gerson', 'Gertrude', 'Gia', 'Gianni',\r\n    'Gideon', 'Gilbert', 'Gilberto', 'Gilda', 'Giles', 'Gillian', 'Gina',\r\n    'Gino', 'Giovani', 'Giovanna', 'Giovanni', 'Giovanny', 'Gisselle',\r\n    'Giuseppe', 'Gladyce', 'Gladys', 'Glen', 'Glenda', 'Glenna', 'Glennie',\r\n    'Gloria', 'Godfrey', 'Golda', 'Golden', 'Gonzalo', 'Gordon', 'Grace',\r\n    'Gracie', 'Graciela', 'Grady', 'Graham', 'Grant', 'Granville', 'Grayce',\r\n    'Grayson', 'Green', 'Greg', 'Gregg', 'Gregoria', 'Gregorio', 'Gregory',\r\n    'Greta', 'Gretchen', 'Greyson', 'Griffin', 'Grover', 'Guadalupe', 'Gudrun',\r\n    'Guido', 'Guillermo', 'Guiseppe', 'Gunnar', 'Gunner', 'Gus', 'Gussie',\r\n    'Gust', 'Gustave', 'Guy', 'Gwen', 'Gwendolyn', 'Hadley', 'Hailee', 'Hailey',\r\n    'Hailie', 'Hal', 'Haleigh', 'Haley', 'Halie', 'Halle', 'Hallie', 'Hank',\r\n    'Hanna', 'Hannah', 'Hans', 'Hardy', 'Harley', 'Harmon', 'Harmony', 'Harold',\r\n    'Harrison', 'Harry', 'Harvey', 'Haskell', 'Hassan', 'Hassie', 'Hattie',\r\n    'Haven', 'Hayden', 'Haylee', 'Hayley', 'Haylie', 'Hazel', 'Hazle', 'Heath',\r\n    'Heather', 'Heaven', 'Heber', 'Hector', 'Heidi', 'Helen', 'Helena',\r\n    'Helene', 'Helga', 'Hellen', 'Helmer', 'Heloise', 'Henderson', 'Henri',\r\n    'Henriette', 'Henry', 'Herbert', 'Herman', 'Hermann', 'Hermina', 'Herminia',\r\n    'Herminio', 'Hershel', 'Herta', 'Hertha', 'Hester', 'Hettie', 'Hilario',\r\n    'Hilbert', 'Hilda', 'Hildegard', 'Hillard', 'Hillary', 'Hilma', 'Hilton',\r\n    'Hipolito', 'Hiram', 'Hobart', 'Holden', 'Hollie', 'Hollis', 'Holly',\r\n    'Hope', 'Horace', 'Horacio', 'Hortense', 'Hosea', 'Houston', 'Howard',\r\n    'Howell', 'Hoyt', 'Hubert', 'Hudson', 'Hugh', 'Hulda', 'Humberto', 'Hunter',\r\n    'Hyman', 'Ian', 'Ibrahim', 'Icie', 'Ida', 'Idell', 'Idella', 'Ignacio',\r\n    'Ignatius', 'Ike', 'Ila', 'Ilene', 'Iliana', 'Ima', 'Imani', 'Imelda',\r\n    'Immanuel', 'Imogene', 'Ines', 'Irma', 'Irving', 'Irwin', 'Isaac', 'Isabel',\r\n    'Isabell', 'Isabella', 'Isabelle', 'Isac', 'Isadore', 'Isai', 'Isaiah',\r\n    'Isaias', 'Isidro', 'Ismael', 'Isobel', 'Isom', 'Israel', 'Issac', 'Itzel',\r\n    'Iva', 'Ivah', 'Ivory', 'Ivy', 'Izabella', 'Izaiah', 'Jabari', 'Jace',\r\n    'Jacey', 'Jacinthe', 'Jacinto', 'Jack', 'Jackeline', 'Jackie', 'Jacklyn',\r\n    'Jackson', 'Jacky', 'Jaclyn', 'Jacquelyn', 'Jacques', 'Jacynthe', 'Jada',\r\n    'Jade', 'Jaden', 'Jadon', 'Jadyn', 'Jaeden', 'Jaida', 'Jaiden', 'Jailyn',\r\n    'Jaime', 'Jairo', 'Jakayla', 'Jake', 'Jakob', 'Jaleel', 'Jalen', 'Jalon',\r\n    'Jalyn', 'Jamaal', 'Jamal', 'Jamar', 'Jamarcus', 'Jamel', 'Jameson',\r\n    'Jamey', 'Jamie', 'Jamil', 'Jamir', 'Jamison', 'Jammie', 'Jan', 'Jana',\r\n    'Janae', 'Jane', 'Janelle', 'Janessa', 'Janet', 'Janice', 'Janick', 'Janie',\r\n    'Janis', 'Janiya', 'Jannie', 'Jany', 'Jaquan', 'Jaquelin', 'Jaqueline',\r\n    'Jared', 'Jaren', 'Jarod', 'Jaron', 'Jarred', 'Jarrell', 'Jarret',\r\n    'Jarrett', 'Jarrod', 'Jarvis', 'Jasen', 'Jasmin', 'Jason', 'Jasper',\r\n    'Jaunita', 'Javier', 'Javon', 'Javonte', 'Jay', 'Jayce', 'Jaycee', 'Jayda',\r\n    'Jayde', 'Jayden', 'Jaydon', 'Jaylan', 'Jaylen', 'Jaylin', 'Jaylon',\r\n    'Jayme', 'Jayne', 'Jayson', 'Jazlyn', 'Jazmin', 'Jazmyn', 'Jazmyne', 'Jean',\r\n    'Jeanette', 'Jeanie', 'Jeanne', 'Jed', 'Jedediah', 'Jedidiah', 'Jeff',\r\n    'Jefferey', 'Jeffery', 'Jeffrey', 'Jeffry', 'Jena', 'Jenifer', 'Jennie',\r\n    'Jennifer', 'Jennings', 'Jennyfer', 'Jensen', 'Jerad', 'Jerald', 'Jeramie',\r\n    'Jeramy', 'Jerel', 'Jeremie', 'Jeremy', 'Jermain', 'Jermaine', 'Jermey',\r\n    'Jerod', 'Jerome', 'Jeromy', 'Jerrell', 'Jerrod', 'Jerrold', 'Jerry',\r\n    'Jess', 'Jesse', 'Jessica', 'Jessie', 'Jessika', 'Jessy', 'Jessyca',\r\n    'Jesus', 'Jett', 'Jettie', 'Jevon', 'Jewel', 'Jewell', 'Jillian', 'Jimmie',\r\n    'Jimmy', 'Jo', 'Joan', 'Joana', 'Joanie', 'Joanne', 'Joannie', 'Joanny',\r\n    'Joany', 'Joaquin', 'Jocelyn', 'Jodie', 'Jody', 'Joe', 'Joel', 'Joelle',\r\n    'Joesph', 'Joey', 'Johan', 'Johann', 'Johanna', 'Johathan', 'John',\r\n    'Johnathan', 'Johnathon', 'Johnnie', 'Johnny', 'Johnpaul', 'Johnson',\r\n    'Jolie', 'Jon', 'Jonas', 'Jonatan', 'Jonathan', 'Jonathon', 'Jordan',\r\n    'Jordane', 'Jordi', 'Jordon', 'Jordy', 'Jordyn', 'Jorge', 'Jose', 'Josefa',\r\n    'Josefina', 'Joseph', 'Josephine', 'Josh', 'Joshua', 'Joshuah', 'Josiah',\r\n    'Josiane', 'Josianne', 'Josie', 'Josue', 'Jovan', 'Jovani', 'Jovanny',\r\n    'Jovany', 'Joy', 'Joyce', 'Juana', 'Juanita', 'Judah', 'Judd', 'Jude',\r\n    'Judge', 'Judson', 'Judy', 'Jules', 'Julia', 'Julian', 'Juliana',\r\n    'Julianne', 'Julie', 'Julien', 'Juliet', 'Julio', 'Julius', 'June',\r\n    'Junior', 'Junius', 'Justen', 'Justice', 'Justina', 'Justine', 'Juston',\r\n    'Justus', 'Justyn', 'Juvenal', 'Juwan', 'Kacey', 'Kaci', 'Kacie', 'Kade',\r\n    'Kaden', 'Kadin', 'Kaela', 'Kaelyn', 'Kaia', 'Kailee', 'Kailey', 'Kailyn',\r\n    'Kaitlin', 'Kaitlyn', 'Kale', 'Kaleb', 'Kaleigh', 'Kaley', 'Kali', 'Kallie',\r\n    'Kameron', 'Kamille', 'Kamren', 'Kamron', 'Kamryn', 'Kane', 'Kara',\r\n    'Kareem', 'Karelle', 'Karen', 'Kari', 'Kariane', 'Karianne', 'Karina',\r\n    'Karine', 'Karl', 'Karlee', 'Karley', 'Karli', 'Karlie', 'Karolann',\r\n    'Karson', 'Kasandra', 'Kasey', 'Kassandra', 'Katarina', 'Katelin',\r\n    'Katelyn', 'Katelynn', 'Katharina', 'Katherine', 'Katheryn', 'Kathleen',\r\n    'Kathlyn', 'Kathryn', 'Kathryne', 'Katlyn', 'Katlynn', 'Katrina', 'Katrine',\r\n    'Kattie', 'Kavon', 'Kay', 'Kaya', 'Kaycee', 'Kayden', 'Kayla', 'Kaylah',\r\n    'Kaylee', 'Kayleigh', 'Kayley', 'Kayli', 'Kaylie', 'Kaylin', 'Keagan',\r\n    'Keanu', 'Keara', 'Keaton', 'Keegan', 'Keeley', 'Keely', 'Keenan', 'Keira',\r\n    'Keith', 'Kellen', 'Kelley', 'Kelli', 'Kellie', 'Kelly', 'Kelsi', 'Kelsie',\r\n    'Kelton', 'Kelvin', 'Ken', 'Kendall', 'Kendra', 'Kendrick', 'Kenna',\r\n    'Kennedi', 'Kennedy', 'Kenneth', 'Kennith', 'Kenny', 'Kenton', 'Kenya',\r\n    'Kenyatta', 'Kenyon', 'Keon', 'Keshaun', 'Keshawn', 'Keven', 'Kevin',\r\n    'Kevon', 'Keyon', 'Keyshawn', 'Khalid', 'Khalil', 'Kian', 'Kiana', 'Kianna',\r\n    'Kiara', 'Kiarra', 'Kiel', 'Kiera', 'Kieran', 'Kiley', 'Kim', 'Kimberly',\r\n    'King', 'Kip', 'Kira', 'Kirk', 'Kirsten', 'Kirstin', 'Kitty', 'Kobe',\r\n    'Koby', 'Kody', 'Kolby', 'Kole', 'Korbin', 'Korey', 'Kory', 'Kraig', 'Kris',\r\n    'Krista', 'Kristian', 'Kristin', 'Kristina', 'Kristofer', 'Kristoffer',\r\n    'Kristopher', 'Kristy', 'Krystal', 'Krystel', 'Krystina', 'Kurt', 'Kurtis',\r\n    'Kyla', 'Kyle', 'Kylee', 'Kyleigh', 'Kyler', 'Kylie', 'Kyra', 'Lacey',\r\n    'Lacy', 'Ladarius', 'Lafayette', 'Laila', 'Laisha', 'Lamar', 'Lambert',\r\n    'Lamont', 'Lance', 'Landen', 'Lane', 'Laney', 'Larissa', 'Laron', 'Larry',\r\n    'Larue', 'Laura', 'Laurel', 'Lauren', 'Laurence', 'Lauretta', 'Lauriane',\r\n    'Laurianne', 'Laurie', 'Laurine', 'Laury', 'Lauryn', 'Lavada', 'Lavern',\r\n    'Laverna', 'Laverne', 'Lavina', 'Lavinia', 'Lavon', 'Lavonne', 'Lawrence',\r\n    'Lawson', 'Layla', 'Layne', 'Lazaro', 'Lea', 'Leann', 'Leanna', 'Leanne',\r\n    'Leatha', 'Leda', 'Lee', 'Leif', 'Leila', 'Leilani', 'Lela', 'Lelah',\r\n    'Leland', 'Lelia', 'Lempi', 'Lemuel', 'Lenna', 'Lennie', 'Lenny', 'Lenora',\r\n    'Lenore', 'Leo', 'Leola', 'Leon', 'Leonard', 'Leonardo', 'Leone', 'Leonel',\r\n    'Leonie', 'Leonor', 'Leonora', 'Leopold', 'Leopoldo', 'Leora', 'Lera',\r\n    'Lesley', 'Leslie', 'Lesly', 'Lessie', 'Lester', 'Leta', 'Letha', 'Letitia',\r\n    'Levi', 'Lew', 'Lewis', 'Lexi', 'Lexie', 'Lexus', 'Lia', 'Liam', 'Liana',\r\n    'Libbie', 'Libby', 'Lila', 'Lilian', 'Liliana', 'Liliane', 'Lilla',\r\n    'Lillian', 'Lilliana', 'Lillie', 'Lilly', 'Lily', 'Lilyan', 'Lina',\r\n    'Lincoln', 'Linda', 'Lindsay', 'Lindsey', 'Linnea', 'Linnie', 'Linwood',\r\n    'Lionel', 'Lisa', 'Lisandro', 'Lisette', 'Litzy', 'Liza', 'Lizeth',\r\n    'Lizzie', 'Llewellyn', 'Lloyd', 'Logan', 'Lois', 'Lola', 'Lolita', 'Loma',\r\n    'Lon', 'London', 'Lonie', 'Lonnie', 'Lonny', 'Lonzo', 'Lora', 'Loraine',\r\n    'Loren', 'Lorena', 'Lorenz', 'Lorenza', 'Lorenzo', 'Lori', 'Lorine',\r\n    'Lorna', 'Lottie', 'Lou', 'Louie', 'Louisa', 'Lourdes', 'Louvenia',\r\n    'Lowell', 'Loy', 'Loyal', 'Loyce', 'Lucas', 'Luciano', 'Lucie', 'Lucienne',\r\n    'Lucile', 'Lucinda', 'Lucio', 'Lucious', 'Lucius', 'Lucy', 'Ludie',\r\n    'Ludwig', 'Lue', 'Luella', 'Luigi', 'Luis', 'Luisa', 'Lukas', 'Lula',\r\n    'Lulu', 'Luna', 'Lupe', 'Lura', 'Lurline', 'Luther', 'Luz', 'Lyda', 'Lydia',\r\n    'Lyla', 'Lynn', 'Lyric', 'Lysanne', 'Mabel', 'Mabelle', 'Mable', 'Mac',\r\n    'Macey', 'Maci', 'Macie', 'Mack', 'Mackenzie', 'Macy', 'Madaline',\r\n    'Madalyn', 'Maddison', 'Madeline', 'Madelyn', 'Madelynn', 'Madge', 'Madie',\r\n    'Madilyn', 'Madisen', 'Madison', 'Madisyn', 'Madonna', 'Madyson', 'Mae',\r\n    'Maegan', 'Maeve', 'Mafalda', 'Magali', 'Magdalen', 'Magdalena', 'Maggie',\r\n    'Magnolia', 'Magnus', 'Maia', 'Maida', 'Maiya', 'Major', 'Makayla',\r\n    'Makenna', 'Makenzie', 'Malachi', 'Malcolm', 'Malika', 'Malinda', 'Mallie',\r\n    'Mallory', 'Malvina', 'Mandy', 'Manley', 'Manuel', 'Manuela', 'Mara',\r\n    'Marc', 'Marcel', 'Marcelina', 'Marcelino', 'Marcella', 'Marcelle',\r\n    'Marcellus', 'Marcelo', 'Marcia', 'Marco', 'Marcos', 'Marcus', 'Margaret',\r\n    'Margarete', 'Margarett', 'Margaretta', 'Margarette', 'Margarita', 'Marge',\r\n    'Margie', 'Margot', 'Margret', 'Marguerite', 'Maria', 'Mariah', 'Mariam',\r\n    'Marian', 'Mariana', 'Mariane', 'Marianna', 'Marianne', 'Mariano',\r\n    'Maribel', 'Marie', 'Mariela', 'Marielle', 'Marietta', 'Marilie', 'Marilou',\r\n    'Marilyne', 'Marina', 'Mario', 'Marion', 'Marisa', 'Marisol', 'Maritza',\r\n    'Marjolaine', 'Marjorie', 'Marjory', 'Mark', 'Markus', 'Marlee', 'Marlen',\r\n    'Marlene', 'Marley', 'Marlin', 'Marlon', 'Marques', 'Marquis', 'Marquise',\r\n    'Marshall', 'Marta', 'Martin', 'Martina', 'Martine', 'Marty', 'Marvin',\r\n    'Mary', 'Maryam', 'Maryjane', 'Maryse', 'Mason', 'Mateo', 'Mathew',\r\n    'Mathias', 'Mathilde', 'Matilda', 'Matilde', 'Matt', 'Matteo', 'Mattie',\r\n    'Maud', 'Maude', 'Maudie', 'Maureen', 'Maurice', 'Mauricio', 'Maurine',\r\n    'Maverick', 'Mavis', 'Max', 'Maxie', 'Maxime', 'Maximilian', 'Maximillia',\r\n    'Maximillian', 'Maximo', 'Maximus', 'Maxine', 'Maxwell', 'May', 'Maya',\r\n    'Maybell', 'Maybelle', 'Maye', 'Maymie', 'Maynard', 'Mayra', 'Mazie',\r\n    'Mckayla', 'Mckenna', 'Mckenzie', 'Meagan', 'Meaghan', 'Meda', 'Megane',\r\n    'Meggie', 'Meghan', 'Mekhi', 'Melany', 'Melba', 'Melisa', 'Melissa',\r\n    'Mellie', 'Melody', 'Melvin', 'Melvina', 'Melyna', 'Melyssa', 'Mercedes',\r\n    'Meredith', 'Merl', 'Merle', 'Merlin', 'Merritt', 'Mertie', 'Mervin',\r\n    'Meta', 'Mia', 'Micaela', 'Micah', 'Michael', 'Michaela', 'Michale',\r\n    'Micheal', 'Michel', 'Michele', 'Michelle', 'Miguel', 'Mikayla', 'Mike',\r\n    'Mikel', 'Milan', 'Miles', 'Milford', 'Miller', 'Millie', 'Milo', 'Milton',\r\n    'Mina', 'Minerva', 'Minnie', 'Miracle', 'Mireille', 'Mireya', 'Misael',\r\n    'Missouri', 'Misty', 'Mitchel', 'Mitchell', 'Mittie', 'Modesta', 'Modesto',\r\n    'Mohamed', 'Mohammad', 'Mohammed', 'Moises', 'Mollie', 'Molly', 'Mona',\r\n    'Monica', 'Monique', 'Monroe', 'Monserrat', 'Monserrate', 'Montana',\r\n    'Monte', 'Monty', 'Morgan', 'Moriah', 'Morris', 'Mortimer', 'Morton',\r\n    'Mose', 'Moses', 'Moshe', 'Mossie', 'Mozell', 'Mozelle', 'Muhammad',\r\n    'Muriel', 'Murl', 'Murphy', 'Murray', 'Mustafa', 'Mya', 'Myah', 'Mylene',\r\n    'Myles', 'Myra', 'Myriam', 'Myrl', 'Myrna', 'Myron', 'Myrtice', 'Myrtie',\r\n    'Myrtis', 'Myrtle', 'Nadia', 'Nakia', 'Name', 'Nannie', 'Naomi', 'Naomie',\r\n    'Napoleon', 'Narciso', 'Nash', 'Nasir', 'Nat', 'Natalia', 'Natalie',\r\n    'Natasha', 'Nathan', 'Nathanael', 'Nathanial', 'Nathaniel', 'Nathen',\r\n    'Nayeli', 'Neal', 'Ned', 'Nedra', 'Neha', 'Neil', 'Nelda', 'Nella', 'Nelle',\r\n    'Nellie', 'Nels', 'Nelson', 'Neoma', 'Nestor', 'Nettie', 'Neva', 'Newell',\r\n    'Newton', 'Nia', 'Nicholas', 'Nicholaus', 'Nichole', 'Nick', 'Nicklaus',\r\n    'Nickolas', 'Nico', 'Nicola', 'Nicolas', 'Nicole', 'Nicolette', 'Nigel',\r\n    'Nikita', 'Nikki', 'Nikko', 'Niko', 'Nikolas', 'Nils', 'Nina', 'Noah',\r\n    'Noble', 'Noe', 'Noel', 'Noelia', 'Noemi', 'Noemie', 'Noemy', 'Nola',\r\n    'Nolan', 'Nona', 'Nora', 'Norbert', 'Norberto', 'Norene', 'Norma', 'Norris',\r\n    'Norval', 'Norwood', 'Nova', 'Novella', 'Nya', 'Nyah', 'Nyasia', 'Obie',\r\n    'Oceane', 'Ocie', 'Octavia', 'Oda', 'Odell', 'Odessa', 'Odie', 'Ofelia',\r\n    'Okey', 'Ola', 'Olaf', 'Ole', 'Olen', 'Oleta', 'Olga', 'Olin', 'Oliver',\r\n    'Ollie', 'Oma', 'Omari', 'Omer', 'Ona', 'Onie', 'Opal', 'Ophelia', 'Ora',\r\n    'Oral', 'Oran', 'Oren', 'Orie', 'Orin', 'Orion', 'Orland', 'Orlando',\r\n    'Orlo', 'Orpha', 'Orrin', 'Orval', 'Orville', 'Osbaldo', 'Osborne', 'Oscar',\r\n    'Osvaldo', 'Oswald', 'Oswaldo', 'Otha', 'Otho', 'Otilia', 'Otis', 'Ottilie',\r\n    'Ottis', 'Otto', 'Ova', 'Owen', 'Ozella', 'Pablo', 'Paige', 'Palma',\r\n    'Pamela', 'Pansy', 'Paolo', 'Paris', 'Parker', 'Pascale', 'Pasquale', 'Pat',\r\n    'Patience', 'Patricia', 'Patrick', 'Patsy', 'Pattie', 'Paul', 'Paula',\r\n    'Pauline', 'Paxton', 'Payton', 'Pearl', 'Pearlie', 'Pearline', 'Pedro',\r\n    'Peggie', 'Penelope', 'Percival', 'Percy', 'Perry', 'Pete', 'Peter',\r\n    'Petra', 'Peyton', 'Philip', 'Phoebe', 'Phyllis', 'Pierce', 'Pierre',\r\n    'Pietro', 'Pink', 'Pinkie', 'Piper', 'Polly', 'Porter', 'Precious',\r\n    'Presley', 'Preston', 'Price', 'Prince', 'Princess', 'Priscilla',\r\n    'Providenci', 'Prudence', 'Queen', 'Queenie', 'Quentin', 'Quincy', 'Quinn',\r\n    'Quinten', 'Quinton', 'Rachael', 'Rachel', 'Rachelle', 'Rae', 'Raegan',\r\n    'Rafael', 'Rafaela', 'Raheem', 'Rahsaan', 'Rahul', 'Raina', 'Raleigh',\r\n    'Ralph', 'Ramiro', 'Ramon', 'Ramona', 'Randal', 'Randall', 'Randi', 'Randy',\r\n    'Ransom', 'Raoul', 'Raphael', 'Raphaelle', 'Raquel', 'Rashad', 'Rashawn',\r\n    'Rasheed', 'Raul', 'Raven', 'Ray', 'Raymond', 'Raymundo', 'Reagan',\r\n    'Reanna', 'Reba', 'Rebeca', 'Rebecca', 'Rebeka', 'Rebekah', 'Reece', 'Reed',\r\n    'Reese', 'Regan', 'Reggie', 'Reginald', 'Reid', 'Reilly', 'Reina',\r\n    'Reinhold', 'Remington', 'Rene', 'Renee', 'Ressie', 'Reta', 'Retha',\r\n    'Retta', 'Reuben', 'Reva', 'Rex', 'Rey', 'Reyes', 'Reymundo', 'Reyna',\r\n    'Reynold', 'Rhea', 'Rhett', 'Rhianna', 'Rhiannon', 'Rhoda', 'Ricardo',\r\n    'Richard', 'Richie', 'Richmond', 'Rick', 'Rickey', 'Rickie', 'Ricky',\r\n    'Rico', 'Rigoberto', 'Riley', 'Rita', 'River', 'Robb', 'Robbie', 'Robert',\r\n    'Roberta', 'Roberto', 'Robin', 'Robyn', 'Rocio', 'Rocky', 'Rod', 'Roderick',\r\n    'Rodger', 'Rodolfo', 'Rodrick', 'Rodrigo', 'Roel', 'Rogelio', 'Roger',\r\n    'Rogers', 'Rolando', 'Rollin', 'Roma', 'Romaine', 'Roman', 'Ron', 'Ronaldo',\r\n    'Ronny', 'Roosevelt', 'Rory', 'Rosa', 'Rosalee', 'Rosalia', 'Rosalind',\r\n    'Rosalinda', 'Rosalyn', 'Rosamond', 'Rosanna', 'Rosario', 'Roscoe', 'Rose',\r\n    'Rosella', 'Roselyn', 'Rosemarie', 'Rosemary', 'Rosendo', 'Rosetta',\r\n    'Rosie', 'Rosina', 'Roslyn', 'Ross', 'Rossie', 'Rowan', 'Rowena', 'Rowland',\r\n    'Roxane', 'Roxanne', 'Roy', 'Royal', 'Royce', 'Rozella', 'Ruben', 'Rubie',\r\n    'Ruby', 'Rubye', 'Rudolph', 'Rudy', 'Rupert', 'Russ', 'Russel', 'Russell',\r\n    'Rusty', 'Ruth', 'Ruthe', 'Ruthie', 'Ryan', 'Ryann', 'Ryder', 'Rylan',\r\n    'Rylee', 'Ryleigh', 'Ryley', 'Sabina', 'Sabrina', 'Sabryna', 'Sadie',\r\n    'Sadye', 'Sage', 'Saige', 'Sallie', 'Sally', 'Salma', 'Salvador',\r\n    'Salvatore', 'Sam', 'Samanta', 'Samantha', 'Samara', 'Samir', 'Sammie',\r\n    'Sammy', 'Samson', 'Sandra', 'Sandrine', 'Sandy', 'Sanford', 'Santa',\r\n    'Santiago', 'Santina', 'Santino', 'Santos', 'Sarah', 'Sarai', 'Sarina',\r\n    'Sasha', 'Saul', 'Savanah', 'Savanna', 'Savannah', 'Savion', 'Scarlett',\r\n    'Schuyler', 'Scot', 'Scottie', 'Scotty', 'Seamus', 'Sean', 'Sebastian',\r\n    'Sedrick', 'Selena', 'Selina', 'Selmer', 'Serena', 'Serenity', 'Seth',\r\n    'Shad', 'Shaina', 'Shakira', 'Shana', 'Shane', 'Shanel', 'Shanelle',\r\n    'Shania', 'Shanie', 'Shaniya', 'Shanna', 'Shannon', 'Shanny', 'Shanon',\r\n    'Shany', 'Sharon', 'Shaun', 'Shawn', 'Shawna', 'Shaylee', 'Shayna',\r\n    'Shayne', 'Shea', 'Sheila', 'Sheldon', 'Shemar', 'Sheridan', 'Sherman',\r\n    'Sherwood', 'Shirley', 'Shyann', 'Shyanne', 'Sibyl', 'Sid', 'Sidney',\r\n    'Sienna', 'Sierra', 'Sigmund', 'Sigrid', 'Sigurd', 'Silas', 'Sim', 'Simeon',\r\n    'Simone', 'Sincere', 'Sister', 'Skye', 'Skyla', 'Skylar', 'Sofia',\r\n    'Soledad', 'Solon', 'Sonia', 'Sonny', 'Sonya', 'Sophia', 'Sophie',\r\n    'Spencer', 'Stacey', 'Stacy', 'Stan', 'Stanford', 'Stanley', 'Stanton',\r\n    'Stefan', 'Stefanie', 'Stella', 'Stephan', 'Stephania', 'Stephanie',\r\n    'Stephany', 'Stephen', 'Stephon', 'Sterling', 'Steve', 'Stevie', 'Stewart',\r\n    'Stone', 'Stuart', 'Summer', 'Sunny', 'Susan', 'Susana', 'Susanna', 'Susie',\r\n    'Suzanne', 'Sven', 'Syble', 'Sydnee', 'Sydney', 'Sydni', 'Sydnie', 'Sylvan',\r\n    'Sylvester', 'Sylvia', 'Tabitha', 'Tad', 'Talia', 'Talon', 'Tamara',\r\n    'Tamia', 'Tania', 'Tanner', 'Tanya', 'Tara', 'Taryn', 'Tate', 'Tatum',\r\n    'Tatyana', 'Taurean', 'Tavares', 'Taya', 'Taylor', 'Teagan', 'Ted', 'Telly',\r\n    'Terence', 'Teresa', 'Terrance', 'Terrell', 'Terrence', 'Terrill', 'Terry',\r\n    'Tess', 'Tessie', 'Tevin', 'Thad', 'Thaddeus', 'Thalia', 'Thea', 'Thelma',\r\n    'Theo', 'Theodora', 'Theodore', 'Theresa', 'Therese', 'Theresia', 'Theron',\r\n    'Thomas', 'Thora', 'Thurman', 'Tia', 'Tiana', 'Tianna', 'Tiara', 'Tierra',\r\n    'Tiffany', 'Tillman', 'Timmothy', 'Timmy', 'Timothy', 'Tina', 'Tito',\r\n    'Titus', 'Tobin', 'Toby', 'Tod', 'Tom', 'Tomas', 'Tomasa', 'Tommie',\r\n    'Toney', 'Toni', 'Tony', 'Torey', 'Torrance', 'Torrey', 'Toy', 'Trace',\r\n    'Tracey', 'Tracy', 'Travis', 'Travon', 'Tre', 'Tremaine', 'Tremayne',\r\n    'Trent', 'Trenton', 'Tressa', 'Tressie', 'Treva', 'Trever', 'Trevion',\r\n    'Trevor', 'Trey', 'Trinity', 'Trisha', 'Tristian', 'Tristin', 'Triston',\r\n    'Troy', 'Trudie', 'Trycia', 'Trystan', 'Turner', 'Twila', 'Tyler', 'Tyra',\r\n    'Tyree', 'Tyreek', 'Tyrel', 'Tyrell', 'Tyrese', 'Tyrique', 'Tyshawn',\r\n    'Tyson', 'Ubaldo', 'Ulices', 'Ulises', 'Una', 'Unique', 'Urban', 'Uriah',\r\n    'Uriel', 'Ursula', 'Vada', 'Valentin', 'Valentina', 'Valentine', 'Valerie',\r\n    'Vallie', 'Van', 'Vance', 'Vanessa', 'Vaughn', 'Veda', 'Velda', 'Vella',\r\n    'Velma', 'Velva', 'Vena', 'Verda', 'Verdie', 'Vergie', 'Verla', 'Verlie',\r\n    'Vern', 'Verna', 'Verner', 'Vernice', 'Vernie', 'Vernon', 'Verona',\r\n    'Veronica', 'Vesta', 'Vicenta', 'Vicente', 'Vickie', 'Vicky', 'Victor',\r\n    'Victoria', 'Vida', 'Vidal', 'Vilma', 'Vince', 'Vincent', 'Vincenza',\r\n    'Vincenzo', 'Vinnie', 'Viola', 'Violet', 'Violette', 'Virgie', 'Virgil',\r\n    'Virginia', 'Virginie', 'Vita', 'Vito', 'Viva', 'Vivian', 'Viviane',\r\n    'Vivianne', 'Vivien', 'Vivienne', 'Vladimir', 'Wade', 'Waino', 'Waldo',\r\n    'Walker', 'Wallace', 'Walter', 'Walton', 'Wanda', 'Ward', 'Warren',\r\n    'Watson', 'Wava', 'Waylon', 'Wayne', 'Webster', 'Weldon', 'Wellington',\r\n    'Wendell', 'Wendy', 'Werner', 'Westley', 'Weston', 'Whitney', 'Wilber',\r\n    'Wilbert', 'Wilburn', 'Wiley', 'Wilford', 'Wilfred', 'Wilfredo', 'Wilfrid',\r\n    'Wilhelm', 'Wilhelmine', 'Will', 'Willa', 'Willard', 'William', 'Willie',\r\n    'Willis', 'Willow', 'Willy', 'Wilma', 'Wilmer', 'Wilson', 'Wilton',\r\n    'Winfield', 'Winifred', 'Winnifred', 'Winona', 'Winston', 'Woodrow',\r\n    'Wyatt', 'Wyman', 'Xander', 'Xavier', 'Xzavier', 'Yadira', 'Yasmeen',\r\n    'Yasmin', 'Yasmine', 'Yazmin', 'Yesenia', 'Yessenia', 'Yolanda', 'Yoshiko',\r\n    'Yvette', 'Yvonne', 'Zachariah', 'Zachary', 'Zachery', 'Zack', 'Zackary',\r\n    'Zackery', 'Zakary', 'Zander', 'Zane', 'Zaria', 'Zechariah', 'Zelda',\r\n    'Zella', 'Zelma', 'Zena', 'Zetta', 'Zion', 'Zita', 'Zoe', 'Zoey', 'Zoie',\r\n    'Zoila', 'Zola', 'Zora', 'Zula'\r\n];\r\n\r\n/**\r\n * Generate random username.\r\n * @returns {string} random username\r\n */\r\nfunction generateUsername() {\r\n    const name = RandomUtil.randomElement(names);\r\n    const suffix = RandomUtil.randomAlphanumStr(3);\r\n\r\n    return `${name}-${suffix}`;\r\n}\r\n\r\nmodule.exports = {\r\n    generateUsername\r\n};\r\n","import browser from '../browser';\r\nimport { browsers } from 'js-utils';\r\n\r\nimport * as StatisticsEvents from '../../service/statistics/Events';\r\nimport * as MediaType from '../../service/RTC/MediaType';\r\n\r\nconst GlobalOnErrorHandler = require('../util/GlobalOnErrorHandler');\r\nconst logger = require('qhsense-meet-logger').getLogger(__filename);\r\n\r\n/**\r\n * The lib-qhsense-meet browser-agnostic names of the browser-specific keys\r\n * reported by RTCPeerConnection#getStats mapped by browser.\r\n */\r\nconst KEYS_BY_BROWSER_TYPE = {};\r\n\r\nKEYS_BY_BROWSER_TYPE[browsers.FIREFOX] = {\r\n    'ssrc': 'ssrc',\r\n    'packetsReceived': 'packetsReceived',\r\n    'packetsLost': 'packetsLost',\r\n    'packetsSent': 'packetsSent',\r\n    'bytesReceived': 'bytesReceived',\r\n    'bytesSent': 'bytesSent',\r\n    'framerateMean': 'framerateMean',\r\n    'ip': 'ipAddress',\r\n    'port': 'portNumber',\r\n    'protocol': 'transport'\r\n};\r\nKEYS_BY_BROWSER_TYPE[browsers.CHROME] = {\r\n    'receiveBandwidth': 'googAvailableReceiveBandwidth',\r\n    'sendBandwidth': 'googAvailableSendBandwidth',\r\n    'remoteAddress': 'googRemoteAddress',\r\n    'transportType': 'googTransportType',\r\n    'localAddress': 'googLocalAddress',\r\n    'activeConnection': 'googActiveConnection',\r\n    'ssrc': 'ssrc',\r\n    'packetsReceived': 'packetsReceived',\r\n    'packetsSent': 'packetsSent',\r\n    'packetsLost': 'packetsLost',\r\n    'bytesReceived': 'bytesReceived',\r\n    'bytesSent': 'bytesSent',\r\n    'googFrameHeightReceived': 'googFrameHeightReceived',\r\n    'googFrameWidthReceived': 'googFrameWidthReceived',\r\n    'googFrameHeightSent': 'googFrameHeightSent',\r\n    'googFrameWidthSent': 'googFrameWidthSent',\r\n    'googFrameRateReceived': 'googFrameRateReceived',\r\n    'googFrameRateSent': 'googFrameRateSent',\r\n    'audioInputLevel': 'audioInputLevel',\r\n    'audioOutputLevel': 'audioOutputLevel',\r\n    'currentRoundTripTime': 'googRtt',\r\n    'remoteCandidateType': 'googRemoteCandidateType',\r\n    'localCandidateType': 'googLocalCandidateType',\r\n    'ip': 'ip',\r\n    'port': 'port',\r\n    'protocol': 'protocol'\r\n};\r\nKEYS_BY_BROWSER_TYPE[browsers.EDGE] = {\r\n    'sendBandwidth': 'googAvailableSendBandwidth',\r\n    'remoteAddress': 'remoteAddress',\r\n    'transportType': 'protocol',\r\n    'localAddress': 'localAddress',\r\n    'activeConnection': 'activeConnection',\r\n    'ssrc': 'ssrc',\r\n    'packetsReceived': 'packetsReceived',\r\n    'packetsSent': 'packetsSent',\r\n    'packetsLost': 'packetsLost',\r\n    'bytesReceived': 'bytesReceived',\r\n    'bytesSent': 'bytesSent',\r\n    'googFrameHeightReceived': 'frameHeight',\r\n    'googFrameWidthReceived': 'frameWidth',\r\n    'googFrameHeightSent': 'frameHeight',\r\n    'googFrameWidthSent': 'frameWidth',\r\n    'googFrameRateReceived': 'framesPerSecond',\r\n    'googFrameRateSent': 'framesPerSecond',\r\n    'audioInputLevel': 'audioLevel',\r\n    'audioOutputLevel': 'audioLevel',\r\n    'currentRoundTripTime': 'roundTripTime'\r\n};\r\nKEYS_BY_BROWSER_TYPE[browsers.OPERA]\r\n    = KEYS_BY_BROWSER_TYPE[browsers.CHROME];\r\nKEYS_BY_BROWSER_TYPE[browsers.NWJS]\r\n    = KEYS_BY_BROWSER_TYPE[browsers.CHROME];\r\nKEYS_BY_BROWSER_TYPE[browsers.ELECTRON]\r\n    = KEYS_BY_BROWSER_TYPE[browsers.CHROME];\r\nKEYS_BY_BROWSER_TYPE[browsers.SAFARI]\r\n    = KEYS_BY_BROWSER_TYPE[browsers.CHROME];\r\nKEYS_BY_BROWSER_TYPE[browsers.REACT_NATIVE]\r\n    = KEYS_BY_BROWSER_TYPE[browsers.CHROME];\r\n\r\n/**\r\n * Calculates packet lost percent using the number of lost packets and the\r\n * number of all packet.\r\n * @param lostPackets the number of lost packets\r\n * @param totalPackets the number of all packets.\r\n * @returns {number} packet loss percent\r\n */\r\nfunction calculatePacketLoss(lostPackets, totalPackets) {\r\n    if (!totalPackets || totalPackets <= 0\r\n            || !lostPackets || lostPackets <= 0) {\r\n        return 0;\r\n    }\r\n\r\n    return Math.round((lostPackets / totalPackets) * 100);\r\n}\r\n\r\n/**\r\n * Holds \"statistics\" for a single SSRC.\r\n * @constructor\r\n */\r\nfunction SsrcStats() {\r\n    this.loss = {};\r\n    this.bitrate = {\r\n        download: 0,\r\n        upload: 0\r\n    };\r\n    this.resolution = {};\r\n    this.framerate = 0;\r\n}\r\n\r\n/**\r\n * Sets the \"loss\" object.\r\n * @param loss the value to set.\r\n */\r\nSsrcStats.prototype.setLoss = function(loss) {\r\n    this.loss = loss || {};\r\n};\r\n\r\n/**\r\n * Sets resolution that belong to the ssrc represented by this instance.\r\n * @param resolution new resolution value to be set.\r\n */\r\nSsrcStats.prototype.setResolution = function(resolution) {\r\n    this.resolution = resolution || {};\r\n};\r\n\r\n/**\r\n * Adds the \"download\" and \"upload\" fields from the \"bitrate\" parameter to\r\n * the respective fields of the \"bitrate\" field of this object.\r\n * @param bitrate an object holding the values to add.\r\n */\r\nSsrcStats.prototype.addBitrate = function(bitrate) {\r\n    this.bitrate.download += bitrate.download;\r\n    this.bitrate.upload += bitrate.upload;\r\n};\r\n\r\n/**\r\n * Resets the bit rate for given <tt>ssrc</tt> that belong to the peer\r\n * represented by this instance.\r\n */\r\nSsrcStats.prototype.resetBitrate = function() {\r\n    this.bitrate.download = 0;\r\n    this.bitrate.upload = 0;\r\n};\r\n\r\n/**\r\n * Sets the \"framerate\".\r\n * @param framerate the value to set.\r\n */\r\nSsrcStats.prototype.setFramerate = function(framerate) {\r\n    this.framerate = framerate || 0;\r\n};\r\n\r\n/**\r\n *\r\n */\r\nfunction ConferenceStats() {\r\n\r\n    /**\r\n     * The bandwidth\r\n     * @type {{}}\r\n     */\r\n    this.bandwidth = {};\r\n\r\n    /**\r\n     * The bit rate\r\n     * @type {{}}\r\n     */\r\n    this.bitrate = {};\r\n\r\n    /**\r\n     * The packet loss rate\r\n     * @type {{}}\r\n     */\r\n    this.packetLoss = null;\r\n\r\n    /**\r\n     * Array with the transport information.\r\n     * @type {Array}\r\n     */\r\n    this.transport = [];\r\n}\r\n\r\n/* eslint-disable max-params */\r\n\r\n/**\r\n * <tt>StatsCollector</tt> registers for stats updates of given\r\n * <tt>peerconnection</tt> in given <tt>interval</tt>. On each update particular\r\n * stats are extracted and put in {@link SsrcStats} objects. Once the processing\r\n * is done <tt>audioLevelsUpdateCallback</tt> is called with <tt>this</tt>\r\n * instance as an event source.\r\n *\r\n * @param peerconnection WebRTC PeerConnection object.\r\n * @param audioLevelsInterval\r\n * @param statsInterval stats refresh interval given in ms.\r\n * @param eventEmitter\r\n * @constructor\r\n */\r\nexport default function StatsCollector(\r\n        peerconnection,\r\n        audioLevelsInterval,\r\n        statsInterval,\r\n        eventEmitter) {\r\n    // StatsCollector depends entirely on the format of the reports returned by\r\n    // RTCPeerConnection#getStats. Given that the value of\r\n    // browser#getName() is very unlikely to change at runtime, it\r\n    // makes sense to discover whether StatsCollector supports the executing\r\n    // browser as soon as possible. Otherwise, (1) getStatValue would have to\r\n    // needlessly check a \"static\" condition multiple times very very often and\r\n    // (2) the lack of support for the executing browser would be discovered and\r\n    // reported multiple times very very often too late in the execution in some\r\n    // totally unrelated callback.\r\n    /**\r\n     * The browser type supported by this StatsCollector. In other words, the\r\n     * type of the browser which initialized this StatsCollector\r\n     * instance.\r\n     * @private\r\n     */\r\n    this._browserType = browser.getName();\r\n    const keys = KEYS_BY_BROWSER_TYPE[this._browserType];\r\n\r\n    if (!keys) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw `The browser type '${this._browserType}' isn't supported!`;\r\n    }\r\n\r\n    /**\r\n     * Whether to use the Promise-based getStats API or not.\r\n     * @type {boolean}\r\n     */\r\n    this._usesPromiseGetStats\r\n        = browser.isSafariWithWebrtc() || browser.isFirefox();\r\n\r\n    /**\r\n     * The function which is to be used to retrieve the value associated in a\r\n     * report returned by RTCPeerConnection#getStats with a lib-qhsense-meet\r\n     * browser-agnostic name/key.\r\n     *\r\n     * @function\r\n     * @private\r\n     */\r\n    this._getStatValue\r\n        = this._usesPromiseGetStats\r\n            ? this._defineNewGetStatValueMethod(keys)\r\n            : this._defineGetStatValueMethod(keys);\r\n\r\n    this.peerconnection = peerconnection;\r\n    this.baselineAudioLevelsReport = null;\r\n    this.currentAudioLevelsReport = null;\r\n    this.currentStatsReport = null;\r\n    this.previousStatsReport = null;\r\n    this.audioLevelsIntervalId = null;\r\n    this.eventEmitter = eventEmitter;\r\n    this.conferenceStats = new ConferenceStats();\r\n\r\n    // Updates stats interval\r\n    this.audioLevelsIntervalMilis = audioLevelsInterval;\r\n\r\n    this.statsIntervalId = null;\r\n    this.statsIntervalMilis = statsInterval;\r\n\r\n    /**\r\n     * Maps SSRC numbers to {@link SsrcStats}.\r\n     * @type {Map<number,SsrcStats}\r\n     */\r\n    this.ssrc2stats = new Map();\r\n}\r\n\r\n/* eslint-enable max-params */\r\n\r\n/**\r\n * Stops stats updates.\r\n */\r\nStatsCollector.prototype.stop = function() {\r\n    if (this.audioLevelsIntervalId) {\r\n        clearInterval(this.audioLevelsIntervalId);\r\n        this.audioLevelsIntervalId = null;\r\n    }\r\n\r\n    if (this.statsIntervalId) {\r\n        clearInterval(this.statsIntervalId);\r\n        this.statsIntervalId = null;\r\n    }\r\n};\r\n\r\n/**\r\n * Callback passed to <tt>getStats</tt> method.\r\n * @param error an error that occurred on <tt>getStats</tt> call.\r\n */\r\nStatsCollector.prototype.errorCallback = function(error) {\r\n    GlobalOnErrorHandler.callErrorHandler(error);\r\n    logger.error('Get stats error', error);\r\n    this.stop();\r\n};\r\n\r\n/**\r\n * Starts stats updates.\r\n */\r\nStatsCollector.prototype.start = function(startAudioLevelStats) {\r\n    const self = this;\r\n\r\n    if (startAudioLevelStats) {\r\n        this.audioLevelsIntervalId = setInterval(\r\n            () => {\r\n                // Interval updates\r\n                self.peerconnection.getStats(\r\n                    report => {\r\n                        let results = null;\r\n\r\n                        if (!report || !report.result\r\n                            || typeof report.result !== 'function') {\r\n                            results = report;\r\n                        } else {\r\n                            results = report.result();\r\n                        }\r\n                        self.currentAudioLevelsReport = results;\r\n                        if (this._usesPromiseGetStats) {\r\n                            self.processNewAudioLevelReport();\r\n                        } else {\r\n                            self.processAudioLevelReport();\r\n                        }\r\n\r\n                        self.baselineAudioLevelsReport\r\n                            = self.currentAudioLevelsReport;\r\n                    },\r\n                    error => self.errorCallback(error)\r\n                );\r\n            },\r\n            self.audioLevelsIntervalMilis\r\n        );\r\n    }\r\n\r\n    if (browser.supportsRtpStatistics()) {\r\n        this.statsIntervalId = setInterval(\r\n            () => {\r\n                // Interval updates\r\n                self.peerconnection.getStats(\r\n                    report => {\r\n                        let results = null;\r\n\r\n                        if (!report || !report.result\r\n                            || typeof report.result !== 'function') {\r\n                            // firefox\r\n                            results = report;\r\n                        } else {\r\n                            // chrome\r\n                            results = report.result();\r\n                        }\r\n\r\n                        self.currentStatsReport = results;\r\n                        try {\r\n                            if (this._usesPromiseGetStats) {\r\n                                self.processNewStatsReport();\r\n                            } else {\r\n                                self.processStatsReport();\r\n                            }\r\n                        } catch (e) {\r\n                            GlobalOnErrorHandler.callErrorHandler(e);\r\n                            logger.error(`Unsupported key:${e}`, e);\r\n                        }\r\n\r\n                        self.previousStatsReport = self.currentStatsReport;\r\n                    },\r\n                    error => self.errorCallback(error)\r\n                );\r\n            },\r\n            self.statsIntervalMilis\r\n        );\r\n    }\r\n};\r\n\r\n/**\r\n * Defines a function which (1) is to be used as a StatsCollector method and (2)\r\n * gets the value from a specific report returned by RTCPeerConnection#getStats\r\n * associated with a lib-qhsense-meet browser-agnostic name.\r\n *\r\n * @param {Object.<string,string>} keys the map of Libqhsense browser-agnostic\r\n * names to RTCPeerConnection#getStats browser-specific keys\r\n */\r\nStatsCollector.prototype._defineGetStatValueMethod = function(keys) {\r\n    // Define the function which converts a lib-qhsens-meet browser-asnostic name\r\n    // to a browser-specific key of a report returned by\r\n    // RTCPeerConnection#getStats.\r\n    const keyFromName = function(name) {\r\n        const key = keys[name];\r\n\r\n        if (key) {\r\n            return key;\r\n        }\r\n\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw `The property '${name}' isn't supported!`;\r\n    };\r\n\r\n    // Define the function which retrieves the value from a specific report\r\n    // returned by RTCPeerConnection#getStats associated with a given\r\n    // browser-specific key.\r\n    let itemStatByKey;\r\n\r\n    switch (this._browserType) {\r\n    case browsers.CHROME:\r\n    case browsers.OPERA:\r\n    case browsers.NWJS:\r\n    case browsers.ELECTRON:\r\n        // TODO What about other types of browser which are based on Chrome such\r\n        // as NW.js? Every time we want to support a new type browser we have to\r\n        // go and add more conditions (here and in multiple other places).\r\n        // Cannot we do a feature detection instead of a browser type check? For\r\n        // example, if item has a stat property of type function, then it's very\r\n        // likely that whoever defined it wanted you to call it in order to\r\n        // retrieve the value associated with a specific key.\r\n        itemStatByKey = (item, key) => item.stat(key);\r\n        break;\r\n    case browsers.REACT_NATIVE:\r\n        // The implementation provided by react-native-webrtc follows the\r\n        // Objective-C WebRTC API: RTCStatsReport has a values property of type\r\n        // Array in which each element is a key-value pair.\r\n        itemStatByKey = function(item, key) {\r\n            let value;\r\n\r\n            item.values.some(pair => {\r\n                if (pair.hasOwnProperty(key)) {\r\n                    value = pair[key];\r\n\r\n                    return true;\r\n                }\r\n\r\n                return false;\r\n\r\n            });\r\n\r\n            return value;\r\n        };\r\n        break;\r\n    case browsers.EDGE:\r\n        itemStatByKey = (item, key) => item[key];\r\n        break;\r\n    default:\r\n        itemStatByKey = (item, key) => item[key];\r\n    }\r\n\r\n    // Compose the 2 functions defined above to get a function which retrieves\r\n    // the value from a specific report returned by RTCPeerConnection#getStats\r\n    // associated with a specific lib-qhsens-meet browser-agnostic name.\r\n    return (item, name) => itemStatByKey(item, keyFromName(name));\r\n};\r\n\r\n/**\r\n * Obtains a stat value from given stat and converts it to a non-negative\r\n * number. If the value is either invalid or negative then 0 will be returned.\r\n * @param report\r\n * @param {string} name\r\n * @return {number}\r\n * @private\r\n */\r\nStatsCollector.prototype.getNonNegativeStat = function(report, name) {\r\n    let value = this._getStatValue(report, name);\r\n\r\n    if (typeof value !== 'number') {\r\n        value = Number(value);\r\n    }\r\n\r\n    if (isNaN(value)) {\r\n        return 0;\r\n    }\r\n\r\n    return Math.max(0, value);\r\n};\r\n\r\n/* eslint-disable no-continue */\r\n\r\n/**\r\n * Stats processing logic.\r\n */\r\nStatsCollector.prototype.processStatsReport = function() {\r\n    if (!this.previousStatsReport) {\r\n        return;\r\n    }\r\n\r\n    const getStatValue = this._getStatValue;\r\n    const byteSentStats = {};\r\n\r\n    for (const idx in this.currentStatsReport) {\r\n        if (!this.currentStatsReport.hasOwnProperty(idx)) {\r\n            continue;\r\n        }\r\n        const now = this.currentStatsReport[idx];\r\n\r\n        // The browser API may return \"undefined\" values in the array\r\n        if (!now) {\r\n            continue;\r\n        }\r\n\r\n        try {\r\n            const receiveBandwidth = getStatValue(now, 'receiveBandwidth');\r\n            const sendBandwidth = getStatValue(now, 'sendBandwidth');\r\n\r\n            if (receiveBandwidth || sendBandwidth) {\r\n                this.conferenceStats.bandwidth = {\r\n                    'download': Math.round(receiveBandwidth / 1000),\r\n                    'upload': Math.round(sendBandwidth / 1000)\r\n                };\r\n            }\r\n        } catch (e) { /* not supported*/ }\r\n\r\n        if (now.type === 'googCandidatePair') {\r\n            let active, ip, localCandidateType, localip,\r\n                remoteCandidateType, rtt, type;\r\n\r\n            try {\r\n                active = getStatValue(now, 'activeConnection');\r\n                if (!active) {\r\n                    continue;\r\n                }\r\n\r\n                ip = getStatValue(now, 'remoteAddress');\r\n                type = getStatValue(now, 'transportType');\r\n                localip = getStatValue(now, 'localAddress');\r\n                localCandidateType = getStatValue(now, 'localCandidateType');\r\n                remoteCandidateType = getStatValue(now, 'remoteCandidateType');\r\n                rtt = this.getNonNegativeStat(now, 'currentRoundTripTime');\r\n            } catch (e) { /* not supported*/ }\r\n            if (!ip || !type || !localip || active !== 'true') {\r\n                continue;\r\n            }\r\n\r\n            // Save the address unless it has been saved already.\r\n            const conferenceStatsTransport = this.conferenceStats.transport;\r\n\r\n            if (!conferenceStatsTransport.some(\r\n                    t =>\r\n                        t.ip === ip\r\n                            && t.type === type\r\n                            && t.localip === localip)) {\r\n                conferenceStatsTransport.push({\r\n                    ip,\r\n                    type,\r\n                    localip,\r\n                    p2p: this.peerconnection.isP2P,\r\n                    localCandidateType,\r\n                    remoteCandidateType,\r\n                    rtt\r\n                });\r\n            }\r\n            continue;\r\n        }\r\n\r\n        if (now.type === 'candidatepair') {\r\n            // we need succeeded and selected pairs only\r\n            if (now.state !== 'succeeded' || !now.selected) {\r\n                continue;\r\n            }\r\n\r\n            const local = this.currentStatsReport[now.localCandidateId];\r\n            const remote = this.currentStatsReport[now.remoteCandidateId];\r\n\r\n            this.conferenceStats.transport.push({\r\n                ip: `${remote.ipAddress}:${remote.portNumber}`,\r\n                type: local.transport,\r\n                localip: `${local.ipAddress}:${local.portNumber}`,\r\n                p2p: this.peerconnection.isP2P,\r\n                localCandidateType: local.candidateType,\r\n                remoteCandidateType: remote.candidateType\r\n            });\r\n        }\r\n\r\n        // NOTE: Edge's proprietary stats via RTCIceTransport.msGetStats().\r\n        if (now.msType === 'transportdiagnostics') {\r\n            this.conferenceStats.transport.push({\r\n                ip: now.remoteAddress,\r\n                type: now.protocol,\r\n                localip: now.localAddress,\r\n                p2p: this.peerconnection.isP2P\r\n            });\r\n        }\r\n\r\n        if (now.type !== 'ssrc' && now.type !== 'outboundrtp'\r\n            && now.type !== 'inboundrtp' && now.type !== 'track') {\r\n            continue;\r\n        }\r\n\r\n        // NOTE: In Edge, stats with type \"inboundrtp\" and \"outboundrtp\" are\r\n        // completely useless, so ignore them.\r\n        if (browser.isEdge()\r\n            && (now.type === 'inboundrtp' || now.type === 'outboundrtp')) {\r\n            continue;\r\n        }\r\n\r\n        const before = this.previousStatsReport[idx];\r\n        let ssrc = this.getNonNegativeStat(now, 'ssrc');\r\n\r\n        // If type=\"track\", take the first SSRC from ssrcIds.\r\n        if (now.type === 'track' && Array.isArray(now.ssrcIds)) {\r\n            ssrc = Number(now.ssrcIds[0]);\r\n        }\r\n\r\n        if (!before || !ssrc) {\r\n            continue;\r\n        }\r\n\r\n        // isRemote is available only in FF and is ignored in case of chrome\r\n        // according to the spec\r\n        // https://www.w3.org/TR/webrtc-stats/#dom-rtcrtpstreamstats-isremote\r\n        // when isRemote is true indicates that the measurements were done at\r\n        // the remote endpoint and reported in an RTCP RR/XR.\r\n        // Fixes a problem where we are calculating local stats wrong adding\r\n        // the sent bytes to the local download bitrate.\r\n        // In new W3 stats spec, type=\"track\" has a remoteSource boolean\r\n        // property.\r\n        // Edge uses the new format, so skip this check.\r\n        if (!browser.isEdge()\r\n                && (now.isRemote === true || now.remoteSource === true)) {\r\n            continue;\r\n        }\r\n\r\n        let ssrcStats = this.ssrc2stats.get(ssrc);\r\n\r\n        if (!ssrcStats) {\r\n            ssrcStats = new SsrcStats();\r\n            this.ssrc2stats.set(ssrc, ssrcStats);\r\n        }\r\n\r\n        let isDownloadStream = true;\r\n        let key = 'packetsReceived';\r\n        let packetsNow = getStatValue(now, key);\r\n\r\n        if (typeof packetsNow === 'undefined'\r\n            || packetsNow === null || packetsNow === '') {\r\n            isDownloadStream = false;\r\n            key = 'packetsSent';\r\n            packetsNow = getStatValue(now, key);\r\n            if (typeof packetsNow === 'undefined' || packetsNow === null) {\r\n                logger.warn('No packetsReceived nor packetsSent stat found');\r\n            }\r\n        }\r\n        if (!packetsNow || packetsNow < 0) {\r\n            packetsNow = 0;\r\n        }\r\n\r\n        const packetsBefore = this.getNonNegativeStat(before, key);\r\n        const packetsDiff = Math.max(0, packetsNow - packetsBefore);\r\n\r\n        const packetsLostNow\r\n            = this.getNonNegativeStat(now, 'packetsLost');\r\n        const packetsLostBefore\r\n            = this.getNonNegativeStat(before, 'packetsLost');\r\n        const packetsLostDiff = Math.max(0, packetsLostNow - packetsLostBefore);\r\n\r\n        ssrcStats.setLoss({\r\n            packetsTotal: packetsDiff + packetsLostDiff,\r\n            packetsLost: packetsLostDiff,\r\n            isDownloadStream\r\n        });\r\n\r\n        const bytesReceivedNow\r\n            = this.getNonNegativeStat(now, 'bytesReceived');\r\n        const bytesReceivedBefore\r\n            = this.getNonNegativeStat(before, 'bytesReceived');\r\n        const bytesReceived\r\n            = Math.max(0, bytesReceivedNow - bytesReceivedBefore);\r\n\r\n        let bytesSent = 0;\r\n\r\n        // TODO: clean this mess up!\r\n        let nowBytesTransmitted = getStatValue(now, 'bytesSent');\r\n\r\n        if (typeof nowBytesTransmitted === 'number'\r\n            || typeof nowBytesTransmitted === 'string') {\r\n            nowBytesTransmitted = Number(nowBytesTransmitted);\r\n            if (!isNaN(nowBytesTransmitted)) {\r\n                byteSentStats[ssrc] = nowBytesTransmitted;\r\n                if (nowBytesTransmitted > 0) {\r\n                    bytesSent = nowBytesTransmitted\r\n                        - getStatValue(before, 'bytesSent');\r\n                }\r\n            }\r\n        }\r\n        bytesSent = Math.max(0, bytesSent);\r\n\r\n        const timeMs = now.timestamp - before.timestamp;\r\n        let bitrateReceivedKbps = 0, bitrateSentKbps = 0;\r\n\r\n        if (timeMs > 0) {\r\n            // TODO is there any reason to round here?\r\n            bitrateReceivedKbps = Math.round((bytesReceived * 8) / timeMs);\r\n            bitrateSentKbps = Math.round((bytesSent * 8) / timeMs);\r\n        }\r\n\r\n        ssrcStats.addBitrate({\r\n            'download': bitrateReceivedKbps,\r\n            'upload': bitrateSentKbps\r\n        });\r\n\r\n        const resolution = {\r\n            height: null,\r\n            width: null\r\n        };\r\n\r\n        try {\r\n            let height, width;\r\n\r\n            if ((height = getStatValue(now, 'googFrameHeightReceived'))\r\n                && (width = getStatValue(now, 'googFrameWidthReceived'))) {\r\n                resolution.height = height;\r\n                resolution.width = width;\r\n            } else if ((height = getStatValue(now, 'googFrameHeightSent'))\r\n                && (width = getStatValue(now, 'googFrameWidthSent'))) {\r\n                resolution.height = height;\r\n                resolution.width = width;\r\n            }\r\n        } catch (e) { /* not supported*/ }\r\n\r\n        // Tries to get frame rate\r\n        let frameRate;\r\n\r\n        try {\r\n            frameRate = getStatValue(now, 'googFrameRateReceived')\r\n                || getStatValue(now, 'googFrameRateSent') || 0;\r\n        } catch (e) {\r\n            // if it fails with previous properties(chrome),\r\n            // let's try with another one (FF)\r\n            try {\r\n                frameRate = this.getNonNegativeStat(now, 'framerateMean');\r\n            } catch (err) { /* not supported*/ }\r\n        }\r\n        ssrcStats.setFramerate(Math.round(frameRate || 0));\r\n\r\n        if (resolution.height && resolution.width) {\r\n            ssrcStats.setResolution(resolution);\r\n        } else {\r\n            ssrcStats.setResolution(null);\r\n        }\r\n    }\r\n\r\n    this.eventEmitter.emit(\r\n        StatisticsEvents.BYTE_SENT_STATS, this.peerconnection, byteSentStats);\r\n\r\n    this._processAndEmitReport();\r\n};\r\n\r\n/**\r\n *\r\n */\r\nStatsCollector.prototype._processAndEmitReport = function() {\r\n    // process stats\r\n    const totalPackets = {\r\n        download: 0,\r\n        upload: 0\r\n    };\r\n    const lostPackets = {\r\n        download: 0,\r\n        upload: 0\r\n    };\r\n    let bitrateDownload = 0;\r\n    let bitrateUpload = 0;\r\n    const resolutions = {};\r\n    const framerates = {};\r\n    let audioBitrateDownload = 0;\r\n    let audioBitrateUpload = 0;\r\n    let videoBitrateDownload = 0;\r\n    let videoBitrateUpload = 0;\r\n\r\n    for (const [ ssrc, ssrcStats ] of this.ssrc2stats) {\r\n        // process packet loss stats\r\n        const loss = ssrcStats.loss;\r\n        const type = loss.isDownloadStream ? 'download' : 'upload';\r\n\r\n        totalPackets[type] += loss.packetsTotal;\r\n        lostPackets[type] += loss.packetsLost;\r\n\r\n        // process bitrate stats\r\n        bitrateDownload += ssrcStats.bitrate.download;\r\n        bitrateUpload += ssrcStats.bitrate.upload;\r\n\r\n        // collect resolutions and framerates\r\n        const track = this.peerconnection.getTrackBySSRC(ssrc);\r\n\r\n        if (track) {\r\n            if (track.isAudioTrack()) {\r\n                audioBitrateDownload += ssrcStats.bitrate.download;\r\n                audioBitrateUpload += ssrcStats.bitrate.upload;\r\n            } else {\r\n                videoBitrateDownload += ssrcStats.bitrate.download;\r\n                videoBitrateUpload += ssrcStats.bitrate.upload;\r\n            }\r\n\r\n            const participantId = track.getParticipantId();\r\n\r\n            if (participantId) {\r\n                const resolution = ssrcStats.resolution;\r\n\r\n                if (resolution.width\r\n                        && resolution.height\r\n                        && resolution.width !== -1\r\n                        && resolution.height !== -1) {\r\n                    const userResolutions = resolutions[participantId] || {};\r\n\r\n                    userResolutions[ssrc] = resolution;\r\n                    resolutions[participantId] = userResolutions;\r\n                }\r\n                if (ssrcStats.framerate !== 0) {\r\n                    const userFramerates = framerates[participantId] || {};\r\n\r\n                    userFramerates[ssrc] = ssrcStats.framerate;\r\n                    framerates[participantId] = userFramerates;\r\n                }\r\n            } else {\r\n                logger.error(`No participant ID returned by ${track}`);\r\n            }\r\n        }\r\n\r\n        ssrcStats.resetBitrate();\r\n    }\r\n\r\n    this.conferenceStats.bitrate = {\r\n        'upload': bitrateUpload,\r\n        'download': bitrateDownload\r\n    };\r\n\r\n    this.conferenceStats.bitrate.audio = {\r\n        'upload': audioBitrateUpload,\r\n        'download': audioBitrateDownload\r\n    };\r\n\r\n    this.conferenceStats.bitrate.video = {\r\n        'upload': videoBitrateUpload,\r\n        'download': videoBitrateDownload\r\n    };\r\n\r\n    this.conferenceStats.packetLoss = {\r\n        total:\r\n            calculatePacketLoss(\r\n                lostPackets.download + lostPackets.upload,\r\n                totalPackets.download + totalPackets.upload),\r\n        download:\r\n            calculatePacketLoss(lostPackets.download, totalPackets.download),\r\n        upload:\r\n            calculatePacketLoss(lostPackets.upload, totalPackets.upload)\r\n    };\r\n\r\n    this.eventEmitter.emit(\r\n        StatisticsEvents.CONNECTION_STATS,\r\n        this.peerconnection,\r\n        {\r\n            'bandwidth': this.conferenceStats.bandwidth,\r\n            'bitrate': this.conferenceStats.bitrate,\r\n            'packetLoss': this.conferenceStats.packetLoss,\r\n            'resolution': resolutions,\r\n            'framerate': framerates,\r\n            'transport': this.conferenceStats.transport\r\n        });\r\n    this.conferenceStats.transport = [];\r\n};\r\n\r\n/**\r\n * Stats processing logic.\r\n */\r\nStatsCollector.prototype.processAudioLevelReport = function() {\r\n    if (!this.baselineAudioLevelsReport) {\r\n        return;\r\n    }\r\n\r\n    const getStatValue = this._getStatValue;\r\n\r\n    for (const idx in this.currentAudioLevelsReport) {\r\n        if (!this.currentAudioLevelsReport.hasOwnProperty(idx)) {\r\n            continue;\r\n        }\r\n\r\n        const now = this.currentAudioLevelsReport[idx];\r\n\r\n        if (now.type !== 'ssrc' && now.type !== 'track') {\r\n            continue;\r\n        }\r\n\r\n        const before = this.baselineAudioLevelsReport[idx];\r\n        let ssrc = this.getNonNegativeStat(now, 'ssrc');\r\n\r\n        if (!ssrc && Array.isArray(now.ssrcIds)) {\r\n            ssrc = Number(now.ssrcIds[0]);\r\n        }\r\n\r\n        if (!before) {\r\n            logger.warn(`${ssrc} not enough data`);\r\n            continue;\r\n        }\r\n\r\n        if (!ssrc) {\r\n            if ((Date.now() - now.timestamp) < 3000) {\r\n                logger.warn('No ssrc: ');\r\n            }\r\n            continue;\r\n        }\r\n\r\n        // Audio level\r\n        let audioLevel;\r\n\r\n        try {\r\n            audioLevel\r\n                = getStatValue(now, 'audioInputLevel')\r\n                    || getStatValue(now, 'audioOutputLevel');\r\n        } catch (e) { /* not supported*/\r\n            logger.warn('Audio Levels are not available in the statistics.');\r\n            clearInterval(this.audioLevelsIntervalId);\r\n\r\n            return;\r\n        }\r\n\r\n        if (audioLevel) {\r\n            let isLocal;\r\n\r\n            // If type=\"ssrc\" (legacy) check whether they are received packets.\r\n            if (now.type === 'ssrc') {\r\n                isLocal = !getStatValue(now, 'packetsReceived');\r\n\r\n            // If type=\"track\", check remoteSource boolean property.\r\n            } else {\r\n                isLocal = !now.remoteSource;\r\n            }\r\n\r\n            // According to the W3C WebRTC Stats spec, audioLevel should be in\r\n            // 0..1 range (0 == silence). However browsers don't behave that\r\n            // way so we must convert it to 0..1.\r\n            //\r\n            // In Edge the range is -100..0 (-100 == silence) measured in dB,\r\n            // so convert to linear. The levels are set to 0 for remote tracks,\r\n            // so don't convert those, since 0 means \"the maximum\" in Edge.\r\n            if (browser.isEdge()) {\r\n                audioLevel = audioLevel < 0 ? Math.pow(10, audioLevel / 20) : 0;\r\n\r\n            // TODO: Can't find specs about what this value really is, but it\r\n            // seems to vary between 0 and around 32k.\r\n            } else {\r\n                audioLevel = audioLevel / 32767;\r\n            }\r\n\r\n            this.eventEmitter.emit(\r\n                StatisticsEvents.AUDIO_LEVEL,\r\n                this.peerconnection,\r\n                ssrc,\r\n                audioLevel,\r\n                isLocal);\r\n        }\r\n    }\r\n};\r\n\r\n/* eslint-enable no-continue */\r\n\r\n/**\r\n * New promised based getStats report processing.\r\n * Tested with chrome, firefox and safari. Not switching it on for chrome as\r\n * frameRate stat is missing and calculating it using framesSent,\r\n * gives values double the values seen in webrtc-internals.\r\n * https://w3c.github.io/webrtc-stats/\r\n */\r\n\r\n/**\r\n * Defines a function which (1) is to be used as a StatsCollector method and (2)\r\n * gets the value from a specific report returned by RTCPeerConnection#getStats\r\n * associated with a lib-qhsens-meet browser-agnostic name in case of using\r\n * Promised based getStats.\r\n *\r\n * @param {Object.<string,string>} keys the map of Libqhsens browser-agnostic\r\n * names to RTCPeerConnection#getStats browser-specific keys\r\n */\r\nStatsCollector.prototype._defineNewGetStatValueMethod = function(keys) {\r\n    // Define the function which converts a lib-qhsens-meet browser-asnostic name\r\n    // to a browser-specific key of a report returned by\r\n    // RTCPeerConnection#getStats.\r\n    const keyFromName = function(name) {\r\n        const key = keys[name];\r\n\r\n        if (key) {\r\n            return key;\r\n        }\r\n\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw `The property '${name}' isn't supported!`;\r\n    };\r\n\r\n    // Compose the 2 functions defined above to get a function which retrieves\r\n    // the value from a specific report returned by RTCPeerConnection#getStats\r\n    // associated with a specific lib-qhsens-meet browser-agnostic name.\r\n    return (item, name) => item[keyFromName(name)];\r\n};\r\n\r\n/**\r\n * Converts the value to a non-negative number.\r\n * If the value is either invalid or negative then 0 will be returned.\r\n * @param {*} v\r\n * @return {number}\r\n * @private\r\n */\r\nStatsCollector.prototype.getNonNegativeValue = function(v) {\r\n    let value = v;\r\n\r\n    if (typeof value !== 'number') {\r\n        value = Number(value);\r\n    }\r\n\r\n    if (isNaN(value)) {\r\n        return 0;\r\n    }\r\n\r\n    return Math.max(0, value);\r\n};\r\n\r\n/**\r\n * Calculates bitrate between before and now using a supplied field name and its\r\n * value in the stats.\r\n * @param {RTCInboundRtpStreamStats|RTCSentRtpStreamStats} now the current stats\r\n * @param {RTCInboundRtpStreamStats|RTCSentRtpStreamStats} before the\r\n * previous stats.\r\n * @param fieldName the field to use for calculations.\r\n * @return {number} the calculated bitrate between now and before.\r\n * @private\r\n */\r\nStatsCollector.prototype._calculateBitrate = function(now, before, fieldName) {\r\n    const bytesNow = this.getNonNegativeValue(now[fieldName]);\r\n    const bytesBefore = this.getNonNegativeValue(before[fieldName]);\r\n    const bytesProcessed = Math.max(0, bytesNow - bytesBefore);\r\n\r\n    const timeMs = now.timestamp - before.timestamp;\r\n    let bitrateKbps = 0;\r\n\r\n    if (timeMs > 0) {\r\n        // TODO is there any reason to round here?\r\n        bitrateKbps = Math.round((bytesProcessed * 8) / timeMs);\r\n    }\r\n\r\n    return bitrateKbps;\r\n};\r\n\r\n/**\r\n * Stats processing new getStats logic.\r\n */\r\nStatsCollector.prototype.processNewStatsReport = function() {\r\n    if (!this.previousStatsReport) {\r\n        return;\r\n    }\r\n\r\n    const getStatValue = this._getStatValue;\r\n    const byteSentStats = {};\r\n\r\n    this.currentStatsReport.forEach(now => {\r\n\r\n        // RTCIceCandidatePairStats\r\n        // https://w3c.github.io/webrtc-stats/#candidatepair-dict*\r\n        if (now.type === 'candidate-pair'\r\n            && now.nominated\r\n            && now.state === 'succeeded') {\r\n\r\n            const availableIncomingBitrate = now.availableIncomingBitrate;\r\n            const availableOutgoingBitrate = now.availableOutgoingBitrate;\r\n\r\n            if (availableIncomingBitrate || availableOutgoingBitrate) {\r\n                this.conferenceStats.bandwidth = {\r\n                    'download': Math.round(availableIncomingBitrate / 1000),\r\n                    'upload': Math.round(availableOutgoingBitrate / 1000)\r\n                };\r\n            }\r\n\r\n            const remoteUsedCandidate\r\n                = this.currentStatsReport.get(now.remoteCandidateId);\r\n            const localUsedCandidate\r\n                = this.currentStatsReport.get(now.localCandidateId);\r\n\r\n            // RTCIceCandidateStats\r\n            // https://w3c.github.io/webrtc-stats/#icecandidate-dict*\r\n            // safari currently does not provide ice candidates in stats\r\n            if (remoteUsedCandidate && localUsedCandidate) {\r\n                // FF uses non-standard ipAddress, portNumber, transport\r\n                // instead of ip, port, protocol\r\n                const remoteIpAddress = getStatValue(remoteUsedCandidate, 'ip');\r\n                const remotePort = getStatValue(remoteUsedCandidate, 'port');\r\n                const ip = `${remoteIpAddress}:${remotePort}`;\r\n\r\n                const localIpAddress = getStatValue(localUsedCandidate, 'ip');\r\n                const localPort = getStatValue(localUsedCandidate, 'port');\r\n\r\n                const localIp = `${localIpAddress}:${localPort}`;\r\n                const type = getStatValue(remoteUsedCandidate, 'protocol');\r\n\r\n                // Save the address unless it has been saved already.\r\n                const conferenceStatsTransport = this.conferenceStats.transport;\r\n\r\n                if (!conferenceStatsTransport.some(\r\n                        t =>\r\n                            t.ip === ip\r\n                            && t.type === type\r\n                            && t.localip === localIp)) {\r\n                    conferenceStatsTransport.push({\r\n                        ip,\r\n                        type,\r\n                        localIp,\r\n                        p2p: this.peerconnection.isP2P,\r\n                        localCandidateType: localUsedCandidate.candidateType,\r\n                        remoteCandidateType: remoteUsedCandidate.candidateType,\r\n                        networkType: localUsedCandidate.networkType,\r\n                        rtt: now.currentRoundTripTime * 1000\r\n                    });\r\n                }\r\n            }\r\n\r\n        // RTCReceivedRtpStreamStats\r\n        // https://w3c.github.io/webrtc-stats/#receivedrtpstats-dict*\r\n        // RTCSentRtpStreamStats\r\n        // https://w3c.github.io/webrtc-stats/#sentrtpstats-dict*\r\n        } else if (now.type === 'inbound-rtp' || now.type === 'outbound-rtp') {\r\n            const before = this.previousStatsReport.get(now.id);\r\n            const ssrc = this.getNonNegativeValue(now.ssrc);\r\n\r\n            if (!before || !ssrc) {\r\n                return;\r\n            }\r\n\r\n            let ssrcStats = this.ssrc2stats.get(ssrc);\r\n\r\n            if (!ssrcStats) {\r\n                ssrcStats = new SsrcStats();\r\n                this.ssrc2stats.set(ssrc, ssrcStats);\r\n            }\r\n\r\n            let isDownloadStream = true;\r\n            let key = 'packetsReceived';\r\n\r\n            if (now.type === 'outbound-rtp') {\r\n                isDownloadStream = false;\r\n                key = 'packetsSent';\r\n            }\r\n\r\n            let packetsNow = now[key];\r\n\r\n            if (!packetsNow || packetsNow < 0) {\r\n                packetsNow = 0;\r\n            }\r\n\r\n            const packetsBefore = this.getNonNegativeValue(before[key]);\r\n            const packetsDiff = Math.max(0, packetsNow - packetsBefore);\r\n\r\n            const packetsLostNow\r\n                = this.getNonNegativeValue(now.packetsLost);\r\n            const packetsLostBefore\r\n                = this.getNonNegativeValue(before.packetsLost);\r\n            const packetsLostDiff\r\n                = Math.max(0, packetsLostNow - packetsLostBefore);\r\n\r\n            ssrcStats.setLoss({\r\n                packetsTotal: packetsDiff + packetsLostDiff,\r\n                packetsLost: packetsLostDiff,\r\n                isDownloadStream\r\n            });\r\n\r\n            if (now.type === 'inbound-rtp') {\r\n\r\n                ssrcStats.addBitrate({\r\n                    'download': this._calculateBitrate(\r\n                                    now, before, 'bytesReceived'),\r\n                    'upload': 0\r\n                });\r\n\r\n                // RTCInboundRtpStreamStats\r\n                // https://w3c.github.io/webrtc-stats/#inboundrtpstats-dict*\r\n                // TODO: can we use framesDecoded for frame rate, available\r\n                // in chrome\r\n            } else {\r\n                byteSentStats[ssrc] = this.getNonNegativeValue(now.bytesSent);\r\n                ssrcStats.addBitrate({\r\n                    'download': 0,\r\n                    'upload': this._calculateBitrate(\r\n                                now, before, 'bytesSent')\r\n                });\r\n\r\n                // RTCOutboundRtpStreamStats\r\n                // https://w3c.github.io/webrtc-stats/#outboundrtpstats-dict*\r\n                // TODO: can we use framesEncoded for frame rate, available\r\n                // in chrome\r\n            }\r\n\r\n            // FF has framerateMean out of spec\r\n            const framerateMean = now.framerateMean;\r\n\r\n            if (framerateMean) {\r\n                ssrcStats.setFramerate(Math.round(framerateMean || 0));\r\n            }\r\n\r\n        // track for resolution\r\n        // RTCVideoHandlerStats\r\n        // https://w3c.github.io/webrtc-stats/#vststats-dict*\r\n        // RTCMediaHandlerStats\r\n        // https://w3c.github.io/webrtc-stats/#mststats-dict*\r\n        } else if (now.type === 'track') {\r\n\r\n            const resolution = {\r\n                height: now.frameHeight,\r\n                width: now.frameWidth\r\n            };\r\n\r\n            // Tries to get frame rate\r\n            let frameRate = now.framesPerSecond;\r\n\r\n            if (!frameRate) {\r\n                // we need to calculate it\r\n                const before = this.previousStatsReport.get(now.id);\r\n\r\n                if (before) {\r\n                    const timeMs = now.timestamp - before.timestamp;\r\n\r\n                    if (timeMs > 0 && now.framesSent) {\r\n                        const numberOfFramesSinceBefore\r\n                            = now.framesSent - before.framesSent;\r\n\r\n                        frameRate = (numberOfFramesSinceBefore / timeMs) * 1000;\r\n                    }\r\n                }\r\n\r\n                if (!frameRate) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            const trackIdentifier = now.trackIdentifier;\r\n            const ssrc = this.peerconnection.getSsrcByTrackId(trackIdentifier);\r\n            let ssrcStats = this.ssrc2stats.get(ssrc);\r\n\r\n            if (!ssrcStats) {\r\n                ssrcStats = new SsrcStats();\r\n                this.ssrc2stats.set(ssrc, ssrcStats);\r\n            }\r\n            ssrcStats.setFramerate(Math.round(frameRate || 0));\r\n\r\n            if (resolution.height && resolution.width) {\r\n                ssrcStats.setResolution(resolution);\r\n            } else {\r\n                ssrcStats.setResolution(null);\r\n            }\r\n        }\r\n    });\r\n\r\n    this.eventEmitter.emit(\r\n        StatisticsEvents.BYTE_SENT_STATS, this.peerconnection, byteSentStats);\r\n\r\n    this._processAndEmitReport();\r\n};\r\n\r\n/**\r\n * Stats processing logic.\r\n */\r\nStatsCollector.prototype.processNewAudioLevelReport = function() {\r\n    if (!this.baselineAudioLevelsReport) {\r\n        return;\r\n    }\r\n\r\n    this.currentAudioLevelsReport.forEach(now => {\r\n        if (now.type !== 'track') {\r\n            return;\r\n        }\r\n\r\n        // Audio level\r\n        const audioLevel = now.audioLevel;\r\n\r\n        if (!audioLevel) {\r\n            return;\r\n        }\r\n\r\n        const trackIdentifier = now.trackIdentifier;\r\n        const ssrc = this.peerconnection.getSsrcByTrackId(trackIdentifier);\r\n\r\n        if (ssrc) {\r\n            const isLocal\r\n                = ssrc === this.peerconnection.getLocalSSRC(\r\n                this.peerconnection.getLocalTracks(MediaType.AUDIO));\r\n\r\n            this.eventEmitter.emit(\r\n                StatisticsEvents.AUDIO_LEVEL,\r\n                this.peerconnection,\r\n                ssrc,\r\n                audioLevel,\r\n                isLocal);\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * End new promised based getStats processing methods.\r\n */\r\n","\r\nimport { Strophe } from 'strophe.js';\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\n\r\nimport * as QHSenseConferenceEvents from './QHSenseConferenceEvents';\r\nimport { ParticipantConnectionStatus }\r\n    from './modules/connectivity/ParticipantConnectionStatus';\r\nimport * as MediaType from './service/RTC/MediaType';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Represents a participant in (i.e. a member of) a conference.\r\n */\r\nexport default class QHSenseParticipant {\r\n\r\n    /* eslint-disable max-params */\r\n\r\n    /**\r\n     * Initializes a new QHSenseParticipant instance.\r\n     *\r\n     * @constructor\r\n     * @param jid the conference XMPP jid\r\n     * @param conference\r\n     * @param displayName\r\n     * @param {Boolean} hidden - True if the new QHSenseParticipant instance is to\r\n     * represent a hidden participant; otherwise, false.\r\n     * @param {string} statsID - optional participant statsID\r\n     * @param {string} status - the initial status if any.\r\n     * @param {object} identity - the xmpp identity\r\n     */\r\n    constructor(jid, conference, displayName, hidden, statsID, status, identity) {\r\n        this._jid = jid;\r\n        this._id = Strophe.getResourceFromJid(jid);\r\n        this._conference = conference;\r\n        this._displayName = displayName;\r\n        this._supportsDTMF = false;\r\n        this._tracks = [];\r\n        this._role = 'none';\r\n        this._status = status;\r\n        this._hidden = hidden;\r\n        this._statsID = statsID;\r\n        this._connectionStatus = ParticipantConnectionStatus.ACTIVE;\r\n        this._properties = {};\r\n        this._identity = identity;\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * @returns {QHSenseConference} The conference that this participant belongs\r\n     * to.\r\n     */\r\n    getConference() {\r\n        return this._conference;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of a property of this participant.\r\n     */\r\n    getProperty(name) {\r\n        return this._properties[name];\r\n    }\r\n\r\n    /**\r\n     * Checks whether this <tt>QHSenseParticipant</tt> has any video tracks which\r\n     * are muted according to their underlying WebRTC <tt>MediaStreamTrack</tt>\r\n     * muted status.\r\n     * @return {boolean} <tt>true</tt> if this <tt>participant</tt> contains any\r\n     * video <tt>QHSenseTrack</tt>s which are muted as defined in\r\n     * {@link QHSenseTrack.isWebRTCTrackMuted}.\r\n     */\r\n    hasAnyVideoTrackWebRTCMuted() {\r\n        return (\r\n            this.getTracks().some(\r\n                QHSenseTrack =>\r\n                    QHSenseTrack.getType() === MediaType.VIDEO\r\n                        && QHSenseTrack.isWebRTCTrackMuted()));\r\n    }\r\n\r\n    /**\r\n     * Updates participant's connection status.\r\n     * @param {string} state the current participant connection state.\r\n     * {@link ParticipantConnectionStatus}.\r\n     * @private\r\n     */\r\n    _setConnectionStatus(status) {\r\n        this._connectionStatus = status;\r\n    }\r\n\r\n    /**\r\n     * Return participant's connectivity status.\r\n     *\r\n     * @returns {string} the connection status\r\n     * <tt>ParticipantConnectionStatus</tt> of the user.\r\n     * {@link ParticipantConnectionStatus}.\r\n     */\r\n    getConnectionStatus() {\r\n        return this._connectionStatus;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of a property of this participant, and fires an event if\r\n     * the value has changed.\r\n     * @name the name of the property.\r\n     * @value the value to set.\r\n     */\r\n    setProperty(name, value) {\r\n        const oldValue = this._properties[name];\r\n\r\n        if (value !== oldValue) {\r\n            this._properties[name] = value;\r\n            this._conference.eventEmitter.emit(\r\n                QHSenseConferenceEvents.PARTICIPANT_PROPERTY_CHANGED,\r\n                this,\r\n                name,\r\n                oldValue,\r\n                value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns {Array.<QHSenseTrack>} The list of media tracks for this\r\n     * participant.\r\n     */\r\n    getTracks() {\r\n        return this._tracks.slice();\r\n    }\r\n\r\n    /**\r\n     * @param {MediaType} mediaType\r\n     * @returns {Array.<QHSenseTrack>} an array of media tracks for this\r\n     * participant, for given media type.\r\n     */\r\n    getTracksByMediaType(mediaType) {\r\n        return this.getTracks().filter(track => track.getType() === mediaType);\r\n    }\r\n\r\n    /**\r\n     * @returns {String} The ID of this participant.\r\n     */\r\n    getId() {\r\n        return this._id;\r\n    }\r\n\r\n    /**\r\n     * @returns {String} The JID of this participant.\r\n     */\r\n    getJid() {\r\n        return this._jid;\r\n    }\r\n\r\n    /**\r\n     * @returns {String} The human-readable display name of this participant.\r\n     */\r\n    getDisplayName() {\r\n        return this._displayName;\r\n    }\r\n\r\n    /**\r\n     * @returns {String} The stats ID of this participant.\r\n     */\r\n    getStatsID() {\r\n        return this._statsID;\r\n    }\r\n\r\n    /**\r\n     * @returns {String} The status of the participant.\r\n     */\r\n    getStatus() {\r\n        return this._status;\r\n    }\r\n\r\n    /**\r\n     * @returns {Boolean} Whether this participant is a moderator or not.\r\n     */\r\n    isModerator() {\r\n        return this._role === 'moderator';\r\n    }\r\n\r\n    /**\r\n     * @returns {Boolean} Whether this participant is a hidden participant. Some\r\n     * special system participants may want to join hidden (like for example the\r\n     * recorder).\r\n     */\r\n    isHidden() {\r\n        return this._hidden;\r\n    }\r\n\r\n    /**\r\n     * @returns {Boolean} Whether this participant has muted their audio.\r\n     */\r\n    isAudioMuted() {\r\n        return this._isMediaTypeMuted(MediaType.AUDIO);\r\n    }\r\n\r\n    /**\r\n     * Determines whether all QHSenseTracks which are of a specific MediaType and\r\n     * which belong to this QHSenseParticipant are muted.\r\n     *\r\n     * @param {MediaType} mediaType - The MediaType of the QHSenseTracks to be\r\n     * checked.\r\n     * @private\r\n     * @returns {Boolean} True if all QHSenseTracks which are of the specified\r\n     * mediaType and which belong to this QHSenseParticipant are muted; otherwise,\r\n     * false.\r\n     */\r\n    _isMediaTypeMuted(mediaType) {\r\n        return this.getTracks().reduce(\r\n            (muted, track) =>\r\n                muted && (track.getType() !== mediaType || track.isMuted()),\r\n            true);\r\n    }\r\n\r\n    /**\r\n     * @returns {Boolean} Whether this participant has muted their video.\r\n     */\r\n    isVideoMuted() {\r\n        return this._isMediaTypeMuted(MediaType.VIDEO);\r\n    }\r\n\r\n    /**\r\n     * @returns {String} The role of this participant.\r\n     */\r\n    getRole() {\r\n        return this._role;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    supportsDTMF() {\r\n        return this._supportsDTMF;\r\n    }\r\n\r\n    /**\r\n     * Returns a set with the features for the participant.\r\n     * @param {int} timeout the timeout in ms for reply from the participant.\r\n     * @returns {Promise<Set<String>, Error>}\r\n     */\r\n    getFeatures(timeout = 5000) {\r\n        return this._conference.xmpp.caps.getFeatures(this._jid, timeout)\r\n            .catch(error => {\r\n                // when we detect version mismatch we return a string as error\r\n                // we want to retry in such case\r\n                if (error && error.constructor === String) {\r\n                    return this._conference.xmpp.caps.getFeatures(this._jid, timeout);\r\n                }\r\n\r\n                logger.warn(`Failed to discover features of ${this._jid}`, error);\r\n\r\n                return Promise.reject(error);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Returns the bot type for the participant.\r\n     *\r\n     * @returns {string|undefined} - The bot type of the participant.\r\n     */\r\n    getBotType() {\r\n        return this._botType;\r\n    }\r\n}\r\n","import {\r\n    CONNECTION_DISCONNECTED,\r\n    CONNECTION_ESTABLISHED,\r\n    CONNECTION_FAILED\r\n} from './QHSenseConnectionEvents';\r\nimport XMPP from './modules/xmpp/xmpp';\r\n\r\n/**\r\n * @typedef {Object} UpgradeRoleError\r\n *\r\n * @property {QHSenseConnectionErrors} [connectionError] - One of\r\n * {@link QHSenseConnectionErrors} which occurred when trying to connect to the\r\n * XMPP server.\r\n * @property {String} [authenticationError] - One of XMPP error conditions\r\n * returned by Jicofo on authentication attempt. See\r\n * {@link https://xmpp.org/rfcs/rfc3920.html#streams-error}.\r\n * @property {String} [message] - More details about the error.\r\n * @property {Object} [credentials] - The credentials that failed the\r\n * authentication.\r\n * @property {String} [credentials.jid] - The XMPP ID part of the credentials\r\n * that failed the authentication.\r\n * @property {string} [credentials.password] - The password part of the\r\n * credentials that failed the authentication.\r\n *\r\n * NOTE If neither one of the errors is present, then the operation has been\r\n * canceled.\r\n */\r\n\r\n/* eslint-disable no-invalid-this */\r\n\r\n/**\r\n * Connects to the XMPP server using the specified credentials and contacts\r\n * Jicofo in order to obtain a session ID (which is then stored in the local\r\n * storage). The user's role of the parent conference will be upgraded to\r\n * moderator (by Jicofo). It's also used to join the conference when starting\r\n * from anonymous domain and only authenticated users are allowed to create new\r\n * rooms.\r\n *\r\n * @param {Object} options\r\n * @param {string} options.id - XMPP user's ID to log in. For example,\r\n * user@xmpp-server.com.\r\n * @param {string} options.password - XMPP user's password to log in with.\r\n * @param {string} [options.roomPassword] - The password to join the MUC with.\r\n * @param {Function} [options.onLoginSuccessful] - Callback called when logging\r\n * into the XMPP server was successful. The next step will be to obtain a new\r\n * session ID from Jicofo and join the MUC using it which will effectively\r\n * upgrade the user's role to moderator.\r\n * @returns {Object} A <tt>thenable</tt> which (1) settles when the process of\r\n * authenticating and upgrading the role of the specified XMPP user finishes and\r\n * (2) has a <tt>cancel</tt> method that allows the caller to interrupt the\r\n * process. If the process finishes successfully, the session ID has been stored\r\n * in the settings and the <tt>thenable</tt> is resolved. If the process\r\n * finishes with failure, the <tt>thenable</tt> is rejected with reason of type\r\n * {@link UpgradeRoleError} which will have either <tt>connectionError</tt> or\r\n * <tt>authenticationError</tt> property set depending on which of the steps has\r\n * failed. If <tt>cancel</tt> is called before the process finishes, then the\r\n * thenable will be rejected with an empty object (i.e. no error property will\r\n * be set on the rejection reason).\r\n */\r\nexport default function authenticateAndUpgradeRole({\r\n    // 1. Log the specified XMPP user in.\r\n    id,\r\n    password,\r\n    onCreateResource,\r\n\r\n    // 2. Let the API client/consumer know as soon as the XMPP user has been\r\n    //    successfully logged in.\r\n    onLoginSuccessful,\r\n\r\n    // 3. Join the MUC.\r\n    roomPassword\r\n}) {\r\n    let canceled = false;\r\n    let rejectPromise;\r\n    let xmpp = new XMPP(this.connection.options);\r\n\r\n    const process = new Promise((resolve, reject) => {\r\n        // The process is represented by a Thenable with a cancel method. The\r\n        // Thenable is implemented using Promise and the cancel using the\r\n        // Promise's reject function.\r\n        rejectPromise = reject;\r\n\r\n\r\n        xmpp.addListener(\r\n            CONNECTION_DISCONNECTED,\r\n            () => {\r\n                xmpp = undefined;\r\n            });\r\n        xmpp.addListener(\r\n            CONNECTION_ESTABLISHED,\r\n            () => {\r\n                if (canceled) {\r\n                    return;\r\n                }\r\n\r\n                // Let the caller know that the XMPP login was successful.\r\n                onLoginSuccessful && onLoginSuccessful();\r\n\r\n                // Now authenticate with Jicofo and get a new session ID.\r\n                const room = xmpp.createRoom(\r\n                    this.options.name,\r\n                    this.options.config,\r\n                    onCreateResource\r\n                );\r\n\r\n                room.moderator.authenticate()\r\n                    .then(() => {\r\n                        xmpp && xmpp.disconnect();\r\n\r\n                        if (canceled) {\r\n                            return;\r\n                        }\r\n\r\n                        // At this point we should have the new session ID\r\n                        // stored in the settings. Jicofo will allow to join the\r\n                        // room.\r\n                        this.join(roomPassword);\r\n\r\n                        resolve();\r\n                    })\r\n                    .catch(({ error, message }) => {\r\n                        xmpp.disconnect();\r\n\r\n                        reject({\r\n                            authenticationError: error,\r\n                            message\r\n                        });\r\n                    });\r\n            });\r\n        xmpp.addListener(\r\n            CONNECTION_FAILED,\r\n            (connectionError, message, credentials) => {\r\n                reject({\r\n                    connectionError,\r\n                    credentials,\r\n                    message\r\n                });\r\n                xmpp = undefined;\r\n            });\r\n\r\n        canceled || xmpp.connect(id, password);\r\n    });\r\n\r\n    /**\r\n     * Cancels the process, if it's in progress, of authenticating and upgrading\r\n     * the role of the local participant/user.\r\n     *\r\n     * @public\r\n     * @returns {void}\r\n     */\r\n    process.cancel = () => {\r\n        canceled = true;\r\n        rejectPromise({});\r\n        xmpp && xmpp.disconnect();\r\n    };\r\n\r\n    return process;\r\n}\r\n\r\n/* eslint-enable no-invalid-this */\r\n","/* global $ */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport { Strophe } from 'strophe.js';\r\n\r\nimport ChatRoom from './ChatRoom';\r\nimport { ConnectionPluginListenable } from './ConnectionPlugin';\r\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * MUC connection plugin.\r\n */\r\nclass MucConnectionPlugin extends ConnectionPluginListenable {\r\n    /**\r\n     *\r\n     * @param xmpp\r\n     */\r\n    constructor(xmpp) {\r\n        super();\r\n        this.xmpp = xmpp;\r\n        this.rooms = {};\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param connection\r\n     */\r\n    init(connection) {\r\n        super.init(connection);\r\n\r\n        // add handlers (just once)\r\n        this.connection.addHandler(this.onPresence.bind(this), null,\r\n            'presence', null, null, null, null);\r\n        this.connection.addHandler(this.onPresenceUnavailable.bind(this),\r\n            null, 'presence', 'unavailable', null);\r\n        this.connection.addHandler(this.onPresenceError.bind(this), null,\r\n            'presence', 'error', null);\r\n        this.connection.addHandler(this.onMessage.bind(this), null,\r\n            'message', null, null);\r\n        this.connection.addHandler(this.onMute.bind(this),\r\n            'http://jitsi.org/jitmeet/audio', 'iq', 'set', null, null);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param jid\r\n     * @param password\r\n     * @param options\r\n     */\r\n    createRoom(jid, password, options) {\r\n        const roomJid = Strophe.getBareJidFromJid(jid);\r\n\r\n        if (this.rooms[roomJid]) {\r\n            const errmsg = 'You are already in the room!';\r\n\r\n            logger.error(errmsg);\r\n            throw new Error(errmsg);\r\n        }\r\n        this.rooms[roomJid] = new ChatRoom(this.connection, jid,\r\n            password, this.xmpp, options);\r\n        this.eventEmitter.emit(\r\n            XMPPEvents.EMUC_ROOM_ADDED, this.rooms[roomJid]);\r\n\r\n        return this.rooms[roomJid];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param jid\r\n     */\r\n    doLeave(jid) {\r\n        this.eventEmitter.emit(\r\n            XMPPEvents.EMUC_ROOM_REMOVED, this.rooms[jid]);\r\n        delete this.rooms[jid];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param pres\r\n     */\r\n    onPresence(pres) {\r\n        const from = pres.getAttribute('from');\r\n\r\n        // What is this for? A workaround for something?\r\n        if (pres.getAttribute('type')) {\r\n            return true;\r\n        }\r\n\r\n        const room = this.rooms[Strophe.getBareJidFromJid(from)];\r\n\r\n        if (!room) {\r\n            return;\r\n        }\r\n\r\n        // Parse status.\r\n        if ($(pres).find('>x[xmlns=\"http://jabber.org/protocol/muc#user\"]'\r\n            + '>status[code=\"201\"]').length) {\r\n            room.createNonAnonymousRoom();\r\n        }\r\n\r\n        room.onPresence(pres);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param pres\r\n     */\r\n    onPresenceUnavailable(pres) {\r\n        const from = pres.getAttribute('from');\r\n        const room = this.rooms[Strophe.getBareJidFromJid(from)];\r\n\r\n        if (!room) {\r\n            return;\r\n        }\r\n\r\n        room.onPresenceUnavailable(pres, from);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param pres\r\n     */\r\n    onPresenceError(pres) {\r\n        const from = pres.getAttribute('from');\r\n        const room = this.rooms[Strophe.getBareJidFromJid(from)];\r\n\r\n        if (!room) {\r\n            return;\r\n        }\r\n\r\n        room.onPresenceError(pres, from);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param msg\r\n     */\r\n    onMessage(msg) {\r\n        // FIXME: this is a hack. but jingle on muc makes nickchanges hard\r\n        const from = msg.getAttribute('from');\r\n        const room = this.rooms[Strophe.getBareJidFromJid(from)];\r\n\r\n        if (!room) {\r\n            return;\r\n        }\r\n\r\n        room.onMessage(msg, from);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * TODO: Document\r\n     * @param iq\r\n     */\r\n    onMute(iq) {\r\n        const from = iq.getAttribute('from');\r\n        const room = this.rooms[Strophe.getBareJidFromJid(from)];\r\n\r\n        // XXX What are the semantics of the return value? Why is it sometimes\r\n        // undefined and sometimes a boolean?\r\n        if (!room) {\r\n            return;\r\n        }\r\n\r\n        room.onMute(iq);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param XMPP\r\n */\r\nexport default function(XMPP) {\r\n    Strophe.addConnectionPlugin('emuc', new MucConnectionPlugin(XMPP));\r\n}\r\n","/* global $, __filename */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport { $iq, $msg, $pres, Strophe } from 'strophe.js';\r\n\r\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\r\nimport * as QHSenseTranscriptionStatus from '../../QHSenseTranscriptionStatus';\r\nimport Listenable from '../util/Listenable';\r\nimport Settings from '../settings/Settings';\r\nimport * as MediaType from '../../service/RTC/MediaType';\r\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\r\n\r\nimport Moderator from './moderator';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\nexport const parser = {\r\n    packet2JSON(xmlElement, nodes) {\r\n        for (const child of Array.from(xmlElement.children)) {\r\n            const node = {\r\n                attributes: {},\r\n                children: [],\r\n                tagName: child.tagName\r\n            };\r\n\r\n            for (const attr of Array.from(child.attributes)) {\r\n                node.attributes[attr.name] = attr.value;\r\n            }\r\n            const text = Strophe.getText(child);\r\n\r\n            if (text) {\r\n                // Using Strophe.getText will do work for traversing all direct\r\n                // child text nodes but returns an escaped value, which is not\r\n                // desirable at this point.\r\n                node.value = Strophe.xmlunescape(text);\r\n            }\r\n            nodes.push(node);\r\n            this.packet2JSON(child, node.children);\r\n        }\r\n    },\r\n    json2packet(nodes, packet) {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n\r\n            if (node) {\r\n                packet.c(node.tagName, node.attributes);\r\n                if (node.value) {\r\n                    packet.t(node.value);\r\n                }\r\n                if (node.children) {\r\n                    this.json2packet(node.children, packet);\r\n                }\r\n                packet.up();\r\n            }\r\n        }\r\n\r\n        // packet.up();\r\n    }\r\n};\r\n\r\n/**\r\n * Returns array of JS objects from the presence JSON associated with the passed\r\n / nodeName\r\n * @param pres the presence JSON\r\n * @param nodeName the name of the node (videomuted, audiomuted, etc)\r\n */\r\nfunction filterNodeFromPresenceJSON(pres, nodeName) {\r\n    const res = [];\r\n\r\n    for (let i = 0; i < pres.length; i++) {\r\n        if (pres[i].tagName === nodeName) {\r\n            res.push(pres[i]);\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\n// XXX As ChatRoom constructs XMPP stanzas and Strophe is build around the idea\r\n// of chaining function calls, allow long function call chains.\r\n/* eslint-disable newline-per-chained-call */\r\n\r\n/**\r\n *\r\n */\r\nexport default class ChatRoom extends Listenable {\r\n\r\n    /* eslint-disable max-params */\r\n\r\n    /**\r\n     *\r\n     * @param connection\r\n     * @param jid\r\n     * @param password\r\n     * @param XMPP\r\n     * @param options\r\n     * @param {boolean} options.disableFocus - when set to {@code false} will\r\n     * not invite Jicofo into the room. This is intended to be used only by\r\n     * qhsense-meet-spot.\r\n     */\r\n    constructor(connection, jid, password, XMPP, options) {\r\n        super();\r\n        this.xmpp = XMPP;\r\n        this.connection = connection;\r\n        this.roomjid = Strophe.getBareJidFromJid(jid);\r\n        this.myroomjid = jid;\r\n        this.password = password;\r\n        logger.info(`Joined MUC as ${this.myroomjid}`);\r\n        this.members = {};\r\n        this.presMap = {};\r\n        this.presHandlers = {};\r\n        this.joined = false;\r\n        this.role = null;\r\n        this.focusMucJid = null;\r\n        this.noBridgeAvailable = false;\r\n        this.options = options || {};\r\n        this.moderator\r\n            = new Moderator(this.roomjid, this.xmpp, this.eventEmitter, {\r\n                connection: this.xmpp.options,\r\n                conference: this.options\r\n            });\r\n        this.initPresenceMap(options);\r\n        this.lastPresences = {};\r\n        this.phoneNumber = null;\r\n        this.phonePin = null;\r\n        this.connectionTimes = {};\r\n        this.participantPropertyListener = null;\r\n\r\n        this.locked = false;\r\n        this.transcriptionStatus = QHSenseTranscriptionStatus.OFF;\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     *\r\n     */\r\n    initPresenceMap(options = {}) {\r\n        this.presMap.to = this.myroomjid;\r\n        this.presMap.xns = 'http://jabber.org/protocol/muc';\r\n        this.presMap.nodes = [];\r\n\r\n        if (options.enableStatsID) {\r\n            this.presMap.nodes.push({\r\n                'tagName': 'stats-id',\r\n                'value': Settings.callStatsUserName\r\n            });\r\n        }\r\n\r\n        // We need to broadcast 'videomuted' status from the beginning, cause\r\n        // Jicofo makes decisions based on that. Initialize it with 'false'\r\n        // here.\r\n        this.addVideoInfoToPresence(false);\r\n\r\n        if (options.deploymentInfo && options.deploymentInfo.userRegion) {\r\n            this.presMap.nodes.push({\r\n                'tagName': 'region',\r\n                'attributes': {\r\n                    id: options.deploymentInfo.userRegion,\r\n                    xmlns: 'http://jitsi.org/jitsi-meet'\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Joins the chat room.\r\n     * @param password\r\n     * @returns {Promise} - resolved when join completes. At the time of this\r\n     * writing it's never rejected.\r\n     */\r\n    join(password) {\r\n        this.password = password;\r\n\r\n        return new Promise(resolve => {\r\n            this.options.disableFocus\r\n                && logger.info('Conference focus disabled');\r\n\r\n            const preJoin\r\n                = this.options.disableFocus\r\n                    ? Promise.resolve()\r\n                    : this.moderator.allocateConferenceFocus();\r\n\r\n            preJoin.then(() => {\r\n                this.sendPresence(true);\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param fromJoin\r\n     */\r\n    sendPresence(fromJoin) {\r\n        const to = this.presMap.to;\r\n\r\n        if (!to || (!this.joined && !fromJoin)) {\r\n            // Too early to send presence - not initialized\r\n            return;\r\n        }\r\n\r\n        const pres = $pres({ to });\r\n\r\n        // xep-0045 defines: \"including in the initial presence stanza an empty\r\n        // <x/> element qualified by the 'http://jabber.org/protocol/muc'\r\n        // namespace\" and subsequent presences should not include that or it can\r\n        // be considered as joining, and server can send us the message history\r\n        // for the room on every presence\r\n        if (fromJoin) {\r\n            pres.c('x', { xmlns: this.presMap.xns });\r\n\r\n            if (this.password) {\r\n                pres.c('password').t(this.password).up();\r\n            }\r\n            pres.up();\r\n        }\r\n\r\n        parser.json2packet(this.presMap.nodes, pres);\r\n        this.connection.send(pres);\r\n        if (fromJoin) {\r\n            // XXX We're pressed for time here because we're beginning a complex\r\n            // and/or lengthy conference-establishment process which supposedly\r\n            // involves multiple RTTs. We don't have the time to wait for\r\n            // Strophe to decide to send our IQ.\r\n            this.connection.flush();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends the presence unavailable, signaling the server\r\n     * we want to leave the room.\r\n     */\r\n    doLeave() {\r\n        logger.log('do leave', this.myroomjid);\r\n        const pres = $pres({ to: this.myroomjid,\r\n            type: 'unavailable' });\r\n\r\n        this.presMap.length = 0;\r\n\r\n        // XXX Strophe is asynchronously sending by default. Unfortunately, that\r\n        // means that there may not be enough time to send the unavailable\r\n        // presence. Switching Strophe to synchronous sending is not much of an\r\n        // option because it may lead to a noticeable delay in navigating away\r\n        // from the current location. As a compromise, we will try to increase\r\n        // the chances of sending the unavailable presence within the short time\r\n        // span that we have upon unloading by invoking flush() on the\r\n        // connection. We flush() once before sending/queuing the unavailable\r\n        // presence in order to attemtp to have the unavailable presence at the\r\n        // top of the send queue. We flush() once more after sending/queuing the\r\n        // unavailable presence in order to attempt to have it sent as soon as\r\n        // possible.\r\n        this.connection.flush();\r\n        this.connection.send(pres);\r\n        this.connection.flush();\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    discoRoomInfo() {\r\n        // https://xmpp.org/extensions/xep-0045.html#disco-roominfo\r\n\r\n        const getInfo\r\n            = $iq({\r\n                type: 'get',\r\n                to: this.roomjid\r\n            })\r\n                .c('query', { xmlns: Strophe.NS.DISCO_INFO });\r\n\r\n        this.connection.sendIQ(getInfo, result => {\r\n            const locked\r\n                = $(result).find('>query>feature[var=\"muc_passwordprotected\"]')\r\n                    .length\r\n                    === 1;\r\n\r\n            if (locked !== this.locked) {\r\n                this.eventEmitter.emit(XMPPEvents.MUC_LOCK_CHANGED, locked);\r\n                this.locked = locked;\r\n            }\r\n        }, error => {\r\n            GlobalOnErrorHandler.callErrorHandler(error);\r\n            logger.error('Error getting room info: ', error);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    createNonAnonymousRoom() {\r\n        // http://xmpp.org/extensions/xep-0045.html#createroom-reserved\r\n\r\n        const getForm = $iq({ type: 'get',\r\n            to: this.roomjid })\r\n            .c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' })\r\n            .c('x', { xmlns: 'jabber:x:data',\r\n                type: 'submit' });\r\n\r\n        const self = this;\r\n\r\n        this.connection.sendIQ(getForm, form => {\r\n            if (!$(form).find(\r\n                    '>query>x[xmlns=\"jabber:x:data\"]'\r\n                    + '>field[var=\"muc#roomconfig_whois\"]').length) {\r\n                const errmsg = 'non-anonymous rooms not supported';\r\n\r\n                GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\r\n                logger.error(errmsg);\r\n\r\n                return;\r\n            }\r\n\r\n            const formSubmit = $iq({ to: self.roomjid,\r\n                type: 'set' })\r\n                .c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' });\r\n\r\n            formSubmit.c('x', { xmlns: 'jabber:x:data',\r\n                type: 'submit' });\r\n\r\n            formSubmit.c('field', { 'var': 'FORM_TYPE' })\r\n                .c('value')\r\n                .t('http://jabber.org/protocol/muc#roomconfig').up().up();\r\n\r\n            formSubmit.c('field', { 'var': 'muc#roomconfig_whois' })\r\n                .c('value').t('anyone').up().up();\r\n\r\n            self.connection.sendIQ(formSubmit);\r\n\r\n        }, error => {\r\n            GlobalOnErrorHandler.callErrorHandler(error);\r\n            logger.error('Error getting room configuration form: ', error);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param pres\r\n     */\r\n    onPresence(pres) {\r\n        const from = pres.getAttribute('from');\r\n        const member = {};\r\n        const statusEl = pres.getElementsByTagName('status')[0];\r\n\r\n        if (statusEl) {\r\n            member.status = statusEl.textContent || '';\r\n        }\r\n        let hasStatusUpdate = false;\r\n        const xElement\r\n            = pres.getElementsByTagNameNS(\r\n                'http://jabber.org/protocol/muc#user', 'x')[0];\r\n        const mucUserItem\r\n            = xElement && xElement.getElementsByTagName('item')[0];\r\n\r\n        member.affiliation\r\n            = mucUserItem && mucUserItem.getAttribute('affiliation');\r\n        member.role = mucUserItem && mucUserItem.getAttribute('role');\r\n\r\n        // Focus recognition\r\n        const jid = mucUserItem && mucUserItem.getAttribute('jid');\r\n\r\n        member.jid = jid;\r\n        member.isFocus\r\n            = jid && jid.indexOf(`${this.moderator.getFocusUserJid()}/`) === 0;\r\n        member.isHiddenDomain\r\n            = jid && jid.indexOf('@') > 0\r\n                && this.options.hiddenDomain\r\n                    === jid.substring(jid.indexOf('@') + 1, jid.indexOf('/'));\r\n\r\n        this.eventEmitter.emit(XMPPEvents.PRESENCE_RECEIVED, {\r\n            fromHiddenDomain: member.isHiddenDomain,\r\n            presence: pres\r\n        });\r\n\r\n        const xEl = pres.querySelector('x');\r\n\r\n        if (xEl) {\r\n            xEl.remove();\r\n        }\r\n\r\n        const nodes = [];\r\n\r\n        parser.packet2JSON(pres, nodes);\r\n        this.lastPresences[from] = nodes;\r\n\r\n        // process nodes to extract data needed for MUC_JOINED and\r\n        // MUC_MEMBER_JOINED events\r\n        const extractIdentityInformation = node => {\r\n            const identity = {};\r\n            const userInfo = node.children.find(c => c.tagName === 'user');\r\n\r\n            if (userInfo) {\r\n                identity.user = {};\r\n                for (const tag of [ 'id', 'name', 'avatar' ]) {\r\n                    const child\r\n                        = userInfo.children.find(c => c.tagName === tag);\r\n\r\n                    if (child) {\r\n                        identity.user[tag] = child.value;\r\n                    }\r\n                }\r\n            }\r\n            const groupInfo = node.children.find(c => c.tagName === 'group');\r\n\r\n            if (groupInfo) {\r\n                identity.group = groupInfo.value;\r\n            }\r\n\r\n            return identity;\r\n        };\r\n\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n\r\n            switch (node.tagName) {\r\n            case 'bot': {\r\n                const { attributes } = node;\r\n\r\n                if (!attributes) {\r\n                    break;\r\n                }\r\n                const { type } = attributes;\r\n\r\n                member.botType = type;\r\n                break;\r\n            }\r\n            case 'nick':\r\n                member.nick = node.value;\r\n                break;\r\n            case 'userId':\r\n                member.id = node.value;\r\n                break;\r\n            case 'stats-id':\r\n                member.statsID = node.value;\r\n                break;\r\n            case 'identity':\r\n                member.identity = extractIdentityInformation(node);\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (from === this.myroomjid) {\r\n            const newRole\r\n                = member.affiliation === 'owner' ? member.role : 'none';\r\n\r\n            if (this.role !== newRole) {\r\n                this.role = newRole;\r\n                this.eventEmitter.emit(\r\n                    XMPPEvents.LOCAL_ROLE_CHANGED,\r\n                    this.role);\r\n            }\r\n            if (!this.joined) {\r\n                this.joined = true;\r\n                const now = this.connectionTimes['muc.joined']\r\n                    = window.performance.now();\r\n\r\n                logger.log('(TIME) MUC joined:\\t', now);\r\n\r\n                // set correct initial state of locked\r\n                if (this.password) {\r\n                    this.locked = true;\r\n                }\r\n\r\n                // Re-send presence in case any presence updates were added,\r\n                // but blocked from sending, during the join process.\r\n                this.sendPresence();\r\n\r\n                this.eventEmitter.emit(XMPPEvents.MUC_JOINED);\r\n            }\r\n        } else if (this.members[from] === undefined) {\r\n            // new participant\r\n            this.members[from] = member;\r\n            logger.log('entered', from, member);\r\n            hasStatusUpdate = member.status !== undefined;\r\n            if (member.isFocus) {\r\n                this._initFocus(from, jid);\r\n            } else {\r\n                // identity is being added to member joined, so external\r\n                // services can be notified for that (currently identity is\r\n                // not used inside library)\r\n                this.eventEmitter.emit(\r\n                    XMPPEvents.MUC_MEMBER_JOINED,\r\n                    from,\r\n                    member.nick,\r\n                    member.role,\r\n                    member.isHiddenDomain,\r\n                    member.statsID,\r\n                    member.status,\r\n                    member.identity,\r\n                    member.botType);\r\n\r\n                // we are reporting the status with the join\r\n                // so we do not want a second event about status update\r\n                hasStatusUpdate = false;\r\n            }\r\n        } else {\r\n            // Presence update for existing participant\r\n            // Watch role change:\r\n            const memberOfThis = this.members[from];\r\n\r\n            if (memberOfThis.role !== member.role) {\r\n                memberOfThis.role = member.role;\r\n                this.eventEmitter.emit(\r\n                    XMPPEvents.MUC_ROLE_CHANGED, from, member.role);\r\n            }\r\n\r\n            // fire event that botType had changed\r\n            if (memberOfThis.botType !== member.botType) {\r\n                memberOfThis.botType = member.botType;\r\n                this.eventEmitter.emit(\r\n                    XMPPEvents.MUC_MEMBER_BOT_TYPE_CHANGED,\r\n                    from,\r\n                    member.botType);\r\n            }\r\n\r\n            if (member.isFocus) {\r\n                // From time to time first few presences of the focus are not\r\n                // containing it's jid. That way we can mark later the focus\r\n                // member instead of not marking it at all and not starting the\r\n                // conference.\r\n                // FIXME: Maybe there is a better way to handle this issue. It\r\n                // seems there is some period of time in prosody that the\r\n                // configuration form is received but not applied. And if any\r\n                // participant joins during that period of time the first\r\n                // presence from the focus won't contain\r\n                // <item jid=\"focus...\" />.\r\n                memberOfThis.isFocus = true;\r\n                this._initFocus(from, jid);\r\n            }\r\n\r\n            // store the new display name\r\n            if (member.displayName) {\r\n                memberOfThis.displayName = member.displayName;\r\n            }\r\n\r\n            // update stored status message to be able to detect changes\r\n            if (memberOfThis.status !== member.status) {\r\n                hasStatusUpdate = true;\r\n                memberOfThis.status = member.status;\r\n            }\r\n        }\r\n\r\n        // after we had fired member or room joined events, lets fire events\r\n        // for the rest info we got in presence\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n\r\n            switch (node.tagName) {\r\n            case 'nick':\r\n                if (!member.isFocus) {\r\n                    const displayName\r\n                        = this.xmpp.options.displayJids\r\n                            ? Strophe.getResourceFromJid(from)\r\n                            : member.nick;\r\n\r\n                    this.eventEmitter.emit(\r\n                        XMPPEvents.DISPLAY_NAME_CHANGED,\r\n                        from,\r\n                        displayName);\r\n                }\r\n                break;\r\n            case 'bridgeNotAvailable':\r\n                if (member.isFocus && !this.noBridgeAvailable) {\r\n                    this.noBridgeAvailable = true;\r\n                    this.eventEmitter.emit(XMPPEvents.BRIDGE_DOWN);\r\n                }\r\n                break;\r\n            case 'conference-properties':\r\n                if (member.isFocus) {\r\n                    const properties = {};\r\n\r\n                    for (let j = 0; j < node.children.length; j++) {\r\n                        const { attributes } = node.children[j];\r\n\r\n                        if (attributes && attributes.key) {\r\n                            properties[attributes.key] = attributes.value;\r\n                        }\r\n                    }\r\n\r\n                    this.eventEmitter.emit(\r\n                        XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, properties);\r\n                }\r\n                break;\r\n            case 'transcription-status': {\r\n                const { attributes } = node;\r\n\r\n                if (!attributes) {\r\n                    break;\r\n                }\r\n\r\n                const { status } = attributes;\r\n\r\n                if (status && status !== this.transcriptionStatus) {\r\n                    this.transcriptionStatus = status;\r\n                    this.eventEmitter.emit(\r\n                        XMPPEvents.TRANSCRIPTION_STATUS_CHANGED,\r\n                        status\r\n                    );\r\n                }\r\n\r\n\r\n                break;\r\n            }\r\n            case 'call-control': {\r\n                const att = node.attributes;\r\n\r\n                if (!att) {\r\n                    break;\r\n                }\r\n                this.phoneNumber = att.phone || null;\r\n                this.phonePin = att.pin || null;\r\n                this.eventEmitter.emit(XMPPEvents.PHONE_NUMBER_CHANGED);\r\n                break;\r\n            }\r\n            default:\r\n                this.processNode(node, from);\r\n            }\r\n        }\r\n\r\n        // Trigger status message update if necessary\r\n        if (hasStatusUpdate) {\r\n            this.eventEmitter.emit(\r\n                XMPPEvents.PRESENCE_STATUS,\r\n                from,\r\n                member.status);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize some properties when the focus participant is verified.\r\n     * @param from jid of the focus\r\n     * @param mucJid the jid of the focus in the muc\r\n     */\r\n    _initFocus(from, mucJid) {\r\n        this.focusMucJid = from;\r\n\r\n        logger.info(`Ignore focus: ${from}, real JID: ${mucJid}`);\r\n    }\r\n\r\n    /**\r\n     * Sets the special listener to be used for \"command\"s whose name starts\r\n     * with \"qhsense_participant_\".\r\n     */\r\n    setParticipantPropertyListener(listener) {\r\n        this.participantPropertyListener = listener;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param node\r\n     * @param from\r\n     */\r\n    processNode(node, from) {\r\n        // make sure we catch all errors coming from any handler\r\n        // otherwise we can remove the presence handler from strophe\r\n        try {\r\n            let tagHandlers = this.presHandlers[node.tagName];\r\n\r\n            if (node.tagName.startsWith('qhsense_participant_')) {\r\n                tagHandlers = [ this.participantPropertyListener ];\r\n            }\r\n\r\n            if (tagHandlers) {\r\n                tagHandlers.forEach(handler => {\r\n                    handler(node, Strophe.getResourceFromJid(from), from);\r\n                });\r\n            }\r\n        } catch (e) {\r\n            GlobalOnErrorHandler.callErrorHandler(e);\r\n            logger.error(`Error processing:${node.tagName} node.`, e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message to the other participants in the conference\r\n     * @param message\r\n     * @param elementName\r\n     * @param nickname\r\n     */\r\n    sendMessage(message, elementName, nickname) {\r\n        const msg = $msg({ to: this.roomjid,\r\n            type: 'groupchat' });\r\n\r\n        // We are adding the message in a packet extension. If this element\r\n        // is different from 'body', we add a custom namespace.\r\n        // e.g. for 'json-message' extension of message stanza.\r\n        if (elementName === 'body') {\r\n            msg.c(elementName, message).up();\r\n        } else {\r\n            msg.c(elementName, { xmlns: 'http://jitsi.org/jitmeet' }, message)\r\n                .up();\r\n        }\r\n        if (nickname) {\r\n            msg.c('nick', { xmlns: 'http://jabber.org/protocol/nick' })\r\n                .t(nickname)\r\n                .up()\r\n                .up();\r\n        }\r\n        this.connection.send(msg);\r\n        this.eventEmitter.emit(XMPPEvents.SENDING_CHAT_MESSAGE, message);\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n    /**\r\n     * Send private text message to another participant of the conference\r\n     * @param id id/muc resource of the receiver\r\n     * @param message\r\n     * @param elementName\r\n     * @param nickname\r\n     */\r\n    sendPrivateMessage(id, message, elementName, nickname) {\r\n        const msg = $msg({ to: `${this.roomjid}/${id}`,\r\n            type: 'chat' });\r\n\r\n        // We are adding the message in packet. If this element is different\r\n        // from 'body', we add our custom namespace for the same.\r\n        // e.g. for 'json-message' message extension.\r\n        if (elementName === 'body') {\r\n            msg.c(elementName, message).up();\r\n        } else {\r\n            msg.c(elementName, { xmlns: 'http://jitsi.org/jitmeet' }, message)\r\n                .up();\r\n        }\r\n        if (nickname) {\r\n            msg.c('nick', { xmlns: 'http://jabber.org/protocol/nick' })\r\n                .t(nickname)\r\n                .up()\r\n                .up();\r\n        }\r\n\r\n        this.connection.send(msg);\r\n        this.eventEmitter.emit(\r\n            XMPPEvents.SENDING_PRIVATE_CHAT_MESSAGE, message);\r\n    }\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     *\r\n     * @param subject\r\n     */\r\n    setSubject(subject) {\r\n        const msg = $msg({ to: this.roomjid,\r\n            type: 'groupchat' });\r\n\r\n        msg.c('subject', subject);\r\n        this.connection.send(msg);\r\n    }\r\n\r\n    /**\r\n     * Called when participant leaves.\r\n     * @param jid the jid of the participant that leaves\r\n     * @param skipEvents optional params to skip any events, including check\r\n     * whether this is the focus that left\r\n     */\r\n    onParticipantLeft(jid, skipEvents) {\r\n        delete this.lastPresences[jid];\r\n\r\n        if (skipEvents) {\r\n            return;\r\n        }\r\n\r\n        this.eventEmitter.emit(XMPPEvents.MUC_MEMBER_LEFT, jid);\r\n\r\n        this.moderator.onMucMemberLeft(jid);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param pres\r\n     * @param from\r\n     */\r\n    onPresenceUnavailable(pres, from) {\r\n        // ignore presence\r\n        if ($(pres).find('>ignore[xmlns=\"http://jitsi.org/jitmeet/\"]').length) {\r\n            return true;\r\n        }\r\n\r\n        // room destroyed ?\r\n        if ($(pres).find('>x[xmlns=\"http://jabber.org/protocol/muc#user\"]'\r\n            + '>destroy').length) {\r\n            let reason;\r\n            const reasonSelect\r\n                = $(pres).find(\r\n                    '>x[xmlns=\"http://jabber.org/protocol/muc#user\"]'\r\n                        + '>destroy>reason');\r\n\r\n            if (reasonSelect.length) {\r\n                reason = reasonSelect.text();\r\n            }\r\n\r\n            this.eventEmitter.emit(XMPPEvents.MUC_DESTROYED, reason);\r\n            this.connection.emuc.doLeave(this.roomjid);\r\n\r\n            return true;\r\n        }\r\n\r\n        // Status code 110 indicates that this notification is \"self-presence\".\r\n        const isSelfPresence\r\n            = $(pres)\r\n                .find(\r\n                    '>x[xmlns=\"http://jabber.org/protocol/muc#user\"]>'\r\n                        + 'status[code=\"110\"]')\r\n                .length;\r\n        const isKick\r\n            = $(pres)\r\n                .find(\r\n                    '>x[xmlns=\"http://jabber.org/protocol/muc#user\"]'\r\n                        + '>status[code=\"307\"]')\r\n                .length;\r\n        const membersKeys = Object.keys(this.members);\r\n\r\n        if (isKick) {\r\n            const actorSelect\r\n                = $(pres)\r\n                .find('>x[xmlns=\"http://jabber.org/protocol/muc#user\"]>item>actor');\r\n\r\n            let actorNick;\r\n\r\n            if (actorSelect.length) {\r\n                actorNick = actorSelect.attr('nick');\r\n            }\r\n\r\n            // if no member is found this is the case we had kicked someone\r\n            // and we are not in the list of members\r\n            if (membersKeys.find(jid => Strophe.getResourceFromJid(jid) === actorNick)) {\r\n                // we first fire the kicked so we can show the participant\r\n                // who kicked, before notifying that participant left\r\n                // we fire kicked for us and for any participant kicked\r\n                this.eventEmitter.emit(\r\n                    XMPPEvents.KICKED,\r\n                    isSelfPresence,\r\n                    actorNick,\r\n                    Strophe.getResourceFromJid(from));\r\n            }\r\n        }\r\n\r\n        if (!isSelfPresence) {\r\n            delete this.members[from];\r\n            this.onParticipantLeft(from, false);\r\n        } else if (membersKeys.length > 0) {\r\n            // If the status code is 110 this means we're leaving and we would\r\n            // like to remove everyone else from our view, so we trigger the\r\n            // event.\r\n            membersKeys.forEach(jid => {\r\n                const member = this.members[jid];\r\n\r\n                delete this.members[jid];\r\n                this.onParticipantLeft(jid, member.isFocus);\r\n            });\r\n            this.connection.emuc.doLeave(this.roomjid);\r\n\r\n            // we fire muc_left only if this is not a kick,\r\n            // kick has both statuses 110 and 307.\r\n            if (!isKick) {\r\n                this.eventEmitter.emit(XMPPEvents.MUC_LEFT);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param msg\r\n     * @param from\r\n     */\r\n    onMessage(msg, from) {\r\n        const nick\r\n            = $(msg).find('>nick[xmlns=\"http://jabber.org/protocol/nick\"]')\r\n                .text()\r\n            || Strophe.getResourceFromJid(from);\r\n\r\n        const txt = $(msg).find('>body').text();\r\n        const type = msg.getAttribute('type');\r\n\r\n        if (type === 'error') {\r\n            this.eventEmitter.emit(XMPPEvents.CHAT_ERROR_RECEIVED,\r\n                $(msg).find('>text').text(), txt);\r\n\r\n            return true;\r\n        }\r\n\r\n        const subject = $(msg).find('>subject');\r\n\r\n        if (subject.length) {\r\n            const subjectText = subject.text();\r\n\r\n            if (subjectText || subjectText === '') {\r\n                this.eventEmitter.emit(XMPPEvents.SUBJECT_CHANGED, subjectText);\r\n                logger.log(`Subject is changed to ${subjectText}`);\r\n            }\r\n        }\r\n\r\n        // xep-0203 delay\r\n        let stamp = $(msg).find('>delay').attr('stamp');\r\n\r\n        if (!stamp) {\r\n            // or xep-0091 delay, UTC timestamp\r\n            stamp = $(msg).find('>[xmlns=\"jabber:x:delay\"]').attr('stamp');\r\n\r\n            if (stamp) {\r\n                // the format is CCYYMMDDThh:mm:ss\r\n                const dateParts\r\n                    = stamp.match(/(\\d{4})(\\d{2})(\\d{2}T\\d{2}:\\d{2}:\\d{2})/);\r\n\r\n                stamp = `${dateParts[1]}-${dateParts[2]}-${dateParts[3]}Z`;\r\n            }\r\n        }\r\n\r\n        if (from === this.roomjid\r\n                && $(msg)\r\n                    .find(\r\n                        '>x[xmlns=\"http://jabber.org/protocol/muc#user\"]'\r\n                            + '>status[code=\"104\"]')\r\n                    .length) {\r\n            this.discoRoomInfo();\r\n        }\r\n        const jsonMessage = $(msg).find('>json-message').text();\r\n        const parsedJson = this.xmpp.tryParseJSONAndVerify(jsonMessage);\r\n\r\n        // We emit this event if the message is a valid json, and is not\r\n        // delivered after a delay, i.e. stamp is undefined.\r\n        // e.g. - subtitles should not be displayed if delayed.\r\n        if (parsedJson && stamp === undefined) {\r\n            this.eventEmitter.emit(XMPPEvents.JSON_MESSAGE_RECEIVED,\r\n                from, parsedJson);\r\n\r\n            return;\r\n        }\r\n\r\n        if (txt) {\r\n            if (type === 'chat') {\r\n                this.eventEmitter.emit(XMPPEvents.PRIVATE_MESSAGE_RECEIVED,\r\n                        from, nick, txt, this.myroomjid, stamp);\r\n            } else if (type === 'groupchat') {\r\n                this.eventEmitter.emit(XMPPEvents.MESSAGE_RECEIVED,\r\n                        from, nick, txt, this.myroomjid, stamp);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param pres\r\n     * @param from\r\n     */\r\n    onPresenceError(pres, from) {\r\n        if ($(pres)\r\n                .find(\r\n                    '>error[type=\"auth\"]'\r\n                        + '>not-authorized['\r\n                        + 'xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\"]')\r\n                .length) {\r\n            logger.log('on password required', from);\r\n            this.eventEmitter.emit(XMPPEvents.PASSWORD_REQUIRED);\r\n        } else if ($(pres)\r\n                .find(\r\n                    '>error[type=\"cancel\"]'\r\n                        + '>not-allowed['\r\n                        + 'xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\"]')\r\n                .length) {\r\n            const toDomain = Strophe.getDomainFromJid(pres.getAttribute('to'));\r\n\r\n            if (toDomain === this.xmpp.options.hosts.anonymousdomain) {\r\n                // enter the room by replying with 'not-authorized'. This would\r\n                // result in reconnection from authorized domain.\r\n                // We're either missing Jicofo/Prosody config for anonymous\r\n                // domains or something is wrong.\r\n                this.eventEmitter.emit(XMPPEvents.ROOM_JOIN_ERROR);\r\n\r\n            } else {\r\n                logger.warn('onPresError ', pres);\r\n                this.eventEmitter.emit(\r\n                    XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR);\r\n            }\r\n        } else if ($(pres).find('>error>service-unavailable').length) {\r\n            logger.warn('Maximum users limit for the room has been reached',\r\n                pres);\r\n            this.eventEmitter.emit(XMPPEvents.ROOM_MAX_USERS_ERROR);\r\n        } else {\r\n            logger.warn('onPresError ', pres);\r\n            this.eventEmitter.emit(XMPPEvents.ROOM_CONNECT_ERROR);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param jid\r\n     */\r\n    kick(jid) {\r\n        const kickIQ = $iq({ to: this.roomjid,\r\n            type: 'set' })\r\n            .c('query', { xmlns: 'http://jabber.org/protocol/muc#admin' })\r\n            .c('item', { nick: Strophe.getResourceFromJid(jid),\r\n                role: 'none' })\r\n            .c('reason').t('You have been kicked.').up().up().up();\r\n\r\n        this.connection.sendIQ(\r\n            kickIQ,\r\n            result => logger.log('Kick participant with jid: ', jid, result),\r\n            error => logger.log('Kick participant error: ', error));\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n\r\n    /**\r\n     *\r\n     * @param key\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @param onNotSupported\r\n     */\r\n    lockRoom(key, onSuccess, onError, onNotSupported) {\r\n        // http://xmpp.org/extensions/xep-0045.html#roomconfig\r\n        this.connection.sendIQ(\r\n            $iq({\r\n                to: this.roomjid,\r\n                type: 'get'\r\n            })\r\n                .c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' }),\r\n            res => {\r\n                if ($(res)\r\n                        .find(\r\n                            '>query>x[xmlns=\"jabber:x:data\"]'\r\n                                + '>field[var=\"muc#roomconfig_roomsecret\"]')\r\n                        .length) {\r\n                    const formsubmit\r\n                        = $iq({\r\n                            to: this.roomjid,\r\n                            type: 'set'\r\n                        })\r\n                            .c('query', {\r\n                                xmlns: 'http://jabber.org/protocol/muc#owner'\r\n                            });\r\n\r\n                    formsubmit.c('x', {\r\n                        xmlns: 'jabber:x:data',\r\n                        type: 'submit'\r\n                    });\r\n                    formsubmit\r\n                        .c('field', { 'var': 'FORM_TYPE' })\r\n                        .c('value')\r\n                        .t('http://jabber.org/protocol/muc#roomconfig')\r\n                        .up()\r\n                        .up();\r\n                    formsubmit\r\n                        .c('field', { 'var': 'muc#roomconfig_roomsecret' })\r\n                        .c('value')\r\n                        .t(key)\r\n                        .up()\r\n                        .up();\r\n\r\n                    // Fixes a bug in prosody 0.9.+\r\n                    // https://prosody.im/issues/issue/373\r\n                    formsubmit\r\n                        .c('field', { 'var': 'muc#roomconfig_whois' })\r\n                        .c('value')\r\n                        .t('anyone')\r\n                        .up()\r\n                        .up();\r\n\r\n                    // FIXME: is muc#roomconfig_passwordprotectedroom required?\r\n                    this.connection.sendIQ(formsubmit, onSuccess, onError);\r\n                } else {\r\n                    onNotSupported();\r\n                }\r\n            },\r\n            onError);\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     *\r\n     * @param key\r\n     * @param values\r\n     */\r\n    addToPresence(key, values) {\r\n        values.tagName = key;\r\n        this.removeFromPresence(key);\r\n        this.presMap.nodes.push(values);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param key\r\n     */\r\n    removeFromPresence(key) {\r\n        const nodes = this.presMap.nodes.filter(node => key !== node.tagName);\r\n\r\n        this.presMap.nodes = nodes;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param name\r\n     * @param handler\r\n     */\r\n    addPresenceListener(name, handler) {\r\n        if (typeof handler !== 'function') {\r\n            throw new Error('\"handler\" is not a function');\r\n        }\r\n        let tagHandlers = this.presHandlers[name];\r\n\r\n        if (!tagHandlers) {\r\n            this.presHandlers[name] = tagHandlers = [];\r\n        }\r\n        if (tagHandlers.indexOf(handler) === -1) {\r\n            tagHandlers.push(handler);\r\n        } else {\r\n            logger.warn(\r\n                `Trying to add the same handler more than once for: ${name}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param name\r\n     * @param handler\r\n     */\r\n    removePresenceListener(name, handler) {\r\n        const tagHandlers = this.presHandlers[name];\r\n        const handlerIdx = tagHandlers ? tagHandlers.indexOf(handler) : -1;\r\n\r\n        // eslint-disable-next-line no-negated-condition\r\n        if (handlerIdx !== -1) {\r\n            tagHandlers.splice(handlerIdx, 1);\r\n        } else {\r\n            logger.warn(`Handler for: ${name} was not registered`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the user identified by given <tt>mucJid</tt> is the conference\r\n     * focus.\r\n     * @param mucJid the full MUC address of the user to be checked.\r\n     * @returns {boolean|null} <tt>true</tt> if MUC user is the conference focus\r\n     * or <tt>false</tt> if is not. When given <tt>mucJid</tt> does not exist in\r\n     * the MUC then <tt>null</tt> is returned.\r\n     */\r\n    isFocus(mucJid) {\r\n        const member = this.members[mucJid];\r\n\r\n        if (member) {\r\n            return member.isFocus;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    isModerator() {\r\n        return this.role === 'moderator';\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param peerJid\r\n     */\r\n    getMemberRole(peerJid) {\r\n        if (this.members[peerJid]) {\r\n            return this.members[peerJid].role;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param mute\r\n     * @param callback\r\n     */\r\n    setVideoMute(mute, callback) {\r\n        this.sendVideoInfoPresence(mute);\r\n        if (callback) {\r\n            callback(mute);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param mute\r\n     * @param callback\r\n     */\r\n    setAudioMute(mute, callback) {\r\n        return this.sendAudioInfoPresence(mute, callback);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param mute\r\n     */\r\n    addAudioInfoToPresence(mute) {\r\n        this.removeFromPresence('audiomuted');\r\n        this.addToPresence(\r\n            'audiomuted',\r\n            {\r\n                attributes: { 'xmlns': 'http://jitsi.org/jitmeet/audio' },\r\n                value: mute.toString()\r\n            });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param mute\r\n     * @param callback\r\n     */\r\n    sendAudioInfoPresence(mute, callback) {\r\n        this.addAudioInfoToPresence(mute);\r\n        if (this.connection) {\r\n            this.sendPresence();\r\n        }\r\n        if (callback) {\r\n            callback();\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param mute\r\n     */\r\n    addVideoInfoToPresence(mute) {\r\n        this.removeFromPresence('videomuted');\r\n        this.addToPresence(\r\n            'videomuted',\r\n            {\r\n                attributes: { 'xmlns': 'http://jitsi.org/jitmeet/video' },\r\n                value: mute.toString()\r\n            });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param mute\r\n     */\r\n    sendVideoInfoPresence(mute) {\r\n        this.addVideoInfoToPresence(mute);\r\n        if (!this.connection) {\r\n            return;\r\n        }\r\n        this.sendPresence();\r\n    }\r\n\r\n    /**\r\n     * Obtains the info about given media advertised in the MUC presence of\r\n     * the participant identified by the given endpoint JID.\r\n     * @param {string} endpointId the endpoint ID mapped to the participant\r\n     * which corresponds to MUC nickname.\r\n     * @param {MediaType} mediaType the type of the media for which presence\r\n     * info will be obtained.\r\n     * @return {PeerMediaInfo} presenceInfo an object with media presence\r\n     * info or <tt>null</tt> either if there is no presence available or if\r\n     * the media type given is invalid.\r\n     */\r\n    getMediaPresenceInfo(endpointId, mediaType) {\r\n        // Will figure out current muted status by looking up owner's presence\r\n        const pres = this.lastPresences[`${this.roomjid}/${endpointId}`];\r\n\r\n        if (!pres) {\r\n            // No presence available\r\n            return null;\r\n        }\r\n        const data = {\r\n            muted: false, // unmuted by default\r\n            videoType: undefined // no video type by default\r\n        };\r\n        let mutedNode = null;\r\n\r\n        if (mediaType === MediaType.AUDIO) {\r\n            mutedNode = filterNodeFromPresenceJSON(pres, 'audiomuted');\r\n        } else if (mediaType === MediaType.VIDEO) {\r\n            mutedNode = filterNodeFromPresenceJSON(pres, 'videomuted');\r\n            const videoTypeNode = filterNodeFromPresenceJSON(pres, 'videoType');\r\n\r\n            if (videoTypeNode.length > 0) {\r\n                data.videoType = videoTypeNode[0].value;\r\n            }\r\n        } else {\r\n            logger.error(`Unsupported media type: ${mediaType}`);\r\n\r\n            return null;\r\n        }\r\n\r\n        data.muted = mutedNode.length > 0 && mutedNode[0].value === 'true';\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the SIP calls are supported and false otherwise\r\n     */\r\n    isSIPCallingSupported() {\r\n        if (this.moderator) {\r\n            return this.moderator.isSipGatewayEnabled();\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Dials a number.\r\n     * @param number the number\r\n     */\r\n    dial(number) {\r\n        return this.connection.rayo.dial(number, 'fromnumber',\r\n            Strophe.getBareJidFromJid(this.myroomjid), this.password,\r\n            this.focusMucJid);\r\n    }\r\n\r\n    /**\r\n     * Hangup an existing call\r\n     */\r\n    hangup() {\r\n        return this.connection.rayo.hangup();\r\n    }\r\n\r\n    /**\r\n     * Returns the phone number for joining the conference.\r\n     */\r\n    getPhoneNumber() {\r\n        return this.phoneNumber;\r\n    }\r\n\r\n    /**\r\n     * Returns the pin for joining the conference with phone.\r\n     */\r\n    getPhonePin() {\r\n        return this.phonePin;\r\n    }\r\n\r\n    /**\r\n     * Mutes remote participant.\r\n     * @param jid of the participant\r\n     * @param mute\r\n     */\r\n    muteParticipant(jid, mute) {\r\n        logger.info('set mute', mute);\r\n        const iqToFocus = $iq(\r\n            { to: this.focusMucJid,\r\n                type: 'set' })\r\n            .c('mute', {\r\n                xmlns: 'http://jitsi.org/jitmeet/audio',\r\n                jid\r\n            })\r\n            .t(mute.toString())\r\n            .up();\r\n\r\n        this.connection.sendIQ(\r\n            iqToFocus,\r\n            result => logger.log('set mute', result),\r\n            error => logger.log('set mute error', error));\r\n    }\r\n\r\n    /**\r\n     * TODO: Document\r\n     * @param iq\r\n     */\r\n    onMute(iq) {\r\n        const from = iq.getAttribute('from');\r\n\r\n        if (from !== this.focusMucJid) {\r\n            logger.warn('Ignored mute from non focus peer');\r\n\r\n            return;\r\n        }\r\n        const mute = $(iq).find('mute');\r\n\r\n        if (mute.length && mute.text() === 'true') {\r\n            this.eventEmitter.emit(XMPPEvents.AUDIO_MUTED_BY_FOCUS, mute.attr('actor'));\r\n        } else {\r\n            // XXX Why do we support anything but muting? Why do we encode the\r\n            // value in the text of the element? Why do we use a separate XML\r\n            // namespace?\r\n            logger.warn('Ignoring a mute request which does not explicitly '\r\n                + 'specify a positive mute command.');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Leaves the room. Closes the jingle session.\r\n     * @returns {Promise} which is resolved if XMPPEvents.MUC_LEFT is received\r\n     * less than 5s after sending presence unavailable. Otherwise the promise is\r\n     * rejected.\r\n     */\r\n    leave() {\r\n        return new Promise((resolve, reject) => {\r\n            const timeout = setTimeout(() => onMucLeft(true), 5000);\r\n            const eventEmitter = this.eventEmitter;\r\n\r\n            /**\r\n             *\r\n             * @param doReject\r\n             */\r\n            function onMucLeft(doReject = false) {\r\n                eventEmitter.removeListener(XMPPEvents.MUC_LEFT, onMucLeft);\r\n                clearTimeout(timeout);\r\n                if (doReject) {\r\n                    // the timeout expired\r\n                    reject(new Error('The timeout for the confirmation about '\r\n                        + 'leaving the room expired.'));\r\n                } else {\r\n                    resolve();\r\n                }\r\n            }\r\n            eventEmitter.on(XMPPEvents.MUC_LEFT, onMucLeft);\r\n            this.doLeave();\r\n        });\r\n    }\r\n}\r\n\r\n/* eslint-enable newline-per-chained-call */\r\n","/* global $, Promise */\r\n\r\nconst logger = require('qhsense-meet-logger').getLogger(__filename);\r\n\r\nimport { $iq, Strophe } from 'strophe.js';\r\n\r\nconst XMPPEvents = require('../../service/xmpp/XMPPEvents');\r\nconst AuthenticationEvents\r\n    = require('../../service/authentication/AuthenticationEvents');\r\nconst GlobalOnErrorHandler = require('../util/GlobalOnErrorHandler');\r\n\r\nimport browser from '../browser';\r\nimport Settings from '../settings/Settings';\r\n\r\n/**\r\n *\r\n * @param step\r\n */\r\nfunction createExpBackoffTimer(step) {\r\n    let count = 1;\r\n\r\n    return function(reset) {\r\n        // Reset call\r\n        if (reset) {\r\n            count = 1;\r\n\r\n            return;\r\n        }\r\n\r\n        // Calculate next timeout\r\n        const timeout = Math.pow(2, count - 1);\r\n\r\n        count += 1;\r\n\r\n        return timeout * step;\r\n    };\r\n}\r\n\r\n/* eslint-disable max-params */\r\n\r\n/**\r\n *\r\n * @param roomName\r\n * @param xmpp\r\n * @param emitter\r\n * @param options\r\n */\r\nexport default function Moderator(roomName, xmpp, emitter, options) {\r\n    this.roomName = roomName;\r\n    this.xmppService = xmpp;\r\n    this.getNextTimeout = createExpBackoffTimer(1000);\r\n    this.getNextErrorTimeout = createExpBackoffTimer(1000);\r\n\r\n    // External authentication stuff\r\n    this.externalAuthEnabled = false;\r\n    this.options = options;\r\n\r\n    // Sip gateway can be enabled by configuring Jigasi host in config.js or\r\n    // it will be enabled automatically if focus detects the component through\r\n    // service discovery.\r\n    this.sipGatewayEnabled\r\n        = this.options.connection.hosts\r\n            && this.options.connection.hosts.call_control !== undefined;\r\n\r\n    this.eventEmitter = emitter;\r\n\r\n    this.connection = this.xmppService.connection;\r\n\r\n    // FIXME: Message listener that talks to POPUP window\r\n    /**\r\n     *\r\n     * @param event\r\n     */\r\n    function listener(event) {\r\n        if (event.data && event.data.sessionId) {\r\n            if (event.origin !== window.location.origin) {\r\n                logger.warn(\r\n                    `Ignoring sessionId from different origin: ${\r\n                        event.origin}`);\r\n\r\n                return;\r\n            }\r\n            Settings.sessionId = event.data.sessionId;\r\n\r\n            // After popup is closed we will authenticate\r\n        }\r\n    }\r\n\r\n    // Register\r\n    if (window.addEventListener) {\r\n        window.addEventListener('message', listener, false);\r\n    } else {\r\n        window.attachEvent('onmessage', listener);\r\n    }\r\n}\r\n\r\n/* eslint-enable max-params */\r\n\r\nModerator.prototype.isExternalAuthEnabled = function() {\r\n    return this.externalAuthEnabled;\r\n};\r\n\r\nModerator.prototype.isSipGatewayEnabled = function() {\r\n    return this.sipGatewayEnabled;\r\n};\r\n\r\nModerator.prototype.onMucMemberLeft = function(jid) {\r\n    logger.info(`Someone left is it focus ? ${jid}`);\r\n    const resource = Strophe.getResourceFromJid(jid);\r\n\r\n    if (resource === 'focus') {\r\n        logger.info(\r\n            'Focus has left the room - leaving conference');\r\n        this.eventEmitter.emit(XMPPEvents.FOCUS_LEFT);\r\n    }\r\n};\r\n\r\nModerator.prototype.setFocusUserJid = function(focusJid) {\r\n    if (!this.focusUserJid) {\r\n        this.focusUserJid = focusJid;\r\n        logger.info(`Focus jid set to:  ${this.focusUserJid}`);\r\n    }\r\n};\r\n\r\nModerator.prototype.getFocusUserJid = function() {\r\n    return this.focusUserJid;\r\n};\r\n\r\nModerator.prototype.getFocusComponent = function() {\r\n    // Get focus component address\r\n    let focusComponent = this.options.connection.hosts.focus;\r\n\r\n    // If not specified use default:  'focus.domain'\r\n\r\n    if (!focusComponent) {\r\n        focusComponent = `focus.${this.options.connection.hosts.domain}`;\r\n    }\r\n\r\n    return focusComponent;\r\n};\r\n\r\nModerator.prototype.createConferenceIq = function() {\r\n    // Generate create conference IQ\r\n    const elem = $iq({ to: this.getFocusComponent(),\r\n        type: 'set' });\r\n\r\n    // Session Id used for authentication\r\n    const { sessionId } = Settings;\r\n    const machineUID = Settings.machineId;\r\n    const config = this.options.conference;\r\n\r\n    logger.info(`Session ID: ${sessionId} machine UID: ${machineUID}`);\r\n\r\n    elem.c('conference', {\r\n        xmlns: 'http://jitsi.org/protocol/focus',\r\n        room: this.roomName,\r\n        'machine-uid': machineUID\r\n    });\r\n\r\n    if (sessionId) {\r\n        elem.attrs({ 'session-id': sessionId });\r\n    }\r\n    if (this.options.connection.enforcedBridge !== undefined) {\r\n        elem.c(\r\n            'property', {\r\n                name: 'enforcedBridge',\r\n                value: this.options.connection.enforcedBridge\r\n            }).up();\r\n    }\r\n\r\n    // Tell the focus we have Jigasi configured\r\n    if (this.options.connection.hosts !== undefined\r\n        && this.options.connection.hosts.call_control !== undefined) {\r\n        elem.c(\r\n            'property', {\r\n                name: 'call_control',\r\n                value: this.options.connection.hosts.call_control\r\n            }).up();\r\n    }\r\n    if (config.channelLastN !== undefined) {\r\n        elem.c(\r\n            'property', {\r\n                name: 'channelLastN',\r\n                value: config.channelLastN\r\n            }).up();\r\n    }\r\n    elem.c(\r\n        'property', {\r\n            name: 'disableRtx',\r\n            value: Boolean(config.disableRtx)\r\n        }).up();\r\n\r\n    if (config.enableTcc !== undefined) {\r\n        elem.c(\r\n                'property', {\r\n                    name: 'enableTcc',\r\n                    value: Boolean(config.enableTcc)\r\n                }).up();\r\n    }\r\n    if (config.enableRemb !== undefined) {\r\n        elem.c(\r\n                'property', {\r\n                    name: 'enableRemb',\r\n                    value: Boolean(config.enableRemb)\r\n                }).up();\r\n    }\r\n    if (config.minParticipants !== undefined) {\r\n        elem.c(\r\n                'property', {\r\n                    name: 'minParticipants',\r\n                    value: config.minParticipants\r\n                }).up();\r\n    }\r\n\r\n    elem.c(\r\n        'property', {\r\n            name: 'enableLipSync',\r\n            value: this.options.connection.enableLipSync !== false\r\n        }).up();\r\n    if (config.audioPacketDelay !== undefined) {\r\n        elem.c(\r\n            'property', {\r\n                name: 'audioPacketDelay',\r\n                value: config.audioPacketDelay\r\n            }).up();\r\n    }\r\n    if (config.startBitrate) {\r\n        elem.c(\r\n            'property', {\r\n                name: 'startBitrate',\r\n                value: config.startBitrate\r\n            }).up();\r\n    }\r\n    if (config.minBitrate) {\r\n        elem.c(\r\n            'property', {\r\n                name: 'minBitrate',\r\n                value: config.minBitrate\r\n            }).up();\r\n    }\r\n    if (config.testing && config.testing.octo\r\n        && typeof config.testing.octo.probability === 'number') {\r\n        if (Math.random() < config.testing.octo.probability) {\r\n            elem.c(\r\n                'property', {\r\n                    name: 'octo',\r\n                    value: true\r\n                }).up();\r\n        }\r\n    }\r\n\r\n    let openSctp;\r\n\r\n    switch (this.options.conference.openBridgeChannel) {\r\n    case 'datachannel':\r\n    case true:\r\n    case undefined:\r\n        openSctp = true;\r\n        break;\r\n    case 'websocket':\r\n        openSctp = false;\r\n        break;\r\n    }\r\n\r\n    if (openSctp && !browser.supportsDataChannels()) {\r\n        openSctp = false;\r\n    }\r\n\r\n    elem.c(\r\n        'property', {\r\n            name: 'openSctp',\r\n            value: openSctp\r\n        }).up();\r\n\r\n    if (this.options.conference.startAudioMuted !== undefined) {\r\n        elem.c(\r\n            'property', {\r\n                name: 'startAudioMuted',\r\n                value: this.options.conference.startAudioMuted\r\n            }).up();\r\n    }\r\n    if (this.options.conference.startVideoMuted !== undefined) {\r\n        elem.c(\r\n            'property', {\r\n                name: 'startVideoMuted',\r\n                value: this.options.conference.startVideoMuted\r\n            }).up();\r\n    }\r\n    if (this.options.conference.stereo !== undefined) {\r\n        elem.c(\r\n            'property', {\r\n                name: 'stereo',\r\n                value: this.options.conference.stereo\r\n            }).up();\r\n    }\r\n    if (this.options.conference.useRoomAsSharedDocumentName !== undefined) {\r\n        elem.c(\r\n            'property', {\r\n                name: 'useRoomAsSharedDocumentName',\r\n                value: this.options.conference.useRoomAsSharedDocumentName\r\n            }).up();\r\n    }\r\n    elem.up();\r\n\r\n    return elem;\r\n};\r\n\r\n\r\nModerator.prototype.parseSessionId = function(resultIq) {\r\n    // eslint-disable-next-line newline-per-chained-call\r\n    const sessionId = $(resultIq).find('conference').attr('session-id');\r\n\r\n    if (sessionId) {\r\n        logger.info(`Received sessionId:  ${sessionId}`);\r\n        Settings.sessionId = sessionId;\r\n    }\r\n};\r\n\r\nModerator.prototype.parseConfigOptions = function(resultIq) {\r\n    // eslint-disable-next-line newline-per-chained-call\r\n    this.setFocusUserJid($(resultIq).find('conference').attr('focusjid'));\r\n\r\n    const authenticationEnabled\r\n        = $(resultIq).find(\r\n            '>conference>property'\r\n            + '[name=\\'authentication\\'][value=\\'true\\']').length > 0;\r\n\r\n    logger.info(`Authentication enabled: ${authenticationEnabled}`);\r\n\r\n    this.externalAuthEnabled = $(resultIq).find(\r\n        '>conference>property'\r\n            + '[name=\\'externalAuth\\'][value=\\'true\\']').length > 0;\r\n\r\n    logger.info(\r\n        `External authentication enabled: ${this.externalAuthEnabled}`);\r\n\r\n    if (!this.externalAuthEnabled) {\r\n        // We expect to receive sessionId in 'internal' authentication mode\r\n        this.parseSessionId(resultIq);\r\n    }\r\n\r\n    // eslint-disable-next-line newline-per-chained-call\r\n    const authIdentity = $(resultIq).find('>conference').attr('identity');\r\n\r\n    this.eventEmitter.emit(AuthenticationEvents.IDENTITY_UPDATED,\r\n        authenticationEnabled, authIdentity);\r\n\r\n    // Check if focus has auto-detected Jigasi component(this will be also\r\n    // included if we have passed our host from the config)\r\n    if ($(resultIq).find(\r\n        '>conference>property'\r\n        + '[name=\\'sipGatewayEnabled\\'][value=\\'true\\']').length) {\r\n        this.sipGatewayEnabled = true;\r\n    }\r\n\r\n    logger.info(`Sip gateway enabled:  ${this.sipGatewayEnabled}`);\r\n};\r\n\r\n// FIXME We need to show the fact that we're waiting for the focus to the user\r\n// (or that the focus is not available)\r\n/**\r\n * Allocates the conference focus.\r\n *\r\n * @param {Function} callback - the function to be called back upon the\r\n * successful allocation of the conference focus\r\n * @returns {Promise} - Resolved when Jicofo allows to join the room. It's never\r\n * rejected and it'll keep on pinging Jicofo forever.\r\n */\r\nModerator.prototype.allocateConferenceFocus = function() {\r\n    return new Promise(resolve => {\r\n        // Try to use focus user JID from the config\r\n        this.setFocusUserJid(this.options.connection.focusUserJid);\r\n\r\n        // Send create conference IQ\r\n        this.connection.sendIQ(\r\n            this.createConferenceIq(),\r\n            result => this._allocateConferenceFocusSuccess(result, resolve),\r\n            error => this._allocateConferenceFocusError(error, resolve));\r\n\r\n        // XXX We're pressed for time here because we're beginning a complex\r\n        // and/or lengthy conference-establishment process which supposedly\r\n        // involves multiple RTTs. We don't have the time to wait for Strophe to\r\n        // decide to send our IQ.\r\n        this.connection.flush();\r\n    });\r\n};\r\n\r\n/**\r\n * Invoked by {@link #allocateConferenceFocus} upon its request receiving an\r\n * error result.\r\n *\r\n * @param error - the error result of the request that\r\n * {@link #allocateConferenceFocus} sent\r\n * @param {Function} callback - the function to be called back upon the\r\n * successful allocation of the conference focus\r\n */\r\nModerator.prototype._allocateConferenceFocusError = function(error, callback) {\r\n    // If the session is invalid, remove and try again without session ID to get\r\n    // a new one\r\n    const invalidSession\r\n        = $(error).find('>error>session-invalid').length\r\n            || $(error).find('>error>not-acceptable').length;\r\n\r\n    if (invalidSession) {\r\n        logger.info('Session expired! - removing');\r\n        Settings.sessionId = undefined;\r\n    }\r\n    if ($(error).find('>error>graceful-shutdown').length) {\r\n        this.eventEmitter.emit(XMPPEvents.GRACEFUL_SHUTDOWN);\r\n\r\n        return;\r\n    }\r\n\r\n    // Check for error returned by the reservation system\r\n    const reservationErr = $(error).find('>error>reservation-error');\r\n\r\n    if (reservationErr.length) {\r\n        // Trigger error event\r\n        const errorCode = reservationErr.attr('error-code');\r\n        const errorTextNode = $(error).find('>error>text');\r\n        let errorMsg;\r\n\r\n        if (errorTextNode) {\r\n            errorMsg = errorTextNode.text();\r\n        }\r\n        this.eventEmitter.emit(\r\n            XMPPEvents.RESERVATION_ERROR,\r\n            errorCode,\r\n            errorMsg);\r\n\r\n        return;\r\n    }\r\n\r\n    // Not authorized to create new room\r\n    if ($(error).find('>error>not-authorized').length) {\r\n        logger.warn('Unauthorized to start the conference', error);\r\n        const toDomain = Strophe.getDomainFromJid(error.getAttribute('to'));\r\n\r\n        if (toDomain !== this.options.connection.hosts.anonymousdomain) {\r\n            // FIXME \"is external\" should come either from the focus or\r\n            // config.js\r\n            this.externalAuthEnabled = true;\r\n        }\r\n        this.eventEmitter.emit(XMPPEvents.AUTHENTICATION_REQUIRED);\r\n\r\n        return;\r\n    }\r\n    const waitMs = this.getNextErrorTimeout();\r\n    const errmsg = `Focus error, retry after ${waitMs}`;\r\n\r\n    GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\r\n    logger.error(errmsg, error);\r\n\r\n    // Show message\r\n    const focusComponent = this.getFocusComponent();\r\n    const retrySec = waitMs / 1000;\r\n\r\n    // FIXME: message is duplicated ? Do not show in case of session invalid\r\n    // which means just a retry\r\n\r\n    if (!invalidSession) {\r\n        this.eventEmitter.emit(\r\n            XMPPEvents.FOCUS_DISCONNECTED,\r\n            focusComponent,\r\n            retrySec);\r\n    }\r\n\r\n    // Reset response timeout\r\n    this.getNextTimeout(true);\r\n    window.setTimeout(\r\n        () => this.allocateConferenceFocus().then(callback),\r\n        waitMs);\r\n};\r\n\r\n/**\r\n * Invoked by {@link #allocateConferenceFocus} upon its request receiving a\r\n * success (i.e. non-error) result.\r\n *\r\n * @param result - the success (i.e. non-error) result of the request that\r\n * {@link #allocateConferenceFocus} sent\r\n * @param {Function} callback - the function to be called back upon the\r\n * successful allocation of the conference focus\r\n */\r\nModerator.prototype._allocateConferenceFocusSuccess = function(\r\n        result,\r\n        callback) {\r\n    // Setup config options\r\n    this.parseConfigOptions(result);\r\n\r\n    // Reset the error timeout (because we haven't failed here).\r\n    this.getNextErrorTimeout(true);\r\n\r\n    // eslint-disable-next-line newline-per-chained-call\r\n    if ($(result).find('conference').attr('ready') === 'true') {\r\n        // Reset the non-error timeout (because we've succeeded here).\r\n        this.getNextTimeout(true);\r\n\r\n        // Exec callback\r\n        callback();\r\n    } else {\r\n        const waitMs = this.getNextTimeout();\r\n\r\n        logger.info(`Waiting for the focus... ${waitMs}`);\r\n        window.setTimeout(\r\n            () => this.allocateConferenceFocus().then(callback),\r\n            waitMs);\r\n    }\r\n};\r\n\r\nModerator.prototype.authenticate = function() {\r\n    return new Promise((resolve, reject) => {\r\n        this.connection.sendIQ(\r\n            this.createConferenceIq(),\r\n            result => {\r\n                this.parseSessionId(result);\r\n                resolve();\r\n            },\r\n            errorIq => reject({\r\n                error: $(errorIq).find('iq>error :first')\r\n                    .prop('tagName'),\r\n                message: $(errorIq).find('iq>error>text')\r\n                    .text()\r\n            })\r\n        );\r\n    });\r\n};\r\n\r\nModerator.prototype.getLoginUrl = function(urlCallback, failureCallback) {\r\n    this._getLoginUrl(/* popup */ false, urlCallback, failureCallback);\r\n};\r\n\r\n/**\r\n *\r\n * @param {boolean} popup false for {@link Moderator#getLoginUrl} or true for\r\n * {@link Moderator#getPopupLoginUrl}\r\n * @param urlCb\r\n * @param failureCb\r\n */\r\nModerator.prototype._getLoginUrl = function(popup, urlCb, failureCb) {\r\n    const iq = $iq({ to: this.getFocusComponent(),\r\n        type: 'get' });\r\n    const attrs = {\r\n        xmlns: 'http://jitsi.org/protocol/focus',\r\n        room: this.roomName,\r\n        'machine-uid': Settings.machineId\r\n    };\r\n    let str = 'auth url'; // for logger\r\n\r\n    if (popup) {\r\n        attrs.popup = true;\r\n        str = `POPUP ${str}`;\r\n    }\r\n    iq.c('login-url', attrs);\r\n\r\n    /**\r\n     * Implements a failure callback which reports an error message and an error\r\n     * through (1) GlobalOnErrorHandler, (2) logger, and (3) failureCb.\r\n     *\r\n     * @param {string} errmsg the error messsage to report\r\n     * @param {*} error the error to report (in addition to errmsg)\r\n     */\r\n    function reportError(errmsg, err) {\r\n        GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\r\n        logger.error(errmsg, err);\r\n        failureCb(err);\r\n    }\r\n    this.connection.sendIQ(\r\n        iq,\r\n        result => {\r\n            // eslint-disable-next-line newline-per-chained-call\r\n            let url = $(result).find('login-url').attr('url');\r\n\r\n            url = decodeURIComponent(url);\r\n            if (url) {\r\n                logger.info(`Got ${str}: ${url}`);\r\n                urlCb(url);\r\n            } else {\r\n                reportError(`Failed to get ${str} from the focus`, result);\r\n            }\r\n        },\r\n        reportError.bind(undefined, `Get ${str} error`)\r\n    );\r\n};\r\n\r\nModerator.prototype.getPopupLoginUrl = function(urlCallback, failureCallback) {\r\n    this._getLoginUrl(/* popup */ true, urlCallback, failureCallback);\r\n};\r\n\r\nModerator.prototype.logout = function(callback) {\r\n    const iq = $iq({ to: this.getFocusComponent(),\r\n        type: 'set' });\r\n    const { sessionId } = Settings;\r\n\r\n    if (!sessionId) {\r\n        callback();\r\n\r\n        return;\r\n    }\r\n    iq.c('logout', {\r\n        xmlns: 'http://jitsi.org/protocol/focus',\r\n        'session-id': sessionId\r\n    });\r\n    this.connection.sendIQ(\r\n        iq,\r\n        result => {\r\n            // eslint-disable-next-line newline-per-chained-call\r\n            let logoutUrl = $(result).find('logout').attr('logout-url');\r\n\r\n            if (logoutUrl) {\r\n                logoutUrl = decodeURIComponent(logoutUrl);\r\n            }\r\n            logger.info(`Log out OK, url: ${logoutUrl}`, result);\r\n            Settings.sessionId = undefined;\r\n            callback(logoutUrl);\r\n        },\r\n        error => {\r\n            const errmsg = 'Logout error';\r\n\r\n            GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\r\n            logger.error(errmsg, error);\r\n        }\r\n    );\r\n};\r\n","/* global $, __filename */\r\n\r\nimport {\r\n    ACTION_JINGLE_TR_RECEIVED,\r\n    ACTION_JINGLE_TR_SUCCESS,\r\n    createJingleEvent\r\n} from '../../service/statistics/AnalyticsEvents';\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport { $iq, Strophe } from 'strophe.js';\r\n\r\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\r\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\r\nimport RandomUtil from '../util/RandomUtil';\r\nimport Statistics from '../statistics/statistics';\r\n\r\nimport JingleSessionPC from './JingleSessionPC';\r\nimport ConnectionPlugin from './ConnectionPlugin';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n// XXX Strophe is build around the idea of chaining function calls so allow long\r\n// function call chains.\r\n/* eslint-disable newline-per-chained-call */\r\n\r\n/**\r\n *\r\n */\r\nclass JingleConnectionPlugin extends ConnectionPlugin {\r\n    /**\r\n     * Creates new <tt>JingleConnectionPlugin</tt>\r\n     * @param {XMPP} xmpp\r\n     * @param {EventEmitter} eventEmitter\r\n     * @param {Object} iceConfig an object that holds the iceConfig to be passed\r\n     * to the p2p and the jvb <tt>PeerConnection</tt>.\r\n     */\r\n    constructor(xmpp, eventEmitter, iceConfig) {\r\n        super();\r\n        this.xmpp = xmpp;\r\n        this.eventEmitter = eventEmitter;\r\n        this.sessions = {};\r\n        this.jvbIceConfig = iceConfig.jvb;\r\n        this.p2pIceConfig = iceConfig.p2p;\r\n        this.mediaConstraints = {\r\n            offerToReceiveAudio: true,\r\n            offerToReceiveVideo: true\r\n        };\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param connection\r\n     */\r\n    init(connection) {\r\n        super.init(connection);\r\n        this.connection.addHandler(this.onJingle.bind(this),\r\n            'urn:xmpp:jingle:1', 'iq', 'set', null, null);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param iq\r\n     */\r\n    onJingle(iq) {\r\n        const sid = $(iq).find('jingle').attr('sid');\r\n        const action = $(iq).find('jingle').attr('action');\r\n        const fromJid = iq.getAttribute('from');\r\n\r\n        // send ack first\r\n        const ack = $iq({ type: 'result',\r\n            to: fromJid,\r\n            id: iq.getAttribute('id')\r\n        });\r\n\r\n        logger.log(`on jingle ${action} from ${fromJid}`, iq);\r\n        let sess = this.sessions[sid];\r\n\r\n        if (action !== 'session-initiate') {\r\n            if (!sess) {\r\n                ack.attrs({ type: 'error' });\r\n                ack.c('error', { type: 'cancel' })\r\n                    .c('item-not-found', {\r\n                        xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'\r\n                    })\r\n                    .up()\r\n                    .c('unknown-session', {\r\n                        xmlns: 'urn:xmpp:jingle:errors:1'\r\n                    });\r\n                logger.warn('invalid session id', iq);\r\n                this.connection.send(ack);\r\n\r\n                return true;\r\n            }\r\n\r\n            // local jid is not checked\r\n            if (fromJid !== sess.remoteJid) {\r\n                logger.warn(\r\n                    'jid mismatch for session id', sid, sess.remoteJid, iq);\r\n                ack.attrs({ type: 'error' });\r\n                ack.c('error', { type: 'cancel' })\r\n                    .c('item-not-found', {\r\n                        xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'\r\n                    })\r\n                    .up()\r\n                    .c('unknown-session', {\r\n                        xmlns: 'urn:xmpp:jingle:errors:1'\r\n                    });\r\n                this.connection.send(ack);\r\n\r\n                return true;\r\n            }\r\n        } else if (sess !== undefined) {\r\n            // Existing session with same session id. This might be out-of-order\r\n            // if the sess.remoteJid is the same as from.\r\n            ack.attrs({ type: 'error' });\r\n            ack.c('error', { type: 'cancel' })\r\n                .c('service-unavailable', {\r\n                    xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'\r\n                })\r\n                .up();\r\n            logger.warn('duplicate session id', sid, iq);\r\n            this.connection.send(ack);\r\n\r\n            return true;\r\n        }\r\n        const now = window.performance.now();\r\n\r\n        // FIXME that should work most of the time, but we'd have to\r\n        // think how secure it is to assume that user with \"focus\"\r\n        // nickname is Jicofo.\r\n        const isP2P = Strophe.getResourceFromJid(fromJid) !== 'focus';\r\n\r\n        // see http://xmpp.org/extensions/xep-0166.html#concepts-session\r\n\r\n        switch (action) {\r\n        case 'session-initiate': {\r\n            logger.log('(TIME) received session-initiate:\\t', now);\r\n            const startMuted = $(iq).find('jingle>startmuted');\r\n\r\n            if (startMuted && startMuted.length > 0) {\r\n                const audioMuted = startMuted.attr('audio');\r\n                const videoMuted = startMuted.attr('video');\r\n\r\n                this.eventEmitter.emit(\r\n                    XMPPEvents.START_MUTED_FROM_FOCUS,\r\n                    audioMuted === 'true',\r\n                    videoMuted === 'true');\r\n            }\r\n\r\n            logger.info(\r\n                `Marking session from ${fromJid\r\n                } as ${isP2P ? '' : '*not*'} P2P`);\r\n            sess\r\n                = new JingleSessionPC(\r\n                    $(iq).find('jingle').attr('sid'),\r\n                    $(iq).attr('to'),\r\n                    fromJid,\r\n                    this.connection,\r\n                    this.mediaConstraints,\r\n                    isP2P ? this.p2pIceConfig : this.jvbIceConfig,\r\n                    isP2P,\r\n                    /* initiator */ false);\r\n\r\n            this.sessions[sess.sid] = sess;\r\n\r\n            this.eventEmitter.emit(XMPPEvents.CALL_INCOMING,\r\n                sess, $(iq).find('>jingle'), now);\r\n            break;\r\n        }\r\n        case 'session-accept': {\r\n            this.eventEmitter.emit(\r\n                XMPPEvents.CALL_ACCEPTED, sess, $(iq).find('>jingle'));\r\n            break;\r\n        }\r\n        case 'content-modify': {\r\n            sess.modifyContents($(iq).find('>jingle'));\r\n            break;\r\n        }\r\n        case 'transport-info': {\r\n            this.eventEmitter.emit(\r\n                XMPPEvents.TRANSPORT_INFO, sess, $(iq).find('>jingle'));\r\n            break;\r\n        }\r\n        case 'session-terminate': {\r\n            logger.log('terminating...', sess.sid);\r\n            let reasonCondition = null;\r\n            let reasonText = null;\r\n\r\n            if ($(iq).find('>jingle>reason').length) {\r\n                reasonCondition\r\n                    = $(iq).find('>jingle>reason>:first')[0].tagName;\r\n                reasonText = $(iq).find('>jingle>reason>text').text();\r\n            }\r\n            this.terminate(sess.sid, reasonCondition, reasonText);\r\n            this.eventEmitter.emit(XMPPEvents.CALL_ENDED,\r\n                sess, reasonCondition, reasonText);\r\n            break;\r\n        }\r\n        case 'transport-replace':\r\n            logger.info('(TIME) Start transport replace', now);\r\n            Statistics.sendAnalytics(createJingleEvent(\r\n                ACTION_JINGLE_TR_RECEIVED,\r\n                {\r\n                    p2p: isP2P,\r\n                    value: now\r\n                }));\r\n\r\n            sess.replaceTransport($(iq).find('>jingle'), () => {\r\n                const successTime = window.performance.now();\r\n\r\n                logger.info('(TIME) Transport replace success!', successTime);\r\n                Statistics.sendAnalytics(createJingleEvent(\r\n                    ACTION_JINGLE_TR_SUCCESS,\r\n                    {\r\n                        p2p: isP2P,\r\n                        value: successTime\r\n                    }));\r\n            }, error => {\r\n                GlobalOnErrorHandler.callErrorHandler(error);\r\n                logger.error('Transport replace failed', error);\r\n                sess.sendTransportReject();\r\n            });\r\n            break;\r\n        case 'addsource': // FIXME: proprietary, un-jingleish\r\n        case 'source-add': // FIXME: proprietary\r\n            sess.addRemoteStream($(iq).find('>jingle>content'));\r\n            break;\r\n        case 'removesource': // FIXME: proprietary, un-jingleish\r\n        case 'source-remove': // FIXME: proprietary\r\n            sess.removeRemoteStream($(iq).find('>jingle>content'));\r\n            break;\r\n        default:\r\n            logger.warn('jingle action not implemented', action);\r\n            ack.attrs({ type: 'error' });\r\n            ack.c('error', { type: 'cancel' })\r\n                .c('bad-request',\r\n                    { xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas' })\r\n                .up();\r\n            break;\r\n        }\r\n        this.connection.send(ack);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates new <tt>JingleSessionPC</tt> meant to be used in a direct P2P\r\n     * connection, configured as 'initiator'.\r\n     * @param {string} me our JID\r\n     * @param {string} peer remote participant's JID\r\n     * @return {JingleSessionPC}\r\n     */\r\n    newP2PJingleSession(me, peer) {\r\n        const sess\r\n            = new JingleSessionPC(\r\n                RandomUtil.randomHexString(12),\r\n                me,\r\n                peer,\r\n                this.connection,\r\n                this.mediaConstraints,\r\n                this.p2pIceConfig,\r\n                /* P2P */ true,\r\n                /* initiator */ true);\r\n\r\n        this.sessions[sess.sid] = sess;\r\n\r\n        return sess;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param sid\r\n     * @param reasonCondition\r\n     * @param reasonText\r\n     */\r\n    terminate(sid, reasonCondition, reasonText) {\r\n        if (this.sessions.hasOwnProperty(sid)) {\r\n            if (this.sessions[sid].state !== 'ended') {\r\n                this.sessions[sid].onTerminated(reasonCondition, reasonText);\r\n            }\r\n            delete this.sessions[sid];\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    getStunAndTurnCredentials() {\r\n        // get stun and turn configuration from server via xep-0215\r\n        // uses time-limited credentials as described in\r\n        // http://tools.ietf.org/html/draft-uberti-behave-turn-rest-00\r\n        //\r\n        // See https://modules.prosody.im/mod_turncredentials.html\r\n        // for a prosody module which implements this.\r\n        //\r\n        // Currently, this doesn't work with updateIce and therefore credentials\r\n        // with a long validity have to be fetched before creating the\r\n        // peerconnection.\r\n        // TODO: implement refresh via updateIce as described in\r\n        //      https://code.google.com/p/webrtc/issues/detail?id=1650\r\n        this.connection.sendIQ(\r\n            $iq({ type: 'get',\r\n                to: this.connection.domain })\r\n                .c('services', { xmlns: 'urn:xmpp:extdisco:1' }),\r\n            res => {\r\n                const iceservers = [];\r\n\r\n                $(res).find('>services>service').each((idx, el) => {\r\n                    // eslint-disable-next-line no-param-reassign\r\n                    el = $(el);\r\n                    const dict = {};\r\n                    const type = el.attr('type');\r\n\r\n                    switch (type) {\r\n                    case 'stun':\r\n                        dict.url = `stun:${el.attr('host')}`;\r\n                        if (el.attr('port')) {\r\n                            dict.url += `:${el.attr('port')}`;\r\n                        }\r\n                        iceservers.push(dict);\r\n                        break;\r\n                    case 'turn':\r\n                    case 'turns': {\r\n                        dict.url = `${type}:`;\r\n                        const username = el.attr('username');\r\n\r\n                        // https://code.google.com/p/webrtc/issues/detail\r\n                        // ?id=1508\r\n\r\n                        if (username) {\r\n                            const match\r\n                                = navigator.userAgent.match(\r\n                                    /Chrom(e|ium)\\/([0-9]+)\\./);\r\n\r\n                            if (match && parseInt(match[2], 10) < 28) {\r\n                                dict.url += `${username}@`;\r\n                            } else {\r\n                                // only works in M28\r\n                                dict.username = username;\r\n                            }\r\n                        }\r\n                        dict.url += el.attr('host');\r\n                        const port = el.attr('port');\r\n\r\n                        if (port) {\r\n                            dict.url += `:${el.attr('port')}`;\r\n                        }\r\n                        const transport = el.attr('transport');\r\n\r\n                        if (transport && transport !== 'udp') {\r\n                            dict.url += `?transport=${transport}`;\r\n                        }\r\n\r\n                        dict.credential = el.attr('password')\r\n                                || dict.credential;\r\n                        iceservers.push(dict);\r\n                        break;\r\n                    }\r\n                    }\r\n                });\r\n\r\n                const options = this.xmpp.options;\r\n\r\n                if (options.useStunTurn) {\r\n                    // we want to filter and leave only tcp/turns candidates\r\n                    // which make sense for the jvb connections\r\n                    this.jvbIceConfig.iceServers\r\n                        = iceservers.filter(s => s.url.startsWith('turns'));\r\n                }\r\n\r\n                if (options.p2p && options.p2p.useStunTurn) {\r\n                    this.p2pIceConfig.iceServers = iceservers;\r\n                }\r\n\r\n            }, err => {\r\n                logger.warn('getting turn credentials failed', err);\r\n                logger.warn('is mod_turncredentials or similar installed?');\r\n            });\r\n\r\n        // implement push?\r\n    }\r\n\r\n    /**\r\n     * Returns the data saved in 'updateLog' in a format to be logged.\r\n     */\r\n    getLog() {\r\n        const data = {};\r\n\r\n        Object.keys(this.sessions).forEach(sid => {\r\n            const session = this.sessions[sid];\r\n            const pc = session.peerconnection;\r\n\r\n            if (pc && pc.updateLog) {\r\n                // FIXME: should probably be a .dump call\r\n                data[`jingle_${sid}`] = {\r\n                    updateLog: pc.updateLog,\r\n                    stats: pc.stats,\r\n                    url: window.location.href\r\n                };\r\n            }\r\n        });\r\n\r\n        return data;\r\n    }\r\n}\r\n\r\n/* eslint-enable newline-per-chained-call */\r\n\r\n/**\r\n *\r\n * @param XMPP\r\n * @param eventEmitter\r\n * @param iceConfig\r\n */\r\nexport default function initJingle(XMPP, eventEmitter, iceConfig) {\r\n    Strophe.addConnectionPlugin(\r\n        'jingle',\r\n        new JingleConnectionPlugin(XMPP, eventEmitter, iceConfig));\r\n}\r\n","/**\r\n * Implements a simple hash code for a string (see\r\n * https://en.wikipedia.org/wiki/Java_hashCode()).\r\n *\r\n * @param {string} The string to return a hash of.\r\n * @return {Number} the integer hash code of the string.\r\n */\r\nfunction integerHash(string) {\r\n    if (!string) {\r\n        return 0;\r\n    }\r\n\r\n    let char, hash = 0, i;\r\n\r\n    for (i = 0; i < string.length; i++) {\r\n        char = string.charCodeAt(i);\r\n        hash += char * Math.pow(31, string.length - 1 - i);\r\n        hash = Math.abs(hash | 0); // eslint-disable-line no-bitwise\r\n    }\r\n\r\n    return hash;\r\n}\r\n\r\nmodule.exports = { integerHash };\r\n","/* global __filename */\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport * as JingleSessionState from './JingleSessionState';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * JingleSession provides an API to manage a single Jingle session. We will\r\n * have different implementations depending on the underlying interface used\r\n * (i.e. WebRTC and ORTC) and here we hold the code common to all of them.\r\n */\r\nexport default class JingleSession {\r\n\r\n    /* eslint-disable max-params */\r\n\r\n    /**\r\n     * Creates new <tt>JingleSession</tt>.\r\n     * @param {string} sid the Jingle session identifier\r\n     * @param {string} localJid our JID\r\n     * @param {string} remoteJid the JID of the remote peer\r\n     * @param {Strophe.Connection} connection the XMPP connection\r\n     * @param {Object} mediaConstraints the media constraints object passed to\r\n     * the PeerConnection onCreateAnswer/Offer as defined by the WebRTC.\r\n     * @param {Object} iceConfig the ICE servers config object as defined by\r\n     * the WebRTC. Passed to the PeerConnection's constructor.\r\n     * @param {boolean} isInitiator indicates if it will be the side which\r\n     * initiates the session.\r\n     */\r\n    constructor(\r\n            sid,\r\n            localJid,\r\n            remoteJid,\r\n            connection,\r\n            mediaConstraints,\r\n            iceConfig,\r\n            isInitiator) {\r\n        this.sid = sid;\r\n        this.localJid = localJid;\r\n        this.remoteJid = remoteJid;\r\n        this.connection = connection;\r\n        this.mediaConstraints = mediaConstraints;\r\n        this.iceConfig = iceConfig;\r\n\r\n        /**\r\n         * Indicates whether this instance is an initiator or an answerer of\r\n         * the Jingle session.\r\n         * @type {boolean}\r\n         */\r\n        this.isInitiator = isInitiator;\r\n\r\n        /**\r\n         * Whether to use dripping or not. Dripping is sending trickle\r\n         * candidates not one-by-one.\r\n         */\r\n        this.usedrip = true;\r\n\r\n        /**\r\n         *  When dripping is used, stores ICE candidates which are to be sent.\r\n         */\r\n        this.dripContainer = [];\r\n\r\n        /**\r\n         * The chat room instance associated with the session.\r\n         * @type {ChatRoom}\r\n         */\r\n        this.room = null;\r\n\r\n        /**\r\n         * Jingle session state - uninitialized until {@link initialize} is\r\n         * called @type {JingleSessionState}\r\n         */\r\n        this.state = null;\r\n\r\n        /**\r\n         * The RTC service instance\r\n         * @type {RTC}\r\n         */\r\n        this.rtc = null;\r\n    }\r\n\r\n    /**\r\n     * Returns XMPP address of this session's initiator.\r\n     * @return {string}\r\n     */\r\n    get initiatorJid() {\r\n        return this.isInitiator ? this.localJid : this.remoteJid;\r\n    }\r\n\r\n    /**\r\n     * Returns XMPP address of this session's responder.\r\n     * @return {string}\r\n     */\r\n    get responderJid() {\r\n        return this.isInitiator ? this.remoteJid : this.localJid;\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Prepares this object to initiate a session.\r\n     * @param {ChatRoom} room the chat room for the conference associated with\r\n     * this session\r\n     * @param {RTC} rtc the RTC service instance\r\n     * @param {object} options - the options, see implementing class's\r\n     * {@link #doInitialize} description for more details.\r\n     */\r\n    initialize(room, rtc, options) {\r\n        if (this.state !== null) {\r\n            const errmsg\r\n                = `attempt to initiate on session ${this.sid}\r\n                   in state ${this.state}`;\r\n\r\n            logger.error(errmsg);\r\n            throw new Error(errmsg);\r\n        }\r\n        this.room = room;\r\n        this.rtc = rtc;\r\n        this.state = JingleSessionState.PENDING;\r\n        this.doInitialize(options);\r\n    }\r\n\r\n    /**\r\n     * The implementing class finishes initialization here. Called at the end of\r\n     * {@link initialize}.\r\n     * @param {Object} options - The options specific to the implementing class.\r\n     * @protected\r\n     */\r\n    doInitialize(options) { } // eslint-disable-line no-unused-vars, no-empty-function, max-len\r\n\r\n    /* eslint-disable no-unused-vars, no-empty-function */\r\n\r\n    /**\r\n     * Adds the ICE candidates found in the 'contents' array as remote\r\n     * candidates?\r\n     * Note: currently only used on transport-info\r\n     *\r\n     * @param contents\r\n     */\r\n    addIceCandidates(contents) {}\r\n\r\n    /* eslint-enable no-unused-vars, no-empty-function */\r\n\r\n    /**\r\n     * Returns current state of this <tt>JingleSession</tt> instance.\r\n     * @returns {JingleSessionState} the current state of this session instance.\r\n     */\r\n    getState() {\r\n        return this.state;\r\n    }\r\n\r\n    /* eslint-disable no-unused-vars, no-empty-function */\r\n\r\n    /**\r\n     * Handles an 'add-source' event.\r\n     *\r\n     * @param contents an array of Jingle 'content' elements.\r\n     */\r\n    addSources(contents) {}\r\n\r\n    /**\r\n     * Handles a 'remove-source' event.\r\n     *\r\n     * @param contents an array of Jingle 'content' elements.\r\n     */\r\n    removeSources(contents) {}\r\n\r\n    /**\r\n     * Terminates this Jingle session by sending session-terminate\r\n     * @param success a callback called once the 'session-terminate' packet has\r\n     * been acknowledged with RESULT.\r\n     * @param failure a callback called when either timeout occurs or ERROR\r\n     * response is received.\r\n     * @param {Object} options\r\n     * @param {string} [options.reason] XMPP Jingle error condition\r\n     * @param {string} [options.reasonDescription] some meaningful error message\r\n     * @param {boolean} [options.sendSessionTerminate=true] set to false to skip\r\n     * sending session-terminate. It may not make sense to send it if the XMPP\r\n     * connection has been closed already or if the remote peer has disconnected\r\n     */\r\n    terminate(success, failure, options) {}\r\n\r\n    /**\r\n     * Handles an offer from the remote peer (prepares to accept a session).\r\n     * @param jingle the 'jingle' XML element.\r\n     * @param success callback called when we the incoming session has been\r\n     * accepted\r\n     * @param failure callback called when we fail for any reason, will supply\r\n     * error object with details(which is meant more to be printed to the logger\r\n     * than analysed in the code, as the error is unrecoverable anyway)\r\n     */\r\n    acceptOffer(jingle, success, failure) {}\r\n\r\n    /**\r\n     * Returns the JID of the initiator of the jingle session.\r\n     */\r\n    _getInitiatorJid() {\r\n        return this.isInitiator ? this.localJid : this.remoteJid;\r\n    }\r\n\r\n    /* eslint-enable no-unused-vars, no-empty-function */\r\n}\r\n","/* global __filename */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport * as MediaType from '../../service/RTC/MediaType';\r\nimport * as SignalingEvents from '../../service/RTC/SignalingEvents';\r\nimport SignalingLayer from '../../service/RTC/SignalingLayer';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Default XMPP implementation of the {@link SignalingLayer} interface. Obtains\r\n * the data from the MUC presence.\r\n */\r\nexport default class SignalingLayerImpl extends SignalingLayer {\r\n    /**\r\n     * Creates new instance.\r\n     */\r\n    constructor() {\r\n        super();\r\n\r\n        /**\r\n         * A map that stores SSRCs of remote streams. And is used only locally\r\n         * We store the mapping when jingle is received, and later is used\r\n         * onaddstream webrtc event where we have only the ssrc\r\n         * FIXME: This map got filled and never cleaned and can grow during long\r\n         * conference\r\n         * @type {Map<number, string>} maps SSRC number to jid\r\n         */\r\n        this.ssrcOwners = new Map();\r\n\r\n        /**\r\n         *\r\n         * @type {ChatRoom|null}\r\n         */\r\n        this.chatRoom = null;\r\n    }\r\n\r\n    /**\r\n     * Sets the <tt>ChatRoom</tt> instance used and binds presence listeners.\r\n     * @param {ChatRoom} room\r\n     */\r\n    setChatRoom(room) {\r\n        const oldChatRoom = this.chatRoom;\r\n\r\n        this.chatRoom = room;\r\n        if (oldChatRoom) {\r\n            oldChatRoom.removePresenceListener(\r\n                'audiomuted', this._audioMuteHandler);\r\n            oldChatRoom.removePresenceListener(\r\n                'videomuted', this._videoMuteHandler);\r\n            oldChatRoom.removePresenceListener(\r\n                'videoType', this._videoTypeHandler);\r\n        }\r\n        if (room) {\r\n            // SignalingEvents\r\n            this._audioMuteHandler = (node, from) => {\r\n                this.eventEmitter.emit(\r\n                    SignalingEvents.PEER_MUTED_CHANGED,\r\n                    from, MediaType.AUDIO, node.value === 'true');\r\n            };\r\n            room.addPresenceListener('audiomuted', this._audioMuteHandler);\r\n\r\n            this._videoMuteHandler = (node, from) => {\r\n                this.eventEmitter.emit(\r\n                    SignalingEvents.PEER_MUTED_CHANGED,\r\n                    from, MediaType.VIDEO, node.value === 'true');\r\n            };\r\n            room.addPresenceListener('videomuted', this._videoMuteHandler);\r\n\r\n            this._videoTypeHandler = (node, from) => {\r\n                this.eventEmitter.emit(\r\n                    SignalingEvents.PEER_VIDEO_TYPE_CHANGED,\r\n                    from, node.value);\r\n            };\r\n            room.addPresenceListener('videoType', this._videoTypeHandler);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    getPeerMediaInfo(owner, mediaType) {\r\n        if (this.chatRoom) {\r\n            return this.chatRoom.getMediaPresenceInfo(owner, mediaType);\r\n        }\r\n        logger.error('Requested peer media info, before room was set');\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    getSSRCOwner(ssrc) {\r\n        return this.ssrcOwners.get(ssrc);\r\n    }\r\n\r\n    /**\r\n     * Set an SSRC owner.\r\n     * @param {number} ssrc an SSRC to be owned\r\n     * @param {string} endpointId owner's ID (MUC nickname)\r\n     * @throws TypeError if <tt>ssrc</tt> is not a number\r\n     */\r\n    setSSRCOwner(ssrc, endpointId) {\r\n        if (typeof ssrc !== 'number') {\r\n            throw new TypeError(`SSRC(${ssrc}) must be a number`);\r\n        }\r\n        this.ssrcOwners.set(ssrc, endpointId);\r\n    }\r\n}\r\n","\r\nimport Listenable from '../../modules/util/Listenable';\r\n\r\n/**\r\n * An object that carries the info about specific media type advertised by\r\n * participant in the signaling channel.\r\n * @typedef {Object} PeerMediaInfo\r\n * @property {boolean} muted indicates if the media is currently muted\r\n * @property {VideoType|undefined} videoType the type of the video if applicable\r\n */\r\n\r\n/**\r\n * Interface used to expose the information carried over the signaling channel\r\n * which is not available to the RTC module in the media SDP.\r\n *\r\n * @interface SignalingLayer\r\n */\r\nexport default class SignalingLayer extends Listenable {\r\n\r\n    /**\r\n     * Obtains the endpoint ID for given SSRC.\r\n     * @param {number} ssrc the SSRC number.\r\n     * @return {string|null} the endpoint ID for given media SSRC.\r\n     */\r\n    getSSRCOwner(ssrc) { // eslint-disable-line no-unused-vars\r\n        throw new Error('not implemented');\r\n    }\r\n\r\n    /**\r\n     * Obtains the info about given media advertised in the MUC presence of\r\n     * the participant identified by the given MUC JID.\r\n     * @param {string} owner the MUC jid of the participant for whom\r\n     * {@link PeerMediaInfo} will be obtained.\r\n     * @param {MediaType} mediaType the type of the media for which presence\r\n     * info will be obtained.\r\n     * @return {PeerMediaInfo|null} presenceInfo an object with media presence\r\n     * info or <tt>null</tt> either if there is no presence available for given\r\n     * JID or if the media type given is invalid.\r\n     */\r\n    getPeerMediaInfo(owner, mediaType) { // eslint-disable-line no-unused-vars\r\n        throw new Error('not implemented');\r\n    }\r\n}\r\n","import async from 'async';\r\n\r\n/**\r\n * A queue for async task execution.\r\n */\r\nexport default class AsyncQueue {\r\n    /**\r\n     * Creates new instance.\r\n     */\r\n    constructor() {\r\n        this._queue = async.queue(this._processQueueTasks.bind(this), 1);\r\n        this._stopped = false;\r\n    }\r\n\r\n    /**\r\n     * Removes any pending tasks from the queue.\r\n     */\r\n    clear() {\r\n        this._queue.kill();\r\n    }\r\n\r\n    /**\r\n     * Internal task processing implementation which makes things work.\r\n     */\r\n    _processQueueTasks(task, finishedCallback) {\r\n        task(finishedCallback);\r\n    }\r\n\r\n    /**\r\n     * The 'task' function will be given a callback it MUST call with either:\r\n     *  1) No arguments if it was successful or\r\n     *  2) An error argument if there was an error\r\n     * If the task wants to process the success or failure of the task, it\r\n     * should pass the {@code callback} to the push function, e.g.:\r\n     * queue.push(task, (err) => {\r\n     *     if (err) {\r\n     *         // error handling\r\n     *     } else {\r\n     *         // success handling\r\n     *     }\r\n     * });\r\n     *\r\n     * @param {function} task - The task to be executed. See the description above.\r\n     * @param {function} [callback] - Optional callback to be called after the task has been executed.\r\n     */\r\n    push(task, callback) {\r\n        if (this._stopped) {\r\n            callback && callback(new Error('The queue has been stopped'));\r\n\r\n            return;\r\n        }\r\n        this._queue.push(task, callback);\r\n    }\r\n\r\n    /**\r\n     * Shutdowns the queue. All already queued tasks will execute, but no future tasks can be added. If a task is added\r\n     * after the queue has been shutdown then the callback will be called with an error.\r\n     */\r\n    shutdown() {\r\n        this._stopped = true;\r\n    }\r\n}\r\n","/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n/*jshint onevar: false, indent:4 */\n/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(done) );\n        });\n        function done(err) {\n          if (err) {\n              callback(err);\n              callback = function () {};\n          }\n          else {\n              completed += 1;\n              if (completed >= arr.length) {\n                  callback();\n              }\n          }\n        }\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        if (!callback) {\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err) {\n                    callback(err);\n                });\n            });\n        } else {\n            var results = [];\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err, v) {\n                    results[x.index] = v;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length\n        if (!remainingTasks) {\n            return callback();\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            remainingTasks--\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (!remainingTasks) {\n                var theCallback = callback;\n                // prevent final callback from calling itself if it errors\n                callback = function () {};\n\n                theCallback(null, results);\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var attempts = [];\n        // Use defaults if times not passed\n        if (typeof times === 'function') {\n            callback = task;\n            task = times;\n            times = DEFAULT_TIMES;\n        }\n        // Make sure times is a number\n        times = parseInt(times, 10) || DEFAULT_TIMES;\n        var wrappedTask = function(wrappedCallback, wrappedResults) {\n            var retryAttempt = function(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            };\n            while (times) {\n                attempts.push(retryAttempt(task, !(times-=1)));\n            }\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || callback)(data.err, data.result);\n            });\n        }\n        // If a callback is passed, run this as a controll flow\n        return callback ? wrappedTask() : wrappedTask\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (!_isArray(tasks)) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (_isArray(tasks)) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (_isArray(tasks)) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (test.apply(null, args)) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (!test.apply(null, args)) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length == 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            kill: function () {\n              q.drain = null;\n              q.tasks = [];\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                if (q.paused === true) { return; }\n                q.paused = true;\n                q.process();\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                q.process();\n            }\n        };\n        return q;\n    };\n    \n    async.priorityQueue = function (worker, concurrency) {\n        \n        function _compareTasks(a, b){\n          return a.priority - b.priority;\n        };\n        \n        function _binarySearch(sequence, item, compare) {\n          var beg = -1,\n              end = sequence.length - 1;\n          while (beg < end) {\n            var mid = beg + ((end - beg + 1) >>> 1);\n            if (compare(item, sequence[mid]) >= 0) {\n              beg = mid;\n            } else {\n              end = mid - 1;\n            }\n          }\n          return beg;\n        }\n        \n        function _insert(q, data, priority, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length == 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  priority: priority,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n              \n              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n        \n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n        \n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n          _insert(q, data, priority, callback);\n        };\n        \n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            drained: true,\n            push: function (data, callback) {\n                if (!_isArray(data)) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    cargo.drained = false;\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain && !cargo.drained) cargo.drain();\n                    cargo.drained = true;\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0, tasks.length);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                async.nextTick(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    async.compose = function (/* functions... */) {\n      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // Node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","/* global __filename */\r\n/**\r\n * Strophe logger implementation. Logs from level WARN and above.\r\n */\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport { Strophe } from 'strophe.js';\r\n\r\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * This is the last HTTP error status captured from Strophe debug logs.\r\n * The purpose of storing it is to distinguish between the network and\r\n * infrastructure reason for connection being dropped (see connectionHandler in\r\n * xmpp.js). The value will be cleared (-1) if the subsequent request succeeds\r\n * which means that the failure could be transient.\r\n *\r\n * FIXME in the latest Strophe (not released on npm) there is API to handle\r\n * particular HTTP errors, but there is no way to learn if the subsequent\r\n * request succeeded in order to tell if the error was one time incident or if\r\n * it was the reason for dropping the connection by Strophe (the connection is\r\n * dropped after 5 subsequent failures). Ideally Strophe should provide more\r\n * details about the reason on why the connection stopped.\r\n *\r\n * @type {number}\r\n */\r\nlet lastErrorStatus = -1;\r\n\r\n/**\r\n * A regular expression used to catch Strophe's log message indicating that the\r\n * last BOSH request was successful. When there is such message seen the\r\n * {@link lastErrorStatus} will be set back to '-1'.\r\n * @type {RegExp}\r\n */\r\nconst resetLastErrorStatusRegExpr = /request id \\d+.\\d+ got 200/;\r\n\r\n/**\r\n * A regular expression used to capture the current value of the BOSH request\r\n * error status (HTTP error code or '0' or something else).\r\n * @type {RegExp}\r\n */\r\nconst lastErrorStatusRegExpr\r\n    = /request errored, status: (\\d+), number of errors: \\d+/;\r\n\r\n/**\r\n *\r\n */\r\nexport default function() {\r\n\r\n    Strophe.log = function(level, msg) {\r\n        // Our global handler reports uncaught errors to the stats which may\r\n        // interpret those as partial call failure.\r\n        // Strophe log entry about secondary request timeout does not mean that\r\n        // it's a final failure(the request will be restarted), so we lower it's\r\n        // level here to a warning.\r\n        logger.trace('Strophe', level, msg);\r\n        if (typeof msg === 'string'\r\n                && msg.indexOf('Request ') !== -1\r\n                && msg.indexOf('timed out (secondary), restarting') !== -1) {\r\n            // eslint-disable-next-line no-param-reassign\r\n            level = Strophe.LogLevel.WARN;\r\n        }\r\n\r\n        /* eslint-disable no-case-declarations */\r\n        switch (level) {\r\n        case Strophe.LogLevel.DEBUG:\r\n            // The log message which reports successful status is logged on\r\n            // Strophe's DEBUG level.\r\n            if (lastErrorStatus !== -1\r\n                    && resetLastErrorStatusRegExpr.test(msg)) {\r\n                logger.debug('Reset lastErrorStatus');\r\n                lastErrorStatus = -1;\r\n            }\r\n            break;\r\n        case Strophe.LogLevel.WARN:\r\n            logger.warn(`Strophe: ${msg}`);\r\n            const errStatusCapture = lastErrorStatusRegExpr.exec(msg);\r\n\r\n            if (errStatusCapture && errStatusCapture.length === 2) {\r\n                lastErrorStatus = parseInt(errStatusCapture[1], 10);\r\n                logger.debug(`lastErrorStatus set to: ${lastErrorStatus}`);\r\n            }\r\n            break;\r\n        case Strophe.LogLevel.ERROR:\r\n        case Strophe.LogLevel.FATAL:\r\n            // eslint-disable-next-line no-param-reassign\r\n            msg = `Strophe: ${msg}`;\r\n            GlobalOnErrorHandler.callErrorHandler(new Error(msg));\r\n            logger.error(msg);\r\n            break;\r\n        }\r\n\r\n        /* eslint-enable no-case-declarations */\r\n    };\r\n\r\n    /**\r\n     * Returns error status (HTTP error code) of the last BOSH request.\r\n     *\r\n     * @return {number} HTTP error code, '0' for unknown or \"god knows what\"\r\n     * (this is a hack).\r\n     */\r\n    Strophe.getLastErrorStatus = function() {\r\n        return lastErrorStatus;\r\n    };\r\n\r\n    Strophe.getStatusString = function(status) {\r\n        switch (status) {\r\n        case Strophe.Status.ERROR:\r\n            return 'ERROR';\r\n        case Strophe.Status.CONNECTING:\r\n            return 'CONNECTING';\r\n        case Strophe.Status.CONNFAIL:\r\n            return 'CONNFAIL';\r\n        case Strophe.Status.AUTHENTICATING:\r\n            return 'AUTHENTICATING';\r\n        case Strophe.Status.AUTHFAIL:\r\n            return 'AUTHFAIL';\r\n        case Strophe.Status.CONNECTED:\r\n            return 'CONNECTED';\r\n        case Strophe.Status.DISCONNECTED:\r\n            return 'DISCONNECTED';\r\n        case Strophe.Status.DISCONNECTING:\r\n            return 'DISCONNECTING';\r\n        case Strophe.Status.ATTACHED:\r\n            return 'ATTACHED';\r\n        default:\r\n            return 'unknown';\r\n        }\r\n    };\r\n}\r\n","import { getLogger } from 'qhsense-meet-logger';\r\nimport { $iq, Strophe } from 'strophe.js';\r\n\r\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\r\n\r\nimport ConnectionPlugin from './ConnectionPlugin';\r\n\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Ping every 10 sec\r\n */\r\nconst PING_INTERVAL = 10000;\r\n\r\n/**\r\n * Ping timeout error after 15 sec of waiting.\r\n */\r\nconst PING_TIMEOUT = 15000;\r\n\r\n/**\r\n * Will close the connection after 3 consecutive ping errors.\r\n */\r\nconst PING_THRESHOLD = 3;\r\n\r\n/**\r\n * The number of timestamps of send pings to keep.\r\n * The current value is 2 minutes.\r\n * @type {number} number of timestamps.\r\n */\r\nconst PING_TIMESTAMPS_TO_KEEP = 120000 / PING_INTERVAL;\r\n\r\n/**\r\n * XEP-0199 ping plugin.\r\n *\r\n * Registers \"urn:xmpp:ping\" namespace under Strophe.NS.PING.\r\n */\r\nclass PingConnectionPlugin extends ConnectionPlugin {\r\n    /**\r\n     * Contructs new object\r\n     * @param {XMPP} xmpp the xmpp module.\r\n     * @constructor\r\n     */\r\n    constructor(xmpp) {\r\n        super();\r\n        this.failedPings = 0;\r\n        this.xmpp = xmpp;\r\n        this.pingExecIntervals = new Array(PING_TIMESTAMPS_TO_KEEP);\r\n    }\r\n\r\n    /**\r\n     * Initializes the plugin. Method called by Strophe.\r\n     * @param connection Strophe connection instance.\r\n     */\r\n    init(connection) {\r\n        super.init(connection);\r\n        Strophe.addNamespace('PING', 'urn:xmpp:ping');\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n\r\n    /**\r\n     * Sends \"ping\" to given <tt>jid</tt>\r\n     * @param jid the JID to which ping request will be sent.\r\n     * @param success callback called on success.\r\n     * @param error callback called on error.\r\n     * @param timeout ms how long are we going to wait for the response. On\r\n     * timeout <tt>error<//t> callback is called with undefined error argument.\r\n     */\r\n    ping(jid, success, error, timeout) {\r\n        this._addPingExecutionTimestamp();\r\n\r\n        const iq = $iq({\r\n            type: 'get',\r\n            to: jid\r\n        });\r\n\r\n        iq.c('ping', { xmlns: Strophe.NS.PING });\r\n        this.connection.sendIQ(iq, success, error, timeout);\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Starts to send ping in given interval to specified remote JID.\r\n     * This plugin supports only one such task and <tt>stopInterval</tt>\r\n     * must be called before starting a new one.\r\n     * @param remoteJid remote JID to which ping requests will be sent to.\r\n     * @param interval task interval in ms.\r\n     */\r\n    startInterval(remoteJid, interval = PING_INTERVAL) {\r\n        if (this.intervalId) {\r\n            const errmsg = 'Ping task scheduled already';\r\n\r\n            GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\r\n            logger.error(errmsg);\r\n\r\n            return;\r\n        }\r\n        this.intervalId = window.setInterval(() => {\r\n            this.ping(remoteJid, () => {\r\n                this.failedPings = 0;\r\n            }, error => {\r\n                this.failedPings += 1;\r\n                const errmsg = `Ping ${error ? 'error' : 'timeout'}`;\r\n\r\n                if (this.failedPings >= PING_THRESHOLD) {\r\n                    GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\r\n                    logger.error(errmsg, error);\r\n\r\n                    // FIXME it doesn't help to disconnect when 3rd PING\r\n                    // times out, it only stops Strophe from retrying.\r\n                    // Not really sure what's the right thing to do in that\r\n                    // situation, but just closing the connection makes no\r\n                    // sense.\r\n                    // self.connection.disconnect();\r\n                } else {\r\n                    logger.warn(errmsg, error);\r\n                }\r\n            }, PING_TIMEOUT);\r\n        }, interval);\r\n        logger.info(`XMPP pings will be sent every ${interval} ms`);\r\n    }\r\n\r\n    /**\r\n     * Stops current \"ping\"  interval task.\r\n     */\r\n    stopInterval() {\r\n        if (this.intervalId) {\r\n            window.clearInterval(this.intervalId);\r\n            this.intervalId = null;\r\n            this.failedPings = 0;\r\n            logger.info('Ping interval cleared');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds the current time to the array of send ping timestamps.\r\n     * @private\r\n     */\r\n    _addPingExecutionTimestamp() {\r\n        this.pingExecIntervals.push(new Date().getTime());\r\n\r\n        // keep array length to PING_TIMESTAMPS_TO_KEEP\r\n        if (this.pingExecIntervals.length > PING_TIMESTAMPS_TO_KEEP) {\r\n            this.pingExecIntervals.shift();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum time between the recent sent pings, if there is a\r\n     * big value it means the computer was inactive for some time(suspended).\r\n     * Checks the maximum gap between sending pings, considering and the\r\n     * current time. Trying to detect computer inactivity (sleep).\r\n     *\r\n     * @returns {int} the time ping was suspended, if it was not 0 is returned.\r\n     */\r\n    getPingSuspendTime() {\r\n        const pingIntervals = this.pingExecIntervals.slice();\r\n\r\n        // we need current time, as if ping was sent now\r\n        // if computer sleeps we will get correct interval after next\r\n        // scheduled ping, bet we sometimes need that interval before waiting\r\n        // for the next ping, on closing the connection on error.\r\n        pingIntervals.push(new Date().getTime());\r\n\r\n        let maxInterval = 0;\r\n        let previousTS = pingIntervals[0];\r\n\r\n        pingIntervals.forEach(e => {\r\n            const currentInterval = e - previousTS;\r\n\r\n            if (currentInterval > maxInterval) {\r\n                maxInterval = currentInterval;\r\n            }\r\n\r\n            previousTS = e;\r\n        });\r\n\r\n        // remove the interval between the ping sent\r\n        // this way in normal execution there is no suspend and the return\r\n        // will be 0 or close to 0.\r\n        maxInterval -= PING_INTERVAL;\r\n\r\n        // make sure we do not return less than 0\r\n        return Math.max(maxInterval, 0);\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param xmpp\r\n */\r\nexport default function(xmpp) {\r\n    Strophe.addConnectionPlugin('ping', new PingConnectionPlugin(xmpp));\r\n}\r\n","/* global $ */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport { $iq, Strophe } from 'strophe.js';\r\n\r\nimport ConnectionPlugin from './ConnectionPlugin';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\nconst RAYO_XMLNS = 'urn:xmpp:rayo:1';\r\n\r\n/**\r\n *\r\n */\r\nclass RayoConnectionPlugin extends ConnectionPlugin {\r\n    /**\r\n     *\r\n     * @param connection\r\n     */\r\n    init(connection) {\r\n        super.init(connection);\r\n\r\n        this.connection.addHandler(\r\n            this.onRayo.bind(this), RAYO_XMLNS, 'iq', 'set', null, null);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param iq\r\n     */\r\n    onRayo(iq) {\r\n        logger.info('Rayo IQ', iq);\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n\r\n    /**\r\n     *\r\n     * @param to\r\n     * @param from\r\n     * @param roomName\r\n     * @param roomPass\r\n     * @param focusMucJid\r\n     */\r\n    dial(to, from, roomName, roomPass, focusMucJid) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!focusMucJid) {\r\n                reject(new Error('Internal error!'));\r\n\r\n                return;\r\n            }\r\n            const req = $iq({\r\n                type: 'set',\r\n                to: focusMucJid\r\n            });\r\n\r\n            req.c('dial', {\r\n                xmlns: RAYO_XMLNS,\r\n                to,\r\n                from\r\n            });\r\n            req.c('header', {\r\n                name: 'JvbRoomName',\r\n                value: roomName\r\n            }).up();\r\n\r\n            if (roomPass && roomPass.length) {\r\n                req.c('header', {\r\n                    name: 'JvbRoomPassword',\r\n                    value: roomPass\r\n                }).up();\r\n            }\r\n\r\n            this.connection.sendIQ(\r\n                req,\r\n                result => {\r\n                    logger.info('Dial result ', result);\r\n\r\n                    // eslint-disable-next-line newline-per-chained-call\r\n                    const resource = $(result).find('ref').attr('uri');\r\n\r\n                    this.callResource = resource.substr('xmpp:'.length);\r\n                    logger.info(`Received call resource: ${this.callResource}`);\r\n                    resolve();\r\n                },\r\n                error => {\r\n                    logger.info('Dial error ', error);\r\n                    reject(error);\r\n                });\r\n        });\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     *\r\n     */\r\n    hangup() {\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.callResource) {\r\n                reject(new Error('No call in progress'));\r\n                logger.warn('No call in progress');\r\n\r\n                return;\r\n            }\r\n\r\n            const req = $iq({\r\n                type: 'set',\r\n                to: this.callResource\r\n            });\r\n\r\n            req.c('hangup', {\r\n                xmlns: RAYO_XMLNS\r\n            });\r\n\r\n            this.connection.sendIQ(req, result => {\r\n                logger.info('Hangup result ', result);\r\n                this.callResource = null;\r\n                resolve();\r\n            }, error => {\r\n                logger.info('Hangup error ', error);\r\n                this.callResource = null;\r\n                reject(new Error('Hangup error '));\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport default function() {\r\n    Strophe.addConnectionPlugin('rayo', new RayoConnectionPlugin());\r\n}\r\n","import { Strophe } from 'strophe.js';\r\n\r\nimport ConnectionPlugin from './ConnectionPlugin';\r\n\r\n/**\r\n *  Logs raw stanzas and makes them available for download as JSON\r\n */\r\nclass StropheLogger extends ConnectionPlugin {\r\n    /**\r\n     *\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.log = [];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param connection\r\n     */\r\n    init(connection) {\r\n        super.init(connection);\r\n        this.connection.rawInput = this.logIncoming.bind(this);\r\n        this.connection.rawOutput = this.logOutgoing.bind(this);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param stanza\r\n     */\r\n    logIncoming(stanza) {\r\n        this.log.push([ new Date().getTime(), 'incoming', stanza ]);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param stanza\r\n     */\r\n    logOutgoing(stanza) {\r\n        this.log.push([ new Date().getTime(), 'outgoing', stanza ]);\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport default function() {\r\n    Strophe.addConnectionPlugin('logger', new StropheLogger());\r\n}\r\n","/**\r\n * Class attaches to Strophe BOSH connection and tracks the time of last successful request.\r\n * It does that by overriding {@code nextValidRid} method and tracking how the RID value changes.\r\n * A request was successful if the number has increased by 1 since the last time the method was called.\r\n */\r\nexport default class LastRequestTracker {\r\n    /**\r\n     * Initializes new instance.\r\n     */\r\n    constructor() {\r\n        this._nextValidRid = null;\r\n        this._lastSuccess = null;\r\n    }\r\n\r\n    /**\r\n     * Starts tracking requests on the given connection.\r\n     *\r\n     * @param {Object} stropheConnection - Strophe connection instance.\r\n     */\r\n    startTracking(stropheConnection) {\r\n        stropheConnection.nextValidRid = rid => {\r\n            // Just before connect and on disconnect RID will get assigned a new random value.\r\n            // A request was successful only when the value got increased exactly by 1.\r\n            if (this._nextValidRid === rid - 1) {\r\n                this._lastSuccess = new Date().getTime();\r\n            }\r\n            this._nextValidRid = rid;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns how many milliseconds have passed since the last successful BOSH request.\r\n     *\r\n     * @returns {number|null}\r\n     */\r\n    getTimeSinceLastSuccess() {\r\n        return this._lastSuccess\r\n            ? new Date().getTime() - this._lastSuccess\r\n            : null;\r\n    }\r\n}\r\n","/* global $ */\r\n\r\nimport { b64_sha1, Strophe } from 'strophe.js'; // eslint-disable-line camelcase\r\n\r\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\r\nimport Listenable from '../util/Listenable';\r\n\r\nconst logger = require('qhsense-meet-logger').getLogger(__filename);\r\n\r\n/**\r\n * The property\r\n */\r\nconst IDENTITY_PROPERTIES = [ 'category', 'type', 'lang', 'name' ];\r\nconst IDENTITY_PROPERTIES_FOR_COMPARE = [ 'category', 'type', 'lang' ];\r\nconst HASH = 'sha-1';\r\n\r\n/**\r\n *\r\n * @param a\r\n * @param b\r\n */\r\nfunction compareIdentities(a, b) {\r\n    let res = 0;\r\n\r\n    IDENTITY_PROPERTIES_FOR_COMPARE.some(key =>\r\n        (res = ((a[key] > b[key]) && 1) || ((a[key] < b[key]) && -1)) !== 0\r\n    );\r\n\r\n    return res;\r\n}\r\n\r\n/**\r\n * Produces a sha-1 from provided identity and features values.\r\n *\r\n * @param {Array<Object>} identities - The identity objects.\r\n * @param {Array<string>} features - The features.\r\n * @returns {string}\r\n */\r\nfunction generateSha(identities, features) {\r\n    const sortedIdentities = identities.sort(compareIdentities).reduce(\r\n        (accumulatedValue, identity) => `${\r\n            IDENTITY_PROPERTIES.reduce(\r\n                (tmp, key, idx) =>\r\n                    tmp\r\n                        + (idx === 0 ? '' : '/')\r\n                        + (identity[key] ? identity[key] : ''),\r\n                '')\r\n        }<`, '');\r\n    const sortedFeatures = features.sort().reduce(\r\n        (tmp, feature) => `${tmp + feature}<`, '');\r\n\r\n    return b64_sha1(sortedIdentities + sortedFeatures);\r\n}\r\n\r\n/**\r\n * Implements xep-0115 ( http://xmpp.org/extensions/xep-0115.html )\r\n */\r\nexport default class Caps extends Listenable {\r\n    /**\r\n     * Constructs new Caps instance.\r\n     * @param {Strophe.Connection} connection the strophe connection object\r\n     * @param {String} node the value of the node attribute of the \"c\" xml node\r\n     * that will be sent to the other participants\r\n     */\r\n    constructor(connection = {}, node = 'http://jitsi.org/jitsimeet') {\r\n        super();\r\n        this.node = node;\r\n        this.disco = connection.disco;\r\n        if (!this.disco) {\r\n            throw new Error(\r\n                'Missing strophe-plugins '\r\n                + '(disco plugin is required)!');\r\n        }\r\n\r\n        this.versionToCapabilities = Object.create(null);\r\n        this.jidToVersion = Object.create(null);\r\n        this.version = '';\r\n        this.rooms = new Set();\r\n\r\n        const emuc = connection.emuc;\r\n\r\n        emuc.addListener(XMPPEvents.EMUC_ROOM_ADDED,\r\n            room => this._addChatRoom(room));\r\n        emuc.addListener(XMPPEvents.EMUC_ROOM_REMOVED,\r\n            room => this._removeChatRoom(room));\r\n        Object.keys(emuc.rooms).forEach(jid => {\r\n            this._addChatRoom(emuc.rooms[jid]);\r\n        });\r\n\r\n        Strophe.addNamespace('CAPS', 'http://jabber.org/protocol/caps');\r\n        this.disco.addFeature(Strophe.NS.CAPS);\r\n        connection.addHandler(this._handleCaps.bind(this), Strophe.NS.CAPS);\r\n\r\n        this._onMucMemberLeft = this._removeJidToVersionEntry.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Adds new feature to the list of supported features for the local\r\n     * participant\r\n     * @param {String} feature the name of the feature.\r\n     * @param {boolean} submit if true - new presence with updated \"c\" node\r\n     * will be sent.\r\n     */\r\n    addFeature(feature, submit = false) {\r\n        this.disco.addFeature(feature);\r\n        this._generateVersion();\r\n        if (submit) {\r\n            this.submit();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a feature from the list of supported features for the local\r\n     * participant\r\n     * @param {String} feature the name of the feature.\r\n     * @param {boolean} submit if true - new presence with updated \"c\" node\r\n     * will be sent.\r\n     */\r\n    removeFeature(feature, submit = false) {\r\n        this.disco.removeFeature(feature);\r\n        this._generateVersion();\r\n        if (submit) {\r\n            this.submit();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends new presence stanza for every room from the list of rooms.\r\n     */\r\n    submit() {\r\n        this.rooms.forEach(room => room.sendPresence());\r\n    }\r\n\r\n    /**\r\n     * Returns a set with the features for a participant.\r\n     * @param {String} jid the jid of the participant\r\n     * @param {int} timeout the timeout in ms for reply from the participant.\r\n     * @returns {Promise<Set<String>, Error>}\r\n     */\r\n    getFeatures(jid, timeout = 5000) {\r\n        const user\r\n            = jid in this.jidToVersion ? this.jidToVersion[jid] : null;\r\n\r\n        if (!user || !(user.version in this.versionToCapabilities)) {\r\n            const node = user ? `${user.node}#${user.version}` : null;\r\n\r\n            return this._getDiscoInfo(jid, node, timeout)\r\n                .then(({ features, identities }) => {\r\n                    if (user) {\r\n                        const sha = generateSha(\r\n                            Array.from(identities),\r\n                            Array.from(features)\r\n                        );\r\n                        const receivedNode = `${user.node}#${sha}`;\r\n\r\n                        if (receivedNode === node) {\r\n                            this.versionToCapabilities[receivedNode] = features;\r\n\r\n                            return features;\r\n                        }\r\n\r\n                        // Check once if it has been cached asynchronously.\r\n                        if (this.versionToCapabilities[receivedNode]) {\r\n                            return this.versionToCapabilities[receivedNode];\r\n                        }\r\n\r\n                        logger.error(`Expected node ${node} but received ${\r\n                            receivedNode}`);\r\n\r\n                        return Promise.reject('Feature version mismatch');\r\n                    }\r\n                });\r\n        }\r\n\r\n        return Promise.resolve(this.versionToCapabilities[user.version]);\r\n    }\r\n\r\n    /**\r\n     * Returns a set with the features for a host.\r\n     * @param {String} jid the jid of the host\r\n     * @param {int} timeout the timeout in ms for reply from the host.\r\n     * @returns {Promise<Set<String>, Error>}\r\n     */\r\n    getFeaturesAndIdentities(jid, timeout = 5000) {\r\n        return this._getDiscoInfo(jid, null, timeout);\r\n    }\r\n\r\n    /**\r\n     * Returns a set with the features and identities for a host.\r\n     * @param {String} jid the jid of the host\r\n     * @param {String|null} node the node to query\r\n     * @param {int} timeout the timeout in ms for reply from the host.\r\n     * @returns {Promise<Object>}\r\n     * @private\r\n     */\r\n    _getDiscoInfo(jid, node, timeout) {\r\n        return new Promise((resolve, reject) =>\r\n            this.disco.info(jid, node, response => {\r\n                const features = new Set();\r\n                const identities = new Set();\r\n\r\n                $(response)\r\n                    .find('>query>feature')\r\n                    .each(\r\n                        (_, el) => features.add(el.getAttribute('var')));\r\n                $(response)\r\n                    .find('>query>identity')\r\n                    .each(\r\n                        (_, el) => identities.add({\r\n                            type: el.getAttribute('type'),\r\n                            name: el.getAttribute('name'),\r\n                            category: el.getAttribute('category')\r\n                        }));\r\n                resolve({\r\n                    features,\r\n                    identities });\r\n            }, reject, timeout)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Adds ChatRoom instance to the list of rooms. Adds listeners to the room\r\n     * and adds \"c\" element to the presences of the room.\r\n     * @param {ChatRoom} room the room.\r\n     */\r\n    _addChatRoom(room) {\r\n        this.rooms.add(room);\r\n        room.addListener(XMPPEvents.MUC_MEMBER_LEFT, this._onMucMemberLeft);\r\n        this._fixChatRoomPresenceMap(room);\r\n    }\r\n\r\n    /**\r\n     * Removes ChatRoom instance from the list of rooms. Removes listeners\r\n     * added from the Caps class.\r\n     * @param {ChatRoom} room the room.\r\n     */\r\n    _removeChatRoom(room) {\r\n        this.rooms.delete(room);\r\n        room.removeListener(XMPPEvents.MUC_MEMBER_LEFT, this._onMucMemberLeft);\r\n    }\r\n\r\n    /**\r\n     * Creates/updates the \"c\" xml node into the presence of the passed room.\r\n     * @param {ChatRoom} room the room.\r\n     */\r\n    _fixChatRoomPresenceMap(room) {\r\n        room.addToPresence('c', {\r\n            attributes: {\r\n                xmlns: Strophe.NS.CAPS,\r\n                hash: HASH,\r\n                node: this.node,\r\n                ver: this.version\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles this.version changes.\r\n     */\r\n    _notifyVersionChanged() {\r\n        // update the version for all rooms\r\n        this.rooms.forEach(room => this._fixChatRoomPresenceMap(room));\r\n    }\r\n\r\n    /**\r\n     * Generates the value for the \"ver\" attribute.\r\n     */\r\n    _generateVersion() {\r\n        this.version\r\n            = generateSha(this.disco._identities, this.disco._features);\r\n\r\n        this._notifyVersionChanged();\r\n    }\r\n\r\n    /**\r\n     * Parses the \"c\" xml node from presence.\r\n     * @param {DOMElement} stanza the presence packet\r\n     */\r\n    _handleCaps(stanza) {\r\n        const from = stanza.getAttribute('from');\r\n        const caps = stanza.querySelector('c');\r\n        const version = caps.getAttribute('ver');\r\n        const node = caps.getAttribute('node');\r\n        const oldVersion = this.jidToVersion[from];\r\n\r\n        this.jidToVersion[from] = { version,\r\n            node };\r\n        if (oldVersion && oldVersion.version !== version) {\r\n            this.eventEmitter.emit(XMPPEvents.PARTCIPANT_FEATURES_CHANGED,\r\n                from);\r\n        }\r\n\r\n        // return true to not remove the handler from Strophe\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes entry from this.jidToVersion map.\r\n     * @param {String} jid the jid to be removed.\r\n     */\r\n    _removeJidToVersionEntry(jid) {\r\n        if (jid in this.jidToVersion) {\r\n            delete this.jidToVersion[jid];\r\n        }\r\n    }\r\n}\r\n","const logger = require('qhsense-meet-logger').getLogger(__filename);\r\n\r\n/**\r\n *\r\n * @param localAudio\r\n * @param peerConnection\r\n */\r\nfunction QHSenseDTMFManager(localAudio, peerConnection) {\r\n    const audioTrack = localAudio.getTrack();\r\n\r\n    if (!audioTrack) {\r\n        throw new Error('Failed to initialize DTMFSender: no audio track.');\r\n    }\r\n    this.dtmfSender\r\n        = peerConnection.peerconnection.createDTMFSender(audioTrack);\r\n    logger.debug('Initialized DTMFSender');\r\n}\r\n\r\nQHSenseDTMFManager.prototype.sendTones = function(tones, duration, pause) {\r\n    this.dtmfSender.insertDTMF(tones, duration || 200, pause || 200);\r\n};\r\n\r\nmodule.exports = QHSenseDTMFManager;\r\n\r\n","import * as QHSenseConferenceEvents from '../QHSenseConferenceEvents';\r\n\r\n/**\r\n * The value which we use to say, every sound over this threshold\r\n * is talking on the mic.\r\n * @type {number}\r\n */\r\nconst SPEECH_DETECT_THRESHOLD = 0.6;\r\n\r\n/**\r\n * The <tt>P2PDominantSpeakerDetection</tt> is activated only when p2p is\r\n * currently used.\r\n * Listens for changes in the audio level changes of the local p2p audio track\r\n * or remote p2p one and fires dominant speaker events to be able to use\r\n * features depending on those events (speaker stats), to make them work without\r\n * the video bridge.\r\n */\r\nexport default class P2PDominantSpeakerDetection {\r\n    /**\r\n     * Creates P2PDominantSpeakerDetection\r\n     * @param conference the QHSenseConference instance that created us.\r\n     * @constructor\r\n     */\r\n    constructor(conference) {\r\n        this.conference = conference;\r\n\r\n        conference.addEventListener(\r\n            QHSenseConferenceEvents.TRACK_AUDIO_LEVEL_CHANGED,\r\n            this._audioLevel.bind(this));\r\n\r\n        this.myUserID = this.conference.myUserId();\r\n    }\r\n\r\n    /**\r\n     * Receives audio level events for all streams in the conference.\r\n     *\r\n     * @param {String} id - The participant id\r\n     * @param {number} audioLevel - The audio level.\r\n     */\r\n    _audioLevel(id, audioLevel) {\r\n\r\n        // we do not process if p2p is not active\r\n        // or audio level is under certain threshold\r\n        // or if the audio level is for local audio track which is muted\r\n        if (!this.conference.isP2PActive()\r\n            || audioLevel <= SPEECH_DETECT_THRESHOLD\r\n            || (id === this.myUserID\r\n                    && this.conference.getLocalAudioTrack().isMuted())) {\r\n            return;\r\n        }\r\n\r\n        this.conference.eventEmitter.emit(\r\n            QHSenseConferenceEvents.DOMINANT_SPEAKER_CHANGED,\r\n            id);\r\n    }\r\n}\r\n","import { getLogger } from 'qhsense-meet-logger';\r\n\r\nimport RTCEvents from '../../service/RTC/RTCEvents';\r\nimport { createBridgeChannelClosedEvent } from '../../service/statistics/AnalyticsEvents';\r\nimport Statistics from '../statistics/statistics';\r\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Handles a WebRTC RTCPeerConnection or a WebSocket instance to communicate\r\n * with the videobridge.\r\n */\r\nexport default class BridgeChannel {\r\n    /**\r\n     * Binds \"ondatachannel\" event listener on the given RTCPeerConnection\r\n     * instance, or creates a WebSocket connection with the videobridge.\r\n     * At least one of both, peerconnection or wsUrl parameters, must be\r\n     * given.\r\n     * @param {RTCPeerConnection} [peerconnection] WebRTC peer connection\r\n     * instance.\r\n     * @param {string} [wsUrl] WebSocket URL.\r\n     * @param {EventEmitter} eventEmitter EventEmitter instance.\r\n     */\r\n    constructor(peerconnection, wsUrl, emitter) {\r\n        if (!peerconnection && !wsUrl) {\r\n            throw new TypeError(\r\n                'At least peerconnection or wsUrl must be given');\r\n        } else if (peerconnection && wsUrl) {\r\n            throw new TypeError(\r\n                'Just one of peerconnection or wsUrl must be given');\r\n        }\r\n\r\n        if (peerconnection) {\r\n            logger.debug('constructor() with peerconnection');\r\n        } else {\r\n            logger.debug(`constructor() with wsUrl:\"${wsUrl}\"`);\r\n        }\r\n\r\n        // The underlying WebRTC RTCDataChannel or WebSocket instance.\r\n        // @type {RTCDataChannel|WebSocket}\r\n        this._channel = null;\r\n\r\n        // @type {EventEmitter}\r\n        this._eventEmitter = emitter;\r\n\r\n        // Whether a RTCDataChannel or WebSocket is internally used.\r\n        // @type {string} \"datachannel\" / \"websocket\"\r\n        this._mode = null;\r\n\r\n        // Indicates whether the connection retries are enabled or not.\r\n        this._areRetriesEnabled = false;\r\n\r\n        // Indicates whether the connection was closed from the client or not.\r\n        this._closedFromClient = false;\r\n\r\n        // If a RTCPeerConnection is given, listen for new RTCDataChannel\r\n        // event.\r\n        if (peerconnection) {\r\n            const datachannel\r\n                = peerconnection.createDataChannel(\r\n                    'JVB data channel', {\r\n                        protocol: 'http://jitsi.org/protocols/colibri'\r\n                    });\r\n\r\n            // Handle the RTCDataChannel.\r\n            this._handleChannel(datachannel);\r\n            this._mode = 'datachannel';\r\n\r\n        // Otherwise create a WebSocket connection.\r\n        } else if (wsUrl) {\r\n            this._areRetriesEnabled = true;\r\n            this._wsUrl = wsUrl;\r\n            this._initWebSocket();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the web socket channel.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    _initWebSocket() {\r\n        // Create a WebSocket instance.\r\n        const ws = new WebSocket(this._wsUrl);\r\n\r\n        // Handle the WebSocket.\r\n        this._handleChannel(ws);\r\n        this._mode = 'websocket';\r\n    }\r\n\r\n    /**\r\n     * Starts the websocket connection retries.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    _startConnectionRetries() {\r\n        let timeoutS = 1;\r\n\r\n        const reload = () => {\r\n            if (this.isOpen()) {\r\n                return;\r\n            }\r\n            this._initWebSocket(this._wsUrl);\r\n            timeoutS = Math.min(timeoutS * 2, 60);\r\n            this._retryTimeout = setTimeout(reload, timeoutS * 1000);\r\n        };\r\n\r\n        this._retryTimeout = setTimeout(reload, timeoutS * 1000);\r\n    }\r\n\r\n    /**\r\n     * Stops the websocket connection retries.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    _stopConnectionRetries() {\r\n        if (this._retryTimeout) {\r\n            clearTimeout(this._retryTimeout);\r\n            this._retryTimeout = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retries to establish the websocket connection after the connection was closed by the server.\r\n     *\r\n     * @param {CloseEvent} closeEvent - The close event that triggered the retries.\r\n     * @returns {void}\r\n     */\r\n    _retryWebSocketConnection(closeEvent) {\r\n        if (!this._areRetriesEnabled) {\r\n            return;\r\n        }\r\n        const { code, reason } = closeEvent;\r\n\r\n        Statistics.sendAnalytics(createBridgeChannelClosedEvent(code, reason));\r\n        this._areRetriesEnabled = false;\r\n        this._eventEmitter.once(RTCEvents.DATA_CHANNEL_OPEN, () => {\r\n            this._stopConnectionRetries();\r\n            this._areRetriesEnabled = true;\r\n        });\r\n        this._startConnectionRetries();\r\n    }\r\n\r\n    /**\r\n     * The channel mode.\r\n     * @return {string} \"datachannel\" or \"websocket\" (or null if not yet set).\r\n     */\r\n    get mode() {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * Closes the currently opened channel.\r\n     */\r\n    close() {\r\n        this._closedFromClient = true;\r\n        this._stopConnectionRetries();\r\n        this._areRetriesEnabled = false;\r\n        if (this._channel) {\r\n            try {\r\n                this._channel.close();\r\n            } catch (error) {} // eslint-disable-line no-empty\r\n\r\n            this._channel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Whether there is an underlying RTCDataChannel or WebSocket and it's\r\n     * open.\r\n     * @return {boolean}\r\n     */\r\n    isOpen() {\r\n        return this._channel && (this._channel.readyState === 'open'\r\n            || this._channel.readyState === WebSocket.OPEN);\r\n    }\r\n\r\n    /**\r\n     * Sends message via the channel.\r\n     * @param {string} to The id of the endpoint that should receive the\r\n     * message. If \"\" the message will be sent to all participants.\r\n     * @param  {object} payload The payload of the message.\r\n     * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\r\n     * {@link https://developer.mozilla.org/docs/Web/API/RTCDataChannel/send})\r\n     * or from WebSocket#send or Error with \"No opened channel\" message.\r\n     */\r\n    sendMessage(to, payload) {\r\n        this._send({\r\n            colibriClass: 'EndpointMessage',\r\n            msgPayload: payload,\r\n            to\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sends a \"lastN value changed\" message via the channel.\r\n     * @param {number} value The new value for lastN. -1 means unlimited.\r\n     */\r\n    sendSetLastNMessage(value) {\r\n        const jsonObject = {\r\n            colibriClass: 'LastNChangedEvent',\r\n            lastN: value\r\n        };\r\n\r\n        this._send(jsonObject);\r\n        logger.log(`Channel lastN set to: ${value}`);\r\n    }\r\n\r\n    /**\r\n     * Sends a \"pinned endpoint changed\" message via the channel.\r\n     * @param {string} endpointId The id of the pinned endpoint.\r\n     * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\r\n     * {@link https://developer.mozilla.org/docs/Web/API/RTCDataChannel/send})\r\n     * or from WebSocket#send or Error with \"No opened channel\" message.\r\n     */\r\n    sendPinnedEndpointMessage(endpointId) {\r\n        logger.log(\r\n            'sending pinned changed notification to the bridge for endpoint ',\r\n            endpointId);\r\n\r\n        this._send({\r\n            colibriClass: 'PinnedEndpointChangedEvent',\r\n            pinnedEndpoint: endpointId || null\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sends a \"selected endpoints changed\" message via the channel.\r\n     *\r\n     * @param {Array<string>} endpointIds - The ids of the selected endpoints.\r\n     * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\r\n     * {@link https://developer.mozilla.org/docs/Web/API/RTCDataChannel/send})\r\n     * or from WebSocket#send or Error with \"No opened channel\" message.\r\n     */\r\n    sendSelectedEndpointsMessage(endpointIds) {\r\n        logger.log(\r\n            'sending selected changed notification to the bridge for endpoints',\r\n            endpointIds);\r\n\r\n        this._send({\r\n            colibriClass: 'SelectedEndpointsChangedEvent',\r\n            selectedEndpoints: endpointIds\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sends a \"receiver video constraint\" message via the channel.\r\n     * @param {Number} maxFrameHeightPixels the maximum frame height,\r\n     * in pixels, this receiver is willing to receive\r\n     */\r\n    sendReceiverVideoConstraintMessage(maxFrameHeightPixels) {\r\n        logger.log('sending a ReceiverVideoConstraint message with '\r\n            + `a maxFrameHeight of ${maxFrameHeightPixels} pixels`);\r\n        this._send({\r\n            colibriClass: 'ReceiverVideoConstraint',\r\n            maxFrameHeight: maxFrameHeightPixels\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set events on the given RTCDataChannel or WebSocket instance.\r\n     */\r\n    _handleChannel(channel) {\r\n        const emitter = this._eventEmitter;\r\n\r\n        channel.onopen = () => {\r\n            logger.info(`${this._mode} channel opened`);\r\n\r\n            // Code sample for sending string and/or binary data.\r\n            // Sends string message to the bridge:\r\n            //     channel.send(\"Hello bridge!\");\r\n            // Sends 12 bytes binary message to the bridge:\r\n            //     channel.send(new ArrayBuffer(12));\r\n\r\n            emitter.emit(RTCEvents.DATA_CHANNEL_OPEN);\r\n        };\r\n\r\n        channel.onerror = event => {\r\n            // WS error events contain no information about the failure (this is available in the onclose event) and\r\n            // the event references the WS object itself, which causes hangs on mobile.\r\n            if (this._mode !== 'websocket') {\r\n                logger.error(`Channel error: ${event.message}`);\r\n            }\r\n        };\r\n\r\n        channel.onmessage = ({ data }) => {\r\n            // JSON object.\r\n            let obj;\r\n\r\n            try {\r\n                obj = JSON.parse(data);\r\n            } catch (error) {\r\n                GlobalOnErrorHandler.callErrorHandler(error);\r\n                logger.error(\r\n                    'Failed to parse channel message as JSON: ',\r\n                    data, error);\r\n\r\n                return;\r\n            }\r\n\r\n            const colibriClass = obj.colibriClass;\r\n\r\n            switch (colibriClass) {\r\n            case 'DominantSpeakerEndpointChangeEvent': {\r\n                // Endpoint ID from the Videobridge.\r\n                const dominantSpeakerEndpoint = obj.dominantSpeakerEndpoint;\r\n\r\n                logger.info(\r\n                    'Channel new dominant speaker event: ',\r\n                    dominantSpeakerEndpoint);\r\n                emitter.emit(\r\n                    RTCEvents.DOMINANT_SPEAKER_CHANGED,\r\n                    dominantSpeakerEndpoint);\r\n                break;\r\n            }\r\n            case 'EndpointConnectivityStatusChangeEvent': {\r\n                const endpoint = obj.endpoint;\r\n                const isActive = obj.active === 'true';\r\n\r\n                logger.info(\r\n                    `Endpoint connection status changed: ${endpoint} active ? ${\r\n                        isActive}`);\r\n                emitter.emit(RTCEvents.ENDPOINT_CONN_STATUS_CHANGED,\r\n                    endpoint, isActive);\r\n\r\n                break;\r\n            }\r\n            case 'EndpointMessage': {\r\n                emitter.emit(\r\n                    RTCEvents.ENDPOINT_MESSAGE_RECEIVED, obj.from,\r\n                    obj.msgPayload);\r\n\r\n                break;\r\n            }\r\n            case 'LastNEndpointsChangeEvent': {\r\n                // The new/latest list of last-n endpoint IDs.\r\n                const lastNEndpoints = obj.lastNEndpoints;\r\n\r\n                logger.info('Channel new last-n event: ',\r\n                    lastNEndpoints, obj);\r\n                emitter.emit(RTCEvents.LASTN_ENDPOINT_CHANGED,\r\n                    lastNEndpoints, obj);\r\n\r\n                break;\r\n            }\r\n            case 'SelectedUpdateEvent': {\r\n                const isSelected = obj.isSelected;\r\n\r\n                logger.info(`SelectedUpdateEvent isSelected? ${isSelected}`);\r\n                emitter.emit(RTCEvents.IS_SELECTED_CHANGED, isSelected);\r\n                break;\r\n            }\r\n            default: {\r\n                logger.debug('Channel JSON-formatted message: ', obj);\r\n\r\n                // The received message appears to be appropriately formatted\r\n                // (i.e. is a JSON object which assigns a value to the\r\n                // mandatory property colibriClass) so don't just swallow it,\r\n                // expose it to public consumption.\r\n                emitter.emit(`rtc.datachannel.${colibriClass}`, obj);\r\n            }\r\n            }\r\n        };\r\n\r\n        channel.onclose = event => {\r\n            logger.info(`Channel closed by ${this._closedFromClient ? 'client' : 'server'}`);\r\n\r\n            if (this._mode === 'websocket') {\r\n                if (!this._closedFromClient) {\r\n                    logger.error(`Channel closed: ${event.code} ${event.reason}`);\r\n                    this._retryWebSocketConnection(event);\r\n                }\r\n            }\r\n\r\n            // Remove the channel.\r\n            this._channel = null;\r\n        };\r\n\r\n        // Store the channel.\r\n        this._channel = channel;\r\n    }\r\n\r\n    /**\r\n     * Sends passed object via the channel.\r\n     * @param {object} jsonObject The object that will be sent.\r\n     * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\r\n     * {@link https://developer.mozilla.org/docs/Web/API/RTCDataChannel/send})\r\n     * or from WebSocket#send or Error with \"No opened channel\" message.\r\n     */\r\n    _send(jsonObject) {\r\n        const channel = this._channel;\r\n\r\n        if (!this.isOpen()) {\r\n            logger.error('Bridge Channel send: no opened channel.');\r\n            throw new Error('No opened channel');\r\n        }\r\n\r\n        channel.send(JSON.stringify(jsonObject));\r\n    }\r\n}\r\n","/* global __filename, RTCSessionDescription */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport transform from 'sdp-transform';\r\n\r\nimport * as GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\r\nimport QHSenseRemoteTrack from './QHSenseRemoteTrack';\r\nimport * as MediaType from '../../service/RTC/MediaType';\r\nimport LocalSdpMunger from './LocalSdpMunger';\r\nimport RTC from './RTC';\r\nimport RTCUtils from './RTCUtils';\r\nimport browser from '../browser';\r\nimport RTCEvents from '../../service/RTC/RTCEvents';\r\nimport RtxModifier from '../xmpp/RtxModifier';\r\n\r\n// FIXME SDP tools should end up in some kind of util module\r\nimport SDP from '../xmpp/SDP';\r\nimport SdpConsistency from '../xmpp/SdpConsistency';\r\nimport { SdpTransformWrap } from '../xmpp/SdpTransformUtil';\r\nimport SDPUtil from '../xmpp/SDPUtil';\r\nimport * as SignalingEvents from '../../service/RTC/SignalingEvents';\r\n\r\nconst logger = getLogger(__filename);\r\nconst SIMULCAST_LAYERS = 3;\r\nconst SIM_LAYER_1_RID = '1';\r\nconst SIM_LAYER_2_RID = '2';\r\nconst SIM_LAYER_3_RID = '3';\r\nconst SIM_LAYER_RIDS = [ SIM_LAYER_1_RID, SIM_LAYER_2_RID, SIM_LAYER_3_RID ];\r\n\r\n/* eslint-disable max-params */\r\n\r\n/**\r\n * Creates new instance of 'TraceablePeerConnection'.\r\n *\r\n * @param {RTC} rtc the instance of <tt>RTC</tt> service\r\n * @param {number} id the peer connection id assigned by the parent RTC module.\r\n * @param {SignalingLayer} signalingLayer the signaling layer instance\r\n * @param {object} iceConfig WebRTC 'PeerConnection' ICE config\r\n * @param {object} constraints WebRTC 'PeerConnection' constraints\r\n * @param {boolean} isP2P indicates whether or not the new instance will be used\r\n * in a peer to peer connection\r\n * @param {object} options <tt>TracablePeerConnection</tt> config options.\r\n * @param {boolean} options.disableSimulcast if set to 'true' will disable\r\n * the simulcast.\r\n * @param {boolean} options.disableRtx if set to 'true' will disable the RTX\r\n * @param {boolean} options.enableFirefoxSimulcast if set to 'true' will enable\r\n * experimental simulcast support on Firefox.\r\n * @param {boolean} options.disableH264 If set to 'true' H264 will be\r\n *      disabled by removing it from the SDP.\r\n * @param {boolean} options.preferH264 if set to 'true' H264 will be preferred\r\n * over other video codecs.\r\n * @param {boolean} options.enableLayerSuspension if set to 'true', we will\r\n * cap the video send bitrate when we are told we have not been selected by\r\n * any endpoints (and therefore the non-thumbnail streams are not in use).\r\n * @param {boolean} options.startSilent If set to 'true' no audio will be sent or received.\r\n *\r\n * FIXME: initially the purpose of TraceablePeerConnection was to be able to\r\n * debug the peer connection. Since many other responsibilities have been added\r\n * it would make sense to extract a separate class from it and come up with\r\n * a more suitable name.\r\n *\r\n * @constructor\r\n */\r\nexport default function TraceablePeerConnection(\r\n        rtc,\r\n        id,\r\n        signalingLayer,\r\n        iceConfig,\r\n        constraints,\r\n        isP2P,\r\n        options) {\r\n\r\n    /**\r\n     * Indicates whether or not this peer connection instance is actively\r\n     * sending/receiving audio media. When set to <tt>false</tt> the SDP audio\r\n     * media direction will be adjusted to 'inactive' in order to suspend\r\n     * the transmission.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.audioTransferActive = !(options.startSilent === true);\r\n\r\n    /**\r\n     * Indicates whether or not this peer connection instance is actively\r\n     * sending/receiving video media. When set to <tt>false</tt> the SDP video\r\n     * media direction will be adjusted to 'inactive' in order to suspend\r\n     * the transmission.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.videoTransferActive = true;\r\n\r\n    /**\r\n     * The parent instance of RTC service which created this\r\n     * <tt>TracablePeerConnection</tt>.\r\n     * @type {RTC}\r\n     */\r\n    this.rtc = rtc;\r\n\r\n    /**\r\n     * The peer connection identifier assigned by the RTC module.\r\n     * @type {number}\r\n     */\r\n    this.id = id;\r\n\r\n    /**\r\n     * Indicates whether or not this instance is used in a peer to peer\r\n     * connection.\r\n     * @type {boolean}\r\n     */\r\n    this.isP2P = isP2P;\r\n\r\n    // FIXME: We should support multiple streams per jid.\r\n    /**\r\n     * The map holds remote tracks associated with this peer connection.\r\n     * It maps user's JID to media type and remote track\r\n     * (one track per media type per user's JID).\r\n     * @type {Map<string, Map<MediaType, QHSenseRemoteTrack>>}\r\n     */\r\n    this.remoteTracks = new Map();\r\n\r\n    /**\r\n     * A map which stores local tracks mapped by {@link QHSenseLocalTrack.rtcId}\r\n     * @type {Map<number, QHSenseLocalTrack>}\r\n     */\r\n    this.localTracks = new Map();\r\n\r\n    /**\r\n     * Keeps tracks of the WebRTC <tt>MediaStream</tt>s that have been added to\r\n     * the underlying WebRTC PeerConnection.\r\n     * @type {Array}\r\n     * @private\r\n     */\r\n    this._addedStreams = [];\r\n\r\n    /**\r\n     * @typedef {Object} TPCGroupInfo\r\n     * @property {string} semantics the SSRC groups semantics\r\n     * @property {Array<number>} ssrcs group's SSRCs in order where the first\r\n     * one is group's primary SSRC, the second one is secondary (RTX) and so\r\n     * on...\r\n     */\r\n    /**\r\n     * @typedef {Object} TPCSSRCInfo\r\n     * @property {Array<number>} ssrcs an array which holds all track's SSRCs\r\n     * @property {Array<TPCGroupInfo>} groups an array stores all track's SSRC\r\n     * groups\r\n     */\r\n    /**\r\n     * Holds the info about local track's SSRCs mapped per their\r\n     * {@link QHSenseLocalTrack.rtcId}\r\n     * @type {Map<number, TPCSSRCInfo>}\r\n     */\r\n    this.localSSRCs = new Map();\r\n\r\n    /**\r\n     * The local ICE username fragment for this session.\r\n     */\r\n    this.localUfrag = null;\r\n\r\n    /**\r\n     * The remote ICE username fragment for this session.\r\n     */\r\n    this.remoteUfrag = null;\r\n\r\n    /**\r\n     * The signaling layer which operates this peer connection.\r\n     * @type {SignalingLayer}\r\n     */\r\n    this.signalingLayer = signalingLayer;\r\n\r\n    // SignalingLayer listeners\r\n    this._peerVideoTypeChanged = this._peerVideoTypeChanged.bind(this);\r\n    this.signalingLayer.on(\r\n        SignalingEvents.PEER_VIDEO_TYPE_CHANGED,\r\n        this._peerVideoTypeChanged);\r\n\r\n    this._peerMutedChanged = this._peerMutedChanged.bind(this);\r\n    this.signalingLayer.on(\r\n        SignalingEvents.PEER_MUTED_CHANGED,\r\n        this._peerMutedChanged);\r\n    this.options = options;\r\n\r\n    this.peerconnection\r\n        = new RTCUtils.RTCPeerConnectionType(iceConfig, constraints);\r\n    this.updateLog = [];\r\n    this.stats = {};\r\n    this.statsinterval = null;\r\n\r\n    /**\r\n     * @type {number} The max number of stats to keep in this.stats. Limit to\r\n     * 300 values, i.e. 5 minutes; set to 0 to disable\r\n     */\r\n    this.maxstats = options.maxstats;\r\n    const Interop = require('@qhsense/sdp-interop').Interop;\r\n\r\n    this.interop = new Interop();\r\n    const Simulcast = require('@qhsense/sdp-simulcast');\r\n\r\n    this.simulcast = new Simulcast({ numOfLayers: SIMULCAST_LAYERS,\r\n        explodeRemoteSimulcast: false });\r\n    this.sdpConsistency = new SdpConsistency(this.toString());\r\n\r\n    /**\r\n     * Munges local SDP provided to the Jingle Session in order to prevent from\r\n     * sending SSRC updates on attach/detach and mute/unmute (for video).\r\n     * @type {LocalSdpMunger}\r\n     */\r\n    this.localSdpMunger = new LocalSdpMunger(this);\r\n\r\n    /**\r\n     * TracablePeerConnection uses RTC's eventEmitter\r\n     * @type {EventEmitter}\r\n     */\r\n    this.eventEmitter = rtc.eventEmitter;\r\n    this.rtxModifier = new RtxModifier();\r\n\r\n    // override as desired\r\n    this.trace = (what, info) => {\r\n        logger.debug(what, info);\r\n\r\n        this.updateLog.push({\r\n            time: new Date(),\r\n            type: what,\r\n            value: info || ''\r\n        });\r\n    };\r\n    this.onicecandidate = null;\r\n    this.peerconnection.onicecandidate = event => {\r\n        this.trace(\r\n            'onicecandidate',\r\n            JSON.stringify(event.candidate, null, ' '));\r\n\r\n        if (this.onicecandidate !== null) {\r\n            this.onicecandidate(event);\r\n        }\r\n    };\r\n    this.peerconnection.onaddstream\r\n        = event => this._remoteStreamAdded(event.stream);\r\n    this.peerconnection.onremovestream\r\n        = event => this._remoteStreamRemoved(event.stream);\r\n    this.onsignalingstatechange = null;\r\n    this.peerconnection.onsignalingstatechange = event => {\r\n        this.trace('onsignalingstatechange', this.signalingState);\r\n        if (this.onsignalingstatechange !== null) {\r\n            this.onsignalingstatechange(event);\r\n        }\r\n    };\r\n    this.oniceconnectionstatechange = null;\r\n    this.peerconnection.oniceconnectionstatechange = event => {\r\n        this.trace('oniceconnectionstatechange', this.iceConnectionState);\r\n        if (this.oniceconnectionstatechange !== null) {\r\n            this.oniceconnectionstatechange(event);\r\n        }\r\n    };\r\n    this.onnegotiationneeded = null;\r\n    this.peerconnection.onnegotiationneeded = event => {\r\n        this.trace('onnegotiationneeded');\r\n        if (this.onnegotiationneeded !== null) {\r\n            this.onnegotiationneeded(event);\r\n        }\r\n    };\r\n    this.ondatachannel = null;\r\n    this.peerconnection.ondatachannel = event => {\r\n        this.trace('ondatachannel');\r\n        if (this.ondatachannel !== null) {\r\n            this.ondatachannel(event);\r\n        }\r\n    };\r\n\r\n    if (this.maxstats) {\r\n        this.statsinterval = window.setInterval(() => {\r\n            this.getStats(stats => {\r\n                if (stats.result\r\n                    && typeof stats.result === 'function') {\r\n                    const results = stats.result();\r\n\r\n                    for (let i = 0; i < results.length; ++i) {\r\n                        const res = results[i];\r\n\r\n                        res.names().forEach(name => {\r\n                            this._processStat(res, name, res.stat(name));\r\n                        });\r\n                    }\r\n                } else {\r\n                    stats.forEach(r => this._processStat(r, '', r));\r\n                }\r\n            }, () => {\r\n\r\n                // empty error callback\r\n            });\r\n        }, 1000);\r\n    }\r\n\r\n    logger.info(`Create new ${this}`);\r\n}\r\n\r\n/* eslint-enable max-params */\r\n\r\n/**\r\n * Process stat and adds it to the array of stats we store.\r\n * @param report the current stats report.\r\n * @param name the name of the report, if available\r\n * @param statValue the value to add.\r\n * @private\r\n */\r\nTraceablePeerConnection.prototype._processStat\r\n    = function(report, name, statValue) {\r\n        const id = `${report.id}-${name}`;\r\n        let s = this.stats[id];\r\n        const now = new Date();\r\n\r\n        if (!s) {\r\n            this.stats[id] = s = {\r\n                startTime: now,\r\n                endTime: now,\r\n                values: [],\r\n                times: []\r\n            };\r\n        }\r\n        s.values.push(statValue);\r\n        s.times.push(now.getTime());\r\n        if (s.values.length > this.maxstats) {\r\n            s.values.shift();\r\n            s.times.shift();\r\n        }\r\n        s.endTime = now;\r\n    };\r\n\r\n/**\r\n * Returns a string representation of a SessionDescription object.\r\n */\r\nconst dumpSDP = function(description) {\r\n    if (typeof description === 'undefined' || description === null) {\r\n        return '';\r\n    }\r\n\r\n    return `type: ${description.type}\\r\\n${description.sdp}`;\r\n};\r\n\r\n\r\n/**\r\n * Forwards the {@link peerconnection.iceConnectionState} state except that it\r\n * will convert \"completed\" into \"connected\" where both mean that the ICE has\r\n * succeeded and is up and running. We never see \"completed\" state for\r\n * the JVB connection, but it started appearing for the P2P one. This method\r\n * allows to adapt old logic to this new situation.\r\n * @return {string}\r\n */\r\nTraceablePeerConnection.prototype.getConnectionState = function() {\r\n    const state = this.peerconnection.iceConnectionState;\r\n\r\n    if (state === 'completed') {\r\n        return 'connected';\r\n    }\r\n\r\n    return state;\r\n};\r\n\r\n/**\r\n * Obtains the media direction for given {@link MediaType}. The method takes\r\n * into account whether or not there are any local tracks for media and\r\n * the {@link audioTransferActive} and {@link videoTransferActive} flags.\r\n * @param {MediaType} mediaType\r\n * @return {string} one of the SDP direction constants ('sendrecv, 'recvonly'\r\n * etc.) which should be used when setting local description on the peer\r\n * connection.\r\n * @private\r\n */\r\nTraceablePeerConnection.prototype._getDesiredMediaDirection = function(\r\n        mediaType) {\r\n    let mediaTransferActive = true;\r\n\r\n    if (mediaType === MediaType.AUDIO) {\r\n        mediaTransferActive = this.audioTransferActive;\r\n    } else if (mediaType === MediaType.VIDEO) {\r\n        mediaTransferActive = this.videoTransferActive;\r\n    }\r\n    if (mediaTransferActive) {\r\n        return this.hasAnyTracksOfType(mediaType) ? 'sendrecv' : 'recvonly';\r\n    }\r\n\r\n    return 'inactive';\r\n};\r\n\r\n/**\r\n * Tells whether or not this TPC instance is using Simulcast.\r\n * @return {boolean} <tt>true</tt> if simulcast is enabled and active or\r\n * <tt>false</tt> if it's turned off.\r\n */\r\nTraceablePeerConnection.prototype.isSimulcastOn = function() {\r\n    return !this.options.disableSimulcast\r\n        && browser.supportsSimulcast()\r\n\r\n        // Firefox has been added as supporting simulcast, but it is\r\n        // experimental so we only want to do it for firefox if the config\r\n        // option is set.  Unfortunately, browser::supportsSimulcast()\r\n        // doesn't have a reference to the config options, so we have\r\n        // to do it here\r\n        && (!browser.isFirefox()\r\n            || this.options.enableFirefoxSimulcast);\r\n};\r\n\r\n/**\r\n * Handles {@link SignalingEvents.PEER_VIDEO_TYPE_CHANGED}\r\n * @param {string} endpointId the video owner's ID (MUC nickname)\r\n * @param {VideoType} videoType the new value\r\n * @private\r\n */\r\nTraceablePeerConnection.prototype._peerVideoTypeChanged = function(\r\n        endpointId,\r\n        videoType) {\r\n    // Check if endpointId has a value to avoid action on random track\r\n    if (!endpointId) {\r\n        logger.error(`No endpointID on peerVideoTypeChanged ${this}`);\r\n\r\n        return;\r\n    }\r\n    const videoTrack = this.getRemoteTracks(endpointId, MediaType.VIDEO);\r\n\r\n    if (videoTrack.length) {\r\n        // NOTE 1 track per media type is assumed\r\n        videoTrack[0]._setVideoType(videoType);\r\n    }\r\n};\r\n\r\n/**\r\n * Handles remote track mute / unmute events.\r\n * @param {string} endpointId the track owner's identifier (MUC nickname)\r\n * @param {MediaType} mediaType \"audio\" or \"video\"\r\n * @param {boolean} isMuted the new mute state\r\n * @private\r\n */\r\nTraceablePeerConnection.prototype._peerMutedChanged = function(\r\n        endpointId,\r\n        mediaType,\r\n        isMuted) {\r\n    // Check if endpointId is a value to avoid doing action on all remote tracks\r\n    if (!endpointId) {\r\n        logger.error('On peerMuteChanged - no endpoint ID');\r\n\r\n        return;\r\n    }\r\n    const track = this.getRemoteTracks(endpointId, mediaType);\r\n\r\n    if (track.length) {\r\n        // NOTE 1 track per media type is assumed\r\n        track[0].setMute(isMuted);\r\n    }\r\n};\r\n\r\n/**\r\n * Obtains local tracks for given {@link MediaType}. If the <tt>mediaType</tt>\r\n * argument is omitted the list of all local tracks will be returned.\r\n * @param {MediaType} [mediaType]\r\n * @return {Array<QHSenseLocalTrack>}\r\n */\r\nTraceablePeerConnection.prototype.getLocalTracks = function(mediaType) {\r\n    let tracks = Array.from(this.localTracks.values());\r\n\r\n    if (mediaType !== undefined) {\r\n        tracks = tracks.filter(track => track.getType() === mediaType);\r\n    }\r\n\r\n    return tracks;\r\n};\r\n\r\n/**\r\n * Checks whether or not this {@link TraceablePeerConnection} instance contains\r\n * any local tracks for given <tt>mediaType</tt>.\r\n * @param {MediaType} mediaType\r\n * @return {boolean}\r\n */\r\nTraceablePeerConnection.prototype.hasAnyTracksOfType = function(mediaType) {\r\n    if (!mediaType) {\r\n        throw new Error('\"mediaType\" is required');\r\n    }\r\n\r\n    return this.getLocalTracks(mediaType).length > 0;\r\n};\r\n\r\n/**\r\n * Obtains all remote tracks currently known to this PeerConnection instance.\r\n * @param {string} [endpointId] the track owner's identifier (MUC nickname)\r\n * @param {MediaType} [mediaType] the remote tracks will be filtered\r\n * by their media type if this argument is specified.\r\n * @return {Array<QHSenseRemoteTrack>}\r\n */\r\nTraceablePeerConnection.prototype.getRemoteTracks = function(\r\n        endpointId,\r\n        mediaType) {\r\n    const remoteTracks = [];\r\n    const endpoints\r\n        = endpointId ? [ endpointId ] : this.remoteTracks.keys();\r\n\r\n    for (const endpoint of endpoints) {\r\n        const endpointTrackMap = this.remoteTracks.get(endpoint);\r\n\r\n        if (!endpointTrackMap) {\r\n\r\n            // Otherwise an empty Map() would have to be allocated above\r\n            // eslint-disable-next-line no-continue\r\n            continue;\r\n        }\r\n\r\n        for (const trackMediaType of endpointTrackMap.keys()) {\r\n            // per media type filtering\r\n            if (!mediaType || mediaType === trackMediaType) {\r\n                const mediaTrack = endpointTrackMap.get(trackMediaType);\r\n\r\n                if (mediaTrack) {\r\n                    remoteTracks.push(mediaTrack);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return remoteTracks;\r\n};\r\n\r\n/**\r\n * Tries to find {@link QHSenseTrack} for given SSRC number. It will search both\r\n * local and remote tracks bound to this instance.\r\n * @param {number} ssrc\r\n * @return {QHSenseTrack|null}\r\n */\r\nTraceablePeerConnection.prototype.getTrackBySSRC = function(ssrc) {\r\n    if (typeof ssrc !== 'number') {\r\n        throw new Error(`SSRC ${ssrc} is not a number`);\r\n    }\r\n    for (const localTrack of this.localTracks.values()) {\r\n        if (this.getLocalSSRC(localTrack) === ssrc) {\r\n            return localTrack;\r\n        }\r\n    }\r\n    for (const remoteTrack of this.getRemoteTracks()) {\r\n        if (remoteTrack.getSSRC() === ssrc) {\r\n            return remoteTrack;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Tries to find SSRC number for given {@link QHSenseTrack} id. It will search\r\n * both local and remote tracks bound to this instance.\r\n * @param {string} id\r\n * @return {number|null}\r\n */\r\nTraceablePeerConnection.prototype.getSsrcByTrackId = function(id) {\r\n\r\n    const findTrackById = track => track.getTrack().id === id;\r\n    const localTrack = this.getLocalTracks().find(findTrackById);\r\n\r\n    if (localTrack) {\r\n        return this.getLocalSSRC(localTrack);\r\n    }\r\n\r\n    const remoteTrack = this.getRemoteTracks().find(findTrackById);\r\n\r\n    if (remoteTrack) {\r\n        return remoteTrack.getSSRC();\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Called when new remote MediaStream is added to the PeerConnection.\r\n * @param {MediaStream} stream the WebRTC MediaStream for remote participant\r\n */\r\nTraceablePeerConnection.prototype._remoteStreamAdded = function(stream) {\r\n    const streamId = RTC.getStreamID(stream);\r\n\r\n    if (!RTC.isUserStreamById(streamId)) {\r\n        logger.info(\r\n            `${this} ignored remote 'stream added' event for non-user stream`\r\n             + `id: ${streamId}`);\r\n\r\n        return;\r\n    }\r\n\r\n    // Bind 'addtrack'/'removetrack' event handlers\r\n    if (browser.isChromiumBased() || browser.isEdge()) {\r\n        stream.onaddtrack = event => {\r\n            this._remoteTrackAdded(stream, event.track);\r\n        };\r\n        stream.onremovetrack = event => {\r\n            this._remoteTrackRemoved(stream, event.track);\r\n        };\r\n    }\r\n\r\n    // Call remoteTrackAdded for each track in the stream\r\n    const streamAudioTracks = stream.getAudioTracks();\r\n\r\n    for (const audioTrack of streamAudioTracks) {\r\n        this._remoteTrackAdded(stream, audioTrack);\r\n    }\r\n    const streamVideoTracks = stream.getVideoTracks();\r\n\r\n    for (const videoTrack of streamVideoTracks) {\r\n        this._remoteTrackAdded(stream, videoTrack);\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * Called on \"track added\" and \"stream added\" PeerConnection events (because we\r\n * handle streams on per track basis). Finds the owner and the SSRC for\r\n * the track and passes that to ChatRoom for further processing.\r\n * @param {MediaStream} stream the WebRTC MediaStream instance which is\r\n * the parent of the track\r\n * @param {MediaStreamTrack} track the WebRTC MediaStreamTrack added for remote\r\n * participant\r\n */\r\nTraceablePeerConnection.prototype._remoteTrackAdded = function(stream, track) {\r\n    const streamId = RTC.getStreamID(stream);\r\n    const mediaType = track.kind;\r\n\r\n    logger.info(`${this} remote track added:`, streamId, mediaType);\r\n\r\n    // look up an associated JID for a stream id\r\n    if (!mediaType) {\r\n        GlobalOnErrorHandler.callErrorHandler(\r\n            new Error(\r\n                `MediaType undefined for remote track, stream id: ${streamId}`\r\n            ));\r\n\r\n        // Abort\r\n        return;\r\n    }\r\n\r\n    const remoteSDP = new SDP(this.remoteDescription.sdp);\r\n    const mediaLines\r\n        = remoteSDP.media.filter(mls => mls.startsWith(`m=${mediaType}`));\r\n\r\n    if (!mediaLines.length) {\r\n        GlobalOnErrorHandler.callErrorHandler(\r\n            new Error(\r\n                `No media lines for type ${\r\n                    mediaType} found in remote SDP for remote track: ${\r\n                    streamId}`));\r\n\r\n        // Abort\r\n        return;\r\n    }\r\n\r\n    let ssrcLines = SDPUtil.findLines(mediaLines[0], 'a=ssrc:');\r\n\r\n    ssrcLines\r\n        = ssrcLines.filter(line => line.indexOf(`msid:${streamId}`) !== -1);\r\n    if (!ssrcLines.length) {\r\n        GlobalOnErrorHandler.callErrorHandler(\r\n            new Error(\r\n                `No SSRC lines for streamId ${\r\n                    streamId} for remote track, media type: ${mediaType}`));\r\n\r\n        // Abort\r\n        return;\r\n    }\r\n\r\n    // FIXME the length of ssrcLines[0] not verified, but it will fail\r\n    // with global error handler anyway\r\n    const ssrcStr = ssrcLines[0].substring(7).split(' ')[0];\r\n    const trackSsrc = Number(ssrcStr);\r\n    const ownerEndpointId = this.signalingLayer.getSSRCOwner(trackSsrc);\r\n\r\n    if (isNaN(trackSsrc) || trackSsrc < 0) {\r\n        GlobalOnErrorHandler.callErrorHandler(\r\n            new Error(\r\n                `Invalid SSRC: ${ssrcStr} for remote track, msid: ${\r\n                    streamId} media type: ${mediaType}`));\r\n\r\n        // Abort\r\n        return;\r\n    } else if (!ownerEndpointId) {\r\n        GlobalOnErrorHandler.callErrorHandler(\r\n            new Error(\r\n                `No SSRC owner known for: ${\r\n                    trackSsrc} for remote track, msid: ${\r\n                    streamId} media type: ${mediaType}`));\r\n\r\n        // Abort\r\n        return;\r\n    }\r\n\r\n    logger.log(`${this} associated ssrc`, ownerEndpointId, trackSsrc);\r\n\r\n    const peerMediaInfo\r\n        = this.signalingLayer.getPeerMediaInfo(ownerEndpointId, mediaType);\r\n\r\n    if (!peerMediaInfo) {\r\n        GlobalOnErrorHandler.callErrorHandler(\r\n            new Error(\r\n                `${this}: no peer media info available for ${\r\n                    ownerEndpointId}`));\r\n\r\n        return;\r\n    }\r\n\r\n    const muted = peerMediaInfo.muted;\r\n    const videoType = peerMediaInfo.videoType; // can be undefined\r\n\r\n    this._createRemoteTrack(\r\n        ownerEndpointId, stream, track, mediaType, videoType, trackSsrc, muted);\r\n};\r\n\r\n// FIXME cleanup params\r\n/* eslint-disable max-params */\r\n\r\n/**\r\n * Initializes a new QHSenseRemoteTrack instance with the data provided by\r\n * the signaling layer and SDP.\r\n *\r\n * @param {string} ownerEndpointId the owner's endpoint ID (MUC nickname)\r\n * @param {MediaStream} stream the WebRTC stream instance\r\n * @param {MediaStreamTrack} track the WebRTC track instance\r\n * @param {MediaType} mediaType the track's type of the media\r\n * @param {VideoType} [videoType] the track's type of the video (if applicable)\r\n * @param {number} ssrc the track's main SSRC number\r\n * @param {boolean} muted the initial muted status\r\n */\r\nTraceablePeerConnection.prototype._createRemoteTrack = function(\r\n        ownerEndpointId,\r\n        stream,\r\n        track,\r\n        mediaType,\r\n        videoType,\r\n        ssrc,\r\n        muted) {\r\n    let remoteTracksMap = this.remoteTracks.get(ownerEndpointId);\r\n\r\n    if (!remoteTracksMap) {\r\n        remoteTracksMap = new Map();\r\n        this.remoteTracks.set(ownerEndpointId, remoteTracksMap);\r\n    }\r\n\r\n    const existingTrack = remoteTracksMap.get(mediaType);\r\n\r\n    if (existingTrack && existingTrack.getTrack() === track) {\r\n        // Ignore duplicated event which can originate either from\r\n        // 'onStreamAdded' or 'onTrackAdded'.\r\n        logger.info(\r\n            `${this} ignored duplicated remote track added event for: `\r\n                + `${ownerEndpointId}, ${mediaType}`);\r\n\r\n        return;\r\n    } else if (existingTrack) {\r\n        logger.error(\r\n            `${this} overwriting remote track for`\r\n                + `${ownerEndpointId} ${mediaType}`);\r\n    }\r\n\r\n    const remoteTrack\r\n        = new QHSenseRemoteTrack(\r\n                this.rtc,\r\n                this.rtc.conference,\r\n                ownerEndpointId,\r\n                stream,\r\n                track,\r\n                mediaType,\r\n                videoType,\r\n                ssrc,\r\n                muted,\r\n                this.isP2P);\r\n\r\n    remoteTracksMap.set(mediaType, remoteTrack);\r\n\r\n    this.eventEmitter.emit(RTCEvents.REMOTE_TRACK_ADDED, remoteTrack);\r\n};\r\n\r\n/* eslint-enable max-params */\r\n\r\n/**\r\n * Handles remote stream removal.\r\n * @param stream the WebRTC MediaStream object which is being removed from the\r\n * PeerConnection\r\n */\r\nTraceablePeerConnection.prototype._remoteStreamRemoved = function(stream) {\r\n    if (!RTC.isUserStream(stream)) {\r\n        const id = RTC.getStreamID(stream);\r\n\r\n        logger.info(\r\n            `Ignored remote 'stream removed' event for non-user stream ${id}`);\r\n\r\n        return;\r\n    }\r\n\r\n    // Call remoteTrackRemoved for each track in the stream\r\n    const streamVideoTracks = stream.getVideoTracks();\r\n\r\n    for (const videoTrack of streamVideoTracks) {\r\n        this._remoteTrackRemoved(stream, videoTrack);\r\n    }\r\n    const streamAudioTracks = stream.getAudioTracks();\r\n\r\n    for (const audioTrack of streamAudioTracks) {\r\n        this._remoteTrackRemoved(stream, audioTrack);\r\n    }\r\n};\r\n\r\n/**\r\n * Handles remote media track removal.\r\n * @param {MediaStream} stream WebRTC MediaStream instance which is the parent\r\n * of the track.\r\n * @param {MediaStreamTrack} track the WebRTC MediaStreamTrack which has been\r\n * removed from the PeerConnection.\r\n */\r\nTraceablePeerConnection.prototype._remoteTrackRemoved = function(\r\n        stream,\r\n        track) {\r\n    const streamId = RTC.getStreamID(stream);\r\n    const trackId = track && RTC.getTrackID(track);\r\n\r\n    logger.info(`${this} - remote track removed: ${streamId}, ${trackId}`);\r\n\r\n    if (!streamId) {\r\n        GlobalOnErrorHandler.callErrorHandler(\r\n            new Error(`${this} remote track removal failed - no stream ID`));\r\n\r\n        return;\r\n    }\r\n\r\n    if (!trackId) {\r\n        GlobalOnErrorHandler.callErrorHandler(\r\n            new Error(`${this} remote track removal failed - no track ID`));\r\n\r\n        return;\r\n    }\r\n\r\n    if (!this._removeRemoteTrackById(streamId, trackId)) {\r\n        // NOTE this warning is always printed when user leaves the room,\r\n        // because we remove remote tracks manually on MUC member left event,\r\n        // before the SSRCs are removed by Jicofo. In most cases it is fine to\r\n        // ignore this warning, but still it's better to keep it printed for\r\n        // debugging purposes.\r\n        //\r\n        // We could change the behaviour to emit track removed only from here,\r\n        // but the order of the events will change and consuming apps could\r\n        // behave unexpectedly (the \"user left\" event would come before \"track\r\n        // removed\" events).\r\n        logger.warn(\r\n            `${this} Removed track not found for msid: ${streamId},\r\n             track id: ${trackId}`);\r\n    }\r\n};\r\n\r\n/**\r\n * Finds remote track by it's stream and track ids.\r\n * @param {string} streamId the media stream id as defined by the WebRTC\r\n * @param {string} trackId the media track id as defined by the WebRTC\r\n * @return {QHSenseRemoteTrack|undefined} the track's instance or\r\n * <tt>undefined</tt> if not found.\r\n * @private\r\n */\r\nTraceablePeerConnection.prototype._getRemoteTrackById = function(\r\n        streamId,\r\n        trackId) {\r\n    // .find will break the loop once the first match is found\r\n    for (const endpointTrackMap of this.remoteTracks.values()) {\r\n        for (const mediaTrack of endpointTrackMap.values()) {\r\n            // FIXME verify and try to use ===\r\n            /* eslint-disable eqeqeq */\r\n            if (mediaTrack.getStreamId() == streamId\r\n                && mediaTrack.getTrackId() == trackId) {\r\n                return mediaTrack;\r\n            }\r\n\r\n            /* eslint-enable eqeqeq */\r\n        }\r\n    }\r\n\r\n    return undefined;\r\n};\r\n\r\n/**\r\n * Removes all QHSenseRemoteTracks associated with given MUC nickname\r\n * (resource part of the JID). Returns array of removed tracks.\r\n *\r\n * @param {string} owner - The resource part of the MUC JID.\r\n * @returns {QHSenseRemoteTrack[]}\r\n */\r\nTraceablePeerConnection.prototype.removeRemoteTracks = function(owner) {\r\n    const removedTracks = [];\r\n    const remoteTracksMap = this.remoteTracks.get(owner);\r\n\r\n    if (remoteTracksMap) {\r\n        const removedAudioTrack = remoteTracksMap.get(MediaType.AUDIO);\r\n        const removedVideoTrack = remoteTracksMap.get(MediaType.VIDEO);\r\n\r\n        removedAudioTrack && removedTracks.push(removedAudioTrack);\r\n        removedVideoTrack && removedTracks.push(removedVideoTrack);\r\n\r\n        this.remoteTracks.delete(owner);\r\n    }\r\n\r\n    logger.debug(\r\n        `${this} removed remote tracks for ${owner} count: ${\r\n            removedTracks.length}`);\r\n\r\n    return removedTracks;\r\n};\r\n\r\n/**\r\n * Removes and disposes given <tt>QHSenseRemoteTrack</tt> instance. Emits\r\n * {@link RTCEvents.REMOTE_TRACK_REMOVED}.\r\n * @param {QHSenseRemoteTrack} toBeRemoved\r\n */\r\nTraceablePeerConnection.prototype._removeRemoteTrack = function(toBeRemoved) {\r\n    toBeRemoved.dispose();\r\n    const participantId = toBeRemoved.getParticipantId();\r\n    const remoteTracksMap = this.remoteTracks.get(participantId);\r\n\r\n    if (!remoteTracksMap) {\r\n        logger.error(\r\n            `removeRemoteTrack: no remote tracks map for ${participantId}`);\r\n    } else if (!remoteTracksMap.delete(toBeRemoved.getType())) {\r\n        logger.error(\r\n            `Failed to remove ${toBeRemoved} - type mapping messed up ?`);\r\n    }\r\n    this.eventEmitter.emit(RTCEvents.REMOTE_TRACK_REMOVED, toBeRemoved);\r\n};\r\n\r\n/**\r\n * Removes and disposes <tt>QHSenseRemoteTrack</tt> identified by given stream and\r\n * track ids.\r\n *\r\n * @param {string} streamId the media stream id as defined by the WebRTC\r\n * @param {string} trackId the media track id as defined by the WebRTC\r\n * @returns {QHSenseRemoteTrack|undefined} the track which has been removed or\r\n * <tt>undefined</tt> if no track matching given stream and track ids was\r\n * found.\r\n */\r\nTraceablePeerConnection.prototype._removeRemoteTrackById = function(\r\n        streamId,\r\n        trackId) {\r\n    const toBeRemoved = this._getRemoteTrackById(streamId, trackId);\r\n\r\n    if (toBeRemoved) {\r\n        this._removeRemoteTrack(toBeRemoved);\r\n    }\r\n\r\n    return toBeRemoved;\r\n};\r\n\r\n/**\r\n * @typedef {Object} SSRCGroupInfo\r\n * @property {Array<number>} ssrcs group's SSRCs\r\n * @property {string} semantics\r\n */\r\n/**\r\n * @typedef {Object} TrackSSRCInfo\r\n * @property {Array<number>} ssrcs track's SSRCs\r\n * @property {Array<SSRCGroupInfo>} groups track's SSRC groups\r\n */\r\n/**\r\n * Returns map with keys msid and <tt>TrackSSRCInfo</tt> values.\r\n * @param {Object} desc the WebRTC SDP instance.\r\n * @return {Map<string,TrackSSRCInfo>}\r\n */\r\nfunction extractSSRCMap(desc) {\r\n    /**\r\n     * Track SSRC infos mapped by stream ID (msid)\r\n     * @type {Map<string,TrackSSRCInfo>}\r\n     */\r\n    const ssrcMap = new Map();\r\n\r\n    /**\r\n     * Groups mapped by primary SSRC number\r\n     * @type {Map<number,Array<SSRCGroupInfo>>}\r\n     */\r\n    const groupsMap = new Map();\r\n\r\n    if (typeof desc !== 'object' || desc === null\r\n        || typeof desc.sdp !== 'string') {\r\n        logger.warn('An empty description was passed as an argument.');\r\n\r\n        return ssrcMap;\r\n    }\r\n\r\n    const session = transform.parse(desc.sdp);\r\n\r\n    if (!Array.isArray(session.media)) {\r\n        return ssrcMap;\r\n    }\r\n\r\n    for (const mLine of session.media) {\r\n        if (!Array.isArray(mLine.ssrcs)) {\r\n            continue; // eslint-disable-line no-continue\r\n        }\r\n\r\n        if (Array.isArray(mLine.ssrcGroups)) {\r\n            for (const group of mLine.ssrcGroups) {\r\n                if (typeof group.semantics !== 'undefined'\r\n                    && typeof group.ssrcs !== 'undefined') {\r\n                    // Parse SSRCs and store as numbers\r\n                    const groupSSRCs\r\n                        = group.ssrcs.split(' ').map(\r\n                            ssrcStr => parseInt(ssrcStr, 10));\r\n                    const primarySSRC = groupSSRCs[0];\r\n\r\n                    // Note that group.semantics is already present\r\n\r\n                    group.ssrcs = groupSSRCs;\r\n\r\n                    // eslint-disable-next-line max-depth\r\n                    if (!groupsMap.has(primarySSRC)) {\r\n                        groupsMap.set(primarySSRC, []);\r\n                    }\r\n                    groupsMap.get(primarySSRC).push(group);\r\n                }\r\n            }\r\n        }\r\n        for (const ssrc of mLine.ssrcs) {\r\n            if (ssrc.attribute !== 'msid') {\r\n                continue; // eslint-disable-line no-continue\r\n            }\r\n\r\n            const msid = ssrc.value;\r\n            let ssrcInfo = ssrcMap.get(msid);\r\n\r\n            if (!ssrcInfo) {\r\n                ssrcInfo = {\r\n                    ssrcs: [],\r\n                    groups: [],\r\n                    msid\r\n                };\r\n                ssrcMap.set(msid, ssrcInfo);\r\n            }\r\n\r\n            const ssrcNumber = ssrc.id;\r\n\r\n            ssrcInfo.ssrcs.push(ssrcNumber);\r\n\r\n            if (groupsMap.has(ssrcNumber)) {\r\n                const ssrcGroups = groupsMap.get(ssrcNumber);\r\n\r\n                for (const group of ssrcGroups) {\r\n                    ssrcInfo.groups.push(group);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return ssrcMap;\r\n}\r\n\r\n/**\r\n * Takes a SessionDescription object and returns a \"normalized\" version.\r\n * Currently it takes care of ordering the a=ssrc lines and denoting receive\r\n * only SSRCs.\r\n */\r\nconst normalizePlanB = function(desc) {\r\n    if (typeof desc !== 'object' || desc === null\r\n        || typeof desc.sdp !== 'string') {\r\n        logger.warn('An empty description was passed as an argument.');\r\n\r\n        return desc;\r\n    }\r\n\r\n    // eslint-disable-next-line no-shadow\r\n    const transform = require('sdp-transform');\r\n    const session = transform.parse(desc.sdp);\r\n\r\n    if (typeof session !== 'undefined'\r\n            && typeof session.media !== 'undefined'\r\n            && Array.isArray(session.media)) {\r\n        session.media.forEach(mLine => {\r\n\r\n            // Chrome appears to be picky about the order in which a=ssrc lines\r\n            // are listed in an m-line when rtx is enabled (and thus there are\r\n            // a=ssrc-group lines with FID semantics). Specifically if we have\r\n            // \"a=ssrc-group:FID S1 S2\" and the \"a=ssrc:S2\" lines appear before\r\n            // the \"a=ssrc:S1\" lines, SRD fails.\r\n            // So, put SSRC which appear as the first SSRC in an FID ssrc-group\r\n            // first.\r\n            const firstSsrcs = [];\r\n            const newSsrcLines = [];\r\n\r\n            if (typeof mLine.ssrcGroups !== 'undefined'\r\n                && Array.isArray(mLine.ssrcGroups)) {\r\n                mLine.ssrcGroups.forEach(group => {\r\n                    if (typeof group.semantics !== 'undefined'\r\n                        && group.semantics === 'FID') {\r\n                        if (typeof group.ssrcs !== 'undefined') {\r\n                            firstSsrcs.push(Number(group.ssrcs.split(' ')[0]));\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            if (Array.isArray(mLine.ssrcs)) {\r\n                let i;\r\n\r\n                for (i = 0; i < mLine.ssrcs.length; i++) {\r\n                    if (typeof mLine.ssrcs[i] === 'object'\r\n                        && typeof mLine.ssrcs[i].id !== 'undefined'\r\n                        && firstSsrcs.indexOf(mLine.ssrcs[i].id) >= 0) {\r\n                        newSsrcLines.push(mLine.ssrcs[i]);\r\n                        delete mLine.ssrcs[i];\r\n                    }\r\n                }\r\n\r\n                for (i = 0; i < mLine.ssrcs.length; i++) {\r\n                    if (typeof mLine.ssrcs[i] !== 'undefined') {\r\n                        newSsrcLines.push(mLine.ssrcs[i]);\r\n                    }\r\n                }\r\n\r\n                mLine.ssrcs = replaceDefaultUnifiedPlanMsid(newSsrcLines);\r\n            }\r\n        });\r\n    }\r\n\r\n    const resStr = transform.write(session);\r\n\r\n\r\n    return new RTCSessionDescription({\r\n        type: desc.type,\r\n        sdp: resStr\r\n    });\r\n};\r\n\r\n/**\r\n * Unified plan differentiates a remote track not associated with a stream using\r\n * the msid \"-\", which can incorrectly trigger an onaddstream event in plan-b.\r\n * For QHSense, these tracks are actually receive-only ssrcs. To prevent\r\n * onaddstream from firing, remove the ssrcs with msid \"-\" except the cname\r\n * line. Normally the ssrcs are not used by the client, as the bridge controls\r\n * media flow, but keep one reference to the ssrc for the p2p case.\r\n *\r\n * @param {Array<Object>} ssrcLines - The ssrc lines from a remote description.\r\n * @private\r\n * @returns {Array<Object>} ssrcLines with removed lines referencing msid \"-\".\r\n */\r\nfunction replaceDefaultUnifiedPlanMsid(ssrcLines = []) {\r\n    if (!browser.isChrome() || !browser.isVersionGreaterThan(70)) {\r\n        return ssrcLines;\r\n    }\r\n\r\n    let filteredLines = [ ...ssrcLines ];\r\n\r\n    const problematicSsrcIds = ssrcLines.filter(ssrcLine =>\r\n        ssrcLine.attribute === 'mslabel' && ssrcLine.value === '-')\r\n        .map(ssrcLine => ssrcLine.id);\r\n\r\n    problematicSsrcIds.forEach(ssrcId => {\r\n        // Find the cname which is to be modified and left in.\r\n        const cnameLine = filteredLines.find(line =>\r\n            line.id === ssrcId && line.attribute === 'cname');\r\n\r\n        cnameLine.value = `recvonly-${ssrcId}`;\r\n\r\n        // Remove all of lines for the ssrc.\r\n        filteredLines\r\n            = filteredLines.filter(line => line.id !== ssrcId);\r\n\r\n        // But re-add the cname line so there is a reference kept to the ssrc\r\n        // in the SDP.\r\n        filteredLines.push(cnameLine);\r\n    });\r\n\r\n    return filteredLines;\r\n}\r\n\r\n/**\r\n * Makes sure that both audio and video directions are configured as 'sendrecv'.\r\n * @param {Object} localDescription the SDP object as defined by WebRTC.\r\n * @param {object} options <tt>TracablePeerConnection</tt> config options.\r\n */\r\nconst enforceSendRecv = function(localDescription, options) {\r\n    if (!localDescription) {\r\n        throw new Error('No local description passed in.');\r\n    }\r\n\r\n    const transformer = new SdpTransformWrap(localDescription.sdp);\r\n    const audioMedia = transformer.selectMedia('audio');\r\n    let changed = false;\r\n\r\n    if (audioMedia && audioMedia.direction !== 'sendrecv') {\r\n        if (options.startSilent) {\r\n            audioMedia.direction = 'inactive';\r\n        } else {\r\n            audioMedia.direction = 'sendrecv';\r\n        }\r\n\r\n        changed = true;\r\n    }\r\n\r\n    const videoMedia = transformer.selectMedia('video');\r\n\r\n    if (videoMedia && videoMedia.direction !== 'sendrecv') {\r\n        videoMedia.direction = 'sendrecv';\r\n        changed = true;\r\n    }\r\n\r\n    if (changed) {\r\n        return new RTCSessionDescription({\r\n            type: localDescription.type,\r\n            sdp: transformer.toRawSDP()\r\n        });\r\n    }\r\n\r\n    return localDescription;\r\n};\r\n\r\n/**\r\n *\r\n * @param {QHSenseLocalTrack} localTrack\r\n */\r\nTraceablePeerConnection.prototype.getLocalSSRC = function(localTrack) {\r\n    const ssrcInfo = this._getSSRC(localTrack.rtcId);\r\n\r\n    return ssrcInfo && ssrcInfo.ssrcs[0];\r\n};\r\n\r\n/**\r\n * When doing unified plan simulcast, we'll have a set of ssrcs with the\r\n * same msid but no ssrc-group, since unified plan signals the simulcast\r\n * group via the a=simulcast line.  Unfortunately, Jicofo will complain\r\n * if it sees ssrcs with matching msids but no ssrc-group, so we'll inject\r\n * an ssrc-group line to make Jicofo happy.\r\n * NOTE: unlike plan B simulcast, the ssrcs in this inject ssrc-group will\r\n * NOT necessarily be in order of quality (low to high) because:\r\n * a) when translating between unified plan and plan b the order of the ssrcs\r\n * is not preserved and\r\n * b) it isn't guaranteed that firefox will give them to us in order to begin\r\n * with\r\n * @param desc A session description object (with 'type' and 'sdp' fields)\r\n * @return A session description object with its sdp field modified to\r\n * contain an inject ssrc-group for simulcast\r\n */\r\nTraceablePeerConnection.prototype._injectSsrcGroupForUnifiedSimulcast\r\n    = function(desc) {\r\n        const sdp = transform.parse(desc.sdp);\r\n        const video = sdp.media.find(mline => mline.type === 'video');\r\n\r\n        if (video.simulcast_03) {\r\n            const ssrcs = [];\r\n\r\n            video.ssrcs.forEach(ssrc => {\r\n                if (ssrc.attribute === 'msid') {\r\n                    ssrcs.push(ssrc.id);\r\n                }\r\n            });\r\n            video.ssrcGroups = video.ssrcGroups || [];\r\n            if (video.ssrcGroups.find(group => group.semantics === 'SIM')) {\r\n                // Group already exists, no need to do anything\r\n                return desc;\r\n            }\r\n            video.ssrcGroups.push({\r\n                semantics: 'SIM',\r\n                ssrcs: ssrcs.join(' ')\r\n            });\r\n        }\r\n\r\n        return new RTCSessionDescription({\r\n            type: desc.type,\r\n            sdp: transform.write(sdp)\r\n        });\r\n    };\r\n\r\n/* eslint-disable-next-line vars-on-top */\r\nconst getters = {\r\n    signalingState() {\r\n        return this.peerconnection.signalingState;\r\n    },\r\n    iceConnectionState() {\r\n        return this.peerconnection.iceConnectionState;\r\n    },\r\n    localDescription() {\r\n        let desc = this.peerconnection.localDescription;\r\n\r\n        if (!desc) {\r\n            logger.debug('getLocalDescription no localDescription found');\r\n\r\n            return {};\r\n        }\r\n\r\n        this.trace('getLocalDescription::preTransform', dumpSDP(desc));\r\n\r\n        // if we're running on FF, transform to Plan B first.\r\n        if (browser.usesUnifiedPlan()) {\r\n            desc = this.interop.toPlanB(desc);\r\n            this.trace('getLocalDescription::postTransform (Plan B)',\r\n                dumpSDP(desc));\r\n\r\n            desc = this._injectSsrcGroupForUnifiedSimulcast(desc);\r\n            this.trace('getLocalDescription::postTransform (inject ssrc group)',\r\n                dumpSDP(desc));\r\n        }\r\n\r\n        if (browser.doesVideoMuteByStreamRemove()) {\r\n            desc = this.localSdpMunger.maybeAddMutedLocalVideoTracksToSDP(desc);\r\n            logger.debug(\r\n                'getLocalDescription::postTransform (munge local SDP)', desc);\r\n        }\r\n\r\n        // What comes out of this getter will be signalled over Jingle to\r\n        // the other peer, so we need to make sure the media direction is\r\n        // 'sendrecv' because we won't change the direction later and don't want\r\n        // the other peer to think we can't send or receive.\r\n        //\r\n        // Note that the description we set in chrome does have the accurate\r\n        // direction (e.g. 'recvonly'), since that is technically what is\r\n        // happening (check setLocalDescription impl).\r\n        desc = enforceSendRecv(desc, this.options);\r\n\r\n        // See the method's doc for more info about this transformation.\r\n        desc = this.localSdpMunger.transformStreamIdentifiers(desc);\r\n\r\n        return desc;\r\n    },\r\n    remoteDescription() {\r\n        let desc = this.peerconnection.remoteDescription;\r\n\r\n        this.trace('getRemoteDescription::preTransform', dumpSDP(desc));\r\n\r\n        // if we're running on FF, transform to Plan B first.\r\n        if (browser.usesUnifiedPlan()) {\r\n            desc = this.interop.toPlanB(desc);\r\n            this.trace(\r\n                'getRemoteDescription::postTransform (Plan B)', dumpSDP(desc));\r\n        }\r\n\r\n        return desc || {};\r\n    }\r\n};\r\n\r\nObject.keys(getters).forEach(prop => {\r\n    Object.defineProperty(\r\n        TraceablePeerConnection.prototype,\r\n        prop, {\r\n            get: getters[prop]\r\n        }\r\n    );\r\n});\r\n\r\nTraceablePeerConnection.prototype._getSSRC = function(rtcId) {\r\n    return this.localSSRCs.get(rtcId);\r\n};\r\n\r\n/**\r\n * Add {@link QHSenseLocalTrack} to this TPC.\r\n * @param {QHSenseLocalTrack} track\r\n */\r\nTraceablePeerConnection.prototype.addTrack = function(track) {\r\n    const rtcId = track.rtcId;\r\n\r\n    logger.info(`add ${track} to: ${this}`);\r\n\r\n    if (this.localTracks.has(rtcId)) {\r\n        logger.error(`${track} is already in ${this}`);\r\n\r\n        return;\r\n    }\r\n\r\n    this.localTracks.set(rtcId, track);\r\n\r\n    const webrtcStream = track.getOriginalStream();\r\n\r\n    if (webrtcStream) {\r\n        this._addStream(webrtcStream);\r\n\r\n    // It's not ok for a track to not have a WebRTC stream if:\r\n    } else if (!browser.doesVideoMuteByStreamRemove()\r\n                || track.isAudioTrack()\r\n                || (track.isVideoTrack() && !track.isMuted())) {\r\n        logger.error(`${this} no WebRTC stream for: ${track}`);\r\n    }\r\n\r\n    // Muted video tracks do not have WebRTC stream\r\n    if (browser.doesVideoMuteByStreamRemove()\r\n            && track.isVideoTrack() && track.isMuted()) {\r\n        const ssrcInfo = this.generateNewStreamSSRCInfo(track);\r\n\r\n        this.sdpConsistency.setPrimarySsrc(ssrcInfo.ssrcs[0]);\r\n        const simGroup\r\n            = ssrcInfo.groups.find(groupInfo => groupInfo.semantics === 'SIM');\r\n\r\n        if (simGroup) {\r\n            this.simulcast.setSsrcCache(simGroup.ssrcs);\r\n        }\r\n        const fidGroups\r\n            = ssrcInfo.groups.filter(\r\n                groupInfo => groupInfo.semantics === 'FID');\r\n\r\n        if (fidGroups) {\r\n            const rtxSsrcMapping = new Map();\r\n\r\n            fidGroups.forEach(fidGroup => {\r\n                const primarySsrc = fidGroup.ssrcs[0];\r\n                const rtxSsrc = fidGroup.ssrcs[1];\r\n\r\n                rtxSsrcMapping.set(primarySsrc, rtxSsrc);\r\n            });\r\n            this.rtxModifier.setSsrcCache(rtxSsrcMapping);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Adds local track as part of the unmute operation.\r\n * @param {QHSenseLocalTrack} track the track to be added as part of the unmute\r\n * operation\r\n * @return {boolean} <tt>true</tt> if the state of underlying PC has changed and\r\n * the renegotiation is required or <tt>false</tt> otherwise.\r\n */\r\nTraceablePeerConnection.prototype.addTrackUnmute = function(track) {\r\n    if (!this._assertTrackBelongs('addTrackUnmute', track)) {\r\n        // Abort\r\n        return false;\r\n    }\r\n\r\n    logger.info(`Adding ${track} as unmute to ${this}`);\r\n    const webRtcStream = track.getOriginalStream();\r\n\r\n    if (!webRtcStream) {\r\n        logger.error(\r\n            `Unable to add ${track} as unmute to ${this} - no WebRTC stream`);\r\n\r\n        return false;\r\n    }\r\n    this._addStream(webRtcStream);\r\n\r\n    return true;\r\n};\r\n\r\n/**\r\n * Adds WebRTC media stream to the underlying PeerConnection\r\n * @param {MediaStream} mediaStream\r\n * @private\r\n */\r\nTraceablePeerConnection.prototype._addStream = function(mediaStream) {\r\n    this.peerconnection.addStream(mediaStream);\r\n    this._addedStreams.push(mediaStream);\r\n};\r\n\r\n/**\r\n * Removes WebRTC media stream from the underlying PeerConection\r\n * @param {MediaStream} mediaStream\r\n */\r\nTraceablePeerConnection.prototype._removeStream = function(mediaStream) {\r\n    if (browser.supportsRtpSender()) {\r\n        this._handleSenderRemoveStream(mediaStream);\r\n    } else {\r\n        this.peerconnection.removeStream(mediaStream);\r\n    }\r\n    this._addedStreams\r\n        = this._addedStreams.filter(stream => stream !== mediaStream);\r\n};\r\n\r\n/**\r\n * This method when called will check if given <tt>localTrack</tt> belongs to\r\n * this TPC (that it has been previously added using {@link addTrack}). If the\r\n * track does not belong an error message will be logged.\r\n * @param {string} methodName the method name that will be logged in an error\r\n * message\r\n * @param {QHSenseLocalTrack} localTrack\r\n * @return {boolean} <tt>true</tt> if given local track belongs to this TPC or\r\n * <tt>false</tt> otherwise.\r\n * @private\r\n */\r\nTraceablePeerConnection.prototype._assertTrackBelongs = function(\r\n        methodName,\r\n        localTrack) {\r\n    const doesBelong = this.localTracks.has(localTrack.rtcId);\r\n\r\n    if (!doesBelong) {\r\n        logger.error(\r\n            `${methodName}: ${localTrack} does not belong to ${this}`);\r\n    }\r\n\r\n    return doesBelong;\r\n};\r\n\r\n/**\r\n * Tells if the given WebRTC <tt>MediaStream</tt> has been added to\r\n * the underlying WebRTC PeerConnection.\r\n * @param {MediaStream} mediaStream\r\n * @returns {boolean}\r\n */\r\nTraceablePeerConnection.prototype.isMediaStreamInPc = function(mediaStream) {\r\n    return this._addedStreams.indexOf(mediaStream) > -1;\r\n};\r\n\r\n/**\r\n * Remove local track from this TPC.\r\n * @param {QHSenseLocalTrack} localTrack the track to be removed from this TPC.\r\n *\r\n * FIXME It should probably remove a boolean just like {@link removeTrackMute}\r\n *       The same applies to addTrack.\r\n */\r\nTraceablePeerConnection.prototype.removeTrack = function(localTrack) {\r\n    const webRtcStream = localTrack.getOriginalStream();\r\n\r\n    this.trace(\r\n        'removeStream',\r\n        localTrack.rtcId, webRtcStream ? webRtcStream.id : undefined);\r\n\r\n    if (!this._assertTrackBelongs('removeStream', localTrack)) {\r\n        // Abort - nothing to be done here\r\n        return;\r\n    }\r\n    this.localTracks.delete(localTrack.rtcId);\r\n    this.localSSRCs.delete(localTrack.rtcId);\r\n\r\n    if (webRtcStream) {\r\n        if (browser.supportsRtpSender()) {\r\n            this._handleSenderRemoveStream(webRtcStream);\r\n        } else {\r\n            this.peerconnection.removeStream(webRtcStream);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Returns the sender corresponding to the given MediaStream.\r\n *\r\n * @param {MediaStream} stream - The media stream used for the search.\r\n * @returns {RTPSender|undefined} - The found sender or undefined if no sender\r\n * was found.\r\n */\r\nTraceablePeerConnection.prototype.findSenderByStream = function(stream) {\r\n    const track = stream.getTracks()[0];\r\n\r\n    if (!track) {\r\n        logger.error('Cannot find sender: no tracks.');\r\n\r\n        return;\r\n    }\r\n\r\n    // Find the right sender (for audio or video)\r\n    return this.peerconnection.getSenders().find(s => s.track === track);\r\n};\r\n\r\n/**\r\n * Replaces <tt>oldTrack</tt> with <tt>newTrack</tt> from the peer connection.\r\n * Either <tt>oldTrack</tt> or <tt>newTrack</tt> can be null; replacing a valid\r\n * <tt>oldTrack</tt> with a null <tt>newTrack</tt> effectively just removes\r\n * <tt>oldTrack</tt>\r\n *\r\n * @param {QHSenseLocalTrack|null} oldTrack - The current track in use to be\r\n * replaced\r\n * @param {QHSenseLocalTrack|null} newTrack - The new track to use\r\n * @returns {Promise<boolean>} - If the promise resolves with true,\r\n * renegotiation will be needed. Otherwise no renegotiation is needed.\r\n */\r\nTraceablePeerConnection.prototype.replaceTrack = function(oldTrack, newTrack) {\r\n    if (browser.supportsRtpSender() && oldTrack && newTrack) {\r\n        // Add and than remove stream in FF leads to wrong local SDP. In order\r\n        // to workaround the issue we need to use sender.replaceTrack().\r\n        const sender = this.findSenderByStream(oldTrack.getOriginalStream());\r\n        const stream = newTrack.getOriginalStream();\r\n\r\n        if (sender && stream) {\r\n            const track = stream.getTracks()[0];\r\n\r\n            if (track) {\r\n                return sender.replaceTrack(track, stream).then(() => {\r\n                    // Since there is no need to do renegotiations we need to\r\n                    // fix all ssrc-msid mappings here.\r\n                    // NOTE: after sender.replaceTrack the sdp will remain the\r\n                    // same but the stream attach to the new QHSenseLocalTrack\r\n                    // will have different msid. Luckily on FF we are not doing\r\n                    // all the transformations related to video mute.\r\n\r\n                    const ssrc = this.localSSRCs.get(oldTrack.rtcId);\r\n\r\n                    this.localTracks.delete(oldTrack.rtcId);\r\n                    this.localSSRCs.delete(oldTrack.rtcId);\r\n                    this._addedStreams\r\n                        = this._addedStreams.filter(s => s !== stream);\r\n\r\n                    this.localTracks.set(newTrack.rtcId, newTrack);\r\n\r\n                    // Override the msid of QHSenseLocalTrack in order to be\r\n                    // consistent with the SDP values.\r\n                    newTrack.storedMSID = oldTrack.storedMSID;\r\n                    this._addedStreams.push(stream);\r\n\r\n                    this.localSSRCs.set(newTrack.rtcId, ssrc);\r\n                    this.eventEmitter.emit(\r\n                        RTCEvents.LOCAL_TRACK_SSRC_UPDATED,\r\n                        newTrack,\r\n                        extractPrimarySSRC(ssrc));\r\n\r\n                    return false;\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    if (oldTrack) {\r\n        this.removeTrack(oldTrack);\r\n    }\r\n    if (newTrack) {\r\n        this.addTrack(newTrack);\r\n    }\r\n\r\n    return Promise.resolve(true);\r\n};\r\n\r\n/**\r\n * Removes local track as part of the mute operation.\r\n * @param {QHSenseLocalTrack} localTrack the local track to be remove as part of\r\n * the mute operation.\r\n * @return {boolean} <tt>true</tt> if the underlying PeerConnection's state has\r\n * changed and the renegotiation is required or <tt>false</tt> otherwise.\r\n */\r\nTraceablePeerConnection.prototype.removeTrackMute = function(localTrack) {\r\n    const webRtcStream = localTrack.getOriginalStream();\r\n\r\n    this.trace(\r\n        'removeStreamMute',\r\n        localTrack.rtcId, webRtcStream ? webRtcStream.id : null);\r\n\r\n    if (!this._assertTrackBelongs('removeStreamMute', localTrack)) {\r\n        // Abort - nothing to be done here\r\n        return false;\r\n    }\r\n\r\n    if (webRtcStream) {\r\n        logger.info(\r\n            `Removing ${localTrack} as mute from ${this}`);\r\n        this._removeStream(webRtcStream);\r\n\r\n        return true;\r\n    }\r\n\r\n    logger.error(`removeStreamMute - no WebRTC stream for ${localTrack}`);\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * Remove stream handling for browsers supporting RTPSender\r\n * @param stream: webrtc media stream\r\n */\r\nTraceablePeerConnection.prototype._handleSenderRemoveStream = function(\r\n        stream) {\r\n    if (!stream) {\r\n        // There is nothing to be changed\r\n        return;\r\n    }\r\n\r\n    const sender = this.findSenderByStream(stream);\r\n\r\n    if (sender) {\r\n        this.peerconnection.removeTrack(sender);\r\n    } else {\r\n        logger.log('Cannot remove tracks: no RTPSender.');\r\n    }\r\n};\r\n\r\nTraceablePeerConnection.prototype.createDataChannel = function(label, opts) {\r\n    this.trace('createDataChannel', label, opts);\r\n\r\n    return this.peerconnection.createDataChannel(label, opts);\r\n};\r\n\r\n/**\r\n * Ensures that the simulcast ssrc-group appears after any other ssrc-groups\r\n * in the SDP so that simulcast is properly activated.\r\n *\r\n * @param {Object} localSdp the WebRTC session description instance for\r\n * the local description.\r\n * @private\r\n */\r\nTraceablePeerConnection.prototype._ensureSimulcastGroupIsLast = function(\r\n        localSdp) {\r\n    let sdpStr = localSdp.sdp;\r\n\r\n    const videoStartIndex = sdpStr.indexOf('m=video');\r\n    const simStartIndex = sdpStr.indexOf('a=ssrc-group:SIM', videoStartIndex);\r\n    let otherStartIndex = sdpStr.lastIndexOf('a=ssrc-group');\r\n\r\n    if (simStartIndex === -1\r\n        || otherStartIndex === -1\r\n        || otherStartIndex === simStartIndex) {\r\n        return localSdp;\r\n    }\r\n\r\n    const simEndIndex = sdpStr.indexOf('\\r\\n', simStartIndex);\r\n    const simStr = sdpStr.substring(simStartIndex, simEndIndex + 2);\r\n\r\n    sdpStr = sdpStr.replace(simStr, '');\r\n    otherStartIndex = sdpStr.lastIndexOf('a=ssrc-group');\r\n    const otherEndIndex = sdpStr.indexOf('\\r\\n', otherStartIndex);\r\n    const sdpHead = sdpStr.slice(0, otherEndIndex);\r\n    const simStrTrimmed = simStr.trim();\r\n    const sdpTail = sdpStr.slice(otherEndIndex);\r\n\r\n    sdpStr = `${sdpHead}\\r\\n${simStrTrimmed}${sdpTail}`;\r\n\r\n    return new RTCSessionDescription({\r\n        type: localSdp.type,\r\n        sdp: sdpStr\r\n    });\r\n};\r\n\r\n/**\r\n * Will adjust audio and video media direction in the given SDP object to\r\n * reflect the current status of the {@link audioTransferActive} and\r\n * {@link videoTransferActive} flags.\r\n * @param {Object} localDescription the WebRTC session description instance for\r\n * the local description.\r\n * @private\r\n */\r\nTraceablePeerConnection.prototype._adjustLocalMediaDirection = function(\r\n        localDescription) {\r\n    const transformer = new SdpTransformWrap(localDescription.sdp);\r\n    let modifiedDirection = false;\r\n    const audioMedia = transformer.selectMedia('audio');\r\n\r\n    if (audioMedia) {\r\n        const desiredAudioDirection\r\n            = this._getDesiredMediaDirection(MediaType.AUDIO);\r\n\r\n        if (audioMedia.direction !== desiredAudioDirection) {\r\n            audioMedia.direction = desiredAudioDirection;\r\n            logger.info(\r\n                `Adjusted local audio direction to ${desiredAudioDirection}`);\r\n            modifiedDirection = true;\r\n        }\r\n    } else {\r\n        logger.warn('No \"audio\" media found int the local description');\r\n    }\r\n\r\n    const videoMedia = transformer.selectMedia('video');\r\n\r\n    if (videoMedia) {\r\n        const desiredVideoDirection\r\n            = this._getDesiredMediaDirection(MediaType.VIDEO);\r\n\r\n        if (videoMedia.direction !== desiredVideoDirection) {\r\n            videoMedia.direction = desiredVideoDirection;\r\n            logger.info(\r\n                `Adjusted local video direction to ${desiredVideoDirection}`);\r\n            modifiedDirection = true;\r\n        }\r\n    } else {\r\n        logger.warn('No \"video\" media found in the local description');\r\n    }\r\n\r\n    if (modifiedDirection) {\r\n        return new RTCSessionDescription({\r\n            type: localDescription.type,\r\n            sdp: transformer.toRawSDP()\r\n        });\r\n    }\r\n\r\n    return localDescription;\r\n};\r\n\r\nTraceablePeerConnection.prototype.setLocalDescription = function(description) {\r\n    let localSdp = description;\r\n\r\n    this.trace('setLocalDescription::preTransform', dumpSDP(localSdp));\r\n\r\n    if (this.options.disableH264 || this.options.preferH264) {\r\n        const parsedSdp = transform.parse(localSdp.sdp);\r\n        const videoMLine = parsedSdp.media.find(m => m.type === 'video');\r\n\r\n        if (this.options.disableH264) {\r\n            SDPUtil.stripVideoCodec(videoMLine, 'h264');\r\n        } else {\r\n            SDPUtil.preferVideoCodec(videoMLine, 'h264');\r\n        }\r\n\r\n        localSdp = new RTCSessionDescription({\r\n            type: localSdp.type,\r\n            sdp: transform.write(parsedSdp)\r\n        });\r\n\r\n        this.trace('setLocalDescription::postTransform (H264)',\r\n            dumpSDP(localSdp));\r\n    }\r\n\r\n    localSdp = this._adjustLocalMediaDirection(localSdp);\r\n\r\n    localSdp = this._ensureSimulcastGroupIsLast(localSdp);\r\n\r\n    // if we're using unified plan, transform to it first.\r\n    if (browser.usesUnifiedPlan()) {\r\n        localSdp = this.interop.toUnifiedPlan(localSdp);\r\n        this.trace(\r\n            'setLocalDescription::postTransform (Unified Plan)',\r\n            dumpSDP(localSdp));\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n        this.peerconnection.setLocalDescription(localSdp)\r\n            .then(() => {\r\n                this.trace('setLocalDescriptionOnSuccess');\r\n                const localUfrag = SDPUtil.getUfrag(localSdp.sdp);\r\n\r\n                if (localUfrag !== this.localUfrag) {\r\n                    this.localUfrag = localUfrag;\r\n                    this.eventEmitter.emit(\r\n                        RTCEvents.LOCAL_UFRAG_CHANGED, this, localUfrag);\r\n                }\r\n                resolve();\r\n            }, err => {\r\n                this.trace('setLocalDescriptionOnFailure', err);\r\n                this.eventEmitter.emit(\r\n                    RTCEvents.SET_LOCAL_DESCRIPTION_FAILED,\r\n                    err, this);\r\n                reject(err);\r\n            });\r\n    });\r\n};\r\n\r\n/**\r\n * Enables/disables audio media transmission on this peer connection. When\r\n * disabled the SDP audio media direction in the local SDP will be adjusted to\r\n * 'inactive' which means that no data will be sent nor accepted, but\r\n * the connection should be kept alive.\r\n * @param {boolean} active <tt>true</tt> to enable audio media transmission or\r\n * <tt>false</tt> to disable. If the value is not a boolean the call will have\r\n * no effect.\r\n * @return {boolean} <tt>true</tt> if the value has changed and sRD/sLD cycle\r\n * needs to be executed in order for the changes to take effect or\r\n * <tt>false</tt> if the given value was the same as the previous one.\r\n * @public\r\n */\r\nTraceablePeerConnection.prototype.setAudioTransferActive = function(active) {\r\n    logger.debug(`${this} audio transfer active: ${active}`);\r\n    const changed = this.audioTransferActive !== active;\r\n\r\n    this.audioTransferActive = active;\r\n\r\n    return changed;\r\n};\r\n\r\n/**\r\n * Takes in a *unified plan* offer and inserts the appropriate\r\n * parameters for adding simulcast receive support.\r\n * @param {Object} desc - A session description object\r\n * @param {String} desc.type - the type (offer/answer)\r\n * @param {String} desc.sdp - the sdp content\r\n *\r\n * @return {Object} A session description (same format as above) object\r\n * with its sdp field modified to advertise simulcast receive support\r\n */\r\nTraceablePeerConnection.prototype._insertUnifiedPlanSimulcastReceive\r\n    = function(desc) {\r\n        const sdp = transform.parse(desc.sdp);\r\n        const video = sdp.media.find(mline => mline.type === 'video');\r\n\r\n        // In order of lowest to highest spatial quality\r\n        video.rids = [\r\n            {\r\n                id: SIM_LAYER_1_RID,\r\n                direction: 'recv'\r\n            },\r\n            {\r\n                id: SIM_LAYER_2_RID,\r\n                direction: 'recv'\r\n            },\r\n            {\r\n                id: SIM_LAYER_3_RID,\r\n                direction: 'recv'\r\n            }\r\n        ];\r\n        // eslint-disable-next-line camelcase\r\n        video.simulcast_03 = {\r\n            value: `recv rid=${SIM_LAYER_RIDS.join(';')}`\r\n        };\r\n\r\n        return new RTCSessionDescription({\r\n            type: desc.type,\r\n            sdp: transform.write(sdp)\r\n        });\r\n    };\r\n\r\nTraceablePeerConnection.prototype.setRemoteDescription = function(description) {\r\n    this.trace('setRemoteDescription::preTransform', dumpSDP(description));\r\n\r\n    // TODO the focus should squeze or explode the remote simulcast\r\n    // eslint-disable-next-line no-param-reassign\r\n    description = this.simulcast.mungeRemoteDescription(description);\r\n    this.trace(\r\n        'setRemoteDescription::postTransform (simulcast)',\r\n        dumpSDP(description));\r\n\r\n    if (this.options.preferH264) {\r\n        const parsedSdp = transform.parse(description.sdp);\r\n        const videoMLine = parsedSdp.media.find(m => m.type === 'video');\r\n\r\n        SDPUtil.preferVideoCodec(videoMLine, 'h264');\r\n\r\n        // eslint-disable-next-line no-param-reassign\r\n        description = new RTCSessionDescription({\r\n            type: description.type,\r\n            sdp: transform.write(parsedSdp)\r\n        });\r\n    }\r\n\r\n    // If the browser uses unified plan, transform to it first\r\n    if (browser.usesUnifiedPlan()) {\r\n        // eslint-disable-next-line no-param-reassign\r\n        description = new RTCSessionDescription({\r\n            type: description.type,\r\n            sdp: this.rtxModifier.stripRtx(description.sdp)\r\n        });\r\n\r\n        this.trace(\r\n            'setRemoteDescription::postTransform (stripRtx)',\r\n            dumpSDP(description));\r\n\r\n        // eslint-disable-next-line no-param-reassign\r\n        description = this.interop.toUnifiedPlan(description);\r\n        this.trace(\r\n            'setRemoteDescription::postTransform (Plan A)',\r\n            dumpSDP(description));\r\n\r\n        if (this.isSimulcastOn()) {\r\n            // eslint-disable-next-line no-param-reassign\r\n            description = this._insertUnifiedPlanSimulcastReceive(description);\r\n            this.trace(\r\n                'setRemoteDescription::postTransform (sim receive)',\r\n                dumpSDP(description));\r\n        }\r\n    } else {\r\n        // Plan B\r\n        // eslint-disable-next-line no-param-reassign\r\n        description = normalizePlanB(description);\r\n    }\r\n\r\n    // Safari WebRTC errors when no supported video codec is found in the offer.\r\n    // To prevent the error, inject H264 into the video mLine.\r\n    if (browser.isSafariWithWebrtc() && !browser.isSafariWithVP8()) {\r\n        logger.debug('Maybe injecting H264 into the remote description');\r\n\r\n        // eslint-disable-next-line no-param-reassign\r\n        description = this._injectH264IfNotPresent(description);\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n        this.peerconnection.setRemoteDescription(description)\r\n            .then(() => {\r\n                this.trace('setRemoteDescriptionOnSuccess');\r\n                const remoteUfrag = SDPUtil.getUfrag(description.sdp);\r\n\r\n                if (remoteUfrag !== this.remoteUfrag) {\r\n                    this.remoteUfrag = remoteUfrag;\r\n                    this.eventEmitter.emit(\r\n                        RTCEvents.REMOTE_UFRAG_CHANGED, this, remoteUfrag);\r\n                }\r\n                resolve();\r\n            }, err => {\r\n                this.trace('setRemoteDescriptionOnFailure', err);\r\n                this.eventEmitter.emit(\r\n                    RTCEvents.SET_REMOTE_DESCRIPTION_FAILED,\r\n                    err,\r\n                    this);\r\n                reject(err);\r\n            });\r\n    });\r\n};\r\n\r\n/**\r\n * Inserts an H264 payload into the description if not already present. This is\r\n * need for Safari WebRTC, which errors when no supported video codec is found\r\n * in the offer. Related bug reports:\r\n * https://bugs.webkit.org/show_bug.cgi?id=173141\r\n * https://bugs.chromium.org/p/webrtc/issues/detail?id=4957\r\n *\r\n * @param {RTCSessionDescription} description - An RTCSessionDescription\r\n * to inject with an H264 payload.\r\n * @private\r\n * @returns {RTCSessionDescription}\r\n */\r\nTraceablePeerConnection.prototype._injectH264IfNotPresent = function(\r\n        description) {\r\n    const parsedSdp = transform.parse(description.sdp);\r\n    const videoMLine = parsedSdp.media.find(m => m.type === 'video');\r\n\r\n    if (!videoMLine) {\r\n        logger.debug('No videoMLine found, no need to inject H264.');\r\n\r\n        return description;\r\n    }\r\n\r\n    if (videoMLine.rtp.some(rtp => rtp.codec.toLowerCase() === 'h264')) {\r\n        logger.debug('H264 codec found in video mLine, no need to inject.');\r\n\r\n        return description;\r\n    }\r\n\r\n    const { fmtp, payloads, rtp } = videoMLine;\r\n    const payloadsArray = payloads.toString().split(' ');\r\n    let dummyPayloadType;\r\n\r\n    for (let i = 127; i >= 96; i--) {\r\n        if (!payloadsArray.includes(i)) {\r\n            dummyPayloadType = i;\r\n            payloadsArray.push(i);\r\n            videoMLine.payloads = payloadsArray.join(' ');\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (typeof dummyPayloadType === 'undefined') {\r\n        logger.error('Could not find valid payload type to inject.');\r\n\r\n        return description;\r\n    }\r\n\r\n    rtp.push({\r\n        codec: 'H264',\r\n        payload: dummyPayloadType,\r\n        rate: 90000\r\n    });\r\n\r\n    fmtp.push({\r\n        config: 'level-asymmetry-allowed=1;'\r\n            + 'packetization-mode=1;'\r\n            + 'profile-level-id=42e01f',\r\n        payload: dummyPayloadType\r\n    });\r\n\r\n    logger.debug(\r\n        `Injecting H264 payload type ${dummyPayloadType} into video mLine.`);\r\n\r\n    return new RTCSessionDescription({\r\n        type: description.type,\r\n        sdp: transform.write(parsedSdp)\r\n    });\r\n};\r\n\r\n/**\r\n * Enables/disables video media transmission on this peer connection. When\r\n * disabled the SDP video media direction in the local SDP will be adjusted to\r\n * 'inactive' which means that no data will be sent nor accepted, but\r\n * the connection should be kept alive.\r\n * @param {boolean} active <tt>true</tt> to enable video media transmission or\r\n * <tt>false</tt> to disable. If the value is not a boolean the call will have\r\n * no effect.\r\n * @return {boolean} <tt>true</tt> if the value has changed and sRD/sLD cycle\r\n * needs to be executed in order for the changes to take effect or\r\n * <tt>false</tt> if the given value was the same as the previous one.\r\n * @public\r\n */\r\nTraceablePeerConnection.prototype.setVideoTransferActive = function(active) {\r\n    logger.debug(`${this} video transfer active: ${active}`);\r\n    const changed = this.videoTransferActive !== active;\r\n\r\n    this.videoTransferActive = active;\r\n\r\n    return changed;\r\n};\r\n\r\n/**\r\n * Makes the underlying TraceablePeerConnection generate new SSRC for\r\n * the recvonly video stream.\r\n */\r\nTraceablePeerConnection.prototype.generateRecvonlySsrc = function() {\r\n    const newSSRC = SDPUtil.generateSsrc();\r\n\r\n    logger.info(`${this} generated new recvonly SSRC: ${newSSRC}`);\r\n    this.sdpConsistency.setPrimarySsrc(newSSRC);\r\n};\r\n\r\n/**\r\n * Makes the underlying TraceablePeerConnection forget the current primary video\r\n * SSRC.\r\n */\r\nTraceablePeerConnection.prototype.clearRecvonlySsrc = function() {\r\n    logger.info('Clearing primary video SSRC!');\r\n    this.sdpConsistency.clearVideoSsrcCache();\r\n};\r\n\r\n/**\r\n * Closes underlying WebRTC PeerConnection instance and removes all remote\r\n * tracks by emitting {@link RTCEvents.REMOTE_TRACK_REMOVED} for each one of\r\n * them.\r\n */\r\nTraceablePeerConnection.prototype.close = function() {\r\n    this.trace('stop');\r\n\r\n    // Off SignalingEvents\r\n    this.signalingLayer.off(\r\n        SignalingEvents.PEER_MUTED_CHANGED, this._peerMutedChanged);\r\n    this.signalingLayer.off(\r\n        SignalingEvents.PEER_VIDEO_TYPE_CHANGED, this._peerVideoTypeChanged);\r\n\r\n    for (const peerTracks of this.remoteTracks.values()) {\r\n        for (const remoteTrack of peerTracks.values()) {\r\n            this._removeRemoteTrack(remoteTrack);\r\n        }\r\n    }\r\n    this.remoteTracks.clear();\r\n\r\n    this._addedStreams = [];\r\n\r\n    if (!this.rtc._removePeerConnection(this)) {\r\n        logger.error('RTC._removePeerConnection returned false');\r\n    }\r\n    if (this.statsinterval !== null) {\r\n        window.clearInterval(this.statsinterval);\r\n        this.statsinterval = null;\r\n    }\r\n    logger.info(`Closing ${this}...`);\r\n    this.peerconnection.close();\r\n};\r\n\r\n/**\r\n * Modifies the values of the setup attributes (defined by\r\n * {@link http://tools.ietf.org/html/rfc4145#section-4}) of a specific SDP\r\n * answer in order to overcome a delay of 1 second in the connection\r\n * establishment between some devices and Videobridge.\r\n *\r\n * @param {SDP} offer - the SDP offer to which the specified SDP answer is\r\n * being prepared to respond\r\n * @param {SDP} answer - the SDP to modify\r\n * @private\r\n */\r\nconst _fixAnswerRFC4145Setup = function(offer, answer) {\r\n    if (!(browser.isChromiumBased() || browser.isReactNative())) {\r\n        // It looks like Firefox doesn't agree with the fix (at least in its\r\n        // current implementation) because it effectively remains active even\r\n        // after we tell it to become passive. Apart from Firefox which I tested\r\n        // after the fix was deployed, I tested Chrome only. In order to prevent\r\n        // issues with other browsers, limit the fix to known devices for the\r\n        // time being.\r\n        return;\r\n    }\r\n\r\n    // XXX Videobridge is the (SDP) offerer and WebRTC (e.g. Chrome) is the\r\n    // answerer (as orchestrated by Jicofo). In accord with\r\n    // http://tools.ietf.org/html/rfc5245#section-5.2 and because both peers\r\n    // are ICE FULL agents, Videobridge will take on the controlling role and\r\n    // WebRTC will take on the controlled role. In accord with\r\n    // https://tools.ietf.org/html/rfc5763#section-5, Videobridge will use the\r\n    // setup attribute value of setup:actpass and WebRTC will be allowed to\r\n    // choose either the setup attribute value of setup:active or\r\n    // setup:passive. Chrome will by default choose setup:active because it is\r\n    // RECOMMENDED by the respective RFC since setup:passive adds additional\r\n    // latency. The case of setup:active allows WebRTC to send a DTLS\r\n    // ClientHello as soon as an ICE connectivity check of its succeeds.\r\n    // Unfortunately, Videobridge will be unable to respond immediately because\r\n    // may not have WebRTC's answer or may have not completed the ICE\r\n    // connectivity establishment. Even more unfortunate is that in the\r\n    // described scenario Chrome's DTLS implementation will insist on\r\n    // retransmitting its ClientHello after a second (the time is in accord\r\n    // with the respective RFC) and will thus cause the whole connection\r\n    // establishment to exceed at least 1 second. To work around Chrome's\r\n    // idiosyncracy, don't allow it to send a ClientHello i.e. change its\r\n    // default choice of setup:active to setup:passive.\r\n    if (offer && answer\r\n            && offer.media && answer.media\r\n            && offer.media.length === answer.media.length) {\r\n        answer.media.forEach((a, i) => {\r\n            if (SDPUtil.findLine(\r\n                    offer.media[i],\r\n                    'a=setup:actpass',\r\n                    offer.session)) {\r\n                answer.media[i]\r\n                    = a.replace(/a=setup:active/g, 'a=setup:passive');\r\n            }\r\n        });\r\n        answer.raw = answer.session + answer.media.join('');\r\n    }\r\n};\r\n\r\nTraceablePeerConnection.prototype.createAnswer = function(constraints) {\r\n    if (browser.isFirefox() && this.isSimulcastOn()) {\r\n        const videoSender\r\n            = this.peerconnection.getSenders().find(sender =>\r\n                sender.track !== null && sender.track.kind === 'video');\r\n        const simParams = {\r\n            encodings: [\r\n                {\r\n                    rid: SIM_LAYER_1_RID,\r\n                    scaleResolutionDownBy: 4\r\n                },\r\n                {\r\n                    rid: SIM_LAYER_2_RID,\r\n                    scaleResolutionDownBy: 2\r\n                },\r\n                {\r\n                    rid: SIM_LAYER_3_RID\r\n                }\r\n            ]\r\n        };\r\n\r\n        videoSender.setParameters(simParams);\r\n    }\r\n\r\n    return this._createOfferOrAnswer(false /* answer */, constraints);\r\n};\r\n\r\nTraceablePeerConnection.prototype.createOffer = function(constraints) {\r\n    return this._createOfferOrAnswer(true /* offer */, constraints);\r\n};\r\n\r\nTraceablePeerConnection.prototype._createOfferOrAnswer = function(\r\n        isOffer,\r\n        constraints) {\r\n    const logName = isOffer ? 'Offer' : 'Answer';\r\n\r\n    this.trace(`create${logName}`, JSON.stringify(constraints, null, ' '));\r\n\r\n    const handleSuccess = (resultSdp, resolveFn, rejectFn) => {\r\n        try {\r\n            this.trace(\r\n                `create${logName}OnSuccess::preTransform`, dumpSDP(resultSdp));\r\n\r\n            // if we're using unified plan, transform to Plan B.\r\n            if (browser.usesUnifiedPlan()) {\r\n                // eslint-disable-next-line no-param-reassign\r\n                resultSdp = this.interop.toPlanB(resultSdp);\r\n                this.trace(\r\n                    `create${logName}OnSuccess::postTransform (Plan B)`,\r\n                    dumpSDP(resultSdp));\r\n                if (this.isSimulcastOn()) {\r\n                    // eslint-disable-next-line no-param-reassign\r\n                    resultSdp\r\n                        = this._injectSsrcGroupForUnifiedSimulcast(resultSdp);\r\n                    this.trace(\r\n                        `create${logName}OnSuccess::postTransform`\r\n                        + '(inject ssrc group)', dumpSDP(resultSdp));\r\n                }\r\n            }\r\n\r\n            /**\r\n             * We don't keep ssrcs consitent for Firefox because rewriting\r\n             *  the ssrcs between createAnswer and setLocalDescription breaks\r\n             *  the caching in sdp-interop (sdp-interop must know about all\r\n             *  ssrcs, and it updates its cache in toPlanB so if we rewrite them\r\n             *  after that, when we try and go back to unified plan it will\r\n             *  complain about unmapped ssrcs)\r\n             */\r\n            if (!browser.usesUnifiedPlan()) {\r\n                // If there are no local video tracks, then a \"recvonly\"\r\n                // SSRC needs to be generated\r\n                if (!this.hasAnyTracksOfType(MediaType.VIDEO)\r\n                    && !this.sdpConsistency.hasPrimarySsrcCached()) {\r\n                    this.generateRecvonlySsrc();\r\n                }\r\n\r\n                // eslint-disable-next-line no-param-reassign\r\n                resultSdp = new RTCSessionDescription({\r\n                    type: resultSdp.type,\r\n                    sdp: this.sdpConsistency.makeVideoPrimarySsrcsConsistent(\r\n                        resultSdp.sdp)\r\n                });\r\n\r\n                this.trace(\r\n                    `create${logName}OnSuccess::postTransform `\r\n                         + '(make primary audio/video ssrcs consistent)',\r\n                    dumpSDP(resultSdp));\r\n            }\r\n\r\n            // Add simulcast streams if simulcast is enabled\r\n            if (this.isSimulcastOn()) {\r\n                // eslint-disable-next-line no-param-reassign\r\n                resultSdp = this.simulcast.mungeLocalDescription(resultSdp);\r\n                this.trace(\r\n                    `create${logName}`\r\n                        + 'OnSuccess::postTransform (simulcast)',\r\n                    dumpSDP(resultSdp));\r\n            }\r\n\r\n            if (!this.options.disableRtx && browser.supportsRtx()) {\r\n                // eslint-disable-next-line no-param-reassign\r\n                resultSdp = new RTCSessionDescription({\r\n                    type: resultSdp.type,\r\n                    sdp: this.rtxModifier.modifyRtxSsrcs(resultSdp.sdp)\r\n                });\r\n\r\n                this.trace(\r\n                    `create${logName}`\r\n                         + 'OnSuccess::postTransform (rtx modifier)',\r\n                    dumpSDP(resultSdp));\r\n            }\r\n\r\n            // Fix the setup attribute (see _fixAnswerRFC4145Setup for\r\n            //  details)\r\n            if (!isOffer) {\r\n                const remoteDescription\r\n                    = new SDP(this.remoteDescription.sdp);\r\n                const localDescription = new SDP(resultSdp.sdp);\r\n\r\n                _fixAnswerRFC4145Setup(remoteDescription, localDescription);\r\n\r\n                // eslint-disable-next-line no-param-reassign\r\n                resultSdp = new RTCSessionDescription({\r\n                    type: resultSdp.type,\r\n                    sdp: localDescription.raw\r\n                });\r\n            }\r\n\r\n            const ssrcMap = extractSSRCMap(resultSdp);\r\n\r\n            logger.debug('Got local SSRCs MAP: ', ssrcMap);\r\n            this._processLocalSSRCsMap(ssrcMap);\r\n\r\n            resolveFn(resultSdp);\r\n        } catch (e) {\r\n            this.trace(`create${logName}OnError`, e);\r\n            this.trace(`create${logName}OnError`, dumpSDP(resultSdp));\r\n            logger.error(`create${logName}OnError`, e, dumpSDP(resultSdp));\r\n\r\n            rejectFn(e);\r\n        }\r\n    };\r\n\r\n    const handleFailure = (err, rejectFn) => {\r\n        this.trace(`create${logName}OnFailure`, err);\r\n        const eventType\r\n            = isOffer\r\n                ? RTCEvents.CREATE_OFFER_FAILED\r\n                : RTCEvents.CREATE_ANSWER_FAILED;\r\n\r\n        this.eventEmitter.emit(eventType, err, this);\r\n\r\n        rejectFn(err);\r\n    };\r\n\r\n    return new Promise((resolve, reject) => {\r\n        let oaPromise;\r\n\r\n        if (isOffer) {\r\n            oaPromise = this.peerconnection.createOffer(constraints);\r\n        } else {\r\n            oaPromise = this.peerconnection.createAnswer(constraints);\r\n        }\r\n\r\n        oaPromise\r\n            .then(\r\n                sdp => handleSuccess(sdp, resolve, reject),\r\n                error => handleFailure(error, reject));\r\n    });\r\n};\r\n\r\n/**\r\n * Extract primary SSRC from given {@link TrackSSRCInfo} object.\r\n * @param {TrackSSRCInfo} ssrcObj\r\n * @return {number|null} the primary SSRC or <tt>null</tt>\r\n */\r\nfunction extractPrimarySSRC(ssrcObj) {\r\n    if (ssrcObj && ssrcObj.groups && ssrcObj.groups.length) {\r\n        return ssrcObj.groups[0].ssrcs[0];\r\n    } else if (ssrcObj && ssrcObj.ssrcs && ssrcObj.ssrcs.length) {\r\n        return ssrcObj.ssrcs[0];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Goes over the SSRC map extracted from the latest local description and tries\r\n * to match them with the local tracks (by MSID). Will update the values\r\n * currently stored in the {@link TraceablePeerConnection.localSSRCs} map.\r\n * @param {Map<string,TrackSSRCInfo>} ssrcMap\r\n * @private\r\n */\r\nTraceablePeerConnection.prototype._processLocalSSRCsMap = function(ssrcMap) {\r\n    for (const track of this.localTracks.values()) {\r\n        const trackMSID = track.storedMSID;\r\n\r\n        if (ssrcMap.has(trackMSID)) {\r\n            const newSSRC = ssrcMap.get(trackMSID);\r\n\r\n            if (!newSSRC) {\r\n                logger.error(`No SSRC found for: ${trackMSID} in ${this}`);\r\n\r\n                return;\r\n            }\r\n            const oldSSRC = this.localSSRCs.get(track.rtcId);\r\n            const newSSRCNum = extractPrimarySSRC(newSSRC);\r\n            const oldSSRCNum = extractPrimarySSRC(oldSSRC);\r\n\r\n            // eslint-disable-next-line no-negated-condition\r\n            if (newSSRCNum !== oldSSRCNum) {\r\n                if (oldSSRCNum === null) {\r\n                    logger.info(\r\n                        `Storing new local SSRC for ${track} in ${this}`,\r\n                        newSSRC);\r\n                } else {\r\n                    logger.error(\r\n                        `Overwriting SSRC for ${track} ${trackMSID} in ${this\r\n                        } with: `, newSSRC);\r\n                }\r\n                this.localSSRCs.set(track.rtcId, newSSRC);\r\n\r\n                this.eventEmitter.emit(\r\n                    RTCEvents.LOCAL_TRACK_SSRC_UPDATED, track, newSSRCNum);\r\n            } else {\r\n                logger.debug(\r\n                    `The local SSRC(${newSSRCNum}) for ${track} ${trackMSID}`\r\n                     + `is still up to date in ${this}`);\r\n            }\r\n        } else if (!track.isVideoTrack() && !track.isMuted()) {\r\n            // It is normal to find no SSRCs for a muted video track in\r\n            // the local SDP as the recv-only SSRC is no longer munged in.\r\n            // So log the warning only if it's not a muted video track.\r\n            logger.warn(`No SSRCs found in the local SDP for ${track} MSID: ${trackMSID} in ${this}`);\r\n        }\r\n    }\r\n};\r\n\r\nTraceablePeerConnection.prototype.addIceCandidate = function(candidate) {\r\n    this.trace('addIceCandidate', JSON.stringify({\r\n        candidate: candidate.candidate,\r\n        sdpMid: candidate.sdpMid,\r\n        sdpMLineIndex: candidate.sdpMLineIndex,\r\n        usernameFragment: candidate.usernameFragment\r\n    }, null, ' '));\r\n\r\n    return this.peerconnection.addIceCandidate(candidate);\r\n};\r\n\r\n/**\r\n * Obtains call-related stats from the peer connection.\r\n *\r\n * @param {Function} callback - The function to invoke after successfully\r\n * obtaining stats.\r\n * @param {Function} errback - The function to invoke after failing to obtain\r\n * stats.\r\n * @returns {void}\r\n */\r\nTraceablePeerConnection.prototype.getStats = function(callback, errback) {\r\n    // TODO (brian): After moving all browsers to adapter, check if adapter is\r\n    // accounting for different getStats apis, making the browser-checking-if\r\n    // unnecessary.\r\n    if (browser.isSafariWithWebrtc() || browser.isFirefox()\r\n            || browser.isReactNative()) {\r\n        // uses the new Promise based getStats\r\n        this.peerconnection.getStats()\r\n            .then(callback)\r\n            .catch(errback || (() => {\r\n\r\n                // Making sure that getStats won't fail if error callback is\r\n                // not passed.\r\n            }));\r\n    } else {\r\n        this.peerconnection.getStats(callback);\r\n    }\r\n};\r\n\r\n/**\r\n * Generates and stores new SSRC info object for given local track.\r\n * The method should be called only for a video track being added to this TPC\r\n * in the muted state (given that the current browser uses this strategy).\r\n * @param {QHSenseLocalTrack} track\r\n * @return {TPCSSRCInfo}\r\n */\r\nTraceablePeerConnection.prototype.generateNewStreamSSRCInfo = function(track) {\r\n    const rtcId = track.rtcId;\r\n    let ssrcInfo = this._getSSRC(rtcId);\r\n\r\n    if (ssrcInfo) {\r\n        logger.error(`Will overwrite local SSRCs for track ID: ${rtcId}`);\r\n    }\r\n    if (this.isSimulcastOn()) {\r\n        ssrcInfo = {\r\n            ssrcs: [],\r\n            groups: []\r\n        };\r\n        for (let i = 0; i < SIMULCAST_LAYERS; i++) {\r\n            ssrcInfo.ssrcs.push(SDPUtil.generateSsrc());\r\n        }\r\n        ssrcInfo.groups.push({\r\n            ssrcs: ssrcInfo.ssrcs.slice(),\r\n            semantics: 'SIM'\r\n        });\r\n    } else {\r\n        ssrcInfo = {\r\n            ssrcs: [ SDPUtil.generateSsrc() ],\r\n            groups: []\r\n        };\r\n    }\r\n    if (!this.options.disableRtx && browser.supportsRtx()) {\r\n        // Specifically use a for loop here because we'll\r\n        //  be adding to the list we're iterating over, so we\r\n        //  only want to iterate through the items originally\r\n        //  on the list\r\n        const currNumSsrcs = ssrcInfo.ssrcs.length;\r\n\r\n        for (let i = 0; i < currNumSsrcs; ++i) {\r\n            const primarySsrc = ssrcInfo.ssrcs[i];\r\n            const rtxSsrc = SDPUtil.generateSsrc();\r\n\r\n            ssrcInfo.ssrcs.push(rtxSsrc);\r\n            ssrcInfo.groups.push({\r\n                ssrcs: [ primarySsrc, rtxSsrc ],\r\n                semantics: 'FID'\r\n            });\r\n        }\r\n    }\r\n    ssrcInfo.msid = track.storedMSID;\r\n    this.localSSRCs.set(rtcId, ssrcInfo);\r\n\r\n    return ssrcInfo;\r\n};\r\n\r\nconst handleLayerSuspension = function(peerConnection, isSelected) {\r\n    if (!peerConnection.getSenders) {\r\n        logger.debug('Browser doesn\\'t support RTPSender');\r\n\r\n        return;\r\n    }\r\n\r\n    const videoSender = peerConnection.getSenders()\r\n        .find(sender => sender.track.kind === 'video');\r\n\r\n    if (!videoSender) {\r\n        logger.warn('handleLayerSuspension unable to find video sender');\r\n\r\n        return;\r\n    }\r\n    if (!videoSender.getParameters) {\r\n        logger.debug('Browser doesn\\'t support RTPSender parameters');\r\n\r\n        return;\r\n    }\r\n    const parameters = videoSender.getParameters();\r\n\r\n    if (isSelected) {\r\n        logger.debug('Currently selected, enabling all sim layers');\r\n\r\n        // Make sure all encodings are enabled\r\n        parameters.encodings.forEach(e => {\r\n            e.active = true;\r\n        });\r\n    } else {\r\n        logger.debug('Not currently selected, disabling upper layers');\r\n\r\n        // Turn off the upper simulcast layers\r\n        [ 1, 2 ].forEach(simIndex => {\r\n            if (parameters.encodings[simIndex]) {\r\n                parameters.encodings[simIndex].active = false;\r\n            }\r\n        });\r\n    }\r\n    videoSender.setParameters(parameters);\r\n};\r\n\r\n/**\r\n * Set whether or not the endpoint is 'selected' by other endpoints, meaning\r\n * it appears on their main stage\r\n */\r\nTraceablePeerConnection.prototype.setIsSelected = function(isSelected) {\r\n    if (this.options.enableLayerSuspension) {\r\n        logger.debug('Layer suspension enabled,'\r\n            + `currently selected? ${isSelected}`);\r\n        handleLayerSuspension(this.peerconnection, isSelected);\r\n    }\r\n};\r\n\r\n/**\r\n * Creates a text representation of this <tt>TraceablePeerConnection</tt>\r\n * instance.\r\n * @return {string}\r\n */\r\nTraceablePeerConnection.prototype.toString = function() {\r\n    return `TPC[${this.id},p2p:${this.isP2P}]`;\r\n};\r\n","import { createTtfmEvent } from '../../service/statistics/AnalyticsEvents';\r\nimport QHSenseTrack from './QHSenseTrack';\r\nimport * as QHSenseTrackEvents from '../../QHSenseTrackEvents';\r\nimport Statistics from '../statistics/statistics';\r\n\r\nconst logger = require('qhsense-meet-logger').getLogger(__filename);\r\nconst RTCEvents = require('../../service/RTC/RTCEvents');\r\n\r\nlet ttfmTrackerAudioAttached = false;\r\nlet ttfmTrackerVideoAttached = false;\r\n\r\n/* eslint-disable max-params */\r\n\r\n/**\r\n * Represents a single media track (either audio or video).\r\n */\r\nexport default class QHSenseRemoteTrack extends QHSenseTrack {\r\n    /**\r\n     * Creates new QHSenseRemoteTrack instance.\r\n     * @param {RTC} rtc the RTC service instance.\r\n     * @param {QHSenseConference} conference the conference to which this track\r\n     *        belongs to\r\n     * @param {string} ownerEndpointId the endpoint ID of the track owner\r\n     * @param {MediaStream} stream WebRTC MediaStream, parent of the track\r\n     * @param {MediaStreamTrack} track underlying WebRTC MediaStreamTrack for\r\n     *        the new QHSenseRemoteTrack\r\n     * @param {MediaType} mediaType the type of the media\r\n     * @param {VideoType} videoType the type of the video if applicable\r\n     * @param {number} ssrc the SSRC number of the Media Stream\r\n     * @param {boolean} muted the initial muted state\r\n     * @param {boolean} isP2P indicates whether or not this track belongs to a\r\n     * P2P session\r\n     * @throws {TypeError} if <tt>ssrc</tt> is not a number.\r\n     * @constructor\r\n     */\r\n    constructor(\r\n            rtc,\r\n            conference,\r\n            ownerEndpointId,\r\n            stream,\r\n            track,\r\n            mediaType,\r\n            videoType,\r\n            ssrc,\r\n            muted,\r\n            isP2P) {\r\n        super(\r\n            conference,\r\n            stream,\r\n            track,\r\n            () => {\r\n                // Nothing to do if the track is inactive.\r\n            },\r\n            mediaType,\r\n            videoType);\r\n        this.rtc = rtc;\r\n\r\n        // Prevent from mixing up type of SSRC which should be a number\r\n        if (typeof ssrc !== 'number') {\r\n            throw new TypeError(`SSRC ${ssrc} is not a number`);\r\n        }\r\n        this.ssrc = ssrc;\r\n        this.ownerEndpointId = ownerEndpointId;\r\n        this.muted = muted;\r\n        this.isP2P = isP2P;\r\n\r\n        // we want to mark whether the track has been ever muted\r\n        // to detect ttfm events for startmuted conferences, as it can\r\n        // significantly increase ttfm values\r\n        this.hasBeenMuted = muted;\r\n\r\n        // Bind 'onmute' and 'onunmute' event handlers\r\n        if (this.rtc && this.track) {\r\n            this._bindMuteHandlers();\r\n        }\r\n    }\r\n\r\n    /* eslint-enable max-params */\r\n    /**\r\n     * Attaches the track muted handlers.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    _bindMuteHandlers() {\r\n        this.track.addEventListener('mute', () => this._onTrackMute());\r\n        this.track.addEventListener('unmute', () => this._onTrackUnmute());\r\n    }\r\n\r\n    /**\r\n     * Callback invoked when the track is muted. Emits an event notifying\r\n     * listeners of the mute event.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onTrackMute() {\r\n        logger.debug(\r\n            `\"onmute\" event(${Date.now()}): `,\r\n            this.getParticipantId(), this.getType(), this.getSSRC());\r\n\r\n        this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_MUTE, this);\r\n    }\r\n\r\n    /**\r\n     * Callback invoked when the track is unmuted. Emits an event notifying\r\n     * listeners of the mute event.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onTrackUnmute() {\r\n        logger.debug(\r\n            `\"onunmute\" event(${Date.now()}): `,\r\n            this.getParticipantId(), this.getType(), this.getSSRC());\r\n\r\n        this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_UNMUTE, this);\r\n    }\r\n\r\n    /**\r\n     * Sets current muted status and fires an events for the change.\r\n     * @param value the muted status.\r\n     */\r\n    setMute(value) {\r\n        if (this.muted === value) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this.hasBeenMuted = true;\r\n        }\r\n\r\n        // we can have a fake video stream\r\n        if (this.stream) {\r\n            this.stream.muted = value;\r\n        }\r\n\r\n        this.muted = value;\r\n        this.emit(QHSenseTrackEvents.TRACK_MUTE_CHANGED, this);\r\n    }\r\n\r\n    /**\r\n     * Returns the current muted status of the track.\r\n     * @returns {boolean|*|QHSenseRemoteTrack.muted} <tt>true</tt> if the track is\r\n     * muted and <tt>false</tt> otherwise.\r\n     */\r\n    isMuted() {\r\n        return this.muted;\r\n    }\r\n\r\n    /**\r\n     * Returns the participant id which owns the track.\r\n     *\r\n     * @returns {string} the id of the participants. It corresponds to the\r\n     * Colibri endpoint id/MUC nickname in case of QHSense-meet.\r\n     */\r\n    getParticipantId() {\r\n        return this.ownerEndpointId;\r\n    }\r\n\r\n    /**\r\n     * Return false;\r\n     */\r\n    isLocal() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the synchronization source identifier (SSRC) of this remote\r\n     * track.\r\n     *\r\n     * @returns {number} the SSRC of this remote track.\r\n     */\r\n    getSSRC() {\r\n        return this.ssrc;\r\n    }\r\n\r\n    /**\r\n     * Changes the video type of the track.\r\n     *\r\n     * @param {string} type - The new video type(\"camera\", \"desktop\").\r\n     */\r\n    _setVideoType(type) {\r\n        if (this.videoType === type) {\r\n            return;\r\n        }\r\n        this.videoType = type;\r\n        this.emit(QHSenseTrackEvents.TRACK_VIDEOTYPE_CHANGED, type);\r\n    }\r\n\r\n    /**\r\n     * Handles track play events.\r\n     */\r\n    _playCallback() {\r\n        const type = this.isVideoTrack() ? 'video' : 'audio';\r\n\r\n        const now = window.performance.now();\r\n\r\n        console.log(`(TIME) Render ${type}:\\t`, now);\r\n        this.conference.getConnectionTimes()[`${type}.render`] = now;\r\n\r\n        // The conference can be started without calling GUM\r\n        // FIXME if there would be a module for connection times this kind\r\n        // of logic (gumDuration or ttfm) should end up there\r\n        const gumStart = window.connectionTimes['obtainPermissions.start'];\r\n        const gumEnd = window.connectionTimes['obtainPermissions.end'];\r\n        const gumDuration\r\n            = !isNaN(gumEnd) && !isNaN(gumStart) ? gumEnd - gumStart : 0;\r\n\r\n        // Subtract the muc.joined-to-session-initiate duration because jicofo\r\n        // waits until there are 2 participants to start Jingle sessions.\r\n        const ttfm = now\r\n            - (this.conference.getConnectionTimes()['session.initiate']\r\n                - this.conference.getConnectionTimes()['muc.joined'])\r\n            - gumDuration;\r\n\r\n        this.conference.getConnectionTimes()[`${type}.ttfm`] = ttfm;\r\n        console.log(`(TIME) TTFM ${type}:\\t`, ttfm);\r\n\r\n        Statistics.sendAnalytics(createTtfmEvent(\r\n            {\r\n                'media_type': type,\r\n                muted: this.hasBeenMuted,\r\n                value: ttfm\r\n            }));\r\n\r\n    }\r\n\r\n    /**\r\n     * Attach time to first media tracker only if there is conference and only\r\n     * for the first element.\r\n     * @param container the HTML container which can be 'video' or 'audio'\r\n     * element.\r\n     * @private\r\n     */\r\n    _attachTTFMTracker(container) {\r\n        if ((ttfmTrackerAudioAttached && this.isAudioTrack())\r\n            || (ttfmTrackerVideoAttached && this.isVideoTrack())) {\r\n            return;\r\n        }\r\n\r\n        if (this.isAudioTrack()) {\r\n            ttfmTrackerAudioAttached = true;\r\n        }\r\n        if (this.isVideoTrack()) {\r\n            ttfmTrackerVideoAttached = true;\r\n        }\r\n\r\n        container.addEventListener('canplay', this._playCallback.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Creates a text representation of this remote track instance.\r\n     * @return {string}\r\n     */\r\n    toString() {\r\n        return `RemoteTrack[${\r\n            this.ownerEndpointId}, ${\r\n            this.getType()}, p2p: ${\r\n            this.isP2P}]`;\r\n    }\r\n}\r\n","/* global __filename */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport * as MediaType from '../../service/RTC/MediaType';\r\nimport { SdpTransformWrap } from '../xmpp/SdpTransformUtil';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Fakes local SDP exposed to {@link JingleSessionPC} through the local\r\n * description getter. Modifies the SDP, so that it will contain muted local\r\n * video tracks description, even though their underlying {MediaStreamTrack}s\r\n * are no longer in the WebRTC peerconnection. That prevents from SSRC updates\r\n * being sent to Jicofo/remote peer and prevents sRD/sLD cycle on the remote\r\n * side.\r\n */\r\nexport default class LocalSdpMunger {\r\n\r\n    /**\r\n     * Creates new <tt>LocalSdpMunger</tt> instance.\r\n     *\r\n     * @param {TraceablePeerConnection} tpc\r\n     */\r\n    constructor(tpc) {\r\n        this.tpc = tpc;\r\n    }\r\n\r\n    /**\r\n     * Makes sure that muted local video tracks associated with the parent\r\n     * {@link TraceablePeerConnection} are described in the local SDP. It's done\r\n     * in order to prevent from sending 'source-remove'/'source-add' Jingle\r\n     * notifications when local video track is muted (<tt>MediaStream</tt> is\r\n     * removed from the peerconnection).\r\n     *\r\n     * NOTE 1 video track is assumed\r\n     *\r\n     * @param {SdpTransformWrap} transformer the transformer instance which will\r\n     * be used to process the SDP.\r\n     * @return {boolean} <tt>true</tt> if there were any modifications to\r\n     * the SDP wrapped by <tt>transformer</tt>.\r\n     * @private\r\n     */\r\n    _addMutedLocalVideoTracksToSDP(transformer) {\r\n        // Go over each video tracks and check if the SDP has to be changed\r\n        const localVideos = this.tpc.getLocalTracks(MediaType.VIDEO);\r\n\r\n        if (!localVideos.length) {\r\n            return false;\r\n        } else if (localVideos.length !== 1) {\r\n            logger.error(\r\n                `${this.tpc} there is more than 1 video track ! `\r\n                    + 'Strange things may happen !', localVideos);\r\n        }\r\n\r\n        const videoMLine = transformer.selectMedia('video');\r\n\r\n        if (!videoMLine) {\r\n            logger.debug(\r\n                `${this.tpc} unable to hack local video track SDP`\r\n                    + '- no \"video\" media');\r\n\r\n            return false;\r\n        }\r\n\r\n        let modified = false;\r\n\r\n        for (const videoTrack of localVideos) {\r\n            const muted = videoTrack.isMuted();\r\n            const mediaStream = videoTrack.getOriginalStream();\r\n\r\n            // During the mute/unmute operation there are periods of time when\r\n            // the track's underlying MediaStream is not added yet to\r\n            // the PeerConnection. The SDP needs to be munged in such case.\r\n            const isInPeerConnection\r\n                = mediaStream && this.tpc.isMediaStreamInPc(mediaStream);\r\n            const shouldFakeSdp = muted || !isInPeerConnection;\r\n\r\n            logger.debug(\r\n                `${this.tpc} ${videoTrack} muted: ${\r\n                    muted}, is in PeerConnection: ${\r\n                    isInPeerConnection} => should fake sdp ? : ${\r\n                    shouldFakeSdp}`);\r\n\r\n            if (!shouldFakeSdp) {\r\n                continue; // eslint-disable-line no-continue\r\n            }\r\n\r\n            // Inject removed SSRCs\r\n            const requiredSSRCs\r\n                = this.tpc.isSimulcastOn()\r\n                    ? this.tpc.simulcast.ssrcCache\r\n                    : [ this.tpc.sdpConsistency.cachedPrimarySsrc ];\r\n\r\n            if (!requiredSSRCs.length) {\r\n                logger.error(\r\n                    `No SSRCs stored for: ${videoTrack} in ${this.tpc}`);\r\n\r\n                continue; // eslint-disable-line no-continue\r\n            }\r\n\r\n            modified = true;\r\n\r\n            // We need to fake sendrecv.\r\n            // NOTE the SDP produced here goes only to Jicofo and is never set\r\n            // as localDescription. That's why\r\n            // TraceablePeerConnection.mediaTransferActive is ignored here.\r\n            videoMLine.direction = 'sendrecv';\r\n\r\n            // Check if the recvonly has MSID\r\n            const primarySSRC = requiredSSRCs[0];\r\n\r\n            // FIXME The cname could come from the stream, but may turn out to\r\n            // be too complex. It is fine to come up with any value, as long as\r\n            // we only care about the actual SSRC values when deciding whether\r\n            // or not an update should be sent.\r\n            const primaryCname = `injected-${primarySSRC}`;\r\n\r\n            for (const ssrcNum of requiredSSRCs) {\r\n                // Remove old attributes\r\n                videoMLine.removeSSRC(ssrcNum);\r\n\r\n                // Inject\r\n                logger.debug(\r\n                    `${this.tpc} injecting video SSRC: ${ssrcNum} for ${\r\n                        videoTrack}`);\r\n                videoMLine.addSSRCAttribute({\r\n                    id: ssrcNum,\r\n                    attribute: 'cname',\r\n                    value: primaryCname\r\n                });\r\n                videoMLine.addSSRCAttribute({\r\n                    id: ssrcNum,\r\n                    attribute: 'msid',\r\n                    value: videoTrack.storedMSID\r\n                });\r\n            }\r\n            if (requiredSSRCs.length > 1) {\r\n                const group = {\r\n                    ssrcs: requiredSSRCs.join(' '),\r\n                    semantics: 'SIM'\r\n                };\r\n\r\n                if (!videoMLine.findGroup(group.semantics, group.ssrcs)) {\r\n                    // Inject the group\r\n                    logger.debug(\r\n                        `${this.tpc} injecting SIM group for ${videoTrack}`,\r\n                        group);\r\n                    videoMLine.addSSRCGroup(group);\r\n                }\r\n            }\r\n\r\n            // Insert RTX\r\n            // FIXME in P2P RTX is used by Chrome regardless of config option\r\n            // status. Because of that 'source-remove'/'source-add'\r\n            // notifications are still sent to remove/add RTX SSRC and FID group\r\n            if (!this.tpc.options.disableRtx) {\r\n                this.tpc.rtxModifier.modifyRtxSsrcs2(videoMLine);\r\n            }\r\n        }\r\n\r\n        return modified;\r\n    }\r\n\r\n    /**\r\n     * Modifies 'cname', 'msid', 'label' and 'mslabel' by appending\r\n     * the id of {@link LocalSdpMunger#tpc} at the end, preceding by a dash\r\n     * sign.\r\n     *\r\n     * @param {MLineWrap} mediaSection - The media part (audio or video) of the\r\n     * session description which will be modified in place.\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    _transformMediaIdentifiers(mediaSection) {\r\n        const pcId = this.tpc.id;\r\n\r\n        for (const ssrcLine of mediaSection.ssrcs) {\r\n            switch (ssrcLine.attribute) {\r\n            case 'cname':\r\n            case 'label':\r\n            case 'mslabel':\r\n                ssrcLine.value = ssrcLine.value && `${ssrcLine.value}-${pcId}`;\r\n                break;\r\n            case 'msid': {\r\n                if (ssrcLine.value) {\r\n                    const streamAndTrackIDs = ssrcLine.value.split(' ');\r\n\r\n                    if (streamAndTrackIDs.length === 2) {\r\n                        const streamId = streamAndTrackIDs[0];\r\n                        const trackId = streamAndTrackIDs[1];\r\n\r\n                        ssrcLine.value\r\n                            = `${streamId}-${pcId} ${trackId}-${pcId}`;\r\n                    } else {\r\n                        logger.warn(\r\n                            'Unable to munge local MSID'\r\n                                + `- weird format detected: ${ssrcLine.value}`);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maybe modifies local description to fake local video tracks SDP when\r\n     * those are muted.\r\n     *\r\n     * @param {object} desc the WebRTC SDP object instance for the local\r\n     * description.\r\n     * @returns {RTCSessionDescription}\r\n     */\r\n    maybeAddMutedLocalVideoTracksToSDP(desc) {\r\n        if (!desc) {\r\n            throw new Error('No local description passed in.');\r\n        }\r\n\r\n        const transformer = new SdpTransformWrap(desc.sdp);\r\n\r\n        if (this._addMutedLocalVideoTracksToSDP(transformer)) {\r\n            return new RTCSessionDescription({\r\n                type: desc.type,\r\n                sdp: transformer.toRawSDP()\r\n            });\r\n        }\r\n\r\n        return desc;\r\n    }\r\n\r\n    /**\r\n     * This transformation will make sure that stream identifiers are unique\r\n     * across all of the local PeerConnections even if the same stream is used\r\n     * by multiple instances at the same time.\r\n     * Each PeerConnection assigns different SSRCs to the same local\r\n     * MediaStream, but the MSID remains the same as it's used to identify\r\n     * the stream by the WebRTC backend. The transformation will append\r\n     * {@link TraceablePeerConnection#id} at the end of each stream's identifier\r\n     * (\"cname\", \"msid\", \"label\" and \"mslabel\").\r\n     *\r\n     * @param {RTCSessionDescription} sessionDesc - The local session\r\n     * description (this instance remains unchanged).\r\n     * @return {RTCSessionDescription} - Transformed local session description\r\n     * (a modified copy of the one given as the input).\r\n     */\r\n    transformStreamIdentifiers(sessionDesc) {\r\n        // FIXME similar check is probably duplicated in all other transformers\r\n        if (!sessionDesc || !sessionDesc.sdp || !sessionDesc.type) {\r\n            return sessionDesc;\r\n        }\r\n\r\n        const transformer = new SdpTransformWrap(sessionDesc.sdp);\r\n        const audioMLine = transformer.selectMedia('audio');\r\n\r\n        if (audioMLine) {\r\n            this._transformMediaIdentifiers(audioMLine);\r\n        }\r\n\r\n        const videoMLine = transformer.selectMedia('video');\r\n\r\n        if (videoMLine) {\r\n            this._transformMediaIdentifiers(videoMLine);\r\n        }\r\n\r\n        return new RTCSessionDescription({\r\n            type: sessionDesc.type,\r\n            sdp: transformer.toRawSDP()\r\n        });\r\n    }\r\n}\r\n","/* global __filename */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport { parseSecondarySSRC, SdpTransformWrap } from './SdpTransformUtil';\r\nimport SDPUtil from './SDPUtil';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Begin helper functions\r\n */\r\n/**\r\n * Updates or inserts the appropriate rtx information for primarySsrc with\r\n *  the given rtxSsrc.  If no rtx ssrc for primarySsrc currently exists, it will\r\n *  add the appropriate ssrc and ssrc group lines.  If primarySsrc already has\r\n *  an rtx ssrc, the appropriate ssrc and group lines will be updated\r\n * @param {MLineWrap} mLine\r\n * @param {object} primarySsrcInfo the info (ssrc, msid & cname) for the\r\n *  primary ssrc\r\n * @param {number} rtxSsrc the rtx ssrc to associate with the primary ssrc\r\n */\r\nfunction updateAssociatedRtxStream(mLine, primarySsrcInfo, rtxSsrc) {\r\n    logger.debug(\r\n        `Updating mline to associate ${rtxSsrc}`\r\n        + `rtx ssrc with primary stream, ${primarySsrcInfo.id}`);\r\n    const primarySsrc = primarySsrcInfo.id;\r\n    const primarySsrcMsid = primarySsrcInfo.msid;\r\n    const primarySsrcCname = primarySsrcInfo.cname;\r\n\r\n    const previousRtxSSRC = mLine.getRtxSSRC(primarySsrc);\r\n\r\n    if (previousRtxSSRC === rtxSsrc) {\r\n        logger.debug(`${rtxSsrc} was already associated with ${primarySsrc}`);\r\n\r\n        return;\r\n    }\r\n    if (previousRtxSSRC) {\r\n        logger.debug(\r\n            `${primarySsrc} was previously associated with rtx`\r\n            + `${previousRtxSSRC}, removing all references to it`);\r\n\r\n        // Stream already had an rtx ssrc that is different than the one given,\r\n        //  remove all trace of the old one\r\n        mLine.removeSSRC(previousRtxSSRC);\r\n\r\n        logger.debug(`groups before filtering for ${previousRtxSSRC}`);\r\n        logger.debug(mLine.dumpSSRCGroups());\r\n\r\n        mLine.removeGroupsWithSSRC(previousRtxSSRC);\r\n    }\r\n    mLine.addSSRCAttribute({\r\n        id: rtxSsrc,\r\n        attribute: 'cname',\r\n        value: primarySsrcCname\r\n    });\r\n    mLine.addSSRCAttribute({\r\n        id: rtxSsrc,\r\n        attribute: 'msid',\r\n        value: primarySsrcMsid\r\n    });\r\n    mLine.addSSRCGroup({\r\n        semantics: 'FID',\r\n        ssrcs: `${primarySsrc} ${rtxSsrc}`\r\n    });\r\n}\r\n\r\n/**\r\n * End helper functions\r\n */\r\n\r\n/**\r\n * Adds any missing RTX streams for video streams\r\n *  and makes sure that they remain consistent\r\n */\r\nexport default class RtxModifier {\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor() {\r\n        /**\r\n         * Map of video ssrc to corresponding RTX\r\n         *  ssrc\r\n         */\r\n        this.correspondingRtxSsrcs = new Map();\r\n    }\r\n\r\n    /**\r\n     * Clear the cached map of primary video ssrcs to\r\n     *  their corresponding rtx ssrcs so that they will\r\n     *  not be used for the next call to modifyRtxSsrcs\r\n     */\r\n    clearSsrcCache() {\r\n        this.correspondingRtxSsrcs.clear();\r\n    }\r\n\r\n    /**\r\n     * Explicitly set the primary video ssrc -> rtx ssrc\r\n     *  mapping to be used in modifyRtxSsrcs\r\n     * @param {Map} ssrcMapping a mapping of primary video\r\n     *  ssrcs to their corresponding rtx ssrcs\r\n     */\r\n    setSsrcCache(ssrcMapping) {\r\n        logger.debug('Setting ssrc cache to ', ssrcMapping);\r\n        this.correspondingRtxSsrcs = ssrcMapping;\r\n    }\r\n\r\n    /**\r\n     * Adds RTX ssrcs for any video ssrcs that don't\r\n     *  already have them.  If the video ssrc has been\r\n     *  seen before, and already had an RTX ssrc generated,\r\n     *  the same RTX ssrc will be used again.\r\n     * @param {string} sdpStr sdp in raw string format\r\n     */\r\n    modifyRtxSsrcs(sdpStr) {\r\n        const sdpTransformer = new SdpTransformWrap(sdpStr);\r\n        const videoMLine = sdpTransformer.selectMedia('video');\r\n\r\n        if (!videoMLine) {\r\n            logger.debug(`No 'video' media found in the sdp: ${sdpStr}`);\r\n\r\n            return sdpStr;\r\n        }\r\n\r\n        return this.modifyRtxSsrcs2(videoMLine)\r\n            ? sdpTransformer.toRawSDP() : sdpStr;\r\n    }\r\n\r\n    /**\r\n     * Does the same thing as {@link modifyRtxSsrcs}, but takes the\r\n     *  {@link MLineWrap} instance wrapping video media as an argument.\r\n     * @param {MLineWrap} videoMLine\r\n     * @return {boolean} <tt>true</tt> if the SDP wrapped by\r\n     *  {@link SdpTransformWrap} has been modified or <tt>false</tt> otherwise.\r\n     */\r\n    modifyRtxSsrcs2(videoMLine) {\r\n        if (videoMLine.direction === 'recvonly') {\r\n            logger.debug('RtxModifier doing nothing, video m line is recvonly');\r\n\r\n            return false;\r\n        }\r\n        if (videoMLine.getSSRCCount() < 1) {\r\n            logger.debug('RtxModifier doing nothing, no video ssrcs present');\r\n\r\n            return false;\r\n        }\r\n        logger.debug('Current ssrc mapping: ', this.correspondingRtxSsrcs);\r\n        const primaryVideoSsrcs = videoMLine.getPrimaryVideoSSRCs();\r\n\r\n        logger.debug('Parsed primary video ssrcs ', primaryVideoSsrcs,\r\n            ' making sure all have rtx streams');\r\n        for (const ssrc of primaryVideoSsrcs) {\r\n            const msid = videoMLine.getSSRCAttrValue(ssrc, 'msid');\r\n            const cname = videoMLine.getSSRCAttrValue(ssrc, 'cname');\r\n            let correspondingRtxSsrc = this.correspondingRtxSsrcs.get(ssrc);\r\n\r\n            if (correspondingRtxSsrc) {\r\n                logger.debug(\r\n                    'Already have an associated rtx ssrc for'\r\n                    + `video ssrc ${ssrc}: ${correspondingRtxSsrc}`);\r\n            } else {\r\n                logger.debug(\r\n                    `No previously associated rtx ssrc for video ssrc ${ssrc}`);\r\n\r\n                // If there's one in the sdp already for it, we'll just set\r\n                //  that as the corresponding one\r\n                const previousAssociatedRtxStream = videoMLine.getRtxSSRC(ssrc);\r\n\r\n                if (previousAssociatedRtxStream) {\r\n                    logger.debug(\r\n                        `Rtx stream ${previousAssociatedRtxStream} `\r\n                        + 'already existed in the sdp as an rtx stream for '\r\n                        + `${ssrc}`);\r\n                    correspondingRtxSsrc = previousAssociatedRtxStream;\r\n                } else {\r\n                    correspondingRtxSsrc = SDPUtil.generateSsrc();\r\n                    logger.debug(`Generated rtx ssrc ${correspondingRtxSsrc} `\r\n                                 + `for ssrc ${ssrc}`);\r\n                }\r\n                logger.debug(`Caching rtx ssrc ${correspondingRtxSsrc} `\r\n                             + `for video ssrc ${ssrc}`);\r\n                this.correspondingRtxSsrcs.set(ssrc, correspondingRtxSsrc);\r\n            }\r\n            updateAssociatedRtxStream(\r\n                videoMLine,\r\n                {\r\n                    id: ssrc,\r\n                    cname,\r\n                    msid\r\n                },\r\n                correspondingRtxSsrc);\r\n        }\r\n\r\n        // FIXME we're not looking into much details whether the SDP has been\r\n        // modified or not once the precondition requirements are met.\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Strip all rtx streams from the given sdp\r\n     * @param {string} sdpStr sdp in raw string format\r\n     * @returns {string} sdp string with all rtx streams stripped\r\n     */\r\n    stripRtx(sdpStr) {\r\n        const sdpTransformer = new SdpTransformWrap(sdpStr);\r\n        const videoMLine = sdpTransformer.selectMedia('video');\r\n\r\n        if (!videoMLine) {\r\n            logger.debug(`No 'video' media found in the sdp: ${sdpStr}`);\r\n\r\n            return sdpStr;\r\n        }\r\n        if (videoMLine.direction === 'recvonly') {\r\n            logger.debug('RtxModifier doing nothing, video m line is recvonly');\r\n\r\n            return sdpStr;\r\n        }\r\n        if (videoMLine.getSSRCCount() < 1) {\r\n            logger.debug('RtxModifier doing nothing, no video ssrcs present');\r\n\r\n            return sdpStr;\r\n        }\r\n        if (!videoMLine.containsAnySSRCGroups()) {\r\n            logger.debug('RtxModifier doing nothing, '\r\n              + 'no video ssrcGroups present');\r\n\r\n            return sdpStr;\r\n        }\r\n        const fidGroups = videoMLine.findGroups('FID');\r\n\r\n        // Remove the fid groups from the mline\r\n\r\n        videoMLine.removeGroupsBySemantics('FID');\r\n\r\n        // Get the rtx ssrcs and remove them from the mline\r\n        for (const fidGroup of fidGroups) {\r\n            const rtxSsrc = parseSecondarySSRC(fidGroup);\r\n\r\n            videoMLine.removeSSRC(rtxSsrc);\r\n        }\r\n\r\n        return sdpTransformer.toRawSDP();\r\n    }\r\n}\r\n","/* global __filename */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport {\r\n    parsePrimarySSRC,\r\n    parseSecondarySSRC,\r\n    SdpTransformWrap\r\n} from './SdpTransformUtil';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Handles the work of keeping video ssrcs consistent across multiple\r\n * o/a cycles, making it such that all stream operations can be\r\n * kept local and do not need to be signaled.\r\n * NOTE: This only keeps the 'primary' video ssrc consistent: meaning\r\n * the primary video stream\r\n */\r\nexport default class SdpConsistency {\r\n    /**\r\n     * Constructor\r\n     * @param {string} logPrefix the log prefix appended to every logged\r\n     * message, currently used to distinguish for which\r\n     * <tt>TraceablePeerConnection</tt> the instance works.\r\n     */\r\n    constructor(logPrefix) {\r\n        this.clearVideoSsrcCache();\r\n        this.logPrefix = logPrefix;\r\n    }\r\n\r\n    /**\r\n     * Clear the cached video primary and primary rtx ssrcs so that\r\n     *  they will not be used for the next call to\r\n     *  makeVideoPrimarySsrcsConsistent\r\n     */\r\n    clearVideoSsrcCache() {\r\n        this.cachedPrimarySsrc = null;\r\n        this.injectRecvOnly = false;\r\n    }\r\n\r\n    /**\r\n     * Explicitly set the primary ssrc to be used in\r\n     *  makeVideoPrimarySsrcsConsistent\r\n     * @param {number} primarySsrc the primarySsrc to be used\r\n     *  in future calls to makeVideoPrimarySsrcsConsistent\r\n     * @throws Error if <tt>primarySsrc</tt> is not a number\r\n     */\r\n    setPrimarySsrc(primarySsrc) {\r\n        if (typeof primarySsrc !== 'number') {\r\n            throw new Error('Primary SSRC must be a number!');\r\n        }\r\n        this.cachedPrimarySsrc = primarySsrc;\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not there is a primary video SSRC cached already.\r\n     * @return {boolean}\r\n     */\r\n    hasPrimarySsrcCached() {\r\n        return Boolean(this.cachedPrimarySsrc);\r\n    }\r\n\r\n    /**\r\n     * Given an sdp string, either:\r\n     *  1) record the primary video and primary rtx ssrcs to be\r\n     *   used in future calls to makeVideoPrimarySsrcsConsistent or\r\n     *  2) change the primary and primary rtx ssrcs in the given sdp\r\n     *   to match the ones previously cached\r\n     * @param {string} sdpStr the sdp string to (potentially)\r\n     *  change to make the video ssrcs consistent\r\n     * @returns {string} a (potentially) modified sdp string\r\n     *  with ssrcs consistent with this class' cache\r\n     */\r\n    makeVideoPrimarySsrcsConsistent(sdpStr) {\r\n        const sdpTransformer = new SdpTransformWrap(sdpStr);\r\n        const videoMLine = sdpTransformer.selectMedia('video');\r\n\r\n        if (!videoMLine) {\r\n            logger.debug(\r\n                `${this.logPrefix} no 'video' media found in the sdp: `\r\n                    + `${sdpStr}`);\r\n\r\n            return sdpStr;\r\n        }\r\n\r\n        if (videoMLine.direction === 'recvonly') {\r\n            // If the mline is recvonly, we'll add the primary\r\n            //  ssrc as a recvonly ssrc\r\n            if (this.cachedPrimarySsrc && this.injectRecvOnly) {\r\n                videoMLine.addSSRCAttribute({\r\n                    id: this.cachedPrimarySsrc,\r\n                    attribute: 'cname',\r\n                    value: `recvonly-${this.cachedPrimarySsrc}`\r\n                });\r\n            } else {\r\n                logger.info(\r\n                    `${this.logPrefix} no SSRC found for the recvonly video`\r\n                        + 'stream!');\r\n            }\r\n        } else {\r\n            const newPrimarySsrc = videoMLine.getPrimaryVideoSsrc();\r\n\r\n            if (!newPrimarySsrc) {\r\n                logger.info(\r\n                    `${this.logPrefix} sdp-consistency couldn't`\r\n                        + ' parse new primary ssrc');\r\n\r\n                return sdpStr;\r\n            }\r\n            if (this.cachedPrimarySsrc) {\r\n                logger.info(\r\n                    `${this.logPrefix} sdp-consistency replacing new ssrc`\r\n                        + `${newPrimarySsrc} with cached `\r\n                        + `${this.cachedPrimarySsrc}`);\r\n                videoMLine.replaceSSRC(newPrimarySsrc, this.cachedPrimarySsrc);\r\n                for (const group of videoMLine.ssrcGroups) {\r\n                    if (group.semantics === 'FID') {\r\n                        const primarySsrc = parsePrimarySSRC(group);\r\n                        const rtxSsrc = parseSecondarySSRC(group);\r\n\r\n                        // eslint-disable-next-line max-depth\r\n                        if (primarySsrc === newPrimarySsrc) {\r\n                            group.ssrcs\r\n                                = `${this.cachedPrimarySsrc} ${rtxSsrc}`;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                this.cachedPrimarySsrc = newPrimarySsrc;\r\n                logger.info(\r\n                    `${this.logPrefix} sdp-consistency caching primary ssrc`\r\n                        + `${this.cachedPrimarySsrc}`);\r\n            }\r\n\r\n            this.injectRecvOnly = true;\r\n        }\r\n\r\n        return sdpTransformer.toRawSDP();\r\n    }\r\n}\r\n","import * as QHSenseConferenceEvents from '../QHSenseConferenceEvents';\r\n\r\n/**\r\n * The value which we use to say, every sound over this threshold\r\n * is talking on the mic.\r\n * @type {number}\r\n */\r\nconst SPEECH_DETECT_THRESHOLD = 0.6;\r\n\r\n/**\r\n * Detect user trying to speek while is locally muted and fires an event.\r\n */\r\nexport default class TalkMutedDetection {\r\n    /**\r\n     * Creates TalkMutedDetection\r\n     * @param conference the QHSenseConference instance that created us.\r\n     * @param callback the callback to call when detected that the local user is\r\n     * talking while her microphone is muted.\r\n     * @constructor\r\n     */\r\n    constructor(conference, callback) {\r\n        /**\r\n         * The callback to call when detected that the local user is talking\r\n         * while her microphone is muted.\r\n         *\r\n         * @private\r\n         */\r\n        this._callback = callback;\r\n\r\n        /**\r\n         * The indicator which determines whether <tt>callback</tt> has been\r\n         * invoked for the current local audio track of <tt>conference</tt> so\r\n         * that it is invoked once only.\r\n         *\r\n         * @private\r\n         */\r\n        this._eventFired = false;\r\n\r\n        // XXX I went back and forth on the subject of where to put the access\r\n        // to statistics. On the one had, (1) statistics is likely intended to\r\n        // be private to conference and (2) there is a desire to keep the\r\n        // dependencies of modules to the minimum (i.e. not have\r\n        // TalkMutedDetection depend on statistics). On the other hand, (1)\r\n        // statistics is technically not private because\r\n        // QHSenseConferenceEventManager accesses it and (2) TalkMutedDetection\r\n        // works exactly because it knows that there are no audio levels for\r\n        // QHSenseLocalTrack but there are audio levels for the local participant\r\n        // through statistics.\r\n        conference.statistics.addAudioLevelListener(\r\n            this._audioLevel.bind(this));\r\n\r\n        conference.on(\r\n            QHSenseConferenceEvents.TRACK_MUTE_CHANGED,\r\n            this._trackMuteChanged.bind(this));\r\n        conference.on(\r\n            QHSenseConferenceEvents.TRACK_ADDED,\r\n            this._trackAdded.bind(this));\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n    /**\r\n     * Receives audio level events for all send and receive streams.\r\n     *\r\n     * @param {TraceablePeerConnection} pc - WebRTC PeerConnection object of the\r\n     * @param {number} ssrc - The synchronization source identifier (SSRC) of\r\n     * the endpoint/participant/stream being reported.\r\n     * @param {number} audioLevel - The audio level of <tt>ssrc</tt>.\r\n     * @param {boolean} isLocal - <tt>true</tt> if <tt>ssrc</tt> represents a\r\n     * local/send stream or <tt>false</tt> for a remote/receive stream.\r\n     */\r\n    _audioLevel(tpc, ssrc, audioLevel, isLocal) {\r\n        // We are interested in the local audio stream only and if event is not\r\n        // sent yet.\r\n        if (!isLocal || !this.audioTrack || this._eventFired) {\r\n            return;\r\n        }\r\n\r\n        if (this.audioTrack.isMuted()\r\n            && audioLevel > SPEECH_DETECT_THRESHOLD) {\r\n            this._eventFired = true;\r\n            this._callback();\r\n        }\r\n    }\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Determines whether a specific {@link QHSenseTrack} represents a local audio\r\n     * track.\r\n     *\r\n     * @param {QHSenseTrack} track - The <tt>QHSenseTrack</tt> to be checked whether\r\n     * it represents a local audio track.\r\n     * @private\r\n     * @return {boolean} - <tt>true</tt> if the specified <tt>track</tt>\r\n     * represents a local audio track; otherwise, <tt>false</tt>.\r\n     */\r\n    _isLocalAudioTrack(track) {\r\n        return track.isAudioTrack() && track.isLocal();\r\n    }\r\n\r\n    /**\r\n     * Notifies this <tt>TalkMutedDetection</tt> that a {@link QHSenseTrack} was\r\n     * added to the associated {@link QHSenseConference}. Looks for the local\r\n     * audio track only.\r\n     *\r\n     * @param {QHSenseTrack} track - The added <tt>QHSenseTrack</tt>.\r\n     * @private\r\n     */\r\n    _trackAdded(track) {\r\n        if (this._isLocalAudioTrack(track)) {\r\n            this.audioTrack = track;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Notifies this <tt>TalkMutedDetection</tt> that the mute state of a\r\n     * {@link QHSenseTrack} has changed. Looks for the local audio track only.\r\n     *\r\n     * @param {QHSenseTrack} track - The <tt>QHSenseTrack</tt> whose mute state has\r\n     * changed.\r\n     * @private\r\n     */\r\n    _trackMuteChanged(track) {\r\n        if (this._isLocalAudioTrack(track) && track.isMuted()) {\r\n            this._eventFired = false;\r\n        }\r\n    }\r\n}\r\n","import * as ConnectionQualityEvents\r\n    from '../../service/connectivity/ConnectionQualityEvents';\r\nimport * as ConferenceEvents from '../../QHSenseConferenceEvents';\r\nimport { getLogger } from 'qhsense-meet-logger';\r\n\r\nconst XMPPEvents = require('../../service/xmpp/XMPPEvents');\r\nconst VideoType = require('../../service/RTC/VideoType');\r\nconst Resolutions = require('../../service/RTC/Resolutions');\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * The value to use for the \"type\" field for messages sent by ConnectionQuality\r\n * over the data channel.\r\n */\r\nconst STATS_MESSAGE_TYPE = 'stats';\r\n\r\n/**\r\n * See media/engine/simulcast.ss from webrtc.org\r\n */\r\nconst kSimulcastFormats = [\r\n    { width: 1920,\r\n        height: 1080,\r\n        layers: 3,\r\n        max: 5000,\r\n        target: 4000,\r\n        min: 800 },\r\n    { width: 1280,\r\n        height: 720,\r\n        layers: 3,\r\n        max: 2500,\r\n        target: 2500,\r\n        min: 600 },\r\n    { width: 960,\r\n        height: 540,\r\n        layers: 3,\r\n        max: 900,\r\n        target: 900,\r\n        min: 450 },\r\n    { width: 640,\r\n        height: 360,\r\n        layers: 2,\r\n        max: 700,\r\n        target: 500,\r\n        min: 150 },\r\n    { width: 480,\r\n        height: 270,\r\n        layers: 2,\r\n        max: 450,\r\n        target: 350,\r\n        min: 150 },\r\n    { width: 320,\r\n        height: 180,\r\n        layers: 1,\r\n        max: 200,\r\n        target: 150,\r\n        min: 30 }\r\n];\r\n\r\n/**\r\n * The maximum bitrate to use as a measurement against the participant's current\r\n * bitrate. This cap helps in the cases where the participant's bitrate is high\r\n * but not enough to fulfill high targets, such as with 1080p.\r\n */\r\nconst MAX_TARGET_BITRATE = 2500;\r\n\r\n/**\r\n * The initial bitrate for video in kbps.\r\n */\r\nlet startBitrate = 800;\r\n\r\n\r\n/**\r\n * The current cap (in kbps) put on the video stream (or null if there isn't\r\n * a cap).  If there is a cap, we'll take it into account when calculating\r\n * the current quality.\r\n */\r\nlet videoBitrateCap = null;\r\n\r\n/**\r\n * Gets the expected bitrate (in kbps) in perfect network conditions.\r\n * @param simulcast {boolean} whether simulcast is enabled or not.\r\n * @param resolution {Resolution} the resolution.\r\n * @param millisSinceStart {number} the number of milliseconds since sending\r\n * video started.\r\n */\r\nfunction getTarget(simulcast, resolution, millisSinceStart) {\r\n    // Completely ignore the bitrate in the first 5 seconds, as the first\r\n    // event seems to fire very early and the value is suspicious and causes\r\n    // false positives.\r\n    if (millisSinceStart < 15000) {\r\n        return 1;\r\n    }\r\n\r\n    let target = 0;\r\n    let height = Math.min(resolution.height, resolution.width);\r\n\r\n    if (simulcast) {\r\n        // Find the first format with height no bigger than ours.\r\n        let simulcastFormat = kSimulcastFormats.find(f => f.height <= height);\r\n\r\n        if (simulcastFormat) {\r\n            // Sum the target fields from all simulcast layers for the given\r\n            // resolution (e.g. 720p + 360p + 180p).\r\n            for (height = simulcastFormat.height; height >= 180; height /= 2) {\r\n                const targetHeight = height;\r\n\r\n                simulcastFormat\r\n                    = kSimulcastFormats.find(f => f.height === targetHeight);\r\n                if (simulcastFormat) {\r\n                    target += simulcastFormat.target;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        // See GetMaxDefaultVideoBitrateKbps in\r\n        // media/engine/webrtcvideoengine2.cc from webrtc.org\r\n        const pixels = resolution.width * resolution.height;\r\n\r\n        if (pixels <= 320 * 240) {\r\n            target = 600;\r\n        } else if (pixels <= 640 * 480) {\r\n            target = 1700;\r\n        } else if (pixels <= 960 * 540) {\r\n            target = 2000;\r\n        } else {\r\n            target = 2500;\r\n        }\r\n    }\r\n\r\n    // Allow for an additional 1 second for ramp up -- delay any initial drop\r\n    // of connection quality by 1 second.\r\n    return Math.min(target, rampUp(Math.max(0, millisSinceStart - 1000)));\r\n}\r\n\r\n/**\r\n * Gets the bitrate to which GCC would have ramped up in perfect network\r\n * conditions after millisSinceStart milliseconds.\r\n * @param millisSinceStart {number} the number of milliseconds since sending\r\n * video was enabled.\r\n */\r\nfunction rampUp(millisSinceStart) {\r\n    if (millisSinceStart > 60000) {\r\n        return Number.MAX_SAFE_INTEGER;\r\n    }\r\n\r\n    // According to GCC the send side bandwidth estimation grows with at most\r\n    // 8% per second.\r\n    // https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02#section-5.5\r\n    return startBitrate * Math.pow(1.08, millisSinceStart / 1000);\r\n}\r\n\r\n/**\r\n * A class which monitors the local statistics coming from the RTC modules, and\r\n * calculates a \"connection quality\" value, in percent, for the media\r\n * connection. A value of 100% indicates a very good network connection, and a\r\n * value of 0% indicates a poor connection.\r\n */\r\nexport default class ConnectionQuality {\r\n    /**\r\n     *\r\n     * @param conference\r\n     * @param eventEmitter\r\n     * @param options\r\n     */\r\n    constructor(conference, eventEmitter, options) {\r\n        this.eventEmitter = eventEmitter;\r\n\r\n        /**\r\n         * The owning QHSenseConference.\r\n         */\r\n        this._conference = conference;\r\n\r\n        /**\r\n         * Holds statistics about the local connection quality.\r\n         */\r\n        this._localStats = {\r\n            connectionQuality: 100,\r\n            jvbRTT: undefined\r\n        };\r\n\r\n        /**\r\n         * The time this._localStats.connectionQuality was last updated.\r\n         */\r\n        this._lastConnectionQualityUpdate = -1;\r\n\r\n        /**\r\n         * Maps a participant ID to an object holding connection quality\r\n         * statistics received from this participant.\r\n         */\r\n        this._remoteStats = {};\r\n\r\n        /**\r\n         * The time that the ICE state last changed to CONNECTED. We use this\r\n         * to calculate how much time we as a sender have had to ramp-up.\r\n         */\r\n        this._timeIceConnected = -1;\r\n\r\n        /**\r\n         * The time that local video was unmuted. We use this to calculate how\r\n         * much time we as a sender have had to ramp-up.\r\n         */\r\n        this._timeVideoUnmuted = -1;\r\n\r\n        /**\r\n         * The time at which a video bitrate cap was last removed.  We use\r\n         * this to calculate how much time we, as a sender, have had to\r\n         * ramp-up\r\n         */\r\n        this._timeLastBwCapRemoved = -1;\r\n\r\n        // We assume a global startBitrate value for the sake of simplicity.\r\n        if (options.config.startBitrate && options.config.startBitrate > 0) {\r\n            startBitrate = options.config.startBitrate;\r\n        }\r\n\r\n        // TODO: consider ignoring these events and letting the user of\r\n        // lib-qhsense-meet handle these separately.\r\n        conference.on(\r\n            ConferenceEvents.CONNECTION_INTERRUPTED,\r\n            () => {\r\n                this._updateLocalConnectionQuality(0);\r\n                this.eventEmitter.emit(\r\n                    ConnectionQualityEvents.LOCAL_STATS_UPDATED,\r\n                    this._localStats);\r\n                this._broadcastLocalStats();\r\n            });\r\n\r\n        conference.room.addListener(\r\n            XMPPEvents.ICE_CONNECTION_STATE_CHANGED,\r\n            (jingleSession, newState) => {\r\n                if (!jingleSession.isP2P && newState === 'connected') {\r\n                    this._timeIceConnected = window.performance.now();\r\n                }\r\n            });\r\n\r\n        // Listen to DataChannel message from other participants in the\r\n        // conference, and update the _remoteStats field accordingly.\r\n        conference.on(\r\n            ConferenceEvents.ENDPOINT_MESSAGE_RECEIVED,\r\n            (participant, payload) => {\r\n                if (payload.type === STATS_MESSAGE_TYPE) {\r\n                    this._updateRemoteStats(\r\n                        participant.getId(), payload.values);\r\n                }\r\n            });\r\n\r\n        // Listen to local statistics events originating from the RTC module\r\n        // and update the _localStats field.\r\n        // Oh, and by the way, the resolutions of all remote participants are\r\n        // also piggy-backed in these \"local\" statistics. It's obvious, really,\r\n        // if one carefully reads the *code* (but not the docs) in\r\n        // UI/VideoLayout/VideoLayout.js#updateLocalConnectionStats in\r\n        // qhsense-meet\r\n        // TODO: We should keep track of the remote resolution in _remoteStats,\r\n        // and notify about changes via separate events.\r\n        conference.statistics.addConnectionStatsListener(\r\n            this._updateLocalStats.bind(this));\r\n\r\n        // Save the last time we were unmuted.\r\n        conference.on(\r\n            ConferenceEvents.TRACK_MUTE_CHANGED,\r\n            track => {\r\n                if (track.isVideoTrack()) {\r\n                    if (track.isMuted()) {\r\n                        this._timeVideoUnmuted = -1;\r\n                    } else {\r\n                        this._maybeUpdateUnmuteTime();\r\n                    }\r\n                }\r\n            });\r\n        conference.on(\r\n            ConferenceEvents.TRACK_ADDED,\r\n            track => {\r\n                if (track.isVideoTrack() && !track.isMuted()) {\r\n                    this._maybeUpdateUnmuteTime();\r\n                }\r\n            });\r\n\r\n        conference.on(\r\n            ConferenceEvents.SERVER_REGION_CHANGED,\r\n            serverRegion => {\r\n                this._localStats.serverRegion = serverRegion;\r\n            });\r\n\r\n        conference.on(\r\n            ConferenceEvents.PROPERTIES_CHANGED,\r\n            properties => {\r\n                this._localStats.bridgeCount\r\n                    = Number((properties || {})['bridge-count']);\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets _timeVideoUnmuted if it was previously unset. If it was already set,\r\n     * doesn't change it.\r\n     */\r\n    _maybeUpdateUnmuteTime() {\r\n        if (this._timeVideoUnmuted < 0) {\r\n            this._timeVideoUnmuted = window.performance.now();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates a new \"connection quality\" value.\r\n     * @param videoType {VideoType} the type of the video source (camera or\r\n     * a screen capture).\r\n     * @param isMuted {boolean} whether the local video is muted.\r\n     * @param resolutionName {Resolution} the input resolution used by the\r\n     * camera.\r\n     * @returns {*} the newly calculated connection quality.\r\n     */\r\n    _calculateConnectionQuality(videoType, isMuted, resolutionName) {\r\n\r\n        // resolutionName is an index into Resolutions (where \"720\" is\r\n        // \"1280x720\" and \"960\" is \"960x720\" ...).\r\n        const resolution = Resolutions[resolutionName];\r\n\r\n        let quality = 100;\r\n        let packetLoss;\r\n\r\n        // TODO: take into account packet loss for received streams\r\n\r\n        if (this._localStats.packetLoss) {\r\n            packetLoss = this._localStats.packetLoss.upload;\r\n\r\n            // Ugly Hack Alert (UHA):\r\n            // The packet loss for the upload direction is calculated based on\r\n            // incoming RTCP Receiver Reports. Since we don't have RTCP\r\n            // termination for audio, these reports come from the actual\r\n            // receivers in the conference and therefore the reported packet\r\n            // loss includes loss from the bridge to the receiver.\r\n            // When we are sending video this effect is small, because the\r\n            // number of video packets is much larger than the number of audio\r\n            // packets (and our calculation is based on the total number of\r\n            // received and lost packets).\r\n            // When video is muted, however, the effect might be significant,\r\n            // but we don't know what it is. We do know that it is positive, so\r\n            // as a temporary solution, until RTCP termination is implemented\r\n            // for the audio streams, we relax the packet loss checks here.\r\n            if (isMuted) {\r\n                packetLoss *= 0.5;\r\n            }\r\n        }\r\n\r\n        if (isMuted || !resolution || videoType === VideoType.DESKTOP\r\n            || this._timeIceConnected < 0\r\n            || this._timeVideoUnmuted < 0) {\r\n\r\n            // Calculate a value based on packet loss only.\r\n            if (packetLoss === undefined) {\r\n                logger.error('Cannot calculate connection quality, unknown '\r\n                    + 'packet loss.');\r\n                quality = 100;\r\n            } else if (packetLoss <= 2) {\r\n                quality = 100; // Full 5 bars.\r\n            } else if (packetLoss <= 4) {\r\n                quality = 70; // 4 bars\r\n            } else if (packetLoss <= 6) {\r\n                quality = 50; // 3 bars\r\n            } else if (packetLoss <= 8) {\r\n                quality = 30; // 2 bars\r\n            } else if (packetLoss <= 12) {\r\n                quality = 10; // 1 bars\r\n            } else {\r\n                quality = 0; // Still 1 bar, but slower climb-up.\r\n            }\r\n        } else {\r\n            // Calculate a value based on the sending bitrate.\r\n\r\n            // Figure out if simulcast is in use\r\n            const activeTPC = this._conference.getActivePeerConnection();\r\n            const isSimulcastOn\r\n                = Boolean(activeTPC && activeTPC.isSimulcastOn());\r\n\r\n            const newVideoBitrateCap\r\n                = activeTPC && activeTPC.bandwidthLimiter\r\n                && activeTPC.bandwidthLimiter.getBandwidthLimit('video');\r\n\r\n            // If we had a cap set but there isn't one now, then it has\r\n            // just been 'lifted', so we should treat this like a new\r\n            // ramp up.\r\n            if (!newVideoBitrateCap && videoBitrateCap) {\r\n                this._timeLastBwCapRemoved = window.performance.now();\r\n\r\n                // Set the start bitrate to whatever we were just capped to\r\n                startBitrate = videoBitrateCap;\r\n            }\r\n            videoBitrateCap = newVideoBitrateCap;\r\n\r\n            // time since sending of video was enabled.\r\n            const millisSinceStart = window.performance.now()\r\n                - Math.max(this._timeVideoUnmuted,\r\n                    this._timeIceConnected,\r\n                    this._timeLastBwCapRemoved);\r\n\r\n            // expected sending bitrate in perfect conditions\r\n            let target\r\n                = getTarget(isSimulcastOn, resolution, millisSinceStart);\r\n\r\n            target = Math.min(0.9 * target, MAX_TARGET_BITRATE);\r\n\r\n            if (videoBitrateCap) {\r\n                target = Math.min(target, videoBitrateCap);\r\n            }\r\n\r\n            quality = 100 * this._localStats.bitrate.upload / target;\r\n\r\n            // Whatever the bitrate, drop early if there is significant loss\r\n            if (packetLoss && packetLoss >= 10) {\r\n                quality = Math.min(quality, 30);\r\n            }\r\n        }\r\n\r\n        // Make sure that the quality doesn't climb quickly\r\n        if (this._lastConnectionQualityUpdate > 0) {\r\n            const maxIncreasePerSecond = 2;\r\n            const prevConnectionQuality = this._localStats.connectionQuality;\r\n            const diffSeconds\r\n                = (window.performance.now() - this._lastConnectionQualityUpdate)\r\n                    / 1000;\r\n\r\n            quality\r\n                = Math.min(\r\n                    quality,\r\n                    prevConnectionQuality\r\n                        + (diffSeconds * maxIncreasePerSecond));\r\n        }\r\n\r\n        return Math.min(100, quality);\r\n    }\r\n\r\n    /**\r\n     * Updates the localConnectionQuality value\r\n     * @param values {number} the new value. Should be in [0, 100].\r\n     */\r\n    _updateLocalConnectionQuality(value) {\r\n        this._localStats.connectionQuality = value;\r\n        this._lastConnectionQualityUpdate = window.performance.now();\r\n    }\r\n\r\n    /**\r\n     * Broadcasts the local statistics to all other participants in the\r\n     * conference.\r\n     */\r\n    _broadcastLocalStats() {\r\n        // Send only the data that remote participants care about.\r\n        const data = {\r\n            bitrate: this._localStats.bitrate,\r\n            packetLoss: this._localStats.packetLoss,\r\n            connectionQuality: this._localStats.connectionQuality,\r\n            jvbRTT: this._localStats.jvbRTT,\r\n            serverRegion: this._localStats.serverRegion\r\n        };\r\n\r\n        try {\r\n            this._conference.broadcastEndpointMessage({\r\n                type: STATS_MESSAGE_TYPE,\r\n                values: data });\r\n        } catch (e) {\r\n            // We often hit this in the beginning of a call, before the data\r\n            // channel is ready. It is not a big problem, because we will\r\n            // send the statistics again after a few seconds, and the error is\r\n            // already logged elsewhere. So just ignore it.\r\n\r\n            // let errorMsg = \"Failed to broadcast local stats\";\r\n            // logger.error(errorMsg, e);\r\n            // GlobalOnErrorHandler.callErrorHandler(\r\n            //    new Error(errorMsg + \": \" + e));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the local statistics\r\n     * @param {TraceablePeerConnection} tpc the peerconnection which emitted\r\n     * the stats\r\n     * @param data new statistics\r\n     */\r\n    _updateLocalStats(tpc, data) {\r\n        // Update jvbRTT\r\n        if (!tpc.isP2P) {\r\n            const jvbRTT\r\n                = data.transport\r\n                    && data.transport.length && data.transport[0].rtt;\r\n\r\n            this._localStats.jvbRTT = jvbRTT ? jvbRTT : undefined;\r\n        }\r\n\r\n        // Do not continue with processing of other stats if they do not\r\n        // originate from the active peerconnection\r\n        if (tpc !== this._conference.getActivePeerConnection()) {\r\n            return;\r\n        }\r\n\r\n        let key;\r\n        const updateLocalConnectionQuality\r\n            = !this._conference.isConnectionInterrupted();\r\n        const localVideoTrack\r\n            = this._conference.getLocalVideoTrack();\r\n        const videoType\r\n            = localVideoTrack ? localVideoTrack.videoType : undefined;\r\n        const isMuted = localVideoTrack ? localVideoTrack.isMuted() : true;\r\n        const resolution = localVideoTrack ? localVideoTrack.resolution : null;\r\n\r\n        if (!isMuted) {\r\n            this._maybeUpdateUnmuteTime();\r\n        }\r\n\r\n        // Copy the fields already in 'data'.\r\n        for (key in data) {\r\n            if (data.hasOwnProperty(key)) {\r\n                this._localStats[key] = data[key];\r\n            }\r\n        }\r\n\r\n        // And re-calculate the connectionQuality field.\r\n        if (updateLocalConnectionQuality) {\r\n            this._updateLocalConnectionQuality(\r\n                this._calculateConnectionQuality(\r\n                    videoType,\r\n                    isMuted,\r\n                    resolution));\r\n        }\r\n\r\n        this.eventEmitter.emit(\r\n            ConnectionQualityEvents.LOCAL_STATS_UPDATED,\r\n            this._localStats);\r\n        this._broadcastLocalStats();\r\n    }\r\n\r\n    /**\r\n     * Updates remote statistics\r\n     * @param id the id of the remote participant\r\n     * @param data the statistics received\r\n     */\r\n    _updateRemoteStats(id, data) {\r\n        // Use only the fields we need\r\n        this._remoteStats[id] = {\r\n            bitrate: data.bitrate,\r\n            packetLoss: data.packetLoss,\r\n            connectionQuality: data.connectionQuality,\r\n            jvbRTT: data.jvbRTT,\r\n            serverRegion: data.serverRegion\r\n        };\r\n\r\n        this.eventEmitter.emit(\r\n            ConnectionQualityEvents.REMOTE_STATS_UPDATED,\r\n            id,\r\n            this._remoteStats[id]);\r\n    }\r\n\r\n    /**\r\n     * Returns the local statistics.\r\n     * Exported only for use in qhsense-meet-torture.\r\n     */\r\n    getStats() {\r\n        return this._localStats;\r\n    }\r\n}\r\n","/* global __filename */\r\nimport { getLogger } from 'qhsense-meet-logger';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * A delayed ICE failed notification which is triggered only if the ICE\r\n * connection does not recover soon after or before the XMPP connection is\r\n * restored (if it was ever broken). If ICE fails while the XMPP connection is\r\n * not broken then the notifications will be sent after 2 seconds delay. This\r\n * extra delay is not intentional just a side effect of the code.\r\n * NOTE that this delayed task can only be used if PING is supported by the XMPP\r\n * server.\r\n */\r\nexport default class IceFailedNotification {\r\n    /**\r\n     * Creates new {@code DelayedIceFailed} task.\r\n     * @param {QHSenseConference} conference\r\n     */\r\n    constructor(conference) {\r\n        this._conference = conference;\r\n    }\r\n\r\n    /**\r\n     * Starts the task.\r\n     * @param {JingleSessionPC} session - the JVB Jingle session.\r\n     */\r\n    start(session) {\r\n        // The 65 seconds are greater than the default Prosody's BOSH\r\n        // timeout of 60. This gives some time for the XMPP connection\r\n        // to recover.\r\n        this._conference.xmpp.ping(65000).then(\r\n            () => {\r\n                if (this._canceled) {\r\n                    return;\r\n                }\r\n\r\n                if (this._conference.isJvbConnectionInterrupted) {\r\n                    this._iceFailedTimeout = window.setTimeout(() => {\r\n                        logger.info(\r\n                            'Sending ICE failed'\r\n                            + ' - the connection has not recovered');\r\n                        this._iceFailedTimeout = undefined;\r\n                        session.sendIceFailedNotification();\r\n                    }, 2000);\r\n                } else {\r\n                    logger.info(\r\n                        'ICE connection restored - not sending ICE failed');\r\n                }\r\n            },\r\n            error => {\r\n                logger.error(\r\n                    'PING error/timeout - not sending ICE failed', error);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Cancels the task.\r\n     */\r\n    cancel() {\r\n        this._canceled = true;\r\n        if (this._iceFailedTimeout) {\r\n            window.clearTimeout(this._iceFailedTimeout);\r\n        }\r\n    }\r\n}\r\n","/* global __filename */\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport { createE2eRttEvent } from '../../service/statistics/AnalyticsEvents';\r\nimport * as E2ePingEvents\r\n    from '../../service/e2eping/E2ePingEvents';\r\nimport * as QHSenseConferenceEvents from '../../QHSenseConferenceEvents';\r\nimport Statistics from '../statistics/statistics';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * The 'type' of a message which designates an e2e ping request.\r\n * @type {string}\r\n */\r\nconst E2E_PING_REQUEST = 'e2e-ping-request';\r\n\r\n/**\r\n * The 'type' of a message which designates an e2e ping response.\r\n * @type {string}\r\n */\r\nconst E2E_PING_RESPONSE = 'e2e-ping-response';\r\n\r\n/**\r\n * Saves e2e ping related state for a single QHSenseParticipant.\r\n */\r\nclass ParticipantWrapper {\r\n    /**\r\n     * Creates a ParticipantWrapper\r\n     * @param {QHSenseParticipant} participant - The remote participant that this\r\n     * object wraps.\r\n     * @param {E2ePing} e2eping\r\n     */\r\n    constructor(participant, e2eping) {\r\n        // The QHSenseParticipant\r\n        this.participant = participant;\r\n\r\n        // The E2ePing\r\n        this.e2eping = e2eping;\r\n\r\n        // Caches the ID\r\n        this.id = participant.getId();\r\n\r\n        // Recently sent requests\r\n        this.requests = {};\r\n\r\n        // The ID of the last sent request. We just increment it for each new\r\n        // request. Start at 1 so we can consider only thruthy values valid.\r\n        this.lastRequestId = 1;\r\n\r\n        this.clearIntervals = this.clearIntervals.bind(this);\r\n        this.sendRequest = this.sendRequest.bind(this);\r\n        this.handleResponse = this.handleResponse.bind(this);\r\n        this.maybeSendAnalytics = this.maybeSendAnalytics.bind(this);\r\n        this.sendAnalytics = this.sendAnalytics.bind(this);\r\n\r\n        // If the data channel was already open (this is likely a participant\r\n        // joining an existing conference) send a request immediately.\r\n        if (e2eping.isDataChannelOpen) {\r\n            this.sendRequest();\r\n        }\r\n\r\n        this.pingInterval = window.setInterval(\r\n            this.sendRequest, e2eping.pingIntervalMs);\r\n        this.analyticsInterval = window.setTimeout(\r\n            this.maybeSendAnalytics, this.e2eping.analyticsIntervalMs);\r\n    }\r\n\r\n    /**\r\n     * Clears the interval which sends pings.\r\n     * @type {*}\r\n     */\r\n    clearIntervals() {\r\n        if (this.pingInterval) {\r\n            window.clearInterval(this.pingInterval);\r\n        }\r\n        if (this.analyticsInterval) {\r\n            window.clearInterval(this.analyticsInterval);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends the next ping request.\r\n     * @type {*}\r\n     */\r\n    sendRequest() {\r\n        const requestId = this.lastRequestId++;\r\n        const requestMessage = {\r\n            type: E2E_PING_REQUEST,\r\n            id: requestId\r\n        };\r\n\r\n        this.e2eping.sendMessage(requestMessage, this.id);\r\n        this.requests[requestId] = {\r\n            id: requestId,\r\n            timeSent: window.performance.now()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Handles a response from this participant.\r\n     * @type {*}\r\n     */\r\n    handleResponse(response) {\r\n        const request = this.requests[response.id];\r\n\r\n        if (request) {\r\n            request.rtt = window.performance.now() - request.timeSent;\r\n            this.e2eping.eventEmitter.emit(\r\n                E2ePingEvents.E2E_RTT_CHANGED,\r\n                this.participant,\r\n                request.rtt);\r\n        }\r\n\r\n        this.maybeSendAnalytics();\r\n    }\r\n\r\n    /**\r\n     * Goes over the requests, clearing ones which we don't need anymore, and\r\n     * if it finds at least one request with a valid RTT in the last\r\n     * 'analyticsIntervalMs' then sends an analytics event.\r\n     * @type {*}\r\n     */\r\n    maybeSendAnalytics() {\r\n        const now = window.performance.now();\r\n\r\n        // The RTT we'll report is the minimum RTT measured in the last\r\n        // analyticsInterval\r\n        let rtt = Infinity;\r\n        let request, requestId;\r\n\r\n        // It's time to send analytics. Clean up all requests and find the\r\n        for (requestId in this.requests) {\r\n            if (this.requests.hasOwnProperty(requestId)) {\r\n                request = this.requests[requestId];\r\n\r\n                if (request.timeSent < now - this.e2eping.analyticsIntervalMs) {\r\n                    // An old request. We don't care about it anymore.\r\n                    delete this.requests[requestId];\r\n                } else if (request.rtt) {\r\n                    rtt = Math.min(rtt, request.rtt);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (rtt < Infinity) {\r\n            this.sendAnalytics(rtt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends an analytics event for this participant with the given RTT.\r\n     * @type {*}\r\n     */\r\n    sendAnalytics(rtt) {\r\n        Statistics.sendAnalytics(createE2eRttEvent(\r\n            this.id,\r\n            this.participant.getProperty('region'),\r\n            rtt));\r\n    }\r\n}\r\n\r\n/**\r\n * Implements end-to-end ping (from one conference participant to another) via\r\n * the qhsense-videobridge channel (either WebRTC data channel or web socket).\r\n *\r\n * TODO: use a broadcast message instead of individual pings to each remote\r\n * participant.\r\n *\r\n * This class:\r\n * 1. Sends periodic ping requests to all other participants in the\r\n * conference.\r\n * 2. Responds to ping requests from other participants.\r\n * 3. Fires events with the end-to-end RTT to each participant whenever a\r\n * response is received.\r\n * 4. Fires analytics events with the end-to-end RTT periodically.\r\n */\r\nexport default class E2ePing {\r\n    /**\r\n     * @param {QHSenseConference} conference - The conference.\r\n     * @param {Function} sendMessage - The function to use to send a message.\r\n     * @param {Object} options\r\n     */\r\n    constructor(conference, options, sendMessage) {\r\n        this.conference = conference;\r\n        this.eventEmitter = conference.eventEmitter;\r\n        this.sendMessage = sendMessage;\r\n\r\n        // The interval at which pings will be sent (<= 0 disables sending).\r\n        this.pingIntervalMs = 10000;\r\n\r\n        // The interval at which analytics events will be sent.\r\n        this.analyticsIntervalMs = 60000;\r\n\r\n        // Maps a participant ID to its ParticipantWrapper\r\n        this.participants = {};\r\n\r\n        // Whether the WebRTC channel has been opened or not.\r\n        this.isDataChannelOpen = false;\r\n\r\n        if (options && options.e2eping) {\r\n            if (typeof options.e2eping.pingInterval === 'number') {\r\n                this.pingIntervalMs = options.e2eping.pingInterval;\r\n            }\r\n            if (typeof options.e2eping.analyticsInterval === 'number') {\r\n                this.analyticsIntervalMs = options.e2eping.analyticsInterval;\r\n            }\r\n\r\n            // We want to report at most once a ping interval.\r\n            if (this.analyticsIntervalMs > 0 && this.analyticsIntervalMs\r\n                < this.pingIntervalMs) {\r\n                this.analyticsIntervalMs = this.pingIntervalMs;\r\n            }\r\n        }\r\n        logger.info(\r\n            `Initializing e2e ping; pingInterval=${\r\n                this.pingIntervalMs}, analyticsInterval=${\r\n                this.analyticsIntervalMs}.`);\r\n\r\n        this.participantJoined = this.participantJoined.bind(this);\r\n        conference.on(\r\n            QHSenseConferenceEvents.USER_JOINED,\r\n            this.participantJoined);\r\n\r\n        this.participantLeft = this.participantLeft.bind(this);\r\n        conference.on(\r\n            QHSenseConferenceEvents.USER_LEFT,\r\n            this.participantLeft);\r\n\r\n        this.messageReceived = this.messageReceived.bind(this);\r\n        conference.on(\r\n            QHSenseConferenceEvents.ENDPOINT_MESSAGE_RECEIVED,\r\n            this.messageReceived);\r\n\r\n        this.dataChannelOpened = this.dataChannelOpened.bind(this);\r\n        conference.on(\r\n            QHSenseConferenceEvents.DATA_CHANNEL_OPENED,\r\n            this.dataChannelOpened);\r\n    }\r\n\r\n    /**\r\n     * Notifies this instance that the communications channel has been opened\r\n     * and it can now send messages via sendMessage.\r\n     */\r\n    dataChannelOpened() {\r\n        this.isDataChannelOpen = true;\r\n\r\n        // We don't want to wait the whole interval before sending the first\r\n        // request, but we can't send it immediately after the participant joins\r\n        // either, because our data channel might not have initialized.\r\n        // So once the data channel initializes, send requests to everyone.\r\n        // Wait an additional 200ms to give a chance to the remote side (if it\r\n        // also just connected as is the case for the first 2 participants in a\r\n        // conference) to open its data channel.\r\n        for (const id in this.participants) {\r\n            if (this.participants.hasOwnProperty(id)) {\r\n                const participantWrapper = this.participants[id];\r\n\r\n                window.setTimeout(participantWrapper.sendRequest, 200);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles a message that was received.\r\n     *\r\n     * @param participant - The message sender.\r\n     * @param payload - The payload of the message.\r\n     */\r\n    messageReceived(participant, payload) {\r\n        // Listen to E2E PING requests and responses from other participants\r\n        // in the conference.\r\n        if (payload.type === E2E_PING_REQUEST) {\r\n            this.handleRequest(participant.getId(), payload);\r\n        } else if (payload.type === E2E_PING_RESPONSE) {\r\n            this.handleResponse(participant.getId(), payload);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles a participant joining the conference. Starts to send ping\r\n     * requests to the participant.\r\n     *\r\n     * @param {String} id - The ID of the participant.\r\n     * @param {QHSenseParticipant} participant - The participant that joined.\r\n     */\r\n    participantJoined(id, participant) {\r\n        if (this.pingIntervalMs <= 0) {\r\n            return;\r\n        }\r\n\r\n        if (this.participants[id]) {\r\n            logger.info(\r\n                `Participant wrapper already exists for ${id}. Clearing.`);\r\n            this.participants[id].clearIntervals();\r\n            delete this.participants[id];\r\n        }\r\n\r\n        this.participants[id] = new ParticipantWrapper(participant, this);\r\n    }\r\n\r\n    /**\r\n     * Handles a participant leaving the conference. Stops sending requests.\r\n     *\r\n     * @param {String} id - The ID of the participant.\r\n     */\r\n    participantLeft(id) {\r\n        if (this.pingIntervalMs <= 0) {\r\n            return;\r\n        }\r\n\r\n        if (this.participants[id]) {\r\n            this.participants[id].clearIntervals();\r\n            delete this.participants[id];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles a ping request coming from another participant.\r\n     *\r\n     * @param {string} participantId - The ID of the participant who sent the\r\n     * request.\r\n     * @param {Object} request - The request.\r\n     */\r\n    handleRequest(participantId, request) {\r\n        // If it's a valid request, just send a response.\r\n        if (request && request.id) {\r\n            const response = {\r\n                type: E2E_PING_RESPONSE,\r\n                id: request.id\r\n            };\r\n\r\n            this.sendMessage(response, participantId);\r\n        } else {\r\n            logger.info(\r\n                `Received an invalid e2e ping request from ${participantId}.`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles a ping response coming from another participant\r\n     * @param {string} participantId - The ID of the participant who sent the\r\n     * response.\r\n     * @param {Object} response - The response.\r\n     */\r\n    handleResponse(participantId, response) {\r\n        const participantWrapper = this.participants[participantId];\r\n\r\n        if (participantWrapper) {\r\n            participantWrapper.handleResponse(response);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops this E2ePing (i.e. stop sending requests).\r\n     */\r\n    stop() {\r\n        logger.info('Stopping e2eping');\r\n\r\n        this.conference.off(\r\n            QHSenseConferenceEvents.USER_JOINED,\r\n            this.participantJoined);\r\n        this.conference.off(\r\n            QHSenseConferenceEvents.USER_LEFT,\r\n            this.participantLeft);\r\n        this.conference.off(\r\n            QHSenseConferenceEvents.ENDPOINT_MESSAGE_RECEIVED,\r\n            this.messageReceived);\r\n        this.conference.off(\r\n            QHSenseConferenceEvents.DATA_CHANNEL_OPENED,\r\n            this.dataChannelOpened);\r\n\r\n        for (const id in this.participants) {\r\n            if (this.participants.hasOwnProperty(id)) {\r\n                this.participants[id].clearIntervals();\r\n            }\r\n        }\r\n\r\n        this.participants = {};\r\n    }\r\n}\r\n\r\n","/* global __filename */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport * as QHSenseConferenceEvents from '../../QHSenseConferenceEvents';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Emits {@link QHSenseConferenceEvents.JVB121_STATUS} events based on the current\r\n * P2P status and the conference participants count. See the event description\r\n * for more info.\r\n */\r\nexport default class Jvb121EventGenerator {\r\n    /**\r\n     * Creates new <tt>Jvb121EventGenerator</tt> for the given conference.\r\n     * @param {QHSenseConference} conference\r\n     */\r\n    constructor(conference) {\r\n        this._conference = conference;\r\n\r\n        /**\r\n         * Indicates whether it's a one to one JVB conference (<tt>true</tt>)\r\n         * or a multiparty (<tt>false</tt>). Will be also <tt>false</tt> if\r\n         * the conference is currently in the P2P mode.\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._jvb121 = true;\r\n\r\n        this._conference.addEventListener(\r\n            QHSenseConferenceEvents.USER_JOINED, () => this.evaluateStatus());\r\n        this._conference.addEventListener(\r\n            QHSenseConferenceEvents.USER_LEFT, () => this.evaluateStatus());\r\n        this._conference.addEventListener(\r\n            QHSenseConferenceEvents.P2P_STATUS, () => this.evaluateStatus());\r\n    }\r\n\r\n    /**\r\n     * Checks whether the JVB121 value should be updated and a new event\r\n     * emitted.\r\n     */\r\n    evaluateStatus() {\r\n        const oldStatus = this._jvb121;\r\n        const newStatus\r\n            = !this._conference.isP2PActive()\r\n                && this._conference.getParticipantCount() <= 2;\r\n\r\n        if (oldStatus !== newStatus) {\r\n            this._jvb121 = newStatus;\r\n            logger.debug(`JVB121 status ${oldStatus} => ${newStatus}`);\r\n            this._conference.eventEmitter.emit(\r\n                QHSenseConferenceEvents.JVB121_STATUS, oldStatus, newStatus);\r\n        }\r\n    }\r\n}\r\n","import { getLogger } from 'qhsense-meet-logger';\r\n\r\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\r\n\r\nimport JibriSession from './JibriSession';\r\nimport recordingXMLUtils from './recordingXMLUtils';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * A class responsible for starting and stopping recording sessions and emitting\r\n * state updates for them.\r\n */\r\nclass RecordingManager {\r\n    /**\r\n     * Initialize {@code RecordingManager} with other objects that are necessary\r\n     * for starting a recording.\r\n     *\r\n     * @param {ChatRoom} chatRoom - The chat room to handle.\r\n     * @returns {void}\r\n     */\r\n    constructor(chatRoom) {\r\n        /**\r\n         * All known recording sessions from the current conference.\r\n         */\r\n        this._sessions = {};\r\n\r\n        this._chatRoom = chatRoom;\r\n\r\n        this.onPresence = this.onPresence.bind(this);\r\n\r\n        this._chatRoom.eventEmitter.addListener(\r\n            XMPPEvents.PRESENCE_RECEIVED, this.onPresence);\r\n    }\r\n\r\n    /**\r\n     * Finds an existing recording session by session ID.\r\n     *\r\n     * @param {string} sessionID - The session ID associated with the recording.\r\n     * @returns {JibriSession|undefined}\r\n     */\r\n    getSession(sessionID) {\r\n        return this._sessions[sessionID];\r\n    }\r\n\r\n    /**\r\n     * Callback to invoke to parse through a presence update to find recording\r\n     * related updates (from Jibri participant doing the recording and the\r\n     * focus which controls recording).\r\n     *\r\n     * @param {Object} event - The presence data from the pubsub event.\r\n     * @param {Node} event.presence - An XMPP presence update.\r\n     * @param {boolean} event.fromHiddenDomain - Whether or not the update comes\r\n     * from a participant that is trusted but not visible, as would be the case\r\n     * with the Jibri recorder participant.\r\n     * @returns {void}\r\n     */\r\n    onPresence({ fromHiddenDomain, presence }) {\r\n        if (recordingXMLUtils.isFromFocus(presence)) {\r\n            this._handleFocusPresence(presence);\r\n        } else if (fromHiddenDomain) {\r\n            this._handleJibriPresence(presence);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start a recording session.\r\n     *\r\n     * @param {Object} options - Configuration for the recording.\r\n     * @param {string} [options.appData] - Data specific to the app/service that\r\n     * the result file will be uploaded.\r\n     * @param {string} [optional] options.broadcastId - The channel on which a\r\n     * live stream will occur.\r\n     * @param {string} options.mode - The mode in which recording should be\r\n     * started. Recognized values are \"file\" and \"stream\".\r\n     * @param {string} [optional] options.streamId - The stream key to be used\r\n     * for live stream broadcasting. Required for live streaming.\r\n     * @returns {Promise} A promise for starting a recording, which will pass\r\n     * back the session on success. The promise resolves after receiving an\r\n     * acknowledgment of the start request success or fail.\r\n     */\r\n    startRecording(options) {\r\n        const session = new JibriSession({\r\n            ...options,\r\n            connection: this._chatRoom.connection\r\n        });\r\n\r\n        return session.start({\r\n            appData: options.appData,\r\n            broadcastId: options.broadcastId,\r\n            focusMucJid: this._chatRoom.focusMucJid,\r\n            streamId: options.streamId\r\n        })\r\n            .then(() => {\r\n                // Only store the session and emit if the session has not been\r\n                // added already. This is a workaround for the session getting\r\n                // created due to a presence update to announce a \"pending\"\r\n                // recording being received before JibriSession#start finishes.\r\n                if (!this.getSession(session.getID())) {\r\n                    this._addSession(session);\r\n                    this._emitSessionUpdate(session);\r\n                }\r\n\r\n                return session;\r\n            })\r\n            .catch(error => {\r\n                this._emitSessionUpdate(session);\r\n\r\n                return Promise.reject(error);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Stop a recording session.\r\n     *\r\n     * @param {string} sessionID - The ID associated with the recording session\r\n     * to be stopped.\r\n     * @returns {Promise} The promise resolves after receiving an\r\n     * acknowledgment of the stop request success or fail.\r\n     */\r\n    stopRecording(sessionID) {\r\n        const session = this.getSession(sessionID);\r\n\r\n        if (session) {\r\n            return session.stop({ focusMucJid: this._chatRoom.focusMucJid });\r\n        }\r\n\r\n        return Promise.reject(new Error('Could not find session'));\r\n    }\r\n\r\n    /**\r\n     * Stores a reference to the passed in JibriSession.\r\n     *\r\n     * @param {string} session - The JibriSession instance to store.\r\n     * @returns {void}\r\n     */\r\n    _addSession(session) {\r\n        this._sessions[session.getID()] = session;\r\n    }\r\n\r\n    /**\r\n     * Create a new instance of a recording session and stores a reference to\r\n     * it.\r\n     *\r\n     * @param {string} sessionID - The session ID of the recording in progress.\r\n     * @param {string} status - The current status of the recording session.\r\n     * @param {string} mode - The recording mode of the session.\r\n     * @returns {JibriSession}\r\n     */\r\n    _createSession(sessionID, status, mode) {\r\n        const session = new JibriSession({\r\n            connection: this._chatRoom.connection,\r\n            focusMucJid: this._chatRoom.focusMucJid,\r\n            mode,\r\n            sessionID,\r\n            status\r\n        });\r\n\r\n        this._addSession(session);\r\n\r\n        return session;\r\n    }\r\n\r\n    /**\r\n     * Notifies listeners of an update to a recording session.\r\n     *\r\n     * @param {JibriSession} session - The session that has been updated.\r\n     */\r\n    _emitSessionUpdate(session) {\r\n        this._chatRoom.eventEmitter.emit(\r\n            XMPPEvents.RECORDER_STATE_CHANGED, session);\r\n    }\r\n\r\n    /**\r\n     * Parses presence to update an existing JibriSession or to create a new\r\n     * JibriSession.\r\n     *\r\n     * @param {Node} presence - An XMPP presence update.\r\n     * @returns {void}\r\n     */\r\n    _handleFocusPresence(presence) {\r\n        const jibriStatus = recordingXMLUtils.getFocusRecordingUpdate(presence);\r\n\r\n        if (!jibriStatus) {\r\n            return;\r\n        }\r\n\r\n        const { sessionID, status, error, recordingMode } = jibriStatus;\r\n\r\n        // We'll look for an existing session or create one (in case we're a\r\n        // participant joining a call with an existing recording going on).\r\n        let session = this.getSession(sessionID);\r\n\r\n        // Handle the case where a status update is received in presence but\r\n        // the local participant has joined while the JibriSession has already\r\n        // ended.\r\n        if (!session && status === 'off') {\r\n            logger.warn(\r\n                'Ignoring recording presence update',\r\n                'Received a new session with status off.');\r\n\r\n            return;\r\n        }\r\n\r\n        // Jicofo sends updates via presence, and any extension in presence\r\n        // is sent until it is explicitly removed.  It's difficult for\r\n        // Jicofo to know when a presence has been sent once, so it won't\r\n        // remove jibri status extension.  This means we may receive the same\r\n        // status update more than once, so check for that here\r\n        if (session\r\n            && session.getStatus() === status\r\n            && session.getError() === error) {\r\n            logger.warn('Ignoring duplicate presence update: ',\r\n                JSON.stringify(jibriStatus));\r\n\r\n            return;\r\n        }\r\n\r\n        if (!session) {\r\n            session = this._createSession(sessionID, status, recordingMode);\r\n        }\r\n\r\n        session.setStatus(status);\r\n\r\n        if (error) {\r\n            session.setError(error);\r\n        }\r\n\r\n        this._emitSessionUpdate(session);\r\n    }\r\n\r\n    /**\r\n     * Handles updates from the Jibri which can broadcast a YouTube URL that\r\n     * needs to be updated in a JibriSession.\r\n     *\r\n     * @param {Node} presence - An XMPP presence update.\r\n     * @returns {void}\r\n     */\r\n    _handleJibriPresence(presence) {\r\n        const { liveStreamViewURL, mode, sessionID }\r\n            = recordingXMLUtils.getHiddenDomainUpdate(presence);\r\n\r\n        if (!sessionID) {\r\n            logger.warn(\r\n                'Ignoring potential jibri presence due to no session id.');\r\n\r\n            return;\r\n        }\r\n\r\n        let session = this.getSession(sessionID);\r\n\r\n        if (!session) {\r\n            session = this._createSession(sessionID, '', mode);\r\n        }\r\n\r\n        session.setLiveStreamViewURL(liveStreamViewURL);\r\n\r\n        this._emitSessionUpdate(session);\r\n    }\r\n}\r\n\r\nexport default RecordingManager;\r\n","import browser from '../browser';\r\nimport { createRttByRegionEvent }\r\n    from '../../service/statistics/AnalyticsEvents';\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport RTCUtils from '../RTC/RTCUtils';\r\nimport Statistics from '../statistics/statistics';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * The options to pass to createOffer (we need to offer to receive *something*\r\n * for the PC to gather candidates.\r\n */\r\nconst offerOptions = {\r\n    offerToReceiveAudio: 1,\r\n    offerToReceiveVideo: 0\r\n};\r\n\r\n\r\n/**\r\n * The interval at which the webrtc engine sends STUN keep alive requests.\r\n * @type {number}\r\n */\r\nconst stunKeepAliveIntervalMs = 10000;\r\n\r\n/**\r\n * Wraps a PeerConnection with one specific STUN server and measures the RTT\r\n * to the STUN server.\r\n */\r\nclass PCMonitor {\r\n    /* eslint-disable max-params */\r\n    /**\r\n     *\r\n     * @param {String} region - The region of the STUN server.\r\n     * @param {String} address - The address of the STUN server.\r\n     * @param {number} getStatsIntervalMs how often to call getStats.\r\n     * @param {number} delay the delay after which the PeerConnection will be\r\n     * started (that is, createOffer and setLocalDescription will be invoked).\r\n     *\r\n     */\r\n    constructor(region, address, getStatsIntervalMs, delay) {\r\n        /* eslint-disable max-params */\r\n        this.region = region;\r\n        this.getStatsIntervalMs = getStatsIntervalMs;\r\n        this.getStatsInterval = null;\r\n\r\n        // What we consider the current RTT. It is Math.min(this.rtts).\r\n        this.rtt = Infinity;\r\n\r\n        // The RTT measurements we've made from the latest getStats() calls.\r\n        this.rtts = [];\r\n\r\n        const iceServers = [ { 'url': `stun:${address}` } ];\r\n\r\n        this.pc = new RTCUtils.RTCPeerConnectionType(\r\n            {\r\n                'iceServers': iceServers\r\n            });\r\n\r\n        // Maps a key consisting of the IP address, port and priority of a\r\n        // candidate to some state related to it. If we have more than one\r\n        // network interface we will might multiple srflx candidates and this\r\n        // helps to distinguish between then.\r\n        this.candidates = {};\r\n\r\n        this.stopped = false;\r\n\r\n        this.start = this.start.bind(this);\r\n        this.stop = this.stop.bind(this);\r\n        this.startStatsInterval = this.startStatsInterval.bind(this);\r\n        this.handleCandidateRtt = this.handleCandidateRtt.bind(this);\r\n\r\n        window.setTimeout(this.start, delay);\r\n    }\r\n\r\n    /**\r\n     * Starts this PCMonitor. That is, invokes createOffer and\r\n     * setLocalDescription on the PeerConnection and starts an interval which\r\n     * calls getStats.\r\n     */\r\n    start() {\r\n        if (this.stopped) {\r\n            return;\r\n        }\r\n\r\n        this.pc.createOffer(offerOptions).then(offer => {\r\n            this.pc.setLocalDescription(\r\n                offer,\r\n                () => {\r\n                    logger.info(\r\n                        `setLocalDescription success for ${this.region}`);\r\n                    this.startStatsInterval();\r\n                },\r\n                error => {\r\n                    logger.warn(\r\n                        `setLocalDescription failed for ${this.region}: ${\r\n                            error}`);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Starts an interval which invokes getStats on the PeerConnection and\r\n     * measures the RTTs for the different candidates.\r\n     */\r\n    startStatsInterval() {\r\n        this.getStatsInterval = window.setInterval(\r\n            () => {\r\n                // Note that the data that we use to measure the RTT is only\r\n                // available in the legacy (callback based) getStats API.\r\n                this.pc.getStats(stats => {\r\n                    const results = stats.result();\r\n\r\n                    for (let i = 0; i < results.length; ++i) {\r\n                        const res = results[i];\r\n                        const rttTotal\r\n                            = Number(res.stat('stunKeepaliveRttTotal'));\r\n\r\n                        // We recognize the results that we care for (local\r\n                        // candidates of type srflx) by the existance of the\r\n                        // stunKeepaliveRttTotal stat.\r\n                        if (rttTotal > 0) {\r\n                            const candidateKey\r\n                                = `${res.stat('ipAddress')}_${\r\n                                    res.stat('portNumber')}_${\r\n                                    res.stat('priority')}`;\r\n\r\n                            this.handleCandidateRtt(\r\n                                candidateKey,\r\n                                rttTotal,\r\n                                Number(\r\n                                    res.stat('stunKeepaliveResponsesReceived')),\r\n                                Number(\r\n                                    res.stat('stunKeepaliveRequestsSent')));\r\n                        }\r\n                    }\r\n\r\n                    // After we've measured the RTT for all candidates we,\r\n                    // update the state of the PC with the shortest one.\r\n                    let rtt = Infinity;\r\n\r\n                    for (const key in this.candidates) {\r\n                        if (this.candidates.hasOwnProperty(key)\r\n                            && this.candidates[key].rtt > 0) {\r\n                            rtt = Math.min(rtt, this.candidates[key].rtt);\r\n                        }\r\n                    }\r\n\r\n                    // We keep the last 6 measured RTTs and choose the shortest\r\n                    // one to export to analytics. This is because we often see\r\n                    // failures get a real measurement which end up as Infinity.\r\n                    this.rtts.push(rtt);\r\n                    if (this.rtts.length > 6) {\r\n                        this.rtts = this.rtts.splice(1, 7);\r\n                    }\r\n                    this.rtt = Math.min(...this.rtts);\r\n                });\r\n            },\r\n            this.getStatsIntervalMs\r\n        );\r\n    }\r\n\r\n    /* eslint-disable max-params */\r\n    /**\r\n     * Updates the RTT for a candidate identified by \"key\" based on the values\r\n     * from getStats() and the previously saved state (i.e. old values).\r\n     *\r\n     * @param {String} key the ID for the candidate\r\n     * @param {number} rttTotal the value of the 'stunKeepaliveRttTotal' just\r\n     * measured.\r\n     * @param {number} responsesReceived the value of the\r\n     * 'stunKeepaliveResponsesReceived' stat just measured.\r\n     * @param {number} requestsSent the value of the 'stunKeepaliveRequestsSent'\r\n     * stat just measured.\r\n     */\r\n    handleCandidateRtt(key, rttTotal, responsesReceived, requestsSent) {\r\n        /* eslist-enable max-params */\r\n        if (!this.candidates[key]) {\r\n            this.candidates[key] = {\r\n                rttTotal: 0,\r\n                responsesReceived: 0,\r\n                requestsSent: 0,\r\n                rtt: NaN\r\n            };\r\n        }\r\n\r\n        const rttTotalDiff = rttTotal - this.candidates[key].rttTotal;\r\n        const responsesReceivedDiff\r\n            = responsesReceived - this.candidates[key].responsesReceived;\r\n\r\n        // We observe that when the difference between the number of requests\r\n        // and responses has grown (i.q. when the value below is positive), the\r\n        // the RTT measurements are incorrect (too low). For this reason we\r\n        // ignore these measurement (setting rtt=NaN), but update our state.\r\n        const requestsResponsesDiff\r\n            = (requestsSent - responsesReceived)\r\n            - (this.candidates[key].requestsSent\r\n                - this.candidates[key].responsesReceived);\r\n        let rtt = NaN;\r\n\r\n        if (responsesReceivedDiff > 0 && requestsResponsesDiff === 0) {\r\n            rtt = rttTotalDiff / responsesReceivedDiff;\r\n        }\r\n\r\n        this.candidates[key].rttTotal = rttTotal;\r\n        this.candidates[key].responsesReceived = responsesReceived;\r\n        this.candidates[key].requestsSent = requestsSent;\r\n        this.candidates[key].rtt = rtt;\r\n    }\r\n\r\n\r\n    /**\r\n     * Stops this PCMonitor, clearing its intervals and stopping the\r\n     * PeerConnection.\r\n     */\r\n    stop() {\r\n        if (this.getStatsInterval) {\r\n            window.clearInterval(this.getStatsInterval);\r\n        }\r\n\r\n        this.pc.close();\r\n\r\n        this.stopped = true;\r\n    }\r\n}\r\n\r\n/**\r\n * A class which monitors the round-trip time (RTT) to a set of STUN servers.\r\n * The measured RTTs are sent as analytics events. It uses a separate\r\n * PeerConnection (represented as a PCMonitor) for each STUN server.\r\n */\r\nexport default class RttMonitor {\r\n    /**\r\n     * Initializes a new RttMonitor.\r\n     * @param {Object} config the object holding the configuration.\r\n     */\r\n    constructor(config) {\r\n        if (!config || !config.enabled\r\n            || !browser.supportsLocalCandidateRttStatistics()) {\r\n            return;\r\n        }\r\n\r\n        // Maps a region to the PCMonitor instance for that region.\r\n        this.pcMonitors = {};\r\n\r\n        this.startPCMonitors = this.startPCMonitors.bind(this);\r\n        this.sendAnalytics = this.sendAnalytics.bind(this);\r\n        this.stop = this.stop.bind(this);\r\n\r\n        this.analyticsInterval = null;\r\n        this.stopped = false;\r\n\r\n        const initialDelay = config.initialDelay || 60000;\r\n\r\n\r\n        logger.info(\r\n            `Starting RTT monitor with an initial delay of ${initialDelay}`);\r\n\r\n\r\n        window.setTimeout(\r\n            () => this.startPCMonitors(config),\r\n            initialDelay);\r\n    }\r\n\r\n    /**\r\n     * Starts the PCMonitors according to the configuration.\r\n     */\r\n    startPCMonitors(config) {\r\n        if (!config.stunServers) {\r\n            logger.warn('No stun servers configured.');\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.stopped) {\r\n            return;\r\n        }\r\n\r\n        const getStatsIntervalMs\r\n            = config.getStatsInterval || stunKeepAliveIntervalMs;\r\n        const analyticsIntervalMs\r\n            = config.analyticsInterval || getStatsIntervalMs;\r\n        const count = Object.keys(config.stunServers).length;\r\n        const offset = getStatsIntervalMs / count;\r\n\r\n        // We delay the initialization of each PC so that they are uniformly\r\n        // distributed across the getStatsIntervalMs.\r\n        let i = 0;\r\n\r\n        for (const region in config.stunServers) {\r\n            if (config.stunServers.hasOwnProperty(region)) {\r\n                const address = config.stunServers[region];\r\n\r\n                this.pcMonitors[region]\r\n                    = new PCMonitor(\r\n                        region,\r\n                        address,\r\n                        getStatsIntervalMs,\r\n                        offset * i);\r\n                i++;\r\n            }\r\n        }\r\n\r\n        window.setTimeout(\r\n            () => {\r\n                if (!this.stopped) {\r\n                    this.analyticsInterval\r\n                        = window.setInterval(\r\n                        this.sendAnalytics, analyticsIntervalMs);\r\n                }\r\n            },\r\n            1000);\r\n    }\r\n\r\n    /**\r\n     * Sends an analytics event with the measured RTT to each region/STUN\r\n     * server.\r\n     */\r\n    sendAnalytics() {\r\n        const rtts = {};\r\n\r\n        for (const region in this.pcMonitors) {\r\n            if (this.pcMonitors.hasOwnProperty(region)) {\r\n                const rtt = this.pcMonitors[region].rtt;\r\n\r\n                if (!isNaN(rtt) && rtt !== Infinity) {\r\n                    rtts[region.replace('-', '_')] = rtt;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (rtts) {\r\n            Statistics.sendAnalytics(createRttByRegionEvent(rtts));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops this RttMonitor, clearing all intervals and closing all\r\n     * PeerConnections.\r\n     */\r\n    stop() {\r\n        logger.info('Stopping RttMonitor.');\r\n        this.stopped = true;\r\n        for (const region in this.pcMonitors) {\r\n            if (this.pcMonitors.hasOwnProperty(region)) {\r\n                this.pcMonitors[region].stop();\r\n            }\r\n        }\r\n        this.pcMonitors = {};\r\n\r\n        if (this.analyticsInterval) {\r\n            window.clearInterval(this.analyticsInterval);\r\n        }\r\n    }\r\n}\r\n","/* global __filename */\r\n\r\nimport { createRtpStatsEvent } from '../../service/statistics/AnalyticsEvents';\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport * as ConnectionQualityEvents\r\n    from '../../service/connectivity/ConnectionQualityEvents';\r\nimport * as ConferenceEvents from '../../QHSenseConferenceEvents';\r\nimport * as MediaType from '../../service/RTC/MediaType';\r\nimport browser from '../browser';\r\nimport Statistics from './statistics';\r\nimport * as VideoType from '../../service/RTC/VideoType';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * This will calculate an average for one, named stat and submit it to\r\n * the analytics module when requested. It automatically counts the samples.\r\n */\r\nclass AverageStatReport {\r\n    /**\r\n     * Creates new <tt>AverageStatReport</tt> for given name.\r\n     * @param {string} name that's the name of the event that will be reported\r\n     * to the analytics module.\r\n     */\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.count = 0;\r\n        this.sum = 0;\r\n        this.samples = [];\r\n    }\r\n\r\n    /**\r\n     * Adds the next value that will be included in the average when\r\n     * {@link calculate} is called.\r\n     * @param {number} nextValue\r\n     */\r\n    addNext(nextValue) {\r\n        if (typeof nextValue !== 'number') {\r\n            logger.error(\r\n                `${this.name} - invalid value for idx: ${this.count}`,\r\n                nextValue);\r\n        } else if (!isNaN(nextValue)) {\r\n            this.sum += nextValue;\r\n            this.samples.push(nextValue);\r\n            this.count += 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates an average for the samples collected using {@link addNext}.\r\n     * @return {number|NaN} an average of all collected samples or <tt>NaN</tt>\r\n     * if no samples were collected.\r\n     */\r\n    calculate() {\r\n        return this.sum / this.count;\r\n    }\r\n\r\n    /**\r\n     * Appends the report to the analytics \"data\" object. The object will be\r\n     * set under <tt>prefix</tt> + {@link this.name} key.\r\n     * @param {Object} report the analytics \"data\" object\r\n     */\r\n    appendReport(report) {\r\n        report[`${this.name}_avg`] = this.calculate();\r\n        report[`${this.name}_samples`] = JSON.stringify(this.samples);\r\n    }\r\n\r\n    /**\r\n     * Clears all memory of any samples collected, so that new average can be\r\n     * calculated using this instance.\r\n     */\r\n    reset() {\r\n        this.samples = [];\r\n        this.sum = 0;\r\n        this.count = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Class gathers the stats that are calculated and reported for a\r\n * {@link TraceablePeerConnection} even if it's not currently active. For\r\n * example we want to monitor RTT for the JVB connection while in P2P mode.\r\n */\r\nclass ConnectionAvgStats {\r\n    /**\r\n     * Creates new <tt>ConnectionAvgStats</tt>\r\n     * @param {AvgRTPStatsReporter} avgRtpStatsReporter\r\n     * @param {boolean} isP2P\r\n     * @param {number} n the number of samples, before arithmetic mean is to be\r\n     * calculated and values submitted to the analytics module.\r\n     */\r\n    constructor(avgRtpStatsReporter, isP2P, n) {\r\n        /**\r\n         * Is this instance for JVB or P2P connection ?\r\n         * @type {boolean}\r\n         */\r\n        this.isP2P = isP2P;\r\n\r\n        /**\r\n         * How many samples are to be included in arithmetic mean calculation.\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._n = n;\r\n\r\n        /**\r\n         * The current sample index. Starts from 0 and goes up to {@link _n})\r\n         * when analytics report will be submitted.\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._sampleIdx = 0;\r\n\r\n        /**\r\n         * Average round trip time reported by the ICE candidate pair.\r\n         * @type {AverageStatReport}\r\n         */\r\n        this._avgRTT = new AverageStatReport('rtt');\r\n\r\n        /**\r\n         * Map stores average RTT to the JVB reported by remote participants.\r\n         * Mapped per participant id {@link QHSenseParticipant.getId}.\r\n         *\r\n         * This is used only when {@link ConnectionAvgStats.isP2P} equals to\r\n         * <tt>false</tt>.\r\n         *\r\n         * @type {Map<string,AverageStatReport>}\r\n         * @private\r\n         */\r\n        this._avgRemoteRTTMap = new Map();\r\n\r\n        /**\r\n         * The conference for which stats will be collected and reported.\r\n         * @type {QHSenseConference}\r\n         * @private\r\n         */\r\n        this._avgRtpStatsReporter = avgRtpStatsReporter;\r\n\r\n        /**\r\n         * The latest average E2E RTT for the JVB connection only.\r\n         *\r\n         * This is used only when {@link ConnectionAvgStats.isP2P} equals to\r\n         * <tt>false</tt>.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this._avgEnd2EndRTT = undefined;\r\n\r\n        this._onConnectionStats = (tpc, stats) => {\r\n            if (this.isP2P === tpc.isP2P) {\r\n                this._calculateAvgStats(stats);\r\n            }\r\n        };\r\n\r\n        const conference = avgRtpStatsReporter._conference;\r\n\r\n        conference.statistics.addConnectionStatsListener(\r\n            this._onConnectionStats);\r\n\r\n        if (!this.isP2P) {\r\n            this._onUserLeft = id => this._avgRemoteRTTMap.delete(id);\r\n            conference.on(ConferenceEvents.USER_LEFT, this._onUserLeft);\r\n\r\n            this._onRemoteStatsUpdated\r\n                = (id, data) => this._processRemoteStats(id, data);\r\n            conference.on(\r\n                ConnectionQualityEvents.REMOTE_STATS_UPDATED,\r\n                this._onRemoteStatsUpdated);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes next batch of stats.\r\n     * @param {go figure} data\r\n     * @private\r\n     */\r\n    _calculateAvgStats(data) {\r\n        if (!data) {\r\n            logger.error('No stats');\r\n\r\n            return;\r\n        }\r\n\r\n        if (browser.supportsRTTStatistics()) {\r\n            if (data.transport && data.transport.length) {\r\n                this._avgRTT.addNext(data.transport[0].rtt);\r\n            }\r\n        }\r\n\r\n        this._sampleIdx += 1;\r\n\r\n        if (this._sampleIdx >= this._n) {\r\n            if (browser.supportsRTTStatistics()) {\r\n                const conference = this._avgRtpStatsReporter._conference;\r\n\r\n                const batchReport = {\r\n                    p2p: this.isP2P,\r\n                    'conference_size': conference.getParticipantCount()\r\n                };\r\n\r\n                if (data.transport && data.transport.length) {\r\n                    Object.assign(batchReport, {\r\n                        'local_candidate_type':\r\n                            data.transport[0].localCandidateType,\r\n                        'remote_candidate_type':\r\n                            data.transport[0].remoteCandidateType,\r\n                        'transport_type': data.transport[0].type\r\n                    });\r\n                }\r\n\r\n                this._avgRTT.appendReport(batchReport);\r\n\r\n                if (this.isP2P) {\r\n                    // Report RTT diff only for P2P.\r\n                    const jvbEnd2EndRTT = this\r\n                        ._avgRtpStatsReporter.jvbStatsMonitor._avgEnd2EndRTT;\r\n\r\n                    if (!isNaN(jvbEnd2EndRTT)) {\r\n                        // eslint-disable-next-line dot-notation\r\n                        batchReport['rtt_diff']\r\n                            = this._avgRTT.calculate() - jvbEnd2EndRTT;\r\n                    }\r\n                } else {\r\n                    // Report end to end RTT only for JVB.\r\n                    const avgRemoteRTT = this._calculateAvgRemoteRTT();\r\n                    const avgLocalRTT = this._avgRTT.calculate();\r\n\r\n                    this._avgEnd2EndRTT = avgLocalRTT + avgRemoteRTT;\r\n\r\n                    if (!isNaN(avgLocalRTT) && !isNaN(avgRemoteRTT)) {\r\n                        // eslint-disable-next-line dot-notation\r\n                        batchReport['end2end_rtt_avg'] = this._avgEnd2EndRTT;\r\n                    }\r\n                }\r\n\r\n                Statistics.sendAnalytics(createRtpStatsEvent(batchReport));\r\n            }\r\n\r\n            this._resetAvgStats();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates arithmetic mean of all RTTs towards the JVB reported by\r\n     * participants.\r\n     * @return {number|NaN} NaN if not available (not enough data)\r\n     * @private\r\n     */\r\n    _calculateAvgRemoteRTT() {\r\n        let count = 0, sum = 0;\r\n\r\n        // FIXME should we ignore RTT for participant\r\n        // who \"is having connectivity issues\" ?\r\n        for (const remoteAvg of this._avgRemoteRTTMap.values()) {\r\n            const avg = remoteAvg.calculate();\r\n\r\n            if (!isNaN(avg)) {\r\n                sum += avg;\r\n                count += 1;\r\n                remoteAvg.reset();\r\n            }\r\n        }\r\n\r\n        return sum / count;\r\n    }\r\n\r\n    /**\r\n     * Processes {@link ConnectionQualityEvents.REMOTE_STATS_UPDATED} to analyse\r\n     * RTT towards the JVB reported by each participant.\r\n     * @param {string} id {@link QHSenseParticipant.getId}\r\n     * @param {go figure in ConnectionQuality.js} data\r\n     * @private\r\n     */\r\n    _processRemoteStats(id, data) {\r\n        const validData = typeof data.jvbRTT === 'number';\r\n        let rttAvg = this._avgRemoteRTTMap.get(id);\r\n\r\n        if (!rttAvg && validData) {\r\n            rttAvg = new AverageStatReport(`${id}_stat_rtt`);\r\n            this._avgRemoteRTTMap.set(id, rttAvg);\r\n        }\r\n\r\n        if (validData) {\r\n            rttAvg.addNext(data.jvbRTT);\r\n        } else if (rttAvg) {\r\n            this._avgRemoteRTTMap.delete(id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset cache of all averages and {@link _sampleIdx}.\r\n     * @private\r\n     */\r\n    _resetAvgStats() {\r\n        this._avgRTT.reset();\r\n        if (this._avgRemoteRTTMap) {\r\n            this._avgRemoteRTTMap.clear();\r\n        }\r\n        this._sampleIdx = 0;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    dispose() {\r\n\r\n        const conference = this._avgRtpStatsReporter._conference;\r\n\r\n        conference.statistics.removeConnectionStatsListener(\r\n            this._onConnectionStats);\r\n        if (!this.isP2P) {\r\n            conference.off(\r\n                ConnectionQualityEvents.REMOTE_STATS_UPDATED,\r\n                this._onRemoteStatsUpdated);\r\n            conference.off(\r\n                ConferenceEvents.USER_LEFT,\r\n                this._onUserLeft);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Reports average RTP statistics values (arithmetic mean) to the analytics\r\n * module for things like bit rate, bandwidth, packet loss etc. It keeps track\r\n * of the P2P vs JVB conference modes and submits the values under different\r\n * namespaces (the events for P2P mode have 'p2p.' prefix). Every switch between\r\n * P2P mode resets the data collected so far and averages are calculated from\r\n * scratch.\r\n */\r\nexport default class AvgRTPStatsReporter {\r\n    /**\r\n     * Creates new instance of <tt>AvgRTPStatsReporter</tt>\r\n     * @param {QHSenseConference} conference\r\n     * @param {number} n the number of samples, before arithmetic mean is to be\r\n     * calculated and values submitted to the analytics module.\r\n     */\r\n    constructor(conference, n) {\r\n        /**\r\n         * How many {@link ConnectionQualityEvents.LOCAL_STATS_UPDATED} samples\r\n         * are to be included in arithmetic mean calculation.\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._n = n;\r\n\r\n        if (n > 0) {\r\n            logger.info(`Avg RTP stats will be calculated every ${n} samples`);\r\n        } else {\r\n            logger.info('Avg RTP stats reports are disabled.');\r\n\r\n            // Do not initialize\r\n            return;\r\n        }\r\n\r\n        /**\r\n         * The current sample index. Starts from 0 and goes up to {@link _n})\r\n         * when analytics report will be submitted.\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._sampleIdx = 0;\r\n\r\n        /**\r\n         * The conference for which stats will be collected and reported.\r\n         * @type {QHSenseConference}\r\n         * @private\r\n         */\r\n        this._conference = conference;\r\n\r\n        /**\r\n         * Average audio upload bitrate\r\n         * XXX What are the units?\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgAudioBitrateUp\r\n            = new AverageStatReport('bitrate_audio_upload');\r\n\r\n        /**\r\n         * Average audio download bitrate\r\n         * XXX What are the units?\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgAudioBitrateDown\r\n            = new AverageStatReport('bitrate_audio_download');\r\n\r\n        /**\r\n         * Average video upload bitrate\r\n         * XXX What are the units?\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgVideoBitrateUp\r\n            = new AverageStatReport('bitrate_video_upload');\r\n\r\n        /**\r\n         * Average video download bitrate\r\n         * XXX What are the units?\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgVideoBitrateDown\r\n            = new AverageStatReport('bitrate_video_download');\r\n\r\n        /**\r\n         * Average upload bandwidth\r\n         * XXX What are the units?\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgBandwidthUp\r\n            = new AverageStatReport('bandwidth_upload');\r\n\r\n        /**\r\n         * Average download bandwidth\r\n         * XXX What are the units?\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgBandwidthDown\r\n            = new AverageStatReport('bandwidth_download');\r\n\r\n        /**\r\n         * Average total packet loss\r\n         * XXX What are the units?\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgPacketLossTotal\r\n            = new AverageStatReport('packet_loss_total');\r\n\r\n        /**\r\n         * Average upload packet loss\r\n         * XXX What are the units?\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgPacketLossUp\r\n            = new AverageStatReport('packet_loss_upload');\r\n\r\n        /**\r\n         * Average download packet loss\r\n         * XXX What are the units?\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgPacketLossDown\r\n            = new AverageStatReport('packet_loss_download');\r\n\r\n        /**\r\n         * Average FPS for remote videos\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgRemoteFPS = new AverageStatReport('framerate_remote');\r\n\r\n        /**\r\n         * Average FPS for remote screen streaming videos (reported only if not\r\n         * a <tt>NaN</tt>).\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgRemoteScreenFPS\r\n            = new AverageStatReport('framerate_screen_remote');\r\n\r\n        /**\r\n         * Average FPS for local video (camera)\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgLocalFPS = new AverageStatReport('framerate_local');\r\n\r\n        /**\r\n         * Average FPS for local screen streaming video (reported only if not\r\n         * a <tt>NaN</tt>).\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgLocalScreenFPS\r\n            = new AverageStatReport('framerate_screen_local');\r\n\r\n        /**\r\n         * Average pixels for remote screen streaming videos (reported only if\r\n         * not a <tt>NaN</tt>).\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgRemoteCameraPixels\r\n            = new AverageStatReport('pixels_remote');\r\n\r\n        /**\r\n         * Average pixels for remote screen streaming videos (reported only if\r\n         * not a <tt>NaN</tt>).\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgRemoteScreenPixels\r\n            = new AverageStatReport('pixels_screen_remote');\r\n\r\n        /**\r\n         * Average pixels for local video (camera)\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgLocalCameraPixels\r\n            = new AverageStatReport('pixels_local');\r\n\r\n        /**\r\n         * Average pixels for local screen streaming video (reported only if not\r\n         * a <tt>NaN</tt>).\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgLocalScreenPixels\r\n            = new AverageStatReport('pixels_screen_local');\r\n\r\n        /**\r\n         * Average connection quality as defined by\r\n         * the {@link ConnectionQuality} module.\r\n         * @type {AverageStatReport}\r\n         * @private\r\n         */\r\n        this._avgCQ = new AverageStatReport('connection_quality');\r\n\r\n        this._onLocalStatsUpdated = data => this._calculateAvgStats(data);\r\n        conference.on(\r\n            ConnectionQualityEvents.LOCAL_STATS_UPDATED,\r\n            this._onLocalStatsUpdated);\r\n\r\n        this._onP2PStatusChanged = () => {\r\n            logger.debug('Resetting average stats calculation');\r\n            this._resetAvgStats();\r\n            this.jvbStatsMonitor._resetAvgStats();\r\n            this.p2pStatsMonitor._resetAvgStats();\r\n        };\r\n        conference.on(\r\n            ConferenceEvents.P2P_STATUS,\r\n            this._onP2PStatusChanged);\r\n\r\n        this._onJvb121StatusChanged = (oldStatus, newStatus) => {\r\n            // We want to reset only on the transition from false => true,\r\n            // because otherwise those stats are resetted on JVB <=> P2P\r\n            // transition.\r\n            if (newStatus === true) {\r\n                logger.info('Resetting JVB avg RTP stats');\r\n                this._resetAvgJvbStats();\r\n            }\r\n        };\r\n        conference.on(\r\n            ConferenceEvents.JVB121_STATUS,\r\n            this._onJvb121StatusChanged);\r\n\r\n        this.jvbStatsMonitor\r\n            = new ConnectionAvgStats(this, false /* JVB */, n);\r\n\r\n        this.p2pStatsMonitor\r\n            = new ConnectionAvgStats(this, true /* P2P */, n);\r\n    }\r\n\r\n    /**\r\n     * Processes next batch of stats reported on\r\n     * {@link ConnectionQualityEvents.LOCAL_STATS_UPDATED}.\r\n     * @param {go figure} data\r\n     * @private\r\n     */\r\n    _calculateAvgStats(data) {\r\n\r\n        if (!data) {\r\n            logger.error('No stats');\r\n\r\n            return;\r\n        }\r\n\r\n        const isP2P = this._conference.isP2PActive();\r\n        const confSize = this._conference.getParticipantCount();\r\n\r\n        if (!isP2P && confSize < 2) {\r\n\r\n            // There's no point in collecting stats for a JVB conference of 1.\r\n            // That happens for short period of time after everyone leaves\r\n            // the room, until Jicofo terminates the session.\r\n            return;\r\n        }\r\n\r\n        /* Uncomment to figure out stats structure\r\n        for (const key in data) {\r\n            if (data.hasOwnProperty(key)) {\r\n                logger.info(`local stat ${key}: `, data[key]);\r\n            }\r\n        } */\r\n\r\n        const bitrate = data.bitrate;\r\n        const bandwidth = data.bandwidth;\r\n        const packetLoss = data.packetLoss;\r\n        const frameRate = data.framerate;\r\n        const resolution = data.resolution;\r\n\r\n        if (!bitrate) {\r\n            logger.error('No \"bitrate\"');\r\n\r\n            return;\r\n        } else if (!bandwidth) {\r\n            logger.error('No \"bandwidth\"');\r\n\r\n            return;\r\n        } else if (!packetLoss) {\r\n            logger.error('No \"packetloss\"');\r\n\r\n            return;\r\n        } else if (!frameRate) {\r\n            logger.error('No \"framerate\"');\r\n\r\n            return;\r\n        } else if (!resolution) {\r\n            logger.error('No resolution');\r\n\r\n            return;\r\n        }\r\n\r\n        this._avgAudioBitrateUp.addNext(bitrate.audio.upload);\r\n        this._avgAudioBitrateDown.addNext(bitrate.audio.download);\r\n\r\n        this._avgVideoBitrateUp.addNext(bitrate.video.upload);\r\n        this._avgVideoBitrateDown.addNext(bitrate.video.download);\r\n\r\n        if (browser.supportsBandwidthStatistics()) {\r\n            this._avgBandwidthUp.addNext(bandwidth.upload);\r\n            this._avgBandwidthDown.addNext(bandwidth.download);\r\n        }\r\n\r\n        this._avgPacketLossUp.addNext(packetLoss.upload);\r\n        this._avgPacketLossDown.addNext(packetLoss.download);\r\n        this._avgPacketLossTotal.addNext(packetLoss.total);\r\n\r\n        this._avgCQ.addNext(data.connectionQuality);\r\n\r\n        if (frameRate) {\r\n            this._avgRemoteFPS.addNext(\r\n                this._calculateAvgVideoFps(\r\n                    frameRate, false /* remote */, VideoType.CAMERA));\r\n            this._avgRemoteScreenFPS.addNext(\r\n                this._calculateAvgVideoFps(\r\n                    frameRate, false /* remote */, VideoType.DESKTOP));\r\n\r\n            this._avgLocalFPS.addNext(\r\n                this._calculateAvgVideoFps(\r\n                    frameRate, true /* local */, VideoType.CAMERA));\r\n            this._avgLocalScreenFPS.addNext(\r\n                this._calculateAvgVideoFps(\r\n                    frameRate, true /* local */, VideoType.DESKTOP));\r\n        }\r\n\r\n        if (resolution) {\r\n            this._avgRemoteCameraPixels.addNext(\r\n                this._calculateAvgVideoPixels(\r\n                    resolution, false /* remote */, VideoType.CAMERA));\r\n\r\n            this._avgRemoteScreenPixels.addNext(\r\n                this._calculateAvgVideoPixels(\r\n                    resolution, false /* remote */, VideoType.DESKTOP));\r\n\r\n            this._avgLocalCameraPixels.addNext(\r\n                this._calculateAvgVideoPixels(\r\n                    resolution, true /* local */, VideoType.CAMERA));\r\n\r\n            this._avgLocalScreenPixels.addNext(\r\n                this._calculateAvgVideoPixels(\r\n                    resolution, true /* local */, VideoType.DESKTOP));\r\n        }\r\n\r\n        this._sampleIdx += 1;\r\n\r\n        if (this._sampleIdx >= this._n) {\r\n\r\n            const batchReport = {\r\n                p2p: isP2P,\r\n                'conference_size': confSize\r\n            };\r\n\r\n            if (data.transport && data.transport.length) {\r\n                Object.assign(batchReport, {\r\n                    'local_candidate_type':\r\n                        data.transport[0].localCandidateType,\r\n                    'remote_candidate_type':\r\n                        data.transport[0].remoteCandidateType,\r\n                    'transport_type': data.transport[0].type\r\n                });\r\n            }\r\n\r\n            this._avgAudioBitrateUp.appendReport(batchReport);\r\n            this._avgAudioBitrateDown.appendReport(batchReport);\r\n\r\n            this._avgVideoBitrateUp.appendReport(batchReport);\r\n            this._avgVideoBitrateDown.appendReport(batchReport);\r\n\r\n            if (browser.supportsBandwidthStatistics()) {\r\n                this._avgBandwidthUp.appendReport(batchReport);\r\n                this._avgBandwidthDown.appendReport(batchReport);\r\n            }\r\n            this._avgPacketLossUp.appendReport(batchReport);\r\n            this._avgPacketLossDown.appendReport(batchReport);\r\n            this._avgPacketLossTotal.appendReport(batchReport);\r\n\r\n            this._avgRemoteFPS.appendReport(batchReport);\r\n            if (!isNaN(this._avgRemoteScreenFPS.calculate())) {\r\n                this._avgRemoteScreenFPS.appendReport(batchReport);\r\n            }\r\n            this._avgLocalFPS.appendReport(batchReport);\r\n            if (!isNaN(this._avgLocalScreenFPS.calculate())) {\r\n                this._avgLocalScreenFPS.appendReport(batchReport);\r\n            }\r\n\r\n            this._avgRemoteCameraPixels.appendReport(batchReport);\r\n            if (!isNaN(this._avgRemoteScreenPixels.calculate())) {\r\n                this._avgRemoteScreenPixels.appendReport(batchReport);\r\n            }\r\n            this._avgLocalCameraPixels.appendReport(batchReport);\r\n            if (!isNaN(this._avgLocalScreenPixels.calculate())) {\r\n                this._avgLocalScreenPixels.appendReport(batchReport);\r\n            }\r\n\r\n            this._avgCQ.appendReport(batchReport);\r\n\r\n            Statistics.sendAnalytics(createRtpStatsEvent(batchReport));\r\n\r\n            this._resetAvgStats();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates average number of pixels for the report\r\n     *\r\n     * @param {map} peerResolutions a map of peer resolutions\r\n     * @param {boolean} isLocal if the average is to be calculated for the local\r\n     * video or <tt>false</tt> if for remote videos.\r\n     * @param {VideoType} videoType\r\n     * @return {number|NaN} average number of pixels or <tt>NaN</tt> if there\r\n     * are no samples.\r\n     * @private\r\n     */\r\n    _calculateAvgVideoPixels(peerResolutions, isLocal, videoType) {\r\n        let peerPixelsSum = 0;\r\n        let peerCount = 0;\r\n        const myID = this._conference.myUserId();\r\n\r\n        for (const peerID of Object.keys(peerResolutions)) {\r\n            if (isLocal ? peerID === myID : peerID !== myID) {\r\n                const participant\r\n                    = isLocal\r\n                        ? null\r\n                        : this._conference.getParticipantById(peerID);\r\n                const videosResolution = peerResolutions[peerID];\r\n\r\n                // Do not continue without participant for non local peerID\r\n                if ((isLocal || participant) && videosResolution) {\r\n                    const peerAvgPixels = this._calculatePeerAvgVideoPixels(\r\n                        videosResolution, participant, videoType);\r\n\r\n                    if (!isNaN(peerAvgPixels)) {\r\n                        peerPixelsSum += peerAvgPixels;\r\n                        peerCount += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return peerPixelsSum / peerCount;\r\n    }\r\n\r\n    /**\r\n     * Calculate average pixels for either remote or local participant\r\n     * @param {object} videos maps resolution per video SSRC\r\n     * @param {QHSenseParticipant|null} participant remote participant or\r\n     * <tt>null</tt> for local video pixels calculation.\r\n     * @param {VideoType} videoType the type of the video for which an average\r\n     * will be calculated.\r\n     * @return {number|NaN} average video pixels of all participant's videos or\r\n     * <tt>NaN</tt> if currently not available\r\n     * @private\r\n     */\r\n    _calculatePeerAvgVideoPixels(videos, participant, videoType) {\r\n        let ssrcs = Object.keys(videos).map(ssrc => Number(ssrc));\r\n        let videoTracks = null;\r\n\r\n        // NOTE that this method is supposed to be called for the stats\r\n        // received from the current peerconnection.\r\n        const tpc = this._conference.getActivePeerConnection();\r\n\r\n        if (participant) {\r\n            videoTracks = participant.getTracksByMediaType(MediaType.VIDEO);\r\n            if (videoTracks) {\r\n                ssrcs\r\n                    = ssrcs.filter(\r\n                        ssrc => videoTracks.find(\r\n                            track =>\r\n                                !track.isMuted()\r\n                                    && track.getSSRC() === ssrc\r\n                                    && track.videoType === videoType));\r\n            }\r\n        } else {\r\n            videoTracks = this._conference.getLocalTracks(MediaType.VIDEO);\r\n            ssrcs\r\n                = ssrcs.filter(\r\n                    ssrc => videoTracks.find(\r\n                        track =>\r\n                            !track.isMuted()\r\n                                && tpc.getLocalSSRC(track) === ssrc\r\n                                && track.videoType === videoType));\r\n        }\r\n\r\n        let peerPixelsSum = 0;\r\n        let peerSsrcCount = 0;\r\n\r\n        for (const ssrc of ssrcs) {\r\n            const peerSsrcPixels\r\n                = Number(videos[ssrc].height) * Number(videos[ssrc].width);\r\n\r\n            // FPS is reported as 0 for users with no video\r\n            if (!isNaN(peerSsrcPixels) && peerSsrcPixels > 0) {\r\n                peerPixelsSum += peerSsrcPixels;\r\n                peerSsrcCount += 1;\r\n            }\r\n        }\r\n\r\n        return peerPixelsSum / peerSsrcCount;\r\n    }\r\n\r\n\r\n    /**\r\n     * Calculates average FPS for the report\r\n     * @param {go figure} frameRate\r\n     * @param {boolean} isLocal if the average is to be calculated for the local\r\n     * video or <tt>false</tt> if for remote videos.\r\n     * @param {VideoType} videoType\r\n     * @return {number|NaN} average FPS or <tt>NaN</tt> if there are no samples.\r\n     * @private\r\n     */\r\n    _calculateAvgVideoFps(frameRate, isLocal, videoType) {\r\n        let peerFpsSum = 0;\r\n        let peerCount = 0;\r\n        const myID = this._conference.myUserId();\r\n\r\n        for (const peerID of Object.keys(frameRate)) {\r\n            if (isLocal ? peerID === myID : peerID !== myID) {\r\n                const participant\r\n                    = isLocal\r\n                        ? null : this._conference.getParticipantById(peerID);\r\n                const videosFps = frameRate[peerID];\r\n\r\n                // Do not continue without participant for non local peerID\r\n                if ((isLocal || participant) && videosFps) {\r\n                    const peerAvgFPS\r\n                        = this._calculatePeerAvgVideoFps(\r\n                            videosFps, participant, videoType);\r\n\r\n                    if (!isNaN(peerAvgFPS)) {\r\n                        peerFpsSum += peerAvgFPS;\r\n                        peerCount += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return peerFpsSum / peerCount;\r\n    }\r\n\r\n    /**\r\n     * Calculate average FPS for either remote or local participant\r\n     * @param {object} videos maps FPS per video SSRC\r\n     * @param {QHSenseParticipant|null} participant remote participant or\r\n     * <tt>null</tt> for local FPS calculation.\r\n     * @param {VideoType} videoType the type of the video for which an average\r\n     * will be calculated.\r\n     * @return {number|NaN} average FPS of all participant's videos or\r\n     * <tt>NaN</tt> if currently not available\r\n     * @private\r\n     */\r\n    _calculatePeerAvgVideoFps(videos, participant, videoType) {\r\n        let ssrcs = Object.keys(videos).map(ssrc => Number(ssrc));\r\n        let videoTracks = null;\r\n\r\n        // NOTE that this method is supposed to be called for the stats\r\n        // received from the current peerconnection.\r\n        const tpc = this._conference.getActivePeerConnection();\r\n\r\n        if (participant) {\r\n            videoTracks = participant.getTracksByMediaType(MediaType.VIDEO);\r\n            if (videoTracks) {\r\n                ssrcs\r\n                    = ssrcs.filter(\r\n                        ssrc => videoTracks.find(\r\n                            track => !track.isMuted()\r\n                                && track.getSSRC() === ssrc\r\n                                && track.videoType === videoType));\r\n            }\r\n        } else {\r\n            videoTracks = this._conference.getLocalTracks(MediaType.VIDEO);\r\n            ssrcs\r\n                = ssrcs.filter(\r\n                    ssrc => videoTracks.find(\r\n                        track => !track.isMuted()\r\n                            && tpc.getLocalSSRC(track) === ssrc\r\n                            && track.videoType === videoType));\r\n        }\r\n\r\n        let peerFpsSum = 0;\r\n        let peerSsrcCount = 0;\r\n\r\n        for (const ssrc of ssrcs) {\r\n            const peerSsrcFps = Number(videos[ssrc]);\r\n\r\n            // FPS is reported as 0 for users with no video\r\n            if (!isNaN(peerSsrcFps) && peerSsrcFps > 0) {\r\n                peerFpsSum += peerSsrcFps;\r\n                peerSsrcCount += 1;\r\n            }\r\n        }\r\n\r\n        return peerFpsSum / peerSsrcCount;\r\n    }\r\n\r\n    /**\r\n     * Resets the stats related to JVB connection. Must not be called when in\r\n     * P2P mode, because then the {@link AverageStatReport} instances are\r\n     * tracking P2P stats. Note that this should never happen unless something\r\n     * is wrong with the P2P and JVB121 events.\r\n     * @private\r\n     */\r\n    _resetAvgJvbStats() {\r\n        this._resetAvgStats();\r\n        this.jvbStatsMonitor._resetAvgStats();\r\n    }\r\n\r\n    /**\r\n     * Reset cache of all averages and {@link _sampleIdx}.\r\n     * @private\r\n     */\r\n    _resetAvgStats() {\r\n        this._avgAudioBitrateUp.reset();\r\n        this._avgAudioBitrateDown.reset();\r\n\r\n        this._avgVideoBitrateUp.reset();\r\n        this._avgVideoBitrateDown.reset();\r\n\r\n        this._avgBandwidthUp.reset();\r\n        this._avgBandwidthDown.reset();\r\n\r\n        this._avgPacketLossUp.reset();\r\n        this._avgPacketLossDown.reset();\r\n        this._avgPacketLossTotal.reset();\r\n\r\n        this._avgRemoteFPS.reset();\r\n        this._avgRemoteScreenFPS.reset();\r\n        this._avgLocalFPS.reset();\r\n        this._avgLocalScreenFPS.reset();\r\n\r\n        this._avgRemoteCameraPixels.reset();\r\n        this._avgRemoteScreenPixels.reset();\r\n        this._avgLocalCameraPixels.reset();\r\n        this._avgLocalScreenPixels.reset();\r\n\r\n        this._avgCQ.reset();\r\n\r\n        this._sampleIdx = 0;\r\n    }\r\n\r\n    /**\r\n     * Unregisters all event listeners and stops working.\r\n     */\r\n    dispose() {\r\n        this._conference.off(\r\n            ConferenceEvents.P2P_STATUS,\r\n            this._onP2PStatusChanged);\r\n        this._conference.off(\r\n            ConnectionQualityEvents.LOCAL_STATS_UPDATED,\r\n            this._onLocalStatsUpdated);\r\n        this._conference.off(\r\n            ConferenceEvents.JVB121_STATUS,\r\n            this._onJvb121StatusChanged);\r\n        this.jvbStatsMonitor.dispose();\r\n        this.p2pStatsMonitor.dispose();\r\n    }\r\n}\r\n","import * as QHSenseConferenceEvents from '../../QHSenseConferenceEvents';\r\nimport SpeakerStats from './SpeakerStats';\r\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\r\n\r\n/**\r\n * A collection for tracking speaker stats. Attaches listeners\r\n * to the conference to automatically update on tracked events.\r\n */\r\nexport default class SpeakerStatsCollector {\r\n    /**\r\n     * Initializes a new SpeakerStatsCollector instance.\r\n     *\r\n     * @constructor\r\n     * @param {QHSenseConference} conference - The conference to track.\r\n     * @returns {void}\r\n     */\r\n    constructor(conference) {\r\n        this.stats = {\r\n            users: {\r\n\r\n                // userId: SpeakerStats\r\n            },\r\n            dominantSpeakerId: null\r\n        };\r\n\r\n        const userId = conference.myUserId();\r\n\r\n        this.stats.users[userId] = new SpeakerStats(userId, null, true);\r\n\r\n        conference.addEventListener(\r\n            QHSenseConferenceEvents.DOMINANT_SPEAKER_CHANGED,\r\n            this._onDominantSpeaker.bind(this));\r\n        conference.addEventListener(\r\n            QHSenseConferenceEvents.USER_JOINED,\r\n            this._onUserJoin.bind(this));\r\n        conference.addEventListener(\r\n            QHSenseConferenceEvents.USER_LEFT,\r\n            this._onUserLeave.bind(this));\r\n        conference.addEventListener(\r\n            QHSenseConferenceEvents.DISPLAY_NAME_CHANGED,\r\n            this._onDisplayNameChange.bind(this));\r\n        if (conference.xmpp) {\r\n            conference.xmpp.addListener(\r\n                XMPPEvents.SPEAKER_STATS_RECEIVED,\r\n                this._updateStats.bind(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reacts to dominant speaker change events by changing its speaker stats\r\n     * models to reflect the current dominant speaker.\r\n     *\r\n     * @param {string} dominantSpeakerId - The user id of the new\r\n     * dominant speaker.\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    _onDominantSpeaker(dominantSpeakerId) {\r\n        const oldDominantSpeaker\r\n            = this.stats.users[this.stats.dominantSpeakerId];\r\n        const newDominantSpeaker = this.stats.users[dominantSpeakerId];\r\n\r\n        oldDominantSpeaker && oldDominantSpeaker.setDominantSpeaker(false);\r\n        newDominantSpeaker && newDominantSpeaker.setDominantSpeaker(true);\r\n        this.stats.dominantSpeakerId = dominantSpeakerId;\r\n    }\r\n\r\n    /**\r\n     * Reacts to user join events by creating a new SpeakerStats model.\r\n     *\r\n     * @param {string} userId - The user id of the new user.\r\n     * @param {QHSenseParticipant} - The QHSenseParticipant model for the new user.\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    _onUserJoin(userId, participant) {\r\n        let savedUser = this.stats.users[userId];\r\n\r\n        if (!savedUser) {\r\n            savedUser = this.stats.users[userId]\r\n                = new SpeakerStats(userId, participant.getDisplayName());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reacts to user leave events by updating the associated user's\r\n     * SpeakerStats model.\r\n     *\r\n     * @param {string} userId - The user id of the user that left.\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    _onUserLeave(userId) {\r\n        const savedUser = this.stats.users[userId];\r\n\r\n        if (savedUser) {\r\n            savedUser.markAsHasLeft();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reacts to user name change events by updating the last known name\r\n     * tracked in the associated SpeakerStats model.\r\n     *\r\n     * @param {string} userId - The user id of the user that left.\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    _onDisplayNameChange(userId, newName) {\r\n        const savedUser = this.stats.users[userId];\r\n\r\n        if (savedUser) {\r\n            savedUser.setDisplayName(newName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return a copy of the tracked SpeakerStats models.\r\n     *\r\n     * @returns {Object} The keys are the user ids and the values are the\r\n     * associated user's SpeakerStats model.\r\n     * @private\r\n     */\r\n    getStats() {\r\n        return this.stats.users;\r\n    }\r\n\r\n    /**\r\n     * Updates of the current stats is requested, passing the new values.\r\n     *\r\n     * @param {Object} newStats - The new values used to update current one.\r\n     * @private\r\n     */\r\n    _updateStats(newStats) {\r\n        for (const userId in newStats) { // eslint-disable-line guard-for-in\r\n            let speakerStatsToUpdate;\r\n\r\n            if (this.stats.users[userId]) {\r\n                speakerStatsToUpdate = this.stats.users[userId];\r\n\r\n                if (!speakerStatsToUpdate.getDisplayName()) {\r\n                    speakerStatsToUpdate\r\n                        .setDisplayName(newStats[userId].displayName);\r\n                }\r\n            } else {\r\n                speakerStatsToUpdate = new SpeakerStats(\r\n                    userId, newStats[userId].displayName);\r\n                this.stats.users[userId] = speakerStatsToUpdate;\r\n                speakerStatsToUpdate.markAsHasLeft();\r\n            }\r\n\r\n            speakerStatsToUpdate.totalDominantSpeakerTime\r\n                = newStats[userId].totalDominantSpeakerTime;\r\n        }\r\n    }\r\n}\r\n","const AudioRecorder = require('./audioRecorder');\r\nconst SphinxService = require(\r\n    './transcriptionServices/SphinxTranscriptionService');\r\n\r\nconst BEFORE_STATE = 'before';\r\nconst RECORDING_STATE = 'recording';\r\nconst TRANSCRIBING_STATE = 'transcribing';\r\nconst FINISHED_STATE = 'finished';\r\n\r\n// the amount of characters each line in the transcription will have\r\nconst MAXIMUM_SENTENCE_LENGTH = 80;\r\n\r\n/**\r\n * This is the main object for handing the Transcription. It interacts with\r\n * the audioRecorder to record every person in a conference and sends the\r\n * recorder audio to a transcriptionService. The returned speech-to-text result\r\n * will be merged to create a transcript\r\n * @param {AudioRecorder} audioRecorder An audioRecorder recording a conference\r\n */\r\nfunction Transcriber() {\r\n    // the object which can record all audio in the conference\r\n    this.audioRecorder = new AudioRecorder();\r\n\r\n    // this object can send the recorder audio to a speech-to-text service\r\n    this.transcriptionService = new SphinxService();\r\n\r\n    // holds a counter to keep track if merging can start\r\n    this.counter = null;\r\n\r\n    // holds the date when transcription started which makes it possible\r\n    // to calculate the offset between recordings\r\n    this.startTime = null;\r\n\r\n    // will hold the transcription once it is completed\r\n    this.transcription = null;\r\n\r\n    // this will be a method which will be called once the transcription is done\r\n    // with the transcription as parameter\r\n    this.callback = null;\r\n\r\n    // stores all the retrieved speech-to-text results to merge together\r\n    // this value will store an Array<Word> object\r\n    this.results = [];\r\n\r\n    // Stores the current state of the transcription process\r\n    this.state = BEFORE_STATE;\r\n\r\n    // Used in the updateTranscription method to add a new line when the\r\n    // sentence becomes to long\r\n    this.lineLength = 0;\r\n}\r\n\r\n/**\r\n * Method to start the transcription process. It will tell the audioRecorder\r\n * to start storing all audio streams and record the start time for merging\r\n * purposes\r\n */\r\nTranscriber.prototype.start = function start() {\r\n    if (this.state !== BEFORE_STATE) {\r\n        throw new Error(\r\n            `The transcription can only start when it's in the \"${\r\n                BEFORE_STATE}\" state. It's currently in the \"${\r\n                this.state}\" state`);\r\n    }\r\n    this.state = RECORDING_STATE;\r\n    this.audioRecorder.start();\r\n    this.startTime = new Date();\r\n};\r\n\r\n/**\r\n * Method to stop the transcription process. It will tell the audioRecorder to\r\n * stop, and get all the recorded audio to send it to the transcription service\r\n\r\n * @param callback a callback which will receive the transcription\r\n */\r\nTranscriber.prototype.stop = function stop(callback) {\r\n    if (this.state !== RECORDING_STATE) {\r\n        throw new Error(\r\n            `The transcription can only stop when it's in the \"${\r\n                RECORDING_STATE}\" state. It's currently in the \"${\r\n                this.state}\" state`);\r\n    }\r\n\r\n    // stop the recording\r\n    console.log('stopping recording and sending audio files');\r\n    this.audioRecorder.stop();\r\n\r\n    // and send all recorded audio the the transcription service\r\n    const callBack = blobCallBack.bind(null, this);\r\n\r\n    this.audioRecorder.getRecordingResults().forEach(recordingResult => {\r\n        this.transcriptionService.send(recordingResult, callBack);\r\n        this.counter++;\r\n    });\r\n\r\n    // set the state to \"transcribing\" so that maybeMerge() functions correctly\r\n    this.state = TRANSCRIBING_STATE;\r\n\r\n    // and store the callback for later\r\n    this.callback = callback;\r\n};\r\n\r\n/**\r\n * This method gets the answer from the transcription service, calculates the\r\n * offset and adds is to every Word object. It will also start the merging\r\n * when every send request has been received\r\n *\r\n * note: Make sure to bind this as a Transcription object\r\n * @param {Transcriber} transcriber the transcriber instance\r\n * @param {RecordingResult} answer a RecordingResult object with a defined\r\n * WordArray\r\n */\r\nfunction blobCallBack(transcriber, answer) {\r\n    console.log(\r\n        'retrieved an answer from the transcription service. The answer has an'\r\n            + ` array of length: ${answer.wordArray.length}`);\r\n\r\n    // first add the offset between the start of the transcription and\r\n    // the start of the recording to all start and end times\r\n    if (answer.wordArray.length > 0) {\r\n        let offset = answer.startTime.getUTCMilliseconds()\r\n            - transcriber.startTime.getUTCMilliseconds();\r\n\r\n        // transcriber time will always be earlier\r\n\r\n        if (offset < 0) {\r\n            offset = 0; // presume 0 if it somehow not earlier\r\n        }\r\n\r\n        let array = '[';\r\n\r\n        answer.wordArray.forEach(wordObject => {\r\n            wordObject.begin += offset;\r\n            wordObject.end += offset;\r\n            array += `${wordObject.word},`;\r\n        });\r\n        array += ']';\r\n        console.log(array);\r\n\r\n        // give a name value to the Array object so that the merging can access\r\n        // the name value without having to use the whole recordingResult object\r\n        // in the algorithm\r\n        answer.wordArray.name = answer.name;\r\n    }\r\n\r\n    // then store the array and decrease the counter\r\n    transcriber.results.push(answer.wordArray);\r\n    transcriber.counter--;\r\n    console.log(`current counter: ${transcriber.counter}`);\r\n\r\n    // and check if all results have been received.\r\n    transcriber.maybeMerge();\r\n}\r\n\r\n/**\r\n * this method will check if the counter is zero. If it is, it will call\r\n * the merging method\r\n */\r\nTranscriber.prototype.maybeMerge = function() {\r\n    if (this.state === TRANSCRIBING_STATE && this.counter === 0) {\r\n        // make sure to include the events in the result arrays before\r\n        // merging starts\r\n        this.merge();\r\n    }\r\n};\r\n\r\n/**\r\n * This method will merge all speech-to-text arrays together in one\r\n * readable transcription string\r\n */\r\nTranscriber.prototype.merge = function() {\r\n    console.log(\r\n        `starting merge process!\\n The length of the array: ${\r\n            this.results.length}`);\r\n    this.transcription = '';\r\n\r\n    // the merging algorithm will look over all Word objects who are at pos 0 in\r\n    // every array. It will then select the one closest in time to the\r\n    // previously placed word, while removing the selected word from its array\r\n    // note: words can be skipped the skipped word's begin and end time somehow\r\n    // end up between the closest word start and end time\r\n    const arrays = this.results;\r\n\r\n    // arrays of Word objects\r\n    const potentialWords = []; // array of the first Word objects\r\n    // check if any arrays are already empty and remove them\r\n\r\n    hasPopulatedArrays(arrays);\r\n\r\n    // populate all the potential Words for a first time\r\n    arrays.forEach(array => pushWordToSortedArray(potentialWords, array));\r\n\r\n    // keep adding words to transcription until all arrays are exhausted\r\n    while (hasPopulatedArrays(arrays)) {\r\n        // first select the lowest array;\r\n        let lowestWordArray = arrays[0];\r\n\r\n        arrays.forEach(wordArray => {\r\n            if (wordArray[0].begin < lowestWordArray[0].begin) {\r\n                lowestWordArray = wordArray;\r\n            }\r\n        });\r\n\r\n        // put the word in the transcription\r\n        let wordToAdd = lowestWordArray.shift();\r\n\r\n        this.updateTranscription(wordToAdd, lowestWordArray.name);\r\n\r\n        // keep going until a word in another array has a smaller time\r\n        // or the array is empty\r\n        while (lowestWordArray.length > 0) {\r\n            let foundSmaller = false;\r\n            const wordToCompare = lowestWordArray[0].begin;\r\n\r\n            arrays.forEach(wordArray => {\r\n                if (wordArray[0].begin < wordToCompare) {\r\n                    foundSmaller = true;\r\n                }\r\n            });\r\n\r\n            // add next word if no smaller time has been found\r\n            if (foundSmaller) {\r\n                break;\r\n            }\r\n\r\n            wordToAdd = lowestWordArray.shift();\r\n            this.updateTranscription(wordToAdd, null);\r\n        }\r\n\r\n    }\r\n\r\n    // set the state to finished and do the necessary left-over tasks\r\n    this.state = FINISHED_STATE;\r\n    if (this.callback) {\r\n        this.callback(this.transcription);\r\n    }\r\n};\r\n\r\n/**\r\n * Appends a word object to the transcription. It will make a new line with a\r\n * name if a name is specified\r\n * @param {Word} word the Word object holding the word to append\r\n * @param {String|null} name the name of a new speaker. Null if not applicable\r\n */\r\nTranscriber.prototype.updateTranscription = function(word, name) {\r\n    if (name !== undefined && name !== null) {\r\n        this.transcription += `\\n${name}:`;\r\n        this.lineLength = name.length + 1; // +1 for the semi-colon\r\n    }\r\n    if (this.lineLength + word.word.length > MAXIMUM_SENTENCE_LENGTH) {\r\n        this.transcription += '\\n    ';\r\n        this.lineLength = 4; // because of the 4 spaces after the new line\r\n    }\r\n    this.transcription += ` ${word.word}`;\r\n    this.lineLength += word.word.length + 1; // +1 for the space\r\n};\r\n\r\n/**\r\n * Check if the given 2 dimensional array has any non-zero Word-arrays in them.\r\n * All zero-element arrays inside will be removed\r\n * If any non-zero-element arrays are found, the method will return true.\r\n * otherwise it will return false\r\n * @param {Array<Array>} twoDimensionalArray the array to check\r\n * @returns {boolean} true if any non-zero arrays inside, otherwise false\r\n */\r\nfunction hasPopulatedArrays(twoDimensionalArray) {\r\n    for (let i = 0; i < twoDimensionalArray.length; i++) {\r\n        if (twoDimensionalArray[i].length === 0) {\r\n            twoDimensionalArray.splice(i, 1);\r\n        }\r\n    }\r\n\r\n    return twoDimensionalArray.length > 0;\r\n}\r\n\r\n/**\r\n * Push a word to the right location in a sorted array. The array is sorted\r\n * from lowest to highest start time. Every word is stored in an object which\r\n * includes the name of the person saying the word.\r\n *\r\n * @param {Array<Word>} array the sorted array to push to\r\n * @param {Word} word the word to push into the array\r\n */\r\nfunction pushWordToSortedArray(array, word) {\r\n    if (array.length === 0) {\r\n        array.push(word);\r\n    } else {\r\n        if (array[array.length - 1].begin <= word.begin) {\r\n            array.push(word);\r\n\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (word.begin < array[i].begin) {\r\n                array.splice(i, 0, word);\r\n\r\n                return;\r\n            }\r\n        }\r\n        array.push(word); // fail safe\r\n    }\r\n}\r\n\r\n/**\r\n * Gives the transcriber a QHSenseTrack holding an audioStream to transcribe.\r\n * The QHSenseTrack is given to the audioRecorder. If it doesn't hold an\r\n * audiostream, it will not be added by the audioRecorder\r\n * @param {QHSenseTrack} track the track to give to the audioRecorder\r\n */\r\nTranscriber.prototype.addTrack = function(track) {\r\n    this.audioRecorder.addTrack(track);\r\n};\r\n\r\n/**\r\n * Remove the given track from the auioRecorder\r\n * @param track\r\n */\r\nTranscriber.prototype.removeTrack = function(track) {\r\n    this.audioRecorder.removeTrack(track);\r\n};\r\n\r\n/**\r\n * Will return the created transcription if it's avialable or throw an error\r\n * when it's not done yet\r\n * @returns {String} the transcription as a String\r\n */\r\nTranscriber.prototype.getTranscription = function() {\r\n    if (this.state !== FINISHED_STATE) {\r\n        throw new Error(\r\n            `The transcription can only be retrieved when it's in the \"${\r\n                FINISHED_STATE}\" state. It's currently in the \"${\r\n                this.state}\" state`);\r\n    }\r\n\r\n    return this.transcription;\r\n};\r\n\r\n/**\r\n * Returns the current state of the transcription process\r\n */\r\nTranscriber.prototype.getState = function() {\r\n    return this.state;\r\n};\r\n\r\n/**\r\n * Resets the state to the \"before\" state, such that it's again possible to\r\n * call the start method\r\n */\r\nTranscriber.prototype.reset = function() {\r\n    this.state = BEFORE_STATE;\r\n    this.counter = null;\r\n    this.transcription = null;\r\n    this.startTime = null;\r\n    this.callback = null;\r\n    this.results = [];\r\n    this.lineLength = 0;\r\n};\r\n\r\nmodule.exports = Transcriber;\r\n","import Statistics from '../statistics/statistics';\r\n\r\nconst logger = require('qhsense-meet-logger').getLogger(__filename);\r\n\r\n/**\r\n * The constant for the name of the focus component.\r\n * @type {string}\r\n */\r\nComponentsVersions.FOCUS_COMPONENT = 'focus';\r\n\r\n/**\r\n * The constant for the name of the videobridge component.\r\n * @type {string}\r\n */\r\nComponentsVersions.VIDEOBRIDGE_COMPONENT = 'videobridge';\r\n\r\n/**\r\n * The constant for the name of the XMPP server component.\r\n * @type {string}\r\n */\r\nComponentsVersions.XMPP_SERVER_COMPONENT = 'xmpp';\r\n\r\n/**\r\n * Creates new instance of <tt>ComponentsVersions</tt> which will be discovering\r\n * the versions of conferencing system components in given\r\n * <tt>QHSenseConference</tt>.\r\n * @param conference <tt>QHSenseConference</tt> instance which will be used to\r\n *        listen for focus presence updates.\r\n * @constructor\r\n */\r\nexport default function ComponentsVersions(conference) {\r\n\r\n    this.versions = {};\r\n\r\n    this.conference = conference;\r\n    this.conference.addCommandListener(\r\n        'versions', this.processPresence.bind(this));\r\n}\r\n\r\nComponentsVersions.prototype.processPresence\r\n    = function(node, mucResource, mucJid) {\r\n        if (node.attributes.xmlns !== 'http://jitsi.org/jitmeet') {\r\n            logger.warn('Ignored presence versions node - invalid xmlns', node);\r\n\r\n            return;\r\n        }\r\n\r\n        if (!this.conference._isFocus(mucJid)) {\r\n            logger.warn(\r\n                `Received versions not from the focus user: ${node}`,\r\n                mucJid);\r\n\r\n            return;\r\n        }\r\n\r\n        const log = [];\r\n\r\n        node.children.forEach(item => {\r\n\r\n            const componentName = item.attributes.name;\r\n\r\n            if (componentName !== ComponentsVersions.FOCUS_COMPONENT\r\n            && componentName !== ComponentsVersions.XMPP_SERVER_COMPONENT\r\n            && componentName !== ComponentsVersions.VIDEOBRIDGE_COMPONENT) {\r\n                logger.warn(\r\n                    `Received version for not supported component name: ${\r\n                        componentName}`);\r\n\r\n                return;\r\n            }\r\n\r\n            const version = item.value;\r\n\r\n            if (this.versions[componentName] !== version) {\r\n                this.versions[componentName] = version;\r\n                logger.info(`Got ${componentName} version: ${version}`);\r\n\r\n                log.push({\r\n                    id: 'component_version',\r\n                    component: componentName,\r\n                    version\r\n                });\r\n            }\r\n        });\r\n\r\n        // logs versions to stats\r\n        if (log.length > 0) {\r\n            Statistics.sendLog(JSON.stringify(log));\r\n        }\r\n    };\r\n\r\n/**\r\n * Obtains the version of conferencing system component.\r\n * @param componentName the name of the component for which we want to obtain\r\n *        the version.\r\n * @returns {String} which describes the version of the component identified by\r\n *          given <tt>componentName</tt> or <tt>undefined</tt> if not found.\r\n */\r\nComponentsVersions.prototype.getComponentVersion = function(componentName) {\r\n    return this.versions[componentName];\r\n};\r\n","import { getLogger } from 'qhsense-meet-logger';\r\nconst logger = getLogger(__filename);\r\n\r\nimport QHSenseVideoSIPGWSession from './QHSenseVideoSIPGWSession';\r\nimport * as Constants from './VideoSIPGWConstants';\r\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\r\n\r\n/**\r\n * Main video SIP GW handler. Stores references of all created sessions.\r\n */\r\nexport default class VideoSIPGW {\r\n\r\n    /**\r\n     * Creates new handler.\r\n     *\r\n     * @param {ChatRoom} chatRoom - Tha chat room to handle.\r\n     */\r\n    constructor(chatRoom) {\r\n        this.chatRoom = chatRoom;\r\n        this.eventEmitter = chatRoom.eventEmitter;\r\n        logger.debug('creating VideoSIPGW');\r\n        this.sessions = {};\r\n\r\n        this.sessionStateChangeListener = this.sessionStateChanged.bind(this);\r\n\r\n        // VideoSIPGW, QHSenseConference and ChatRoom are not reusable and no\r\n        // more than one VideoSIPGW can be created per QHSenseConference,\r\n        // so we don't bother to cleanup\r\n        chatRoom.addPresenceListener('jibri-sip-call-state',\r\n            this.handleJibriSIPState.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Handles presence nodes with name: jibri-sip-call-state.\r\n     *\r\n     * @param {Object} node the presence node Object to handle.\r\n     * Object representing part of the presence received over xmpp.\r\n     */\r\n    handleJibriSIPState(node) {\r\n        const attributes = node.attributes;\r\n\r\n        if (!attributes) {\r\n            return;\r\n        }\r\n\r\n        logger.debug('Handle video sip gw state : ', attributes);\r\n\r\n        const newState = attributes.state;\r\n\r\n        if (newState === this.state) {\r\n            return;\r\n        }\r\n\r\n        switch (newState) {\r\n        case Constants.STATE_ON:\r\n        case Constants.STATE_OFF:\r\n        case Constants.STATE_PENDING:\r\n        case Constants.STATE_RETRYING:\r\n        case Constants.STATE_FAILED: {\r\n            const address = attributes.sipaddress;\r\n\r\n            if (!address) {\r\n                return;\r\n            }\r\n\r\n            // find the corresponding session and set its state\r\n            const session = this.sessions[address];\r\n\r\n            if (session) {\r\n                session.setState(newState, attributes.failure_reason);\r\n            } else {\r\n                logger.warn('Video SIP GW session not found:', address);\r\n            }\r\n        }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates new session and stores its reference if it does not exist or\r\n     * returns an error otherwise.\r\n     *\r\n     * @param {string} sipAddress - The sip address to use.\r\n     * @param {string} displayName - The display name to use.\r\n     * @returns {QHSenseVideoSIPGWSession|Error}\r\n     */\r\n    createVideoSIPGWSession(sipAddress, displayName) {\r\n        if (this.sessions[sipAddress]) {\r\n            logger.warn('There was already a Video SIP GW session for address',\r\n                sipAddress);\r\n\r\n            return new Error(Constants.ERROR_SESSION_EXISTS);\r\n        }\r\n\r\n        const session = new QHSenseVideoSIPGWSession(\r\n            sipAddress, displayName, this.chatRoom);\r\n\r\n        session.addStateListener(this.sessionStateChangeListener);\r\n\r\n        this.sessions[sipAddress] = session;\r\n\r\n        return session;\r\n    }\r\n\r\n    /**\r\n     * Listener for session state changed. When a session goes to off or failed\r\n     * we delete its reference.\r\n     *\r\n     * @param {options} event - { address, oldState, newState, displayName }\r\n     */\r\n    sessionStateChanged(event) {\r\n        const address = event.address;\r\n\r\n        if (event.newState === Constants.STATE_OFF\r\n            || event.newState === Constants.STATE_FAILED) {\r\n            const session = this.sessions[address];\r\n\r\n            if (!session) {\r\n                logger.error('Missing Video SIP GW session with address:',\r\n                    address);\r\n\r\n                return;\r\n            }\r\n\r\n            session.removeStateListener(this.sessionStateChangeListener);\r\n            delete this.sessions[address];\r\n        }\r\n\r\n        this.eventEmitter.emit(\r\n            XMPPEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED,\r\n            event);\r\n    }\r\n}\r\n","import { getLogger } from 'qhsense-meet-logger';\r\nimport { $iq } from 'strophe.js';\r\n\r\nimport Listenable from '../util/Listenable';\r\n\r\nimport * as VideoSIPGWConstants from './VideoSIPGWConstants';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * The event name for current sip video session state changed.\r\n * @type {string} event name for sip video session state changed.\r\n */\r\nconst STATE_CHANGED = 'STATE_CHANGED';\r\n\r\n/**\r\n * QHSense video SIP GW session. Holding its state and able to start/stop it.\r\n * When session is in OFF or FAILED stated it cannot be used anymore.\r\n */\r\nexport default class QHSenseVideoSIPGWSession extends Listenable {\r\n\r\n    /**\r\n     * Creates new session with the desired sip address and display name.\r\n     *\r\n     * @param {string} sipAddress - The sip address to use when\r\n     * starting the session.\r\n     * @param {string} displayName - The display name to use for\r\n     * that participant.\r\n     * @param {ChatRoom} chatRoom - The chat room this session is bound to.\r\n     */\r\n    constructor(sipAddress, displayName, chatRoom) {\r\n        super();\r\n\r\n        this.sipAddress = sipAddress;\r\n        this.displayName = displayName;\r\n        this.chatRoom = chatRoom;\r\n\r\n        /*\r\n         * The initial state is undefined. Initial state cannot be STATE_OFF,\r\n         * the session enters this state when it was in STATE_ON and was stopped\r\n         * and such session cannot be used anymore.\r\n         *\r\n         * @type {VideoSIPGWConstants|undefined}\r\n         */\r\n        this.state = undefined;\r\n    }\r\n\r\n    /**\r\n     * Stops the current session.\r\n     */\r\n    stop() {\r\n        if (this.state === VideoSIPGWConstants.STATE_OFF\r\n            || this.state === VideoSIPGWConstants.STATE_FAILED) {\r\n            logger.warn('Video SIP GW session already stopped or failed!');\r\n\r\n            return;\r\n        }\r\n\r\n        this._sendJibriIQ('stop');\r\n    }\r\n\r\n    /**\r\n     * Starts a new session. Sends an iq to the focus.\r\n     */\r\n    start() {\r\n        // if state is off, this session was active for some reason\r\n        // and we should create new one, rather than reusing it\r\n        if (this.state === VideoSIPGWConstants.STATE_ON\r\n            || this.state === VideoSIPGWConstants.STATE_OFF\r\n            || this.state === VideoSIPGWConstants.STATE_PENDING\r\n            || this.state === VideoSIPGWConstants.STATE_RETRYING) {\r\n            logger.warn('Video SIP GW session already started!');\r\n\r\n            return;\r\n        }\r\n\r\n        this._sendJibriIQ('start');\r\n    }\r\n\r\n    /**\r\n     * Changes the state of this session.\r\n     *\r\n     * @param {string} newState - The new {VideoSIPGWConstants} state to set.\r\n     * @param {string} [optional] failureReason - The reason why a failure state\r\n     * was entered.\r\n     * @returns {void}\r\n     */\r\n    setState(newState, failureReason) {\r\n        if (newState === this.state) {\r\n            return;\r\n        }\r\n\r\n        const oldState = this.state;\r\n\r\n        this.state = newState;\r\n        this.eventEmitter.emit(STATE_CHANGED,\r\n            {\r\n                address: this.sipAddress,\r\n                failureReason,\r\n                oldState,\r\n                newState: this.state,\r\n                displayName: this.displayName\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Subscribes the passed listener to the event for state change of this\r\n     * session.\r\n     *\r\n     * @param {Function} listener - The function that will receive the event.\r\n     */\r\n    addStateListener(listener) {\r\n        this.addListener(STATE_CHANGED, listener);\r\n    }\r\n\r\n    /**\r\n     * Unsubscribes the passed handler.\r\n     *\r\n     * @param {Function} listener - The function to be removed.\r\n     */\r\n    removeStateListener(listener) {\r\n        this.removeListener(STATE_CHANGED, listener);\r\n    }\r\n\r\n    /**\r\n     * Sends a jibri command using an iq.\r\n     *\r\n     * @private\r\n     * @param {string} action - The action to send ('start' or 'stop').\r\n     */\r\n    _sendJibriIQ(action) {\r\n        const attributes = {\r\n            'xmlns': 'http://jitsi.org/protocol/jibri',\r\n            'action': action,\r\n            sipaddress: this.sipAddress\r\n        };\r\n\r\n        attributes.displayname = this.displayName;\r\n\r\n        const iq = $iq({\r\n            to: this.chatRoom.focusMucJid,\r\n            type: 'set' })\r\n            .c('jibri', attributes)\r\n            .up();\r\n\r\n        logger.debug(`${action} video SIP GW session`, iq.nodeTree);\r\n        this.chatRoom.connection.sendIQ(\r\n            iq,\r\n            () => {}, // eslint-disable-line no-empty-function\r\n            error => {\r\n                logger.error(\r\n                    `Failed to ${action} video SIP GW session, error: `, error);\r\n                this.setState(VideoSIPGWConstants.STATE_FAILED);\r\n            });\r\n    }\r\n}\r\n","export default {\r\n    error: {\r\n        BUSY: 'busy',\r\n        ERROR: 'error',\r\n        RESOURCE_CONSTRAINT: 'resource-constraint',\r\n        SERVICE_UNAVAILABLE: 'service-unavailable'\r\n    },\r\n    mode: {\r\n        FILE: 'file',\r\n        STREAM: 'stream'\r\n    },\r\n    status: {\r\n        OFF: 'off',\r\n        ON: 'on',\r\n        PENDING: 'pending'\r\n    }\r\n};\r\n","/* globals $ */\r\n\r\nimport { getLogger } from 'qhsense-meet-logger';\r\nimport { $iq } from 'strophe.js';\r\n\r\nimport * as MediaType from '../../service/RTC/MediaType';\r\nimport VideoType from '../../service/RTC/VideoType';\r\nimport RTC from '../RTC/RTC';\r\n\r\nimport ProxyConnectionPC from './ProxyConnectionPC';\r\nimport { ACTIONS } from './constants';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * Instantiates a new ProxyConnectionPC and ensures only one exists at a given\r\n * time. Currently it assumes ProxyConnectionPC is used only for screensharing\r\n * and assumes IQs to be used for communication.\r\n */\r\nexport default class ProxyConnectionService {\r\n    /**\r\n     * Initializes a new {@code ProxyConnectionService} instance.\r\n     *\r\n     * @param {Object} options - Values to initialize the instance with.\r\n     * @param {boolean} [options.convertVideoToDesktop] - Whether or not proxied\r\n     * video should be returned as a desktop stream. Defaults to false.\r\n     * @param {Object} [options.iceConfig] - The {@code RTCConfiguration} to use\r\n     * for the peer connection.\r\n     * @param {QHSenseConnection} [options.qhsenseConnection] - The\r\n     * {@code QHSenseConnection} which will be used to fetch TURN credentials for\r\n     * the P2P connection.\r\n     * @param {Function} options.onRemoteStream - Callback to invoke when a\r\n     * remote video stream has been received and converted to a\r\n     * {@code QHSenseLocakTrack}. The {@code QHSenseLocakTrack} will be passed in.\r\n     * @param {Function} options.onSendMessage - Callback to invoke when a\r\n     * message has to be sent (signaled) out. The arguments passed in are the\r\n     * jid to send the message to and the message\r\n     */\r\n    constructor(options = {}) {\r\n        const {\r\n            qhsenseConnection,\r\n            ...otherOptions\r\n        } = options;\r\n\r\n        /**\r\n         * Holds a reference to the collection of all callbacks.\r\n         *\r\n         * @type {Object}\r\n         */\r\n        this._options = {\r\n            iceConfig: qhsenseConnection\r\n                && qhsenseConnection.xmpp.connection.jingle.p2pIceConfig,\r\n            ...otherOptions\r\n        };\r\n\r\n        /**\r\n         * The active instance of {@code ProxyConnectionService}.\r\n         *\r\n         * @type {ProxyConnectionPC|null}\r\n         */\r\n        this._peerConnection = null;\r\n\r\n        // Bind event handlers so they are only bound once for every instance.\r\n        this._onFatalError = this._onFatalError.bind(this);\r\n        this._onSendMessage = this._onSendMessage.bind(this);\r\n        this._onRemoteStream = this._onRemoteStream.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a message object regarding a proxy connection to create a new\r\n     * proxy connection or update and existing connection.\r\n     *\r\n     * @param {Object} message - A message object regarding establishing or\r\n     * updating a proxy connection.\r\n     * @param {Object} message.data - An object containing additional message\r\n     * details.\r\n     * @param {string} message.data.iq - The stringified iq which explains how\r\n     * and what to update regarding the proxy connection.\r\n     * @param {string} message.from - The message sender's full jid. Used for\r\n     * sending replies.\r\n     * @returns {void}\r\n     */\r\n    processMessage(message) {\r\n        const peerJid = message.from;\r\n\r\n        if (!peerJid) {\r\n            return;\r\n        }\r\n\r\n        // If a proxy connection has already been established and messages come\r\n        // from another peer jid then those messages should be replied to with\r\n        // a rejection.\r\n        if (this._peerConnection\r\n            && this._peerConnection.getPeerJid() !== peerJid) {\r\n            this._onFatalError(\r\n                peerJid,\r\n                ACTIONS.CONNECTION_ERROR,\r\n                'rejected'\r\n            );\r\n\r\n            return;\r\n        }\r\n\r\n        const iq = this._convertStringToXML(message.data.iq);\r\n        const $jingle = iq && iq.find('jingle');\r\n        const action = $jingle && $jingle.attr('action');\r\n\r\n        if (action === ACTIONS.INITIATE) {\r\n            this._peerConnection = this._createPeerConnection(peerJid, {\r\n                isInitiator: false,\r\n                receiveVideo: true\r\n            });\r\n        }\r\n\r\n        // Truthy check for peer connection added to protect against possibly\r\n        // receiving actions before an ACTIONS.INITIATE.\r\n        if (this._peerConnection) {\r\n            this._peerConnection.processMessage($jingle);\r\n        }\r\n\r\n        // Take additional steps to ensure the peer connection is cleaned up\r\n        // if it is to be closed.\r\n        if (action === ACTIONS.CONNECTION_ERROR\r\n            || action === ACTIONS.UNAVAILABLE\r\n            || action === ACTIONS.TERMINATE) {\r\n            this._selfCloseConnection();\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Instantiates and initiates a proxy peer connection.\r\n     *\r\n     * @param {string} peerJid - The jid of the remote client that should\r\n     * receive messages.\r\n     * @param {Array<QHSenseLocalTrack>} localTracks - Initial media tracks to\r\n     * send through to the peer.\r\n     * @returns {void}\r\n     */\r\n    start(peerJid, localTracks = []) {\r\n        this._peerConnection = this._createPeerConnection(peerJid, {\r\n            isInitiator: true,\r\n            receiveVideo: false\r\n        });\r\n\r\n        this._peerConnection.start(localTracks);\r\n    }\r\n\r\n    /**\r\n     * Terminates any active proxy peer connection.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    stop() {\r\n        if (this._peerConnection) {\r\n            this._peerConnection.stop();\r\n        }\r\n\r\n        this._peerConnection = null;\r\n    }\r\n\r\n    /**\r\n     * Transforms a stringified xML into a XML wrapped in jQuery.\r\n     *\r\n     * @param {string} xml - The XML in string form.\r\n     * @private\r\n     * @returns {Object|null} A jQuery version of the xml. Null will be returned\r\n     * if an error is encountered during transformation.\r\n     */\r\n    _convertStringToXML(xml) {\r\n        try {\r\n            const xmlDom = new DOMParser().parseFromString(xml, 'text/xml');\r\n\r\n            return $(xmlDom);\r\n        } catch (e) {\r\n            logger.error('Attempted to convert incorrectly formatted xml');\r\n\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper for creating an instance of {@code ProxyConnectionPC}.\r\n     *\r\n     * @param {string} peerJid - The jid of the remote peer with which the\r\n     * {@code ProxyConnectionPC} will be established with.\r\n     * @param {Object} options - Additional defaults to instantiate the\r\n     * {@code ProxyConnectionPC} with. See the constructor of ProxyConnectionPC\r\n     * for more details.\r\n     * @private\r\n     * @returns {ProxyConnectionPC}\r\n     */\r\n    _createPeerConnection(peerJid, options = {}) {\r\n        if (!peerJid) {\r\n            throw new Error('Cannot create ProxyConnectionPC without a peer.');\r\n        }\r\n\r\n        const pcOptions = {\r\n            iceConfig: this._options.iceConfig,\r\n            onError: this._onFatalError,\r\n            onRemoteStream: this._onRemoteStream,\r\n            onSendMessage: this._onSendMessage,\r\n            peerJid,\r\n            ...options\r\n        };\r\n\r\n        return new ProxyConnectionPC(pcOptions);\r\n    }\r\n\r\n    /**\r\n     * Callback invoked when an error occurs that should cause\r\n     * {@code ProxyConnectionPC} to be closed if the peer is currently\r\n     * connected. Sends an error message/reply back to the peer.\r\n     *\r\n     * @param {string} peerJid - The peer jid with which the connection was\r\n     * attempted or started, and to which an iq with error details should be\r\n     * sent.\r\n     * @param {string} errorType - The constant indicating the type of the error\r\n     * that occured.\r\n     * @param {string} details - Optional additional data about the error.\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onFatalError(peerJid, errorType, details = '') {\r\n        logger.error(\r\n            'Received a proxy connection error', peerJid, errorType, details);\r\n\r\n        const iq = $iq({\r\n            to: peerJid,\r\n            type: 'set'\r\n        })\r\n            .c('jingle', {\r\n                xmlns: 'urn:xmpp:jingle:1',\r\n                action: errorType\r\n            })\r\n            .c('details')\r\n            .t(details)\r\n            .up();\r\n\r\n        this._onSendMessage(peerJid, iq);\r\n\r\n        if (this._peerConnection\r\n            && this._peerConnection.getPeerJid() === peerJid) {\r\n            this._selfCloseConnection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback invoked when the remote peer of the {@code ProxyConnectionPC}\r\n     * has offered a media stream. The stream is converted into a\r\n     * {@code QHSenseLocalTrack} for local usage if the {@code onRemoteStream}\r\n     * callback is defined.\r\n     *\r\n     * @param {QHSenseRemoteTrack} qhsenseRemoteTrack - The {@code QHSenseRemoteTrack}\r\n     * for the peer's media stream.\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onRemoteStream(qhsenseRemoteTrack) {\r\n        if (!this._options.onRemoteStream) {\r\n            logger.error('Remote track received without callback.');\r\n            qhsenseRemoteTrack.dispose();\r\n\r\n            return;\r\n        }\r\n\r\n        const isVideo = qhsenseRemoteTrack.isVideoTrack();\r\n        let videoType;\r\n\r\n        if (isVideo) {\r\n            videoType = this._options.convertVideoToDesktop\r\n                ? VideoType.DESKTOP : VideoType.CAMERA;\r\n        }\r\n\r\n        // Grab the webrtc media stream and pipe it through the same processing\r\n        // that would occur for a locally obtained media stream.\r\n        const mediaStream = qhsenseRemoteTrack.getOriginalStream();\r\n        const qhsenseLocalTracks = RTC.newCreateLocalTracks(\r\n            [\r\n                {\r\n                    deviceId:\r\n                        `proxy:${this._peerConnection.getPeerJid()}`,\r\n                    mediaType: isVideo ? MediaType.VIDEO : MediaType.AUDIO,\r\n                    sourceType: 'proxy',\r\n                    stream: mediaStream,\r\n                    track: mediaStream.getVideoTracks()[0],\r\n                    videoType\r\n                }\r\n            ]);\r\n\r\n        this._options.onRemoteStream(qhsenseLocalTracks[0]);\r\n    }\r\n\r\n    /**\r\n     * Formats and forwards a message an iq to be sent to a peer jid.\r\n     *\r\n     * @param {string} peerJid - The jid the iq should be sent to.\r\n     * @param {Object} iq - The iq which would be sent to the peer jid.\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onSendMessage(peerJid, iq) {\r\n        if (!this._options.onSendMessage) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const stringifiedIq\r\n                = new XMLSerializer().serializeToString(iq.nodeTree || iq);\r\n\r\n            this._options.onSendMessage(peerJid, { iq: stringifiedIq });\r\n        } catch (e) {\r\n            logger.error('Attempted to send an incorrectly formatted iq.');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Invoked when preemptively closing the {@code ProxyConnectionPC}.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _selfCloseConnection() {\r\n        this.stop();\r\n\r\n        this._options.onConnectionClosed\r\n            && this._options.onConnectionClosed();\r\n    }\r\n}\r\n","import { getLogger } from 'qhsense-meet-logger';\r\n\r\nimport RTC from '../RTC/RTC';\r\nimport RTCEvents from '../../service/RTC/RTCEvents';\r\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\r\n\r\nimport JingleSessionPC from '../xmpp/JingleSessionPC';\r\nimport { DEFAULT_STUN_SERVERS } from '../xmpp/xmpp';\r\n\r\nimport { ACTIONS } from './constants';\r\n\r\nconst logger = getLogger(__filename);\r\n\r\n/**\r\n * An adapter around {@code JingleSessionPC} so its logic can be re-used without\r\n * an XMPP connection. It is being re-used for consistency with the rest of the\r\n * codebase and to leverage existing peer connection event handling. Also\r\n * this class provides a facade to hide most of the API for\r\n * {@code JingleSessionPC}.\r\n */\r\nexport default class ProxyConnectionPC {\r\n    /**\r\n     * Initializes a new {@code ProxyConnectionPC} instance.\r\n     *\r\n     * @param {Object} options - Values to initialize the instance with.\r\n     * @param {Object} [options.iceConfig] - The {@code RTCConfiguration} to use\r\n     * for the peer connection.\r\n     * @param {boolean} [options.isInitiator] - If true, the local client should\r\n     * send offers. If false, the local client should send answers. Defaults to\r\n     * false.\r\n     * @param {Function} options.onRemoteStream - Callback to invoke when a\r\n     * remote media stream has been received through the peer connection.\r\n     * @param {string} options.peerJid - The jid of the remote client with which\r\n     * the peer connection is being establish and which should receive direct\r\n     * messages regarding peer connection updates.\r\n     * @param {boolean} [options.receiveVideo] - Whether or not the peer\r\n     * connection should accept incoming video streams. Defaults to false.\r\n     * @param {Function} options.onSendMessage - Callback to invoke when a\r\n     * message has to be sent (signaled) out.\r\n     */\r\n    constructor(options = {}) {\r\n        this._options = {\r\n            iceConfig: {},\r\n            isInitiator: false,\r\n            receiveAudio: false,\r\n            receiveVideo: false,\r\n            ...options\r\n        };\r\n\r\n        /**\r\n         * Instances of {@code QHSenseTrack} associated with this instance of\r\n         * {@code ProxyConnectionPC}.\r\n         *\r\n         * @type {Array<QHSenseTrack>}\r\n         */\r\n        this._tracks = [];\r\n\r\n        /**\r\n         * The active instance of {@code JingleSessionPC}.\r\n         *\r\n         * @type {JingleSessionPC|null}\r\n         */\r\n        this._peerConnection = null;\r\n\r\n        // Bind event handlers so they are only bound once for every instance.\r\n        this._onError = this._onError.bind(this);\r\n        this._onRemoteStream = this._onRemoteStream.bind(this);\r\n        this._onSendMessage = this._onSendMessage.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the jid of the remote peer with which this peer connection should\r\n     * be established with.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    getPeerJid() {\r\n        return this._options.peerJid;\r\n    }\r\n\r\n    /**\r\n     * Updates the peer connection based on the passed in jingle.\r\n     *\r\n     * @param {Object} $jingle - An XML jingle element, wrapped in query,\r\n     * describing how the peer connection should be updated.\r\n     * @returns {void}\r\n     */\r\n    processMessage($jingle) {\r\n        switch ($jingle.attr('action')) {\r\n        case ACTIONS.ACCEPT:\r\n            this._onSessionAccept($jingle);\r\n            break;\r\n\r\n        case ACTIONS.INITIATE:\r\n            this._onSessionInitiate($jingle);\r\n            break;\r\n\r\n        case ACTIONS.TERMINATE:\r\n            this._onSessionTerminate($jingle);\r\n            break;\r\n\r\n        case ACTIONS.TRANSPORT_INFO:\r\n            this._onTransportInfo($jingle);\r\n            break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a peer connection and starts the offer/answer cycle to\r\n     * establish a connection with a remote peer.\r\n     *\r\n     * @param {Array<QHSenseLocalTrack>} localTracks - Initial local tracks to add\r\n     * to add to the peer connection.\r\n     * @returns {void}\r\n     */\r\n    start(localTracks = []) {\r\n        if (this._peerConnection) {\r\n            return;\r\n        }\r\n\r\n        this._tracks = this._tracks.concat(localTracks);\r\n\r\n        this._peerConnection = this._createPeerConnection();\r\n\r\n        this._peerConnection.invite(localTracks);\r\n    }\r\n\r\n    /**\r\n     * Begins the process of disconnecting from a remote peer and cleaning up\r\n     * the peer connection.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    stop() {\r\n        if (this._peerConnection) {\r\n            this._peerConnection.terminate();\r\n        }\r\n\r\n        this._onSessionTerminate();\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new {@code JingleSessionPC} by stubbing out the various\r\n     * dependencies of {@code JingleSessionPC}.\r\n     *\r\n     * @private\r\n     * @returns {JingleSessionPC}\r\n     */\r\n    _createPeerConnection() {\r\n        /**\r\n         * {@code JingleSessionPC} takes in the entire QHSense-meet config.js\r\n         * object, which may not be accessible from the caller.\r\n         *\r\n         * @type {Object}\r\n         */\r\n        const configStub = {};\r\n\r\n        /**\r\n         * {@code JingleSessionPC} assumes an XMPP/Strophe connection object is\r\n         * passed through, which also has the jingle plugin initialized on it.\r\n         * This connection object is used to signal out peer connection updates\r\n         * via iqs, and those updates need to be piped back out to the remote\r\n         * peer.\r\n         *\r\n         * @type {Object}\r\n         */\r\n        const connectionStub = {\r\n            jingle: {\r\n                terminate: () => { /** no-op */ }\r\n            },\r\n            sendIQ: this._onSendMessage\r\n        };\r\n\r\n        /**\r\n         * {@code JingleSessionPC} can take in a custom ice configuration,\r\n         * depending on the peer connection type, peer-to-peer or other.\r\n         * However, {@code ProxyConnectionPC} always assume a peer-to-peer\r\n         * connection so the ice configuration is hard-coded with defaults.\r\n         *\r\n         * @type {Object}\r\n         */\r\n        const iceConfigStub = {\r\n            iceServers: DEFAULT_STUN_SERVERS,\r\n            ...this._options.iceConfig\r\n        };\r\n\r\n        /**\r\n         * {@code JingleSessionPC} expects an instance of\r\n         * {@code QHSenseConference}, which has an event emitter that is used\r\n         * to signal various connection updates that the local client should\r\n         * act upon. The conference instance is not a dependency of a proxy\r\n         * connection, but the emitted events can be relevant to the proxy\r\n         * connection so the event emitter is stubbed.\r\n         *\r\n         * @param {string} event - The constant for the event type.\r\n         * @type {Function}\r\n         * @returns {void}\r\n         */\r\n        const emitter = event => {\r\n            switch (event) {\r\n            case XMPPEvents.CONNECTION_ICE_FAILED:\r\n            case XMPPEvents.CONNECTION_FAILED:\r\n                this._onError(ACTIONS.CONNECTION_ERROR, event);\r\n                break;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * {@code JingleSessionPC} expects an instance of\r\n         * {@code QHSenseConference} to be passed in. {@code ProxyConnectionPC}\r\n         * is instantiated outside of the {@code QHSenseConference}, so it must be\r\n         * stubbed to prevent errors.\r\n         *\r\n         * @type {Object}\r\n         */\r\n        const roomStub = {\r\n            addPresenceListener: () => { /** no-op */ },\r\n            connectionTimes: [],\r\n            eventEmitter: { emit: emitter },\r\n            getMediaPresenceInfo: () => {\r\n                // Errors occur if this function does not return an object\r\n\r\n                return {};\r\n            },\r\n            removePresenceListener: () => { /** no-op */ }\r\n        };\r\n\r\n        /**\r\n         * Create an instance of {@code RTC} as it is required for peer\r\n         * connection creation by {@code JingleSessionPC}. An existing instance\r\n         * of {@code RTC} from elsewhere should not be re-used because it is\r\n         * a stateful grouping of utilities.\r\n         */\r\n        this._rtc = new RTC(this, {});\r\n\r\n        /**\r\n         * Add the remote track listener here as {@code JingleSessionPC} has\r\n         * {@code TraceablePeerConnection} which uses {@code RTC}'s event\r\n         * emitter.\r\n         */\r\n        this._rtc.addListener(\r\n            RTCEvents.REMOTE_TRACK_ADDED,\r\n            this._onRemoteStream\r\n        );\r\n\r\n        const peerConnection = new JingleSessionPC(\r\n            undefined, // sid\r\n            undefined, // localJid\r\n            this._options.peerJid, // remoteJid\r\n            connectionStub, // connection\r\n            {\r\n                offerToReceiveAudio: this._options.receiveAudio,\r\n                offerToReceiveVideo: this._options.receiveVideo\r\n            }, // mediaConstraints\r\n            iceConfigStub, // iceConfig\r\n            true, // isP2P\r\n            this._options.isInitiator // isInitiator\r\n        );\r\n\r\n        /**\r\n         * An additional initialize call is necessary to properly set instance\r\n         * variable for calling.\r\n         */\r\n        peerConnection.initialize(roomStub, this._rtc, configStub);\r\n\r\n        return peerConnection;\r\n    }\r\n\r\n    /**\r\n     * Invoked when a connection related issue has been encountered.\r\n     *\r\n     * @param {string} errorType - The constant indicating the type of the error\r\n     * that occured.\r\n     * @param {string} details - Optional additional data about the error.\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onError(errorType, details = '') {\r\n        this._options.onError(this._options.peerJid, errorType, details);\r\n    }\r\n\r\n    /**\r\n     * Callback invoked when the peer connection has received a remote media\r\n     * stream.\r\n     *\r\n     * @param {QHSenseRemoteTrack} qhsenseRemoteTrack - The remote media stream\r\n     * wrapped in {@code QHSenseRemoteTrack}.\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onRemoteStream(qhsenseRemoteTrack) {\r\n        this._tracks.push(qhsenseRemoteTrack);\r\n\r\n        this._options.onRemoteStream(qhsenseRemoteTrack);\r\n    }\r\n\r\n    /**\r\n     * Callback invoked when {@code JingleSessionPC} needs to signal a message\r\n     * out to the remote peer.\r\n     *\r\n     * @param {XML} iq - The message to signal out.\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onSendMessage(iq) {\r\n        this._options.onSendMessage(this._options.peerJid, iq);\r\n    }\r\n\r\n    /**\r\n     * Callback invoked in response to an agreement to start a proxy connection.\r\n     * The passed in jingle element should contain an SDP answer to a previously\r\n     * sent SDP offer.\r\n     *\r\n     * @param {Object} $jingle - The jingle element wrapped in jQuery.\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onSessionAccept($jingle) {\r\n        if (!this._peerConnection) {\r\n            logger.error('Received an answer when no peer connection exists.');\r\n\r\n            return;\r\n        }\r\n\r\n        this._peerConnection.setAnswer($jingle);\r\n    }\r\n\r\n    /**\r\n     * Callback invoked in response to a request to start a proxy connection.\r\n     * The passed in jingle element should contain an SDP offer.\r\n     *\r\n     * @param {Object} $jingle - The jingle element wrapped in jQuery.\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onSessionInitiate($jingle) {\r\n        if (this._peerConnection) {\r\n            logger.error('Received an offer when an offer was already sent.');\r\n\r\n            return;\r\n        }\r\n\r\n        this._peerConnection = this._createPeerConnection();\r\n\r\n        this._peerConnection.acceptOffer(\r\n            $jingle,\r\n            () => { /** no-op */ },\r\n            () => this._onError(\r\n                this._options.peerJid,\r\n                ACTIONS.CONNECTION_ERROR,\r\n                'session initiate error'\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Callback invoked in response to a request to disconnect an active proxy\r\n     * connection. Cleans up tracks and the peer connection.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onSessionTerminate() {\r\n        this._tracks.forEach(track => track.dispose());\r\n        this._tracks = [];\r\n\r\n        if (this._peerConnection) {\r\n            this._peerConnection.onTerminated();\r\n        }\r\n\r\n        if (this._rtc) {\r\n            this._rtc.removeListener(\r\n                RTCEvents.REMOTE_TRACK_ADDED,\r\n                this._onRemoteStream\r\n            );\r\n\r\n            this._rtc.destroy();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback invoked in response to ICE candidates from the remote peer.\r\n     * The passed in jingle element should contain an ICE candidate.\r\n     *\r\n     * @param {Object} $jingle - The jingle element wrapped in jQuery.\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    _onTransportInfo($jingle) {\r\n        this._peerConnection.addIceCandidates($jingle);\r\n    }\r\n}\r\n","// For legacy purposes, preserve the UMD of the public API of the QHSense Meet\r\n// library (a.k.a. QHSenseMeetJS).\r\nmodule.exports = require('./QHSenseMeetJS').default;\r\n","/* global __filename */\r\n\r\nimport { createGetUserMediaEvent } from './service/statistics/AnalyticsEvents';\r\nimport AuthUtil from './modules/util/AuthUtil';\r\nimport * as ConnectionQualityEvents\r\n    from './service/connectivity/ConnectionQualityEvents';\r\nimport * as E2ePingEvents from './service/e2eping/E2ePingEvents';\r\nimport GlobalOnErrorHandler from './modules/util/GlobalOnErrorHandler';\r\nimport * as QHSenseConferenceErrors from './QHSenseConferenceErrors';\r\nimport * as QHSenseConferenceEvents from './QHSenseConferenceEvents';\r\nimport QHSenseConnection from './QHSenseConnection';\r\nimport * as QHSenseConnectionErrors from './QHSenseConnectionErrors';\r\nimport * as QHSenseConnectionEvents from './QHSenseConnectionEvents';\r\nimport QHSenseMediaDevices from './QHSenseMediaDevices';\r\nimport * as QHSenseMediaDevicesEvents from './QHSenseMediaDevicesEvents';\r\nimport QHSenseTrackError from './QHSenseTrackError';\r\nimport * as QHSenseTrackErrors from './QHSenseTrackErrors';\r\nimport * as QHSenseTrackEvents from './QHSenseTrackEvents';\r\nimport * as QHSenseTranscriptionStatus from './QHSenseTranscriptionStatus';\r\nimport LocalStatsCollector from './modules/statistics/LocalStatsCollector';\r\nimport Logger from 'qhsense-meet-logger';\r\nimport * as MediaType from './service/RTC/MediaType';\r\nimport Resolutions from './service/RTC/Resolutions';\r\nimport { ParticipantConnectionStatus }\r\n    from './modules/connectivity/ParticipantConnectionStatus';\r\nimport RTC from './modules/RTC/RTC';\r\nimport browser from './modules/browser';\r\nimport ScriptUtil from './modules/util/ScriptUtil';\r\nimport recordingConstants from './modules/recording/recordingConstants';\r\nimport ProxyConnectionService\r\n    from './modules/proxyconnection/ProxyConnectionService';\r\nimport Statistics from './modules/statistics/statistics';\r\nimport * as VideoSIPGWConstants from './modules/videosipgw/VideoSIPGWConstants';\r\n\r\nconst logger = Logger.getLogger(__filename);\r\n\r\n/**\r\n * The amount of time to wait until firing\r\n * {@link QHSenseMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN} event.\r\n */\r\nconst USER_MEDIA_PERMISSION_PROMPT_TIMEOUT = 1000;\r\n\r\n/**\r\n * Gets the next lowest desirable resolution to try for a camera. If the given\r\n * resolution is already the lowest acceptable resolution, returns {@code null}.\r\n *\r\n * @param resolution the current resolution\r\n * @return the next lowest resolution from the given one, or {@code null} if it\r\n * is already the lowest acceptable resolution.\r\n */\r\nfunction getLowerResolution(resolution) {\r\n    if (!Resolutions[resolution]) {\r\n        return null;\r\n    }\r\n    const order = Resolutions[resolution].order;\r\n    let res = null;\r\n    let resName = null;\r\n\r\n    Object.keys(Resolutions).forEach(r => {\r\n        const value = Resolutions[r];\r\n\r\n        if (!res || (res.order < value.order && value.order < order)) {\r\n            resName = r;\r\n            res = value;\r\n        }\r\n    });\r\n\r\n    if (resName === resolution) {\r\n        resName = null;\r\n    }\r\n\r\n    return resName;\r\n}\r\n\r\n/**\r\n * Extracts from an 'options' objects with a specific format (TODO what IS the\r\n * format?) the attributes which are to be logged in analytics events.\r\n *\r\n * @param options gum options (???)\r\n * @returns {*} the attributes to attach to analytics events.\r\n */\r\nfunction getAnalyticsAttributesFromOptions(options) {\r\n    const attributes = {\r\n        'audio_requested':\r\n            options.devices.includes('audio'),\r\n        'video_requested':\r\n            options.devices.includes('video'),\r\n        'screen_sharing_requested':\r\n            options.devices.includes('desktop')\r\n    };\r\n\r\n    if (attributes.video_requested) {\r\n        attributes.resolution = options.resolution;\r\n    }\r\n\r\n    return attributes;\r\n}\r\n\r\n/**\r\n * Tries to deal with the following problem: {@code QHSenseMeetJS} is not only\r\n * this module, it's also a global (i.e. attached to {@code window}) namespace\r\n * for all globals of the projects in the QHSense Meet family. If lib-QHSense-meet\r\n * is loaded through an HTML {@code script} tag, {@code QHSenseMeetJS} will\r\n * automatically be attached to {@code window} by webpack. Unfortunately,\r\n * webpack's source code does not check whether the global variable has already\r\n * been assigned and overwrites it. Which is OK for the module\r\n * {@code QHSenseMeetJS} but is not OK for the namespace {@code QHSenseMeetJS}\r\n * because it may already contain the values of other projects in the QHSense Meet\r\n * family. The solution offered here works around webpack by merging all\r\n * existing values of the namespace {@code QHSenseMeetJS} into the module\r\n * {@code QHSenseMeetJS}.\r\n *\r\n * @param {Object} module - The module {@code QHSenseMeetJS} (which will be\r\n * exported and may be attached to {@code window} by webpack later on).\r\n * @private\r\n * @returns {Object} - A {@code QHSenseMeetJS} module which contains all existing\r\n * value of the namespace {@code QHSenseMeetJS} (if any).\r\n */\r\nfunction _mergeNamespaceAndModule(module) {\r\n    return (\r\n        typeof window.QHSenseMeetJS === 'object'\r\n            ? Object.assign({}, window.QHSenseMeetJS, module)\r\n            : module);\r\n}\r\n\r\n/**\r\n * The public API of the QHSense Meet library (a.k.a. {@code QHSenseMeetJS}).\r\n */\r\nexport default _mergeNamespaceAndModule({\r\n\r\n    version: '{#COMMIT_HASH#}',\r\n\r\n    QHSenseConnection,\r\n\r\n    /**\r\n     * {@code ProxyConnectionService} is used to connect a remote peer to a\r\n     * local QHSense participant without going through a QHSense conference. It is\r\n     * currently used for room integration development, specifically wireless\r\n     * screensharing. Its API is experimental and will likely change; usage of\r\n     * it is advised against.\r\n     */\r\n    ProxyConnectionService,\r\n\r\n    constants: {\r\n        participantConnectionStatus: ParticipantConnectionStatus,\r\n        recording: recordingConstants,\r\n        sipVideoGW: VideoSIPGWConstants,\r\n        transcriptionStatus: QHSenseTranscriptionStatus\r\n    },\r\n    events: {\r\n        conference: QHSenseConferenceEvents,\r\n        connection: QHSenseConnectionEvents,\r\n        track: QHSenseTrackEvents,\r\n        mediaDevices: QHSenseMediaDevicesEvents,\r\n        connectionQuality: ConnectionQualityEvents,\r\n        e2eping: E2ePingEvents\r\n    },\r\n    errors: {\r\n        conference: QHSenseConferenceErrors,\r\n        connection: QHSenseConnectionErrors,\r\n        track: QHSenseTrackErrors\r\n    },\r\n    errorTypes: {\r\n        QHSenseTrackError\r\n    },\r\n    logLevels: Logger.levels,\r\n    mediaDevices: QHSenseMediaDevices,\r\n    analytics: Statistics.analytics,\r\n    init(options = {}) {\r\n        Statistics.init(options);\r\n\r\n        // Initialize global window.connectionTimes\r\n        // FIXME do not use 'window'\r\n        if (!window.connectionTimes) {\r\n            window.connectionTimes = {};\r\n        }\r\n\r\n        if (options.enableAnalyticsLogging !== true) {\r\n            logger.warn('Analytics disabled, disposing.');\r\n            this.analytics.dispose();\r\n        }\r\n\r\n        if (options.enableWindowOnErrorHandler) {\r\n            GlobalOnErrorHandler.addHandler(\r\n                this.getGlobalOnErrorHandler.bind(this));\r\n        }\r\n\r\n        // Log deployment-specific information, if available. Defined outside\r\n        // the application by individual deployments\r\n        const aprops = options.deploymentInfo;\r\n\r\n        if (aprops && Object.keys(aprops).length > 0) {\r\n            const logObject = {};\r\n\r\n            for (const attr in aprops) {\r\n                if (aprops.hasOwnProperty(attr)) {\r\n                    logObject[attr] = aprops[attr];\r\n                }\r\n            }\r\n\r\n            logObject.id = 'deployment_info';\r\n            Statistics.sendLog(JSON.stringify(logObject));\r\n        }\r\n\r\n        if (this.version) {\r\n            const logObject = {\r\n                id: 'component_version',\r\n                component: 'lib-QHSense-meet',\r\n                version: this.version\r\n            };\r\n\r\n            Statistics.sendLog(JSON.stringify(logObject));\r\n        }\r\n\r\n        return RTC.init(options);\r\n    },\r\n\r\n    /**\r\n     * Returns whether the desktop sharing is enabled or not.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    isDesktopSharingEnabled() {\r\n        return RTC.isDesktopSharingEnabled();\r\n    },\r\n\r\n    /**\r\n     * Returns whether the current execution environment supports WebRTC (for\r\n     * use within this library).\r\n     *\r\n     * @returns {boolean} {@code true} if WebRTC is supported in the current\r\n     * execution environment (for use within this library); {@code false},\r\n     * otherwise.\r\n     */\r\n    isWebRtcSupported() {\r\n        return RTC.isWebRtcSupported();\r\n    },\r\n\r\n    setLogLevel(level) {\r\n        Logger.setLogLevel(level);\r\n    },\r\n\r\n    /**\r\n     * Sets the log level to the <tt>Logger</tt> instance with given id.\r\n     *\r\n     * @param {Logger.levels} level the logging level to be set\r\n     * @param {string} id the logger id to which new logging level will be set.\r\n     * Usually it's the name of the JavaScript source file including the path\r\n     * ex. \"modules/xmpp/ChatRoom.js\"\r\n     */\r\n    setLogLevelById(level, id) {\r\n        Logger.setLogLevelById(level, id);\r\n    },\r\n\r\n    /**\r\n     * Registers new global logger transport to the library logging framework.\r\n     *\r\n     * @param globalTransport\r\n     * @see Logger.addGlobalTransport\r\n     */\r\n    addGlobalLogTransport(globalTransport) {\r\n        Logger.addGlobalTransport(globalTransport);\r\n    },\r\n\r\n    /**\r\n     * Removes global logging transport from the library logging framework.\r\n     *\r\n     * @param globalTransport\r\n     * @see Logger.removeGlobalTransport\r\n     */\r\n    removeGlobalLogTransport(globalTransport) {\r\n        Logger.removeGlobalTransport(globalTransport);\r\n    },\r\n\r\n    /**\r\n     * Creates the media tracks and returns them trough the callback.\r\n     *\r\n     * @param options Object with properties / settings specifying the tracks\r\n     * which should be created. should be created or some additional\r\n     * configurations about resolution for example.\r\n     * @param {Array} options.effects optional effects array for the track\r\n     * @param {Array} options.devices the devices that will be requested\r\n     * @param {string} options.resolution resolution constraints\r\n     * @param {string} options.cameraDeviceId\r\n     * @param {string} options.micDeviceId\r\n     * @param {object} options.desktopSharingExtensionExternalInstallation -\r\n     * enables external installation process for desktop sharing extension if\r\n     * the inline installation is not posible. The following properties should\r\n     * be provided:\r\n     * @param {intiger} interval - the interval (in ms) for\r\n     * checking whether the desktop sharing extension is installed or not\r\n     * @param {Function} checkAgain - returns boolean. While checkAgain()==true\r\n     * createLocalTracks will wait and check on every \"interval\" ms for the\r\n     * extension. If the desktop extension is not install and checkAgain()==true\r\n     * createLocalTracks will finish with rejected Promise.\r\n     * @param {Function} listener - The listener will be called to notify the\r\n     * user of lib-QHSense-meet that createLocalTracks is starting external\r\n     * extension installation process.\r\n     * NOTE: If the inline installation process is not possible and external\r\n     * installation is enabled the listener property will be called to notify\r\n     * the start of external installation process. After that createLocalTracks\r\n     * will start to check for the extension on every interval ms until the\r\n     * plugin is installed or until checkAgain return false. If the extension\r\n     * is found createLocalTracks will try to get the desktop sharing track and\r\n     * will finish the execution. If checkAgain returns false, createLocalTracks\r\n     * will finish the execution with rejected Promise.\r\n     *\r\n     * @param {boolean} (firePermissionPromptIsShownEvent) - if event\r\n     * QHSenseMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN should be fired\r\n     * @param originalOptions - internal use only, to be able to store the\r\n     * originally requested options.\r\n     * @returns {Promise.<{Array.<QHSenseTrack>}, QHSenseConferenceError>} A promise\r\n     * that returns an array of created QHSenseTracks if resolved, or a\r\n     * QHSenseConferenceError if rejected.\r\n     */\r\n    createLocalTracks(\r\n            options = {}, firePermissionPromptIsShownEvent, originalOptions) {\r\n        let promiseFulfilled = false;\r\n\r\n        if (firePermissionPromptIsShownEvent === true) {\r\n            window.setTimeout(() => {\r\n                if (!promiseFulfilled) {\r\n                    QHSenseMediaDevices.emitEvent(\r\n                        QHSenseMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN,\r\n                        browser.getName());\r\n                }\r\n            }, USER_MEDIA_PERMISSION_PROMPT_TIMEOUT);\r\n        }\r\n\r\n        if (!window.connectionTimes) {\r\n            window.connectionTimes = {};\r\n        }\r\n        window.connectionTimes['obtainPermissions.start']\r\n            = window.performance.now();\r\n\r\n        return RTC.obtainAudioAndVideoPermissions(options)\r\n            .then(tracks => {\r\n                promiseFulfilled = true;\r\n\r\n                window.connectionTimes['obtainPermissions.end']\r\n                    = window.performance.now();\r\n\r\n                Statistics.sendAnalytics(\r\n                    createGetUserMediaEvent(\r\n                        'success',\r\n                        getAnalyticsAttributesFromOptions(options)));\r\n\r\n                if (!RTC.options.disableAudioLevels) {\r\n                    for (let i = 0; i < tracks.length; i++) {\r\n                        const track = tracks[i];\r\n                        const mStream = track.getOriginalStream();\r\n\r\n                        if (track.getType() === MediaType.AUDIO) {\r\n                            Statistics.startLocalStats(mStream,\r\n                                track.setAudioLevel.bind(track));\r\n                            track.addEventListener(\r\n                                QHSenseTrackEvents.LOCAL_TRACK_STOPPED,\r\n                                () => {\r\n                                    Statistics.stopLocalStats(mStream);\r\n                                });\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // set real device ids\r\n                const currentlyAvailableMediaDevices\r\n                    = RTC.getCurrentlyAvailableMediaDevices();\r\n\r\n                if (currentlyAvailableMediaDevices) {\r\n                    for (let i = 0; i < tracks.length; i++) {\r\n                        const track = tracks[i];\r\n\r\n                        track._setRealDeviceIdFromDeviceList(\r\n                            currentlyAvailableMediaDevices);\r\n                    }\r\n                }\r\n\r\n                return tracks;\r\n            })\r\n            .catch(error => {\r\n                promiseFulfilled = true;\r\n\r\n                if (error.name === QHSenseTrackErrors.UNSUPPORTED_RESOLUTION\r\n                    && !browser.usesNewGumFlow()) {\r\n                    const oldResolution = options.resolution || '720';\r\n                    const newResolution = getLowerResolution(oldResolution);\r\n\r\n                    if (newResolution !== null) {\r\n                        options.resolution = newResolution;\r\n\r\n                        logger.debug(\r\n                            'Retry createLocalTracks with resolution',\r\n                            newResolution);\r\n\r\n                        Statistics.sendAnalytics(createGetUserMediaEvent(\r\n                            'warning',\r\n                            {\r\n                                'old_resolution': oldResolution,\r\n                                'new_resolution': newResolution,\r\n                                reason: 'unsupported resolution'\r\n                            }));\r\n\r\n                        return this.createLocalTracks(\r\n                            options,\r\n                            undefined,\r\n                            originalOptions || Object.assign({}, options));\r\n                    }\r\n\r\n                    // We tried everything. If there is a mandatory device id,\r\n                    // remove it and let gum find a device to use.\r\n                    if (originalOptions\r\n                        && error.gum.constraints\r\n                        && error.gum.constraints.video\r\n                        && error.gum.constraints.video.mandatory\r\n                        && error.gum.constraints.video.mandatory.sourceId) {\r\n                        originalOptions.cameraDeviceId = undefined;\r\n\r\n                        return this.createLocalTracks(originalOptions);\r\n                    }\r\n                }\r\n\r\n                if (error.name\r\n                        === QHSenseTrackErrors.CHROME_EXTENSION_USER_CANCELED) {\r\n                    // User cancelled action is not really an error, so only\r\n                    // log it as an event to avoid having conference classified\r\n                    // as partially failed\r\n                    const logObject = {\r\n                        id: 'chrome_extension_user_canceled',\r\n                        message: error.message\r\n                    };\r\n\r\n                    Statistics.sendLog(JSON.stringify(logObject));\r\n\r\n                    Statistics.sendAnalytics(\r\n                        createGetUserMediaEvent(\r\n                            'warning',\r\n                            {\r\n                                reason: 'extension install user canceled'\r\n                            }));\r\n                } else if (error.name === QHSenseTrackErrors.NOT_FOUND) {\r\n                    // logs not found devices with just application log to cs\r\n                    const logObject = {\r\n                        id: 'usermedia_missing_device',\r\n                        status: error.gum.devices\r\n                    };\r\n\r\n                    Statistics.sendLog(JSON.stringify(logObject));\r\n\r\n                    const attributes\r\n                        = getAnalyticsAttributesFromOptions(options);\r\n\r\n                    attributes.reason = 'device not found';\r\n                    attributes.devices = error.gum.devices.join('.');\r\n                    Statistics.sendAnalytics(\r\n                        createGetUserMediaEvent('error', attributes));\r\n                } else {\r\n                    // Report gUM failed to the stats\r\n                    Statistics.sendGetUserMediaFailed(error);\r\n\r\n                    const attributes\r\n                        = getAnalyticsAttributesFromOptions(options);\r\n\r\n                    attributes.reason = error.name;\r\n                    Statistics.sendAnalytics(\r\n                        createGetUserMediaEvent('error', attributes));\r\n                }\r\n\r\n                window.connectionTimes['obtainPermissions.end']\r\n                    = window.performance.now();\r\n\r\n                return Promise.reject(error);\r\n            });\r\n    },\r\n\r\n    /**\r\n     * Checks if its possible to enumerate available cameras/microphones.\r\n     *\r\n     * @returns {Promise<boolean>} a Promise which will be resolved only once\r\n     * the WebRTC stack is ready, either with true if the device listing is\r\n     * available available or with false otherwise.\r\n     * @deprecated use QHSenseMeetJS.mediaDevices.isDeviceListAvailable instead\r\n     */\r\n    isDeviceListAvailable() {\r\n        logger.warn('This method is deprecated, use '\r\n            + 'QHSenseMeetJS.mediaDevices.isDeviceListAvailable instead');\r\n\r\n        return this.mediaDevices.isDeviceListAvailable();\r\n    },\r\n\r\n    /**\r\n     * Returns true if changing the input (camera / microphone) or output\r\n     * (audio) device is supported and false if not.\r\n     *\r\n     * @param {string} [deviceType] - type of device to change. Default is\r\n     * {@code undefined} or 'input', 'output' - for audio output device change.\r\n     * @returns {boolean} {@code true} if available; {@code false}, otherwise.\r\n     * @deprecated use QHSenseMeetJS.mediaDevices.isDeviceChangeAvailable instead\r\n     */\r\n    isDeviceChangeAvailable(deviceType) {\r\n        logger.warn('This method is deprecated, use '\r\n            + 'QHSenseMeetJS.mediaDevices.isDeviceChangeAvailable instead');\r\n\r\n        return this.mediaDevices.isDeviceChangeAvailable(deviceType);\r\n    },\r\n\r\n\r\n    /**\r\n     * Checks if the current environment supports having multiple audio\r\n     * input devices in use simultaneously.\r\n     *\r\n     * @returns {boolean} True if multiple audio input devices can be used.\r\n     */\r\n    isMultipleAudioInputSupported() {\r\n        return this.mediaDevices.isMultipleAudioInputSupported();\r\n    },\r\n\r\n    /**\r\n     * Checks if local tracks can collect stats and collection is enabled.\r\n     *\r\n     * @param {boolean} True if stats are being collected for local tracks.\r\n     */\r\n    isCollectingLocalStats() {\r\n        return Statistics.audioLevelsEnabled\r\n            && LocalStatsCollector.isLocalStatsSupported();\r\n    },\r\n\r\n    /**\r\n     * Executes callback with list of media devices connected.\r\n     *\r\n     * @param {function} callback\r\n     * @deprecated use QHSenseMeetJS.mediaDevices.enumerateDevices instead\r\n     */\r\n    enumerateDevices(callback) {\r\n        logger.warn('This method is deprecated, use '\r\n            + 'QHSenseMeetJS.mediaDevices.enumerateDevices instead');\r\n        this.mediaDevices.enumerateDevices(callback);\r\n    },\r\n\r\n    /* eslint-disable max-params */\r\n\r\n    /**\r\n     * @returns function that can be used to be attached to window.onerror and\r\n     * if options.enableWindowOnErrorHandler is enabled returns\r\n     * the function used by the lib.\r\n     * (function(message, source, lineno, colno, error)).\r\n     */\r\n    getGlobalOnErrorHandler(message, source, lineno, colno, error) {\r\n        logger.error(\r\n            `UnhandledError: ${message}`,\r\n            `Script: ${source}`,\r\n            `Line: ${lineno}`,\r\n            `Column: ${colno}`,\r\n            'StackTrace: ', error);\r\n        Statistics.reportGlobalError(error);\r\n    },\r\n\r\n    /* eslint-enable max-params */\r\n\r\n    /**\r\n     * Represents a hub/namespace for utility functionality which may be of\r\n     * interest to lib-QHSense-meet clients.\r\n     */\r\n    util: {\r\n        AuthUtil,\r\n        ScriptUtil,\r\n        browser\r\n    }\r\n});\r\n","/* Copyright @ 2016 Atlassian Pty Ltd\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar Logger = require('./Logger.js');\r\n\r\n/**\r\n * Creates new <tt>LogCollector</tt>. Class implements <tt>LoggerTransport</tt>\r\n * and thus can be added as global transport in order to capture all the logs.\r\n *\r\n * It captures subsequent log lines created whenever <tt>Logger</tt> logs\r\n * a message and stores them in a queue in order to batch log entries. There are\r\n * time and size limit constraints which determine how often batch entries are\r\n * stored. Whenever one of these limits is exceeded the <tt>LogCollector</tt>\r\n * will use the <tt>logStorage</tt> object given as an argument to save\r\n * the batch log entry.\r\n *\r\n * @param {Object} logStorage an object which allows to store the logs collected\r\n * @param {function(string|object[])} logStorage.storeLogs a method called when\r\n * this <tt>LogCollector</tt> requests log entry storage. The method's argument\r\n * is an array which can contain <tt>string</tt>s and <tt>object</tt>s. If given\r\n * item is an object it means that it's an aggregated message. That is a message\r\n * which is the same as the previous one and it's representation has\r\n * the following format:\r\n * {\r\n *   {string} text: 'the text of some duplicated message'\r\n *   {number} count: 3 // how many times the message appeared in a row\r\n * }\r\n * If a message \"B\" after an aggregated message \"A\" is different, then it breaks\r\n * the sequence of \"A\". Which means that even if the next message \"C\" is\r\n * the same as \"A\" it will start a new aggregated message \"C\".\r\n * @param {function()} logStorage.isReady a method which should return\r\n * a <tt>boolean</tt> to tell the collector that it's ready to store. During the\r\n * time storage is not ready log batches will be cached and stored on the next\r\n * occasion (flush or interval timeout).\r\n *\r\n * @param {Object} options the <tt>LogCollector</tt> configuration options.\r\n * @param {number} options.maxEntryLength the size limit for a single log entry\r\n * to be stored. The <tt>LogCollector</tt> will push the entry as soon as it\r\n * reaches or exceeds this limit given that <tt>logStorage.isReady</tt>\r\n * returns <tt>true</tt>. Otherwise the log entry will be cached until the log\r\n * storage becomes ready. Note that the \"is ready\" condition is checked every\r\n * <tt>options.storeInterval</tt> milliseconds.\r\n * @param {number} options.storeInterval how often the logs should be stored in\r\n * case <tt>maxEntryLength</tt> was not exceeded.\r\n * @param {boolean} options.stringifyObjects indicates whether or not object\r\n * arguments should be \"stringified\" with <tt>JSON.stringify</tt> when a log\r\n * message is composed. Note that objects logged on the error log level are\r\n * always stringified.\r\n *\r\n * @constructor\r\n */\r\nfunction LogCollector(logStorage, options) {\r\n    this.logStorage = logStorage;\r\n    this.stringifyObjects\r\n        = options && options.stringifyObjects\r\n            ? options.stringifyObjects : false;\r\n    this.storeInterval\r\n        = options && options.storeInterval\r\n            ? options.storeInterval: 30000;\r\n    this.maxEntryLength\r\n        = options && options.maxEntryLength\r\n            ? options.maxEntryLength : 10000;\r\n    // Bind the log method for each level to the corresponding method name\r\n    // in order to implement \"global log transport\" object.\r\n    Object.keys(Logger.levels).forEach(\r\n    function (logLevel) {\r\n        var methodName = Logger.levels[logLevel];\r\n        this[methodName] = function (logLevel) {\r\n            this._log.apply(this, arguments);\r\n        }.bind(this, logLevel);\r\n    }.bind(this));\r\n    /**\r\n     * The ID of store logs interval if one is currently scheduled or\r\n     * <tt>null</tt> otherwise.\r\n     * @type {number|null}\r\n     */\r\n    this.storeLogsIntervalID = null;\r\n    /**\r\n     * The log messages that are to be batched into log entry when\r\n     * {@link LogCollector._flush} method is called.\r\n     * @type {string[]}\r\n     */\r\n    this.queue = [];\r\n    /**\r\n     * The total length of all messages currently stored in the {@link queue}.\r\n     * @type {number}\r\n     */\r\n    this.totalLen = 0;\r\n    /**\r\n     * An array used to temporarily store log batches, before the storage gets\r\n     * ready.\r\n     * @type {string[]}\r\n     */\r\n    this.outputCache = [];\r\n}\r\n\r\n/**\r\n * Method called inside of {@link formatLogMessage} in order to covert an\r\n * <tt>Object</tt> argument to string. The conversion will happen when either\r\n * 'stringifyObjects' option is enabled or on the {@link Logger.levels.ERROR}\r\n * log level. The default implementation uses <tt>JSON.stringify</tt> and\r\n * returns \"[object with circular refs?]\" instead of an object if it fails.\r\n *\r\n * @param {object} someObject the <tt>object</tt> to be stringified.\r\n *\r\n * @return {string} the result of <tt>JSON.stringify</tt> or\r\n * \"[object with circular refs?]\" if any error occurs during \"stringification\".\r\n *\r\n * @protected\r\n */\r\nLogCollector.prototype.stringify = function (someObject) {\r\n    try {\r\n        return JSON.stringify(someObject);\r\n    } catch (error) {\r\n        return \"[object with circular refs?]\";\r\n    }\r\n};\r\n\r\n/**\r\n * Formats log entry for the given logging level and arguments passed to the\r\n * <tt>Logger</tt>'s log method. The first argument is log level and the next\r\n * arguments have to be captured using JS built-in 'arguments' variable.\r\n *\r\n * @param {Logger.levels} logLevel provides the logging level of the message to\r\n * be logged.\r\n *\r\n * @return {string|null} a non-empty string representation of the log entry\r\n * crafted from the log arguments. If the return value is <tt>null</tt> then\r\n * the message wil be discarded by this <tt>LogCollector</tt>.\r\n *\r\n * @protected\r\n */\r\nLogCollector.prototype.formatLogMessage\r\n= function (logLevel/*, arg1, arg2, arg3... */) {\r\n    var msg = '';\r\n    for (var i = 1, len = arguments.length; i < len; i++) {\r\n        var arg = arguments[i];\r\n        // objects logged on error level are always converted to JSON\r\n        if ((this.stringifyObjects || logLevel === Logger.levels.ERROR)\r\n            && typeof arg === 'object') {\r\n            arg = this.stringify(arg);\r\n        }\r\n        msg += arg;\r\n        if (i != len - 1) {\r\n            msg += ' ';\r\n        }\r\n    }\r\n    return msg.length ? msg : null;\r\n};\r\n\r\n/**\r\n * The log method bound to each of the logging levels in order to implement\r\n * \"global log transport\" object.\r\n *\r\n * @private\r\n */\r\nLogCollector.prototype._log = function() {\r\n\r\n    // var logLevel = arguments[0]; first argument is the log level\r\n    var msg = this.formatLogMessage.apply(this, arguments);\r\n    if (msg) {\r\n        // The same as the previous message aggregation logic\r\n        var prevMessage\r\n            = this.queue.length ? this.queue[this.queue.length -1] : undefined;\r\n        // NOTE that typeof undefined is 'undefined'\r\n        var prevMessageText\r\n            = typeof prevMessage === 'object' ? prevMessage.text : prevMessage;\r\n        // Is it the same as the previous one ?\r\n        if (prevMessageText == msg) {\r\n            if (typeof prevMessage === 'object') {\r\n                prevMessage.count += 1;\r\n            } else {\r\n                this.queue[this.queue.length-1] = {\r\n                    text: msg,\r\n                    count: 2\r\n                }\r\n            }\r\n        } else {\r\n            this.queue.push(msg);\r\n            this.totalLen += msg.length;\r\n        }\r\n    }\r\n\r\n    if (this.totalLen >= this.maxEntryLength) {\r\n        this._flush(true /* force */, true /* reschedule */);\r\n    }\r\n};\r\n\r\n/**\r\n * Starts periodical \"store logs\" task which will be triggered at the interval\r\n * specified in the constructor options.\r\n */\r\nLogCollector.prototype.start = function () {\r\n    this._reschedulePublishInterval();\r\n};\r\n\r\n/**\r\n * Reschedules the periodical \"store logs\" task which will store the next batch\r\n * log entry in the storage.\r\n * @private\r\n */\r\nLogCollector.prototype._reschedulePublishInterval = function () {\r\n    if (this.storeLogsIntervalID) {\r\n        window.clearTimeout(this.storeLogsIntervalID);\r\n        this.storeLogsIntervalID = null;\r\n    }\r\n    // It's actually a timeout, because it is rescheduled on every flush\r\n    this.storeLogsIntervalID\r\n        = window.setTimeout(\r\n            this._flush.bind(\r\n                this, false /* do not force */, true /* reschedule */),\r\n            this.storeInterval);\r\n};\r\n\r\n/**\r\n * Call this method to flush the log entry buffer and store it in the log\r\n * storage immediately (given that the storage is ready).\r\n */\r\nLogCollector.prototype.flush = function() {\r\n    this._flush(\r\n        false /* do not force, as it will not be stored anyway */,\r\n        true /* reschedule next update */ )\r\n};\r\n\r\n/**\r\n * Stores the next batch log entry in the log storage.\r\n * @param {boolean} force enforce current logs batch to be stored or cached if\r\n * there is anything to be logged, but the storage is not ready yet. One of\r\n * legitimate reasons to force is when the logs length exceeds size limit which\r\n * could result in truncation.\r\n * @param {boolean} reschedule <tt>true</tt> if the next periodic task should be\r\n * scheduled after the log entry is stored. <tt>false</tt> will end the periodic\r\n * task cycle.\r\n * @private\r\n */\r\nLogCollector.prototype._flush = function(force, reschedule) {\r\n    // Publish only if there's anything to be logged\r\n    if (this.totalLen > 0 && (this.logStorage.isReady() || force)) {\r\n        //FIXME avoid truncating\r\n        // right now we don't care if the message size is \"slightly\" exceeded\r\n        if (this.logStorage.isReady()) {\r\n            // Sends all cached logs\r\n            if (this.outputCache.length) {\r\n                this.outputCache.forEach(\r\n                    function (cachedQueue) {\r\n                        this.logStorage.storeLogs(cachedQueue);\r\n                    }.bind(this)\r\n                );\r\n                // Clear the cache\r\n                this.outputCache = [];\r\n            }\r\n            // Send current batch\r\n            this.logStorage.storeLogs(this.queue);\r\n        } else {\r\n            this.outputCache.push(this.queue);\r\n        }\r\n\r\n        this.queue = [];\r\n        this.totalLen = 0;\r\n    }\r\n\r\n    if (reschedule) {\r\n        this._reschedulePublishInterval();\r\n    }\r\n};\r\n\r\n/**\r\n * Stops the periodical \"store logs\" task and immediately stores any pending\r\n * log entries as a batch.\r\n */\r\nLogCollector.prototype.stop = function() {\r\n    // Flush and stop publishing logs\r\n    this._flush(false /* do not force */, false /* do not reschedule */);\r\n};\r\n\r\nmodule.exports = LogCollector;\r\n","module.exports = function() {\r\n\tthrow new Error(\"define cannot be used indirect\");\r\n};\r\n","/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n","/*!\n * currentExecutingScript\n * Get the currently executing script, regardless of its source/trigger/synchronicity. Similar to HTML5's `document.currentScript` but arguably much more useful!\n * Copyright (c) 2015 James M. Greene\n * Licensed MIT\n * https://github.com/JamesMGreene/currentExecutingScript\n * v0.1.3\n */\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === \"object\") {\n    // CommonJS-like environments that support `module.exports`,\n    // like Node.js. Does not work with strict CommonJS!\n    module.exports = factory();\n  } else {\n    // Browser globals (`root` is `window`)\n    root.currentExecutingScript = factory();\n  }\n}(\n  // Current context/scope\n  this || window,\n\n  // Factory function to return the export\n  function() {\n\nvar scriptReadyRegex = /^(interactive|loaded|complete)$/;\n\n// This page's URL (minus query string and fragment identifer hash, if any)\nvar fullPageUrl = !!window.location ? window.location.href : null;\nvar pageUrl = fullPageUrl ? fullPageUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\") || null : null;\n\n// Live NodeList collection\nvar scripts = document.getElementsByTagName(\"script\");\n\n// Check if the browser supports the `readyState` property on `script` elements\nvar supportsScriptReadyState = \"readyState\" in (scripts[0] || document.createElement(\"script\"));\n\n// Lousy browser detection for [not] Opera\nvar isNotOpera = !window.opera || window.opera.toString() !== \"[object Opera]\";\n\n// Detect if `document.currentScript` is supported\nvar hasNativeCurrentScriptAccessor = \"currentScript\" in document;\n\nvar originalStackDepthConfig;\n// Detect if the V8 Error Stack Trace API is supported\nif (\"stackTraceLimit\" in Error && Error.stackTraceLimit !== Infinity) {\n  originalStackDepthConfig = Error.stackTraceLimit;\n  Error.stackTraceLimit = Infinity;\n}\n\n\n// In some browsers (e.g. Chrome), you can get the current stack from an Error\n// object instance without needing to throw it. Avoiding an unnecessary\n// use of `throw` saves time and performance.\nvar hasStackBeforeThrowing = false,\n    hasStackAfterThrowing = false;\n(function() {\n  try {\n    var err = new Error();\n    hasStackBeforeThrowing = typeof err.stack === \"string\" && !!err.stack;\n    throw err;\n  }\n  catch (thrownErr) {\n    hasStackAfterThrowing = typeof thrownErr.stack === \"string\" && !!thrownErr.stack;\n  }\n})();\n\n\n// Normalize whitespace within a string\nfunction normalizeWhitespace(str) {\n  return str ? str.replace(/^\\s+$|\\s+$/g, \"\").replace(/\\s\\s+/g, \" \") : \"\";\n}\n\n// Get script object based on the `src` URL\nfunction getScriptFromUrl(url, eligibleScripts) {\n  var i,\n      script = null;\n\n  eligibleScripts = eligibleScripts || scripts;\n\n  if (typeof url === \"string\" && url) {\n    for (i = eligibleScripts.length; i--; ) {\n      if (eligibleScripts[i].src === url) {\n        // NOTE: Could check if the same script URL is used by more than one `script` element\n        // here... but let's not. That would yield less useful results in \"loose\" detection. ;)\n        script = eligibleScripts[i];\n        break;\n      }\n    }\n  }\n  return script;\n}\n\n// Get script object based on the caller function's source code body (text)\nfunction getInlineScriptFromCallerSource(callerFnSource, eligibleScripts) {\n  var i, inlineScriptText,\n      script = null,\n      callerSourceText = normalizeWhitespace(callerFnSource);\n\n  eligibleScripts = eligibleScripts || scripts;\n\n  if (callerFnSource && callerSourceText) {\n    for (i = eligibleScripts.length; i--; ) {\n      // Only look at inline scripts\n      if (!eligibleScripts[i].hasAttribute(\"src\")) {\n        inlineScriptText = normalizeWhitespace(eligibleScripts[i].text);\n        if (inlineScriptText.indexOf(callerSourceText) !== -1) {\n          // If more than one match is found, don't return any\n          if (script) {\n            script = null;\n            break;\n          }\n          script = eligibleScripts[i];\n        }\n      }\n    }\n  }\n\n  return script;\n}\n\n// If there is only a single inline script on the page, return it; otherwise `null`\nfunction getSoleInlineScript(eligibleScripts) {\n  var i, len,\n      script = null;\n  eligibleScripts = eligibleScripts || scripts;\n  for (i = 0, len = eligibleScripts.length; i < len; i++) {\n    if (!eligibleScripts[i].hasAttribute(\"src\")) {\n      if (script) {\n        script = null;\n        break;\n      }\n      script = eligibleScripts[i];\n    }\n  }\n  return script;\n}\n\n// Get the currently executing script URL from an Error stack trace\nfunction getScriptUrlFromStack(stack, skipStackDepth) {\n  var matches, remainingStack,\n      url = null,\n      ignoreMessage = typeof skipStackDepth === \"number\";\n  skipStackDepth = ignoreMessage ? Math.round(skipStackDepth) : 0;\n  if (typeof stack === \"string\" && stack) {\n    if (ignoreMessage) {\n      matches = stack.match(/(data:text\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?/);\n    }\n    else {\n      matches = stack.match(/^(?:|[^:@]*@|.+\\)@(?=data:text\\/javascript|blob|http[s]?|file)|.+?\\s+(?: at |@)(?:[^:\\(]+ )*[\\(]?)(data:text\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?/);\n\n      if (!(matches && matches[1])) {\n        matches = stack.match(/\\)@(data:text\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?/);\n      }\n    }\n\n    if (matches && matches[1]) {\n      if (skipStackDepth > 0) {\n        remainingStack = stack.slice(stack.indexOf(matches[0]) + matches[0].length);\n        url = getScriptUrlFromStack(remainingStack, (skipStackDepth - 1));\n      }\n      else {\n        url = matches[1];\n      }\n    }\n\n    // TODO: Handle more edge cases!\n    // Fixes #1\n    // See https://github.com/JamesMGreene/currentExecutingScript/issues/1\n\n    // ???\n\n  }\n  return url;\n}\n\n\n// Get the farthest currently executing (i.e. yes, EXECUTING) `script` DOM\n// element for the caller function, regardless of whether it is that `script`\n// DOM element is currently being evaluated for the first time. The farthest\n// currently executing `script` DOM element would typically be considered the\n// originator of the current execution stack.\nfunction _farthestExecutingScript() {\n  /*jshint noarg:false */\n\n  // TODO: Implement!\n  // Fixes #3\n  // See https://github.com/JamesMGreene/currentExecutingScript/issues/3\n  return null;\n\n/*\n  // Yes, this IS possible, i.e. if a script removes other scripts (or itself)\n  if (scripts.length === 0) {\n    return null;\n  }\n\n  // Guaranteed accurate in IE 6-10.\n  // Not accurate/supported in any other browsers.\n  if (isNotOpera && supportsScriptReadyState) {\n    for (var i = scripts.length; i--; ) {\n      if (scripts[i].readyState === \"interactive\") {\n        return scripts[i];\n      }\n    }\n  }\n\n  var stack,\n      e = new Error();\n  if (hasStackBeforeThrowing) {\n    stack = e.stack;\n  }\n  if (!stack && hasStackAfterThrowing) {\n    try {\n      throw e;\n    }\n    catch (err) {\n      // NOTE: Cannot use `err.sourceURL` or `err.fileName` as they will always be THIS script\n      stack = err.stack;\n    }\n  }\n  if (stack) {\n    var url = getScriptUrlFromStack(stack, skipStackDepth);\n    var script = getScriptFromUrl(url, scripts );\n    if (!script && pageUrl && url === pageUrl) {\n      // Try to find the correct inline script by searching through\n      // inline scripts' text content for the caller function's source\n      // code to be present. If the caller function's source code is\n      // not available, see if there is only one inline script element\n      // in the DOM and return that (even though it may be wrong)\n\n      // TODO: Implement!\n      // Fixes #4 in part\n      // See https://github.com/JamesMGreene/currentExecutingScript/issues/4\n\n      var callerFn = _farthestExecutingScript.caller || null,\n          callerFnStack = [],\n          callerFnSource = null;\n\n      while (callerFn) {\n        callerFnStack.push(callerFn);\n        callerFn = callerFn.caller || null;\n      }\n      callerFn = callerFnStack.slice(-1)[0];\n      callerFnSource = callerFn ? (\"\" + callerFn) : null;\n\n\n      if (callerFnSource) {\n        script = getInlineScriptFromCallerSource(callerFnSource);\n      }\n      else {\n        // NOTE: This is a loose assumption that could be inaccurate!\n        //\n        // Inaccuracies:\n        //  - If the inline script that initiated the call was also removed from the DOM.\n        //  - If the call was initiated by an element's inline event handler,\n        //    e.g. `<a onclick=\"(function() { alert(currentExecutingScript()); }()\">click</a>`\n        script = getSoleInlineScript();\n      }\n    }\n    return script;\n  }\n\n  // NOTE: This is a loose assumption that could be inaccurate!\n  //\n  // Inaccuracies:\n  //  - If a script is created dynamically and appended to some position\n  //    other than the very end of the document.\n  //  - If multiple scripts are created dynamically and all appended to the\n  //    same position within the document (and do not have their `async` attributes\n  //    set to `false`, at least in browsers that support async script evaluation.\n  //    other than the very end of the document.\n  //  - If any scripts are added with the `async` attribute set to `true` in a browser\n  //    that supports it.\n  //  - May get confused by `script` elements within `svg` elements\n  return scripts[scripts.length - 1] || null;\n*/\n}\n\n\n// Get the originating currently executing (i.e. yes, EXECUTING) `script` DOM\n// element or attribute node (e.g. `onclick`) for the caller function,\n// regardless of whether it is that `script` DOM element is currently being\n// evaluated for the first time. The originating currently executing `script`\n// DOM element [or attribute node] is the originator of the current execution stack.\nfunction _originatingExecutingScript() {\n  // TODO: Implement!\n  // Fixes #2\n  // See https://github.com/JamesMGreene/currentExecutingScript/issues/2\n  return null;\n}\n\n// Get the nearest currently executing (i.e. yes, EXECUTING) `script` DOM\n// element for the caller function, regardless of whether it is that `script`\n// DOM element is currently being evaluated for the first time.\nfunction _nearestExecutingScript() {\n  /*jshint noarg:false */\n\n  // Yes, this IS possible, i.e. if a script removes other scripts (or itself)\n  if (scripts.length === 0) {\n    return null;\n  }\n\n  var i, e, stack, url, script,\n      eligibleScripts = [],\n      skipStackDepth = _nearestExecutingScript.skipStackDepth || 1,\n\n      // TODO: Implement!\n      // Fixes #4 in part\n      // See https://github.com/JamesMGreene/currentExecutingScript/issues/4\n      callerFnSource = null;  //(\"\" + (_nearestExecutingScript.caller || \"\")) || null;\n\n  // This part will only help in IE 6-10.\n  for (i = 0; i < scripts.length; i++) {\n    if (isNotOpera && supportsScriptReadyState) {\n      if (scriptReadyRegex.test(scripts[i].readyState)) {\n        eligibleScripts.push(scripts[i]);\n      }\n    }\n    else {\n      eligibleScripts.push(scripts[i]);\n    }\n  }\n\n  e = new Error();\n  if (hasStackBeforeThrowing) {\n    stack = e.stack;\n  }\n  if (!stack && hasStackAfterThrowing) {\n    try {\n      throw e;\n    }\n    catch (err) {\n      // NOTE: Cannot use `err.sourceURL` or `err.fileName` as they will always be THIS script\n      stack = err.stack;\n    }\n  }\n\n  if (stack) {\n    url = getScriptUrlFromStack(stack, skipStackDepth);\n    script = getScriptFromUrl(url, eligibleScripts);\n\n    if (!script && pageUrl && url === pageUrl) {\n      // Try to find the correct inline script by searching through\n      // inline scripts' text content for the caller function's source\n      // code to be present.\n      if (callerFnSource) {\n        script = getInlineScriptFromCallerSource(callerFnSource, eligibleScripts);\n      }\n      // If the caller function's source code is not available, see if\n      // there is only one inline script element in the DOM and return\n      // that (even though it may be wrong)...\n      else {\n        // NOTE: This is a loose assumption that could be inaccurate!\n        //\n        // Inaccuracies:\n        //  - If the inline script that initiated the call was also removed from the DOM.\n        //  - If the call was initiated by an element's inline event handler,\n        //    e.g. `<a onclick=\"(function() { alert(currentExecutingScript()); }()\">click</a>`\n        script = getSoleInlineScript(eligibleScripts);\n      }\n    }\n  }\n\n  //\n  // Welcome to the Island of Inaccurate Assumptions!\n  // NOTE: ALL of the following are loose assumptions that could be inaccurate!\n  //\n\n  if (!script) {\n    // Inaccuracies:\n    //  - If the inline script that initiated the call was also removed from the DOM.\n    //  - If the call was initiated by an element's inline event handler,\n    //    e.g. `<a onclick=\"(function() { alert(currentExecutingScript()); }()\">click</a>`\n    if (eligibleScripts.length === 1) {\n      script = eligibleScripts[0];\n    }\n  }\n\n  if (!script) {\n    // Inaccuracies:\n    //  - If script currently being synchronously evaluated by the parser is the\n    //    originator of this call stack but NOT the source script of the caller/invocation\n    //    e.g.\n    //    ```html\n    //    <script id=\"a\">\n    //    function getCurrentScriptCallerFn() {\n    //      return currentExecutingScript.near();\n    //    }\n    //    </script>\n    //    <script id=\"b\">\n    //    // Should get `script[id=\"a\"]` but will get `script[id=\"b\"]` instead\n    //    getCurrentScriptCallerFn();\n    //    </script>\n    if (hasNativeCurrentScriptAccessor) {\n      script = document.currentScript;\n    }\n  }\n\n  if (!script) {\n    // Inaccuracies:\n    //  - If script currently being synchronously evaluated by the parser is the\n    //    originator of this call stack but NOT the source script of the caller/invocation\n    //    e.g.\n    //    ```html\n    //    <script id=\"a\">\n    //    function getCurrentScriptCallerFn() {\n    //      return currentExecutingScript.near();\n    //    }\n    //    </script>\n    //    <script id=\"b\">\n    //    // Should get `script[id=\"a\"]` but will get `script[id=\"b\"]` instead\n    //    getCurrentScriptCallerFn();\n    //    </script>\n    if (isNotOpera && supportsScriptReadyState) {\n      for (i = eligibleScripts.length; i--; ) {\n        if (eligibleScripts[i].readyState === \"interactive\") {\n          script = eligibleScripts[i];\n          break;\n        }\n      }\n    }\n  }\n\n  if (!script) {\n    // Inaccuracies:\n    //  - If a script is created dynamically and appended to some position\n    //    other than the very end of the document.\n    //  - If multiple scripts are created dynamically and all appended to the\n    //    same position within the document (and do not have their `async` attributes\n    //    set to `false`, at least in browsers that support async script evaluation.\n    //    other than the very end of the document.\n    //  - If any scripts are added with the `async` attribute set to `true` in a browser\n    //    that supports it.\n    //  - May get confused by `script` elements within `svg` elements\n    //  - If script currently being synchronously evaluated by the parser is the\n    //    originator of this call stack but NOT the source script of the caller/invocation\n    //    e.g.\n    //    ```html\n    //    <script id=\"a\">\n    //    function getCurrentScriptCallerFn() {\n    //      return currentExecutingScript.near();\n    //    }\n    //    </script>\n    //    <script id=\"b\">\n    //    // Should get `script[id=\"a\"]` but will get `script[id=\"b\"]` instead\n    //    getCurrentScriptCallerFn();\n    //    </script>\n    //    ```\n    script = eligibleScripts[eligibleScripts.length - 1] || null;\n  }\n\n  return script;\n}\n\n// Default stack depth to skip over when analyzing call stack frames\n_nearestExecutingScript.skipStackDepth = 1;\n\n\n\n    //\n    // Export the API\n    //\n    var currentExecutingScript    = _nearestExecutingScript;      // default\n    currentExecutingScript.near   = _nearestExecutingScript;\n    currentExecutingScript.far    = _farthestExecutingScript;\n    currentExecutingScript.origin = _originatingExecutingScript;\n\n\n    // Just return a value to define the module export.\n    // This example returns an object, but the module\n    // can return a function as the exported value.\n    return currentExecutingScript;\n  })\n);\n","const Constants = {\r\n    LOCAL_JID: 'local'\r\n};\r\n\r\nmodule.exports = Constants;\r\n","import { $iq, Strophe } from 'strophe.js';\n\nStrophe.addConnectionPlugin('disco',\n{\n    _connection: null,\n    _identities : [],\n    _features : [],\n    _items : [],\n    /** Function: init\n     * Plugin init\n     *\n     * Parameters:\n     *   (Strophe.Connection) conn - Strophe connection\n     */\n    init: function(conn)\n    {\n    this._connection = conn;\n        this._identities = [];\n        this._features   = [];\n        this._items      = [];\n        // disco info\n        conn.addHandler(this._onDiscoInfo.bind(this), Strophe.NS.DISCO_INFO, 'iq', 'get', null, null);\n        // disco items\n        conn.addHandler(this._onDiscoItems.bind(this), Strophe.NS.DISCO_ITEMS, 'iq', 'get', null, null);\n    },\n    /** Function: addIdentity\n     * See http://xmpp.org/registrar/disco-categories.html\n     * Parameters:\n     *   (String) category - category of identity (like client, automation, etc ...)\n     *   (String) type - type of identity (like pc, web, bot , etc ...)\n     *   (String) name - name of identity in natural language\n     *   (String) lang - lang of name parameter\n     *\n     * Returns:\n     *   Boolean\n     */\n    addIdentity: function(category, type, name, lang)\n    {\n        for (var i=0; i<this._identities.length; i++)\n        {\n            if (this._identities[i].category == category &&\n                this._identities[i].type == type &&\n                this._identities[i].name == name &&\n                this._identities[i].lang == lang)\n            {\n                return false;\n            }\n        }\n        this._identities.push({category: category, type: type, name: name, lang: lang});\n        return true;\n    },\n    /** Function: addFeature\n     *\n     * Parameters:\n     *   (String) var_name - feature name (like jabber:iq:version)\n     *\n     * Returns:\n     *   boolean\n     */\n    addFeature: function(var_name)\n    {\n        for (var i=0; i<this._features.length; i++)\n        {\n             if (this._features[i] == var_name)\n                 return false;\n        }\n        this._features.push(var_name);\n        return true;\n    },\n    /** Function: removeFeature\n     *\n     * Parameters:\n     *   (String) var_name - feature name (like jabber:iq:version)\n     *\n     * Returns:\n     *   boolean\n     */\n    removeFeature: function(var_name)\n    {\n        for (var i=0; i<this._features.length; i++)\n        {\n             if (this._features[i] === var_name){\n                 this._features.splice(i,1);\n                 return true;\n             }\n        }\n        return false;\n    },\n    /** Function: addItem\n     *\n     * Parameters:\n     *   (String) jid\n     *   (String) name\n     *   (String) node\n     *   (Function) call_back\n     *\n     * Returns:\n     *   boolean\n     */\n    addItem: function(jid, name, node, call_back)\n    {\n        if (node && !call_back)\n            return false;\n        this._items.push({jid: jid, name: name, node: node, call_back: call_back});\n        return true;\n    },\n    /** Function: info\n     * Info query\n     *\n     * Parameters:\n     *   (Function) call_back\n     *   (String) jid\n     *   (String) node\n     */\n    info: function(jid, node, success, error, timeout)\n    {\n        var attrs = {xmlns: Strophe.NS.DISCO_INFO};\n        if (node)\n            attrs.node = node;\n\n        var info = $iq({from:this._connection.jid,\n                         to:jid, type:'get'}).c('query', attrs);\n        this._connection.sendIQ(info, success, error, timeout);\n    },\n    /** Function: items\n     * Items query\n     *\n     * Parameters:\n     *   (Function) call_back\n     *   (String) jid\n     *   (String) node\n     */\n    items: function(jid, node, success, error, timeout)\n    {\n        var attrs = {xmlns: Strophe.NS.DISCO_ITEMS};\n        if (node)\n            attrs.node = node;\n\n        var items = $iq({from:this._connection.jid,\n                         to:jid, type:'get'}).c('query', attrs);\n        this._connection.sendIQ(items, success, error, timeout);\n    },\n\n    /** PrivateFunction: _buildIQResult\n     */\n    _buildIQResult: function(stanza, query_attrs)\n    {\n        var id   =  stanza.getAttribute('id');\n        var from = stanza.getAttribute('from');\n        var iqresult = $iq({type: 'result', id: id});\n\n        if (from !== null) {\n            iqresult.attrs({to: from});\n        }\n\n        return iqresult.c('query', query_attrs);\n    },\n\n    /** PrivateFunction: _onDiscoInfo\n     * Called when receive info request\n     */\n    _onDiscoInfo: function(stanza)\n    {\n        var node = stanza.getElementsByTagName('query')[0].getAttribute('node');\n        var attrs = {xmlns: Strophe.NS.DISCO_INFO};\n        var i;\n        if (node)\n        {\n            attrs.node = node;\n        }\n        var iqresult = this._buildIQResult(stanza, attrs);\n        for (i=0; i<this._identities.length; i++)\n        {\n            attrs = {category: this._identities[i].category,\n                         type    : this._identities[i].type};\n            if (this._identities[i].name)\n                attrs.name = this._identities[i].name;\n            if (this._identities[i].lang)\n                attrs['xml:lang'] = this._identities[i].lang;\n            iqresult.c('identity', attrs).up();\n        }\n        for (i=0; i<this._features.length; i++)\n        {\n            iqresult.c('feature', {'var':this._features[i]}).up();\n        }\n        this._connection.send(iqresult.tree());\n        return true;\n    },\n    /** PrivateFunction: _onDiscoItems\n     * Called when receive items request\n     */\n    _onDiscoItems: function(stanza)\n    {\n        var query_attrs = {xmlns: Strophe.NS.DISCO_ITEMS};\n        var node = stanza.getElementsByTagName('query')[0].getAttribute('node');\n        var items, i;\n        if (node)\n        {\n            query_attrs.node = node;\n            items = [];\n            for (i = 0; i < this._items.length; i++)\n            {\n                if (this._items[i].node == node)\n                {\n                    items = this._items[i].call_back(stanza);\n                    break;\n                }\n            }\n        }\n        else\n        {\n            items = this._items;\n        }\n        var iqresult = this._buildIQResult(stanza, query_attrs);\n        for (i = 0; i < items.length; i++)\n        {\n            var attrs = {jid:  items[i].jid};\n            if (items[i].name)\n                attrs.name = items[i].name;\n            if (items[i].node)\n                attrs.node = items[i].node;\n            iqresult.c('item', attrs).up();\n        }\n        this._connection.send(iqresult.tree());\n        return true;\n    }\n});\n","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n /* eslint-env node */\r\n\r\n'use strict';\r\n\r\nvar adapterFactory = require('./adapter_factory.js');\r\nmodule.exports = adapterFactory({window: global.window});\r\n","/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n /* eslint-env node */\r\n\r\n'use strict';\r\n\r\nvar utils = require('./utils');\r\n// Shimming starts here.\r\nmodule.exports = function(dependencies, opts) {\r\n  var window = dependencies && dependencies.window;\r\n\r\n  var options = {\r\n    shimChrome: true,\r\n    shimFirefox: true,\r\n    shimEdge: true,\r\n    shimSafari: true,\r\n  };\r\n\r\n  for (var key in opts) {\r\n    if (hasOwnProperty.call(opts, key)) {\r\n      options[key] = opts[key];\r\n    }\r\n  }\r\n\r\n  // Utils.\r\n  var logging = utils.log;\r\n  var browserDetails = utils.detectBrowser(window);\r\n\r\n  // Export to the adapter global object visible in the browser.\r\n  var adapter = {\r\n    browserDetails: browserDetails,\r\n    extractVersion: utils.extractVersion,\r\n    disableLog: utils.disableLog,\r\n    disableWarnings: utils.disableWarnings\r\n  };\r\n\r\n  // Uncomment the line below if you want logging to occur, including logging\r\n  // for the switch statement below. Can also be turned on in the browser via\r\n  // adapter.disableLog(false), but then logging from the switch statement below\r\n  // will not appear.\r\n  // require('./utils').disableLog(false);\r\n\r\n  // Browser shims.\r\n  var chromeShim = require('./chrome/chrome_shim') || null;\r\n  var edgeShim = require('./edge/edge_shim') || null;\r\n  var firefoxShim = require('./firefox/firefox_shim') || null;\r\n  var safariShim = require('./safari/safari_shim') || null;\r\n  var commonShim = require('./common_shim') || null;\r\n\r\n  // Shim browser if found.\r\n  switch (browserDetails.browser) {\r\n    case 'chrome':\r\n      if (!chromeShim || !chromeShim.shimPeerConnection ||\r\n          !options.shimChrome) {\r\n        logging('Chrome shim is not included in this adapter release.');\r\n        return adapter;\r\n      }\r\n      logging('adapter.js shimming chrome.');\r\n      // Export to the adapter global object visible in the browser.\r\n      adapter.browserShim = chromeShim;\r\n      commonShim.shimCreateObjectURL(window);\r\n\r\n      chromeShim.shimGetUserMedia(window);\r\n      chromeShim.shimMediaStream(window);\r\n      chromeShim.shimSourceObject(window);\r\n      chromeShim.shimPeerConnection(window);\r\n      chromeShim.shimOnTrack(window);\r\n      chromeShim.shimAddTrackRemoveTrack(window);\r\n      chromeShim.shimGetSendersWithDtmf(window);\r\n\r\n      commonShim.shimRTCIceCandidate(window);\r\n      break;\r\n    case 'firefox':\r\n      if (!firefoxShim || !firefoxShim.shimPeerConnection ||\r\n          !options.shimFirefox) {\r\n        logging('Firefox shim is not included in this adapter release.');\r\n        return adapter;\r\n      }\r\n      logging('adapter.js shimming firefox.');\r\n      // Export to the adapter global object visible in the browser.\r\n      adapter.browserShim = firefoxShim;\r\n      commonShim.shimCreateObjectURL(window);\r\n\r\n      firefoxShim.shimGetUserMedia(window);\r\n      firefoxShim.shimSourceObject(window);\r\n      firefoxShim.shimPeerConnection(window);\r\n      firefoxShim.shimOnTrack(window);\r\n\r\n      commonShim.shimRTCIceCandidate(window);\r\n      break;\r\n    case 'edge':\r\n      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {\r\n        logging('MS edge shim is not included in this adapter release.');\r\n        return adapter;\r\n      }\r\n      logging('adapter.js shimming edge.');\r\n      // Export to the adapter global object visible in the browser.\r\n      adapter.browserShim = edgeShim;\r\n      commonShim.shimCreateObjectURL(window);\r\n\r\n      edgeShim.shimGetUserMedia(window);\r\n      edgeShim.shimPeerConnection(window);\r\n      edgeShim.shimReplaceTrack(window);\r\n\r\n      // the edge shim implements the full RTCIceCandidate object.\r\n      break;\r\n    case 'safari':\r\n      if (!safariShim || !options.shimSafari) {\r\n        logging('Safari shim is not included in this adapter release.');\r\n        return adapter;\r\n      }\r\n      logging('adapter.js shimming safari.');\r\n      // Export to the adapter global object visible in the browser.\r\n      adapter.browserShim = safariShim;\r\n      commonShim.shimCreateObjectURL(window);\r\n\r\n      safariShim.shimRTCIceServerUrls(window);\r\n      safariShim.shimCallbacksAPI(window);\r\n      safariShim.shimLocalStreamsAPI(window);\r\n      safariShim.shimRemoteStreamsAPI(window);\r\n      safariShim.shimTrackEventTransceiver(window);\r\n      safariShim.shimGetUserMedia(window);\r\n      safariShim.shimCreateOfferLegacy(window);\r\n\r\n      commonShim.shimRTCIceCandidate(window);\r\n      break;\r\n    default:\r\n      logging('Unsupported browser!');\r\n      break;\r\n  }\r\n\r\n  return adapter;\r\n};\r\n","\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n /* eslint-env node */\r\n'use strict';\r\nvar utils = require('../utils.js');\r\nvar logging = utils.log;\r\n\r\nvar chromeShim = {\r\n  shimMediaStream: function(window) {\r\n    window.MediaStream = window.MediaStream || window.webkitMediaStream;\r\n  },\r\n\r\n  shimOnTrack: function(window) {\r\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\r\n        window.RTCPeerConnection.prototype)) {\r\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\r\n        get: function() {\r\n          return this._ontrack;\r\n        },\r\n        set: function(f) {\r\n          if (this._ontrack) {\r\n            this.removeEventListener('track', this._ontrack);\r\n          }\r\n          this.addEventListener('track', this._ontrack = f);\r\n        }\r\n      });\r\n      var origSetRemoteDescription =\r\n          window.RTCPeerConnection.prototype.setRemoteDescription;\r\n      window.RTCPeerConnection.prototype.setRemoteDescription = function() {\r\n        var pc = this;\r\n        if (!pc._ontrackpoly) {\r\n          pc._ontrackpoly = function(e) {\r\n            // onaddstream does not fire when a track is added to an existing\r\n            // stream. But stream.onaddtrack is implemented so we use that.\r\n            e.stream.addEventListener('addtrack', function(te) {\r\n              var receiver;\r\n              if (window.RTCPeerConnection.prototype.getReceivers) {\r\n                receiver = pc.getReceivers().find(function(r) {\r\n                  return r.track && r.track.id === te.track.id;\r\n                });\r\n              } else {\r\n                receiver = {track: te.track};\r\n              }\r\n\r\n              var event = new Event('track');\r\n              event.track = te.track;\r\n              event.receiver = receiver;\r\n              event.transceiver = {receiver: receiver};\r\n              event.streams = [e.stream];\r\n              pc.dispatchEvent(event);\r\n            });\r\n            e.stream.getTracks().forEach(function(track) {\r\n              var receiver;\r\n              if (window.RTCPeerConnection.prototype.getReceivers) {\r\n                receiver = pc.getReceivers().find(function(r) {\r\n                  return r.track && r.track.id === track.id;\r\n                });\r\n              } else {\r\n                receiver = {track: track};\r\n              }\r\n              var event = new Event('track');\r\n              event.track = track;\r\n              event.receiver = receiver;\r\n              event.transceiver = {receiver: receiver};\r\n              event.streams = [e.stream];\r\n              pc.dispatchEvent(event);\r\n            });\r\n          };\r\n          pc.addEventListener('addstream', pc._ontrackpoly);\r\n        }\r\n        return origSetRemoteDescription.apply(pc, arguments);\r\n      };\r\n    }\r\n  },\r\n\r\n  shimGetSendersWithDtmf: function(window) {\r\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\r\n    if (typeof window === 'object' && window.RTCPeerConnection &&\r\n        !('getSenders' in window.RTCPeerConnection.prototype) &&\r\n        'createDTMFSender' in window.RTCPeerConnection.prototype) {\r\n      var shimSenderWithDtmf = function(pc, track) {\r\n        return {\r\n          track: track,\r\n          get dtmf() {\r\n            if (this._dtmf === undefined) {\r\n              if (track.kind === 'audio') {\r\n                this._dtmf = pc.createDTMFSender(track);\r\n              } else {\r\n                this._dtmf = null;\r\n              }\r\n            }\r\n            return this._dtmf;\r\n          },\r\n          _pc: pc\r\n        };\r\n      };\r\n\r\n      // augment addTrack when getSenders is not available.\r\n      if (!window.RTCPeerConnection.prototype.getSenders) {\r\n        window.RTCPeerConnection.prototype.getSenders = function() {\r\n          this._senders = this._senders || [];\r\n          return this._senders.slice(); // return a copy of the internal state.\r\n        };\r\n        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\r\n        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\r\n          var pc = this;\r\n          var sender = origAddTrack.apply(pc, arguments);\r\n          if (!sender) {\r\n            sender = shimSenderWithDtmf(pc, track);\r\n            pc._senders.push(sender);\r\n          }\r\n          return sender;\r\n        };\r\n\r\n        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\r\n        window.RTCPeerConnection.prototype.removeTrack = function(sender) {\r\n          var pc = this;\r\n          origRemoveTrack.apply(pc, arguments);\r\n          var idx = pc._senders.indexOf(sender);\r\n          if (idx !== -1) {\r\n            pc._senders.splice(idx, 1);\r\n          }\r\n        };\r\n      }\r\n      var origAddStream = window.RTCPeerConnection.prototype.addStream;\r\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\r\n        var pc = this;\r\n        pc._senders = pc._senders || [];\r\n        origAddStream.apply(pc, [stream]);\r\n        stream.getTracks().forEach(function(track) {\r\n          pc._senders.push(shimSenderWithDtmf(pc, track));\r\n        });\r\n      };\r\n\r\n      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\r\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\r\n        var pc = this;\r\n        pc._senders = pc._senders || [];\r\n        origRemoveStream.apply(pc, [stream]);\r\n\r\n        stream.getTracks().forEach(function(track) {\r\n          var sender = pc._senders.find(function(s) {\r\n            return s.track === track;\r\n          });\r\n          if (sender) {\r\n            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender\r\n          }\r\n        });\r\n      };\r\n    } else if (typeof window === 'object' && window.RTCPeerConnection &&\r\n               'getSenders' in window.RTCPeerConnection.prototype &&\r\n               'createDTMFSender' in window.RTCPeerConnection.prototype &&\r\n               window.RTCRtpSender &&\r\n               !('dtmf' in window.RTCRtpSender.prototype)) {\r\n      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\r\n      window.RTCPeerConnection.prototype.getSenders = function() {\r\n        var pc = this;\r\n        var senders = origGetSenders.apply(pc, []);\r\n        senders.forEach(function(sender) {\r\n          sender._pc = pc;\r\n        });\r\n        return senders;\r\n      };\r\n\r\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\r\n        get: function() {\r\n          if (this._dtmf === undefined) {\r\n            if (this.track.kind === 'audio') {\r\n              this._dtmf = this._pc.createDTMFSender(this.track);\r\n            } else {\r\n              this._dtmf = null;\r\n            }\r\n          }\r\n          return this._dtmf;\r\n        }\r\n      });\r\n    }\r\n  },\r\n\r\n  shimSourceObject: function(window) {\r\n    var URL = window && window.URL;\r\n\r\n    if (typeof window === 'object') {\r\n      if (window.HTMLMediaElement &&\r\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\r\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\r\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\r\n          get: function() {\r\n            return this._srcObject;\r\n          },\r\n          set: function(stream) {\r\n            var self = this;\r\n            // Use _srcObject as a private property for this shim\r\n            this._srcObject = stream;\r\n            if (this.src) {\r\n              URL.revokeObjectURL(this.src);\r\n            }\r\n\r\n            if (!stream) {\r\n              this.src = '';\r\n              return undefined;\r\n            }\r\n            this.src = URL.createObjectURL(stream);\r\n            // We need to recreate the blob url when a track is added or\r\n            // removed. Doing it manually since we want to avoid a recursion.\r\n            stream.addEventListener('addtrack', function() {\r\n              if (self.src) {\r\n                URL.revokeObjectURL(self.src);\r\n              }\r\n              self.src = URL.createObjectURL(stream);\r\n            });\r\n            stream.addEventListener('removetrack', function() {\r\n              if (self.src) {\r\n                URL.revokeObjectURL(self.src);\r\n              }\r\n              self.src = URL.createObjectURL(stream);\r\n            });\r\n          }\r\n        });\r\n      }\r\n    }\r\n  },\r\n\r\n  shimAddTrackRemoveTrack: function(window) {\r\n    var browserDetails = utils.detectBrowser(window);\r\n    // shim addTrack and removeTrack.\r\n    if (window.RTCPeerConnection.prototype.addTrack &&\r\n        browserDetails.version >= 63) {\r\n      return;\r\n    }\r\n\r\n    // also shim pc.getLocalStreams when addTrack is shimmed\r\n    // to return the original streams.\r\n    var origGetLocalStreams = window.RTCPeerConnection.prototype\r\n        .getLocalStreams;\r\n    window.RTCPeerConnection.prototype.getLocalStreams = function() {\r\n      var self = this;\r\n      var nativeStreams = origGetLocalStreams.apply(this);\r\n      self._reverseStreams = self._reverseStreams || {};\r\n      return nativeStreams.map(function(stream) {\r\n        return self._reverseStreams[stream.id];\r\n      });\r\n    };\r\n\r\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\r\n    window.RTCPeerConnection.prototype.addStream = function(stream) {\r\n      var pc = this;\r\n      pc._streams = pc._streams || {};\r\n      pc._reverseStreams = pc._reverseStreams || {};\r\n\r\n      stream.getTracks().forEach(function(track) {\r\n        var alreadyExists = pc.getSenders().find(function(s) {\r\n          return s.track === track;\r\n        });\r\n        if (alreadyExists) {\r\n          throw new DOMException('Track already exists.',\r\n              'InvalidAccessError');\r\n        }\r\n      });\r\n      // Add identity mapping for consistency with addTrack.\r\n      // Unless this is being used with a stream from addTrack.\r\n      if (!pc._reverseStreams[stream.id]) {\r\n        var newStream = new window.MediaStream(stream.getTracks());\r\n        pc._streams[stream.id] = newStream;\r\n        pc._reverseStreams[newStream.id] = stream;\r\n        stream = newStream;\r\n      }\r\n      origAddStream.apply(pc, [stream]);\r\n    };\r\n\r\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\r\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\r\n      var pc = this;\r\n      pc._streams = pc._streams || {};\r\n      pc._reverseStreams = pc._reverseStreams || {};\r\n\r\n      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);\r\n      delete pc._reverseStreams[(pc._streams[stream.id] ?\r\n          pc._streams[stream.id].id : stream.id)];\r\n      delete pc._streams[stream.id];\r\n    };\r\n\r\n    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\r\n      var pc = this;\r\n      if (pc.signalingState === 'closed') {\r\n        throw new DOMException(\r\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\r\n          'InvalidStateError');\r\n      }\r\n      var streams = [].slice.call(arguments, 1);\r\n      if (streams.length !== 1 ||\r\n          !streams[0].getTracks().find(function(t) {\r\n            return t === track;\r\n          })) {\r\n        // this is not fully correct but all we can manage without\r\n        // [[associated MediaStreams]] internal slot.\r\n        throw new DOMException(\r\n          'The adapter.js addTrack polyfill only supports a single ' +\r\n          ' stream which is associated with the specified track.',\r\n          'NotSupportedError');\r\n      }\r\n\r\n      var alreadyExists = pc.getSenders().find(function(s) {\r\n        return s.track === track;\r\n      });\r\n      if (alreadyExists) {\r\n        throw new DOMException('Track already exists.',\r\n            'InvalidAccessError');\r\n      }\r\n\r\n      pc._streams = pc._streams || {};\r\n      pc._reverseStreams = pc._reverseStreams || {};\r\n      var oldStream = pc._streams[stream.id];\r\n      if (oldStream) {\r\n        // this is using odd Chrome behaviour, use with caution:\r\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\r\n        // Note: we rely on the high-level addTrack/dtmf shim to\r\n        // create the sender with a dtmf sender.\r\n        oldStream.addTrack(track);\r\n\r\n        // Trigger ONN async.\r\n        Promise.resolve().then(function() {\r\n          pc.dispatchEvent(new Event('negotiationneeded'));\r\n        });\r\n      } else {\r\n        var newStream = new window.MediaStream([track]);\r\n        pc._streams[stream.id] = newStream;\r\n        pc._reverseStreams[newStream.id] = stream;\r\n        pc.addStream(newStream);\r\n      }\r\n      return pc.getSenders().find(function(s) {\r\n        return s.track === track;\r\n      });\r\n    };\r\n\r\n    // replace the internal stream id with the external one and\r\n    // vice versa.\r\n    function replaceInternalStreamId(pc, description) {\r\n      var sdp = description.sdp;\r\n      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {\r\n        var externalStream = pc._reverseStreams[internalId];\r\n        var internalStream = pc._streams[externalStream.id];\r\n        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\r\n            externalStream.id);\r\n      });\r\n      return new RTCSessionDescription({\r\n        type: description.type,\r\n        sdp: sdp\r\n      });\r\n    }\r\n    function replaceExternalStreamId(pc, description) {\r\n      var sdp = description.sdp;\r\n      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {\r\n        var externalStream = pc._reverseStreams[internalId];\r\n        var internalStream = pc._streams[externalStream.id];\r\n        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\r\n            internalStream.id);\r\n      });\r\n      return new RTCSessionDescription({\r\n        type: description.type,\r\n        sdp: sdp\r\n      });\r\n    }\r\n    ['createOffer', 'createAnswer'].forEach(function(method) {\r\n      var nativeMethod = window.RTCPeerConnection.prototype[method];\r\n      window.RTCPeerConnection.prototype[method] = function() {\r\n        var pc = this;\r\n        var args = arguments;\r\n        var isLegacyCall = arguments.length &&\r\n            typeof arguments[0] === 'function';\r\n        if (isLegacyCall) {\r\n          return nativeMethod.apply(pc, [\r\n            function(description) {\r\n              var desc = replaceInternalStreamId(pc, description);\r\n              args[0].apply(null, [desc]);\r\n            },\r\n            function(err) {\r\n              if (args[1]) {\r\n                args[1].apply(null, err);\r\n              }\r\n            }, arguments[2]\r\n          ]);\r\n        }\r\n        return nativeMethod.apply(pc, arguments)\r\n        .then(function(description) {\r\n          return replaceInternalStreamId(pc, description);\r\n        });\r\n      };\r\n    });\r\n\r\n    var origSetLocalDescription =\r\n        window.RTCPeerConnection.prototype.setLocalDescription;\r\n    window.RTCPeerConnection.prototype.setLocalDescription = function() {\r\n      var pc = this;\r\n      if (!arguments.length || !arguments[0].type) {\r\n        return origSetLocalDescription.apply(pc, arguments);\r\n      }\r\n      arguments[0] = replaceExternalStreamId(pc, arguments[0]);\r\n      return origSetLocalDescription.apply(pc, arguments);\r\n    };\r\n\r\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\r\n\r\n    var origLocalDescription = Object.getOwnPropertyDescriptor(\r\n        window.RTCPeerConnection.prototype, 'localDescription');\r\n    Object.defineProperty(window.RTCPeerConnection.prototype,\r\n        'localDescription', {\r\n          get: function() {\r\n            var pc = this;\r\n            var description = origLocalDescription.get.apply(this);\r\n            if (description.type === '') {\r\n              return description;\r\n            }\r\n            return replaceInternalStreamId(pc, description);\r\n          }\r\n        });\r\n\r\n    window.RTCPeerConnection.prototype.removeTrack = function(sender) {\r\n      var pc = this;\r\n      if (pc.signalingState === 'closed') {\r\n        throw new DOMException(\r\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\r\n          'InvalidStateError');\r\n      }\r\n      // We can not yet check for sender instanceof RTCRtpSender\r\n      // since we shim RTPSender. So we check if sender._pc is set.\r\n      if (!sender._pc) {\r\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\r\n            'does not implement interface RTCRtpSender.', 'TypeError');\r\n      }\r\n      var isLocal = sender._pc === pc;\r\n      if (!isLocal) {\r\n        throw new DOMException('Sender was not created by this connection.',\r\n            'InvalidAccessError');\r\n      }\r\n\r\n      // Search for the native stream the senders track belongs to.\r\n      pc._streams = pc._streams || {};\r\n      var stream;\r\n      Object.keys(pc._streams).forEach(function(streamid) {\r\n        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {\r\n          return sender.track === track;\r\n        });\r\n        if (hasTrack) {\r\n          stream = pc._streams[streamid];\r\n        }\r\n      });\r\n\r\n      if (stream) {\r\n        if (stream.getTracks().length === 1) {\r\n          // if this is the last track of the stream, remove the stream. This\r\n          // takes care of any shimmed _senders.\r\n          pc.removeStream(pc._reverseStreams[stream.id]);\r\n        } else {\r\n          // relying on the same odd chrome behaviour as above.\r\n          stream.removeTrack(sender.track);\r\n        }\r\n        pc.dispatchEvent(new Event('negotiationneeded'));\r\n      }\r\n    };\r\n  },\r\n\r\n  shimPeerConnection: function(window) {\r\n    var browserDetails = utils.detectBrowser(window);\r\n\r\n    // The RTCPeerConnection object.\r\n    if (!window.RTCPeerConnection) {\r\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\r\n        // Translate iceTransportPolicy to iceTransports,\r\n        // see https://code.google.com/p/webrtc/issues/detail?id=4869\r\n        // this was fixed in M56 along with unprefixing RTCPeerConnection.\r\n        logging('PeerConnection');\r\n        if (pcConfig && pcConfig.iceTransportPolicy) {\r\n          pcConfig.iceTransports = pcConfig.iceTransportPolicy;\r\n        }\r\n\r\n        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);\r\n      };\r\n      window.RTCPeerConnection.prototype =\r\n          window.webkitRTCPeerConnection.prototype;\r\n      // wrap static methods. Currently just generateCertificate.\r\n      if (window.webkitRTCPeerConnection.generateCertificate) {\r\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\r\n          get: function() {\r\n            return window.webkitRTCPeerConnection.generateCertificate;\r\n          }\r\n        });\r\n      }\r\n    } else {\r\n      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\r\n      var OrigPeerConnection = window.RTCPeerConnection;\r\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\r\n        if (pcConfig && pcConfig.iceServers) {\r\n          var newIceServers = [];\r\n          for (var i = 0; i < pcConfig.iceServers.length; i++) {\r\n            var server = pcConfig.iceServers[i];\r\n            if (!server.hasOwnProperty('urls') &&\r\n                server.hasOwnProperty('url')) {\r\n              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\r\n              server = JSON.parse(JSON.stringify(server));\r\n              server.urls = server.url;\r\n              newIceServers.push(server);\r\n            } else {\r\n              newIceServers.push(pcConfig.iceServers[i]);\r\n            }\r\n          }\r\n          pcConfig.iceServers = newIceServers;\r\n        }\r\n        return new OrigPeerConnection(pcConfig, pcConstraints);\r\n      };\r\n      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\r\n      // wrap static methods. Currently just generateCertificate.\r\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\r\n        get: function() {\r\n          return OrigPeerConnection.generateCertificate;\r\n        }\r\n      });\r\n    }\r\n\r\n    var origGetStats = window.RTCPeerConnection.prototype.getStats;\r\n    window.RTCPeerConnection.prototype.getStats = function(selector,\r\n        successCallback, errorCallback) {\r\n      var self = this;\r\n      var args = arguments;\r\n\r\n      // If selector is a function then we are in the old style stats so just\r\n      // pass back the original getStats format to avoid breaking old users.\r\n      if (arguments.length > 0 && typeof selector === 'function') {\r\n        return origGetStats.apply(this, arguments);\r\n      }\r\n\r\n      // When spec-style getStats is supported, return those when called with\r\n      // either no arguments or the selector argument is null.\r\n      if (origGetStats.length === 0 && (arguments.length === 0 ||\r\n          typeof arguments[0] !== 'function')) {\r\n        return origGetStats.apply(this, []);\r\n      }\r\n\r\n      var fixChromeStats_ = function(response) {\r\n        var standardReport = {};\r\n        var reports = response.result();\r\n        reports.forEach(function(report) {\r\n          var standardStats = {\r\n            id: report.id,\r\n            timestamp: report.timestamp,\r\n            type: {\r\n              localcandidate: 'local-candidate',\r\n              remotecandidate: 'remote-candidate'\r\n            }[report.type] || report.type\r\n          };\r\n          report.names().forEach(function(name) {\r\n            standardStats[name] = report.stat(name);\r\n          });\r\n          standardReport[standardStats.id] = standardStats;\r\n        });\r\n\r\n        return standardReport;\r\n      };\r\n\r\n      // shim getStats with maplike support\r\n      var makeMapStats = function(stats) {\r\n        return new Map(Object.keys(stats).map(function(key) {\r\n          return [key, stats[key]];\r\n        }));\r\n      };\r\n\r\n      if (arguments.length >= 2) {\r\n        var successCallbackWrapper_ = function(response) {\r\n          args[1](makeMapStats(fixChromeStats_(response)));\r\n        };\r\n\r\n        return origGetStats.apply(this, [successCallbackWrapper_,\r\n          arguments[0]]);\r\n      }\r\n\r\n      // promise-support\r\n      return new Promise(function(resolve, reject) {\r\n        origGetStats.apply(self, [\r\n          function(response) {\r\n            resolve(makeMapStats(fixChromeStats_(response)));\r\n          }, reject]);\r\n      }).then(successCallback, errorCallback);\r\n    };\r\n\r\n    // add promise support -- natively available in Chrome 51\r\n    if (browserDetails.version < 51) {\r\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\r\n          .forEach(function(method) {\r\n            var nativeMethod = window.RTCPeerConnection.prototype[method];\r\n            window.RTCPeerConnection.prototype[method] = function() {\r\n              var args = arguments;\r\n              var self = this;\r\n              var promise = new Promise(function(resolve, reject) {\r\n                nativeMethod.apply(self, [args[0], resolve, reject]);\r\n              });\r\n              if (args.length < 2) {\r\n                return promise;\r\n              }\r\n              return promise.then(function() {\r\n                args[1].apply(null, []);\r\n              },\r\n              function(err) {\r\n                if (args.length >= 3) {\r\n                  args[2].apply(null, [err]);\r\n                }\r\n              });\r\n            };\r\n          });\r\n    }\r\n\r\n    // promise support for createOffer and createAnswer. Available (without\r\n    // bugs) since M52: crbug/619289\r\n    if (browserDetails.version < 52) {\r\n      ['createOffer', 'createAnswer'].forEach(function(method) {\r\n        var nativeMethod = window.RTCPeerConnection.prototype[method];\r\n        window.RTCPeerConnection.prototype[method] = function() {\r\n          var self = this;\r\n          if (arguments.length < 1 || (arguments.length === 1 &&\r\n              typeof arguments[0] === 'object')) {\r\n            var opts = arguments.length === 1 ? arguments[0] : undefined;\r\n            return new Promise(function(resolve, reject) {\r\n              nativeMethod.apply(self, [resolve, reject, opts]);\r\n            });\r\n          }\r\n          return nativeMethod.apply(this, arguments);\r\n        };\r\n      });\r\n    }\r\n\r\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\r\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\r\n        .forEach(function(method) {\r\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\r\n          window.RTCPeerConnection.prototype[method] = function() {\r\n            arguments[0] = new ((method === 'addIceCandidate') ?\r\n                window.RTCIceCandidate :\r\n                window.RTCSessionDescription)(arguments[0]);\r\n            return nativeMethod.apply(this, arguments);\r\n          };\r\n        });\r\n\r\n    // support for addIceCandidate(null or undefined)\r\n    var nativeAddIceCandidate =\r\n        window.RTCPeerConnection.prototype.addIceCandidate;\r\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\r\n      if (!arguments[0]) {\r\n        if (arguments[1]) {\r\n          arguments[1].apply(null);\r\n        }\r\n        return Promise.resolve();\r\n      }\r\n      return nativeAddIceCandidate.apply(this, arguments);\r\n    };\r\n  }\r\n};\r\n\r\n\r\n// Expose public methods.\r\nmodule.exports = {\r\n  shimMediaStream: chromeShim.shimMediaStream,\r\n  shimOnTrack: chromeShim.shimOnTrack,\r\n  shimAddTrackRemoveTrack: chromeShim.shimAddTrackRemoveTrack,\r\n  shimGetSendersWithDtmf: chromeShim.shimGetSendersWithDtmf,\r\n  shimSourceObject: chromeShim.shimSourceObject,\r\n  shimPeerConnection: chromeShim.shimPeerConnection,\r\n  shimGetUserMedia: require('./getusermedia')\r\n};\r\n","/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n /* eslint-env node */\r\n'use strict';\r\nvar utils = require('../utils.js');\r\nvar logging = utils.log;\r\n\r\n// Expose public methods.\r\nmodule.exports = function(window) {\r\n  var browserDetails = utils.detectBrowser(window);\r\n  var navigator = window && window.navigator;\r\n\r\n  var constraintsToChrome_ = function(c) {\r\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\r\n      return c;\r\n    }\r\n    var cc = {};\r\n    Object.keys(c).forEach(function(key) {\r\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\r\n        return;\r\n      }\r\n      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\r\n      if (r.exact !== undefined && typeof r.exact === 'number') {\r\n        r.min = r.max = r.exact;\r\n      }\r\n      var oldname_ = function(prefix, name) {\r\n        if (prefix) {\r\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\r\n        }\r\n        return (name === 'deviceId') ? 'sourceId' : name;\r\n      };\r\n      if (r.ideal !== undefined) {\r\n        cc.optional = cc.optional || [];\r\n        var oc = {};\r\n        if (typeof r.ideal === 'number') {\r\n          oc[oldname_('min', key)] = r.ideal;\r\n          cc.optional.push(oc);\r\n          oc = {};\r\n          oc[oldname_('max', key)] = r.ideal;\r\n          cc.optional.push(oc);\r\n        } else {\r\n          oc[oldname_('', key)] = r.ideal;\r\n          cc.optional.push(oc);\r\n        }\r\n      }\r\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\r\n        cc.mandatory = cc.mandatory || {};\r\n        cc.mandatory[oldname_('', key)] = r.exact;\r\n      } else {\r\n        ['min', 'max'].forEach(function(mix) {\r\n          if (r[mix] !== undefined) {\r\n            cc.mandatory = cc.mandatory || {};\r\n            cc.mandatory[oldname_(mix, key)] = r[mix];\r\n          }\r\n        });\r\n      }\r\n    });\r\n    if (c.advanced) {\r\n      cc.optional = (cc.optional || []).concat(c.advanced);\r\n    }\r\n    return cc;\r\n  };\r\n\r\n  var shimConstraints_ = function(constraints, func) {\r\n    if (browserDetails.version >= 61) {\r\n      return func(constraints);\r\n    }\r\n    constraints = JSON.parse(JSON.stringify(constraints));\r\n    if (constraints && typeof constraints.audio === 'object') {\r\n      var remap = function(obj, a, b) {\r\n        if (a in obj && !(b in obj)) {\r\n          obj[b] = obj[a];\r\n          delete obj[a];\r\n        }\r\n      };\r\n      constraints = JSON.parse(JSON.stringify(constraints));\r\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\r\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\r\n      constraints.audio = constraintsToChrome_(constraints.audio);\r\n    }\r\n    if (constraints && typeof constraints.video === 'object') {\r\n      // Shim facingMode for mobile & surface pro.\r\n      var face = constraints.video.facingMode;\r\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\r\n      var getSupportedFacingModeLies = browserDetails.version < 66;\r\n\r\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\r\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\r\n          !(navigator.mediaDevices.getSupportedConstraints &&\r\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\r\n            !getSupportedFacingModeLies)) {\r\n        delete constraints.video.facingMode;\r\n        var matches;\r\n        if (face.exact === 'environment' || face.ideal === 'environment') {\r\n          matches = ['back', 'rear'];\r\n        } else if (face.exact === 'user' || face.ideal === 'user') {\r\n          matches = ['front'];\r\n        }\r\n        if (matches) {\r\n          // Look for matches in label, or use last cam for back (typical).\r\n          return navigator.mediaDevices.enumerateDevices()\r\n          .then(function(devices) {\r\n            devices = devices.filter(function(d) {\r\n              return d.kind === 'videoinput';\r\n            });\r\n            var dev = devices.find(function(d) {\r\n              return matches.some(function(match) {\r\n                return d.label.toLowerCase().indexOf(match) !== -1;\r\n              });\r\n            });\r\n            if (!dev && devices.length && matches.indexOf('back') !== -1) {\r\n              dev = devices[devices.length - 1]; // more likely the back cam\r\n            }\r\n            if (dev) {\r\n              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :\r\n                                                        {ideal: dev.deviceId};\r\n            }\r\n            constraints.video = constraintsToChrome_(constraints.video);\r\n            logging('chrome: ' + JSON.stringify(constraints));\r\n            return func(constraints);\r\n          });\r\n        }\r\n      }\r\n      constraints.video = constraintsToChrome_(constraints.video);\r\n    }\r\n    logging('chrome: ' + JSON.stringify(constraints));\r\n    return func(constraints);\r\n  };\r\n\r\n  var shimError_ = function(e) {\r\n    return {\r\n      name: {\r\n        PermissionDeniedError: 'NotAllowedError',\r\n        InvalidStateError: 'NotReadableError',\r\n        DevicesNotFoundError: 'NotFoundError',\r\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\r\n        TrackStartError: 'NotReadableError',\r\n        MediaDeviceFailedDueToShutdown: 'NotReadableError',\r\n        MediaDeviceKillSwitchOn: 'NotReadableError'\r\n      }[e.name] || e.name,\r\n      message: e.message,\r\n      constraint: e.constraintName,\r\n      toString: function() {\r\n        return this.name + (this.message && ': ') + this.message;\r\n      }\r\n    };\r\n  };\r\n\r\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\r\n    shimConstraints_(constraints, function(c) {\r\n      navigator.webkitGetUserMedia(c, onSuccess, function(e) {\r\n        if (onError) {\r\n          onError(shimError_(e));\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  navigator.getUserMedia = getUserMedia_;\r\n\r\n  // Returns the result of getUserMedia as a Promise.\r\n  var getUserMediaPromise_ = function(constraints) {\r\n    return new Promise(function(resolve, reject) {\r\n      navigator.getUserMedia(constraints, resolve, reject);\r\n    });\r\n  };\r\n\r\n  if (!navigator.mediaDevices) {\r\n    navigator.mediaDevices = {\r\n      getUserMedia: getUserMediaPromise_,\r\n      enumerateDevices: function() {\r\n        return new Promise(function(resolve) {\r\n          var kinds = {audio: 'audioinput', video: 'videoinput'};\r\n          return window.MediaStreamTrack.getSources(function(devices) {\r\n            resolve(devices.map(function(device) {\r\n              return {label: device.label,\r\n                kind: kinds[device.kind],\r\n                deviceId: device.id,\r\n                groupId: ''};\r\n            }));\r\n          });\r\n        });\r\n      },\r\n      getSupportedConstraints: function() {\r\n        return {\r\n          deviceId: true, echoCancellation: true, facingMode: true,\r\n          frameRate: true, height: true, width: true\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  // A shim for getUserMedia method on the mediaDevices object.\r\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\r\n  if (!navigator.mediaDevices.getUserMedia) {\r\n    navigator.mediaDevices.getUserMedia = function(constraints) {\r\n      return getUserMediaPromise_(constraints);\r\n    };\r\n  } else {\r\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\r\n    // function which returns a Promise, it does not accept spec-style\r\n    // constraints.\r\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\r\n        bind(navigator.mediaDevices);\r\n    navigator.mediaDevices.getUserMedia = function(cs) {\r\n      return shimConstraints_(cs, function(c) {\r\n        return origGetUserMedia(c).then(function(stream) {\r\n          if (c.audio && !stream.getAudioTracks().length ||\r\n              c.video && !stream.getVideoTracks().length) {\r\n            stream.getTracks().forEach(function(track) {\r\n              track.stop();\r\n            });\r\n            throw new DOMException('', 'NotFoundError');\r\n          }\r\n          return stream;\r\n        }, function(e) {\r\n          return Promise.reject(shimError_(e));\r\n        });\r\n      });\r\n    };\r\n  }\r\n\r\n  // Dummy devicechange event methods.\r\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\r\n  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {\r\n    navigator.mediaDevices.addEventListener = function() {\r\n      logging('Dummy mediaDevices.addEventListener called.');\r\n    };\r\n  }\r\n  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {\r\n    navigator.mediaDevices.removeEventListener = function() {\r\n      logging('Dummy mediaDevices.removeEventListener called.');\r\n    };\r\n  }\r\n};\r\n","/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n /* eslint-env node */\r\n'use strict';\r\n\r\nvar utils = require('../utils');\r\nvar shimRTCPeerConnection = require('rtcpeerconnection-shim');\r\n\r\nmodule.exports = {\r\n  shimGetUserMedia: require('./getusermedia'),\r\n  shimPeerConnection: function(window) {\r\n    var browserDetails = utils.detectBrowser(window);\r\n\r\n    if (window.RTCIceGatherer) {\r\n      // ORTC defines an RTCIceCandidate object but no constructor.\r\n      // Not implemented in Edge.\r\n      if (!window.RTCIceCandidate) {\r\n        window.RTCIceCandidate = function(args) {\r\n          return args;\r\n        };\r\n      }\r\n      // ORTC does not have a session description object but\r\n      // other browsers (i.e. Chrome) that will support both PC and ORTC\r\n      // in the future might have this defined already.\r\n      if (!window.RTCSessionDescription) {\r\n        window.RTCSessionDescription = function(args) {\r\n          return args;\r\n        };\r\n      }\r\n      // this adds an additional event listener to MediaStrackTrack that signals\r\n      // when a tracks enabled property was changed. Workaround for a bug in\r\n      // addStream, see below. No longer required in 15025+\r\n      if (browserDetails.version < 15025) {\r\n        var origMSTEnabled = Object.getOwnPropertyDescriptor(\r\n            window.MediaStreamTrack.prototype, 'enabled');\r\n        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {\r\n          set: function(value) {\r\n            origMSTEnabled.set.call(this, value);\r\n            var ev = new Event('enabled');\r\n            ev.enabled = value;\r\n            this.dispatchEvent(ev);\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    // ORTC defines the DTMF sender a bit different.\r\n    // https://github.com/w3c/ortc/issues/714\r\n    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\r\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\r\n        get: function() {\r\n          if (this._dtmf === undefined) {\r\n            if (this.track.kind === 'audio') {\r\n              this._dtmf = new window.RTCDtmfSender(this);\r\n            } else if (this.track.kind === 'video') {\r\n              this._dtmf = null;\r\n            }\r\n          }\r\n          return this._dtmf;\r\n        }\r\n      });\r\n    }\r\n\r\n    window.RTCPeerConnection =\r\n        shimRTCPeerConnection(window, browserDetails.version);\r\n  },\r\n  shimReplaceTrack: function(window) {\r\n    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614\r\n    if (window.RTCRtpSender &&\r\n        !('replaceTrack' in window.RTCRtpSender.prototype)) {\r\n      window.RTCRtpSender.prototype.replaceTrack =\r\n          window.RTCRtpSender.prototype.setTrack;\r\n    }\r\n  }\r\n};\r\n","/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\n\nvar SDPUtils = require('sdp');\n\nfunction fixStatsType(stat) {\n  return {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  }[stat.type] || stat.type;\n}\n\nfunction writeMediaSection(transceiver, caps, type, stream, dtlsRole) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : dtlsRole || 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    var trackId = transceiver.rtpSender._initialTrackId ||\n        transceiver.rtpSender.track.id;\n    transceiver.rtpSender._initialTrackId = trackId;\n    // spec.\n    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +\n        trackId + '\\r\\n';\n    sdp += 'a=' + msid;\n    // for Chrome. Legacy should no longer be required.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n\n    // RTX\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n}\n\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function(server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function(url) {\n        var validTurn = url.indexOf('turn:') === 0 &&\n            url.indexOf('transport=udp') !== -1 &&\n            url.indexOf('turn:[') === -1 &&\n            !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&\n            url.indexOf('?transport=udp') === -1;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n}\n\n// Determines the intersection of local and remote capabilities.\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\n  var commonCapabilities = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: []\n  };\n\n  var findCodecByPayloadType = function(pt, codecs) {\n    pt = parseInt(pt, 10);\n    for (var i = 0; i < codecs.length; i++) {\n      if (codecs[i].payloadType === pt ||\n          codecs[i].preferredPayloadType === pt) {\n        return codecs[i];\n      }\n    }\n  };\n\n  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\n    return lCodec && rCodec &&\n        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\n  };\n\n  localCapabilities.codecs.forEach(function(lCodec) {\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n      var rCodec = remoteCapabilities.codecs[i];\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\n          lCodec.clockRate === rCodec.clockRate) {\n        if (lCodec.name.toLowerCase() === 'rtx' &&\n            lCodec.parameters && rCodec.parameters.apt) {\n          // for RTX we need to find the local rtx that has a apt\n          // which points to the same local codec as the remote one.\n          if (!rtxCapabilityMatches(lCodec, rCodec,\n              localCapabilities.codecs, remoteCapabilities.codecs)) {\n            continue;\n          }\n        }\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\n        // number of channels is the highest common number of channels\n        rCodec.numChannels = Math.min(lCodec.numChannels,\n            rCodec.numChannels);\n        // push rCodec so we reply with offerer payload type\n        commonCapabilities.codecs.push(rCodec);\n\n        // determine common feedback mechanisms\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n            if (lCodec.rtcpFeedback[j].type === fb.type &&\n                lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n              return true;\n            }\n          }\n          return false;\n        });\n        // FIXME: also need to determine .parameters\n        //  see https://github.com/openpeer/ortc/issues/569\n        break;\n      }\n    }\n  });\n\n  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length;\n         i++) {\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\n        break;\n      }\n    }\n  });\n\n  // FIXME: fecMechanisms\n  return commonCapabilities;\n}\n\n// is action=setLocalDescription with type allowed in signalingState\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\n  return {\n    offer: {\n      setLocalDescription: ['stable', 'have-local-offer'],\n      setRemoteDescription: ['stable', 'have-remote-offer']\n    },\n    answer: {\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\n    }\n  }[type][action].indexOf(signalingState) !== -1;\n}\n\nfunction maybeAddCandidate(iceTransport, candidate) {\n  // Edge's internal representation adds some fields therefore\n  // not all field are taken into account.\n  var alreadyAdded = iceTransport.getRemoteCandidates()\n      .find(function(remoteCandidate) {\n        return candidate.foundation === remoteCandidate.foundation &&\n            candidate.ip === remoteCandidate.ip &&\n            candidate.port === remoteCandidate.port &&\n            candidate.priority === remoteCandidate.priority &&\n            candidate.protocol === remoteCandidate.protocol &&\n            candidate.type === remoteCandidate.type;\n      });\n  if (!alreadyAdded) {\n    iceTransport.addRemoteCandidate(candidate);\n  }\n  return !alreadyAdded;\n}\n\n\nfunction makeError(name, description) {\n  var e = new Error(description);\n  e.name = name;\n  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names\n  e.code = {\n    NotSupportedError: 9,\n    InvalidStateError: 11,\n    InvalidAccessError: 15,\n    TypeError: undefined,\n    OperationError: undefined\n  }[name];\n  return e;\n}\n\nmodule.exports = function(window, edgeVersion) {\n  // https://w3c.github.io/mediacapture-main/#mediastream\n  // Helper function to add the track to the stream and\n  // dispatch the event ourselves.\n  function addTrackToStreamAndFireEvent(track, stream) {\n    stream.addTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',\n        {track: track}));\n  }\n\n  function removeTrackFromStreamAndFireEvent(track, stream) {\n    stream.removeTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',\n        {track: track}));\n  }\n\n  function fireAddTrack(pc, track, receiver, streams) {\n    var trackEvent = new Event('track');\n    trackEvent.track = track;\n    trackEvent.receiver = receiver;\n    trackEvent.transceiver = {receiver: receiver};\n    trackEvent.streams = streams;\n    window.setTimeout(function() {\n      pc._dispatchEvent('track', trackEvent);\n    });\n  }\n\n  var RTCPeerConnection = function(config) {\n    var pc = this;\n\n    var _eventTarget = document.createDocumentFragment();\n    ['addEventListener', 'removeEventListener', 'dispatchEvent']\n        .forEach(function(method) {\n          pc[method] = _eventTarget[method].bind(_eventTarget);\n        });\n\n    this.canTrickleIceCandidates = null;\n\n    this.needNegotiation = false;\n\n    this.localStreams = [];\n    this.remoteStreams = [];\n\n    this._localDescription = null;\n    this._remoteDescription = null;\n\n    this.signalingState = 'stable';\n    this.iceConnectionState = 'new';\n    this.connectionState = 'new';\n    this.iceGatheringState = 'new';\n\n    config = JSON.parse(JSON.stringify(config || {}));\n\n    this.usingBundle = config.bundlePolicy === 'max-bundle';\n    if (config.rtcpMuxPolicy === 'negotiate') {\n      throw(makeError('NotSupportedError',\n          'rtcpMuxPolicy \\'negotiate\\' is not supported'));\n    } else if (!config.rtcpMuxPolicy) {\n      config.rtcpMuxPolicy = 'require';\n    }\n\n    switch (config.iceTransportPolicy) {\n      case 'all':\n      case 'relay':\n        break;\n      default:\n        config.iceTransportPolicy = 'all';\n        break;\n    }\n\n    switch (config.bundlePolicy) {\n      case 'balanced':\n      case 'max-compat':\n      case 'max-bundle':\n        break;\n      default:\n        config.bundlePolicy = 'balanced';\n        break;\n    }\n\n    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);\n\n    this._iceGatherers = [];\n    if (config.iceCandidatePoolSize) {\n      for (var i = config.iceCandidatePoolSize; i > 0; i--) {\n        this._iceGatherers.push(new window.RTCIceGatherer({\n          iceServers: config.iceServers,\n          gatherPolicy: config.iceTransportPolicy\n        }));\n      }\n    } else {\n      config.iceCandidatePoolSize = 0;\n    }\n\n    this._config = config;\n\n    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n    // everything that is needed to describe a SDP m-line.\n    this.transceivers = [];\n\n    this._sdpSessionId = SDPUtils.generateSessionId();\n    this._sdpSessionVersion = 0;\n\n    this._dtlsRole = undefined; // role for a=setup to use in answers.\n\n    this._isClosed = false;\n  };\n\n  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {\n    configurable: true,\n    get: function() {\n      return this._localDescription;\n    }\n  });\n  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {\n    configurable: true,\n    get: function() {\n      return this._remoteDescription;\n    }\n  });\n\n  // set up event handlers on prototype\n  RTCPeerConnection.prototype.onicecandidate = null;\n  RTCPeerConnection.prototype.onaddstream = null;\n  RTCPeerConnection.prototype.ontrack = null;\n  RTCPeerConnection.prototype.onremovestream = null;\n  RTCPeerConnection.prototype.onsignalingstatechange = null;\n  RTCPeerConnection.prototype.oniceconnectionstatechange = null;\n  RTCPeerConnection.prototype.onconnectionstatechange = null;\n  RTCPeerConnection.prototype.onicegatheringstatechange = null;\n  RTCPeerConnection.prototype.onnegotiationneeded = null;\n  RTCPeerConnection.prototype.ondatachannel = null;\n\n  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {\n    if (this._isClosed) {\n      return;\n    }\n    this.dispatchEvent(event);\n    if (typeof this['on' + name] === 'function') {\n      this['on' + name](event);\n    }\n  };\n\n  RTCPeerConnection.prototype._emitGatheringStateChange = function() {\n    var event = new Event('icegatheringstatechange');\n    this._dispatchEvent('icegatheringstatechange', event);\n  };\n\n  RTCPeerConnection.prototype.getConfiguration = function() {\n    return this._config;\n  };\n\n  RTCPeerConnection.prototype.getLocalStreams = function() {\n    return this.localStreams;\n  };\n\n  RTCPeerConnection.prototype.getRemoteStreams = function() {\n    return this.remoteStreams;\n  };\n\n  // internal helper to create a transceiver object.\n  // (which is not yet the same as the WebRTC 1.0 transceiver)\n  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {\n    var hasBundleTransport = this.transceivers.length > 0;\n    var transceiver = {\n      track: null,\n      iceGatherer: null,\n      iceTransport: null,\n      dtlsTransport: null,\n      localCapabilities: null,\n      remoteCapabilities: null,\n      rtpSender: null,\n      rtpReceiver: null,\n      kind: kind,\n      mid: null,\n      sendEncodingParameters: null,\n      recvEncodingParameters: null,\n      stream: null,\n      associatedRemoteMediaStreams: [],\n      wantReceive: true\n    };\n    if (this.usingBundle && hasBundleTransport) {\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\n    } else {\n      var transports = this._createIceAndDtlsTransports();\n      transceiver.iceTransport = transports.iceTransport;\n      transceiver.dtlsTransport = transports.dtlsTransport;\n    }\n    if (!doNotAdd) {\n      this.transceivers.push(transceiver);\n    }\n    return transceiver;\n  };\n\n  RTCPeerConnection.prototype.addTrack = function(track, stream) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call addTrack on a closed peerconnection.');\n    }\n\n    var alreadyExists = this.transceivers.find(function(s) {\n      return s.track === track;\n    });\n\n    if (alreadyExists) {\n      throw makeError('InvalidAccessError', 'Track already exists.');\n    }\n\n    var transceiver;\n    for (var i = 0; i < this.transceivers.length; i++) {\n      if (!this.transceivers[i].track &&\n          this.transceivers[i].kind === track.kind) {\n        transceiver = this.transceivers[i];\n      }\n    }\n    if (!transceiver) {\n      transceiver = this._createTransceiver(track.kind);\n    }\n\n    this._maybeFireNegotiationNeeded();\n\n    if (this.localStreams.indexOf(stream) === -1) {\n      this.localStreams.push(stream);\n    }\n\n    transceiver.track = track;\n    transceiver.stream = stream;\n    transceiver.rtpSender = new window.RTCRtpSender(track,\n        transceiver.dtlsTransport);\n    return transceiver.rtpSender;\n  };\n\n  RTCPeerConnection.prototype.addStream = function(stream) {\n    var pc = this;\n    if (edgeVersion >= 15025) {\n      stream.getTracks().forEach(function(track) {\n        pc.addTrack(track, stream);\n      });\n    } else {\n      // Clone is necessary for local demos mostly, attaching directly\n      // to two different senders does not work (build 10547).\n      // Fixed in 15025 (or earlier)\n      var clonedStream = stream.clone();\n      stream.getTracks().forEach(function(track, idx) {\n        var clonedTrack = clonedStream.getTracks()[idx];\n        track.addEventListener('enabled', function(event) {\n          clonedTrack.enabled = event.enabled;\n        });\n      });\n      clonedStream.getTracks().forEach(function(track) {\n        pc.addTrack(track, clonedStream);\n      });\n    }\n  };\n\n  RTCPeerConnection.prototype.removeTrack = function(sender) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call removeTrack on a closed peerconnection.');\n    }\n\n    if (!(sender instanceof window.RTCRtpSender)) {\n      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +\n          'does not implement interface RTCRtpSender.');\n    }\n\n    var transceiver = this.transceivers.find(function(t) {\n      return t.rtpSender === sender;\n    });\n\n    if (!transceiver) {\n      throw makeError('InvalidAccessError',\n          'Sender was not created by this connection.');\n    }\n    var stream = transceiver.stream;\n\n    transceiver.rtpSender.stop();\n    transceiver.rtpSender = null;\n    transceiver.track = null;\n    transceiver.stream = null;\n\n    // remove the stream from the set of local streams\n    var localStreams = this.transceivers.map(function(t) {\n      return t.stream;\n    });\n    if (localStreams.indexOf(stream) === -1 &&\n        this.localStreams.indexOf(stream) > -1) {\n      this.localStreams.splice(this.localStreams.indexOf(stream), 1);\n    }\n\n    this._maybeFireNegotiationNeeded();\n  };\n\n  RTCPeerConnection.prototype.removeStream = function(stream) {\n    var pc = this;\n    stream.getTracks().forEach(function(track) {\n      var sender = pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n      if (sender) {\n        pc.removeTrack(sender);\n      }\n    });\n  };\n\n  RTCPeerConnection.prototype.getSenders = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpSender;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpSender;\n    });\n  };\n\n  RTCPeerConnection.prototype.getReceivers = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpReceiver;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpReceiver;\n    });\n  };\n\n\n  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,\n      usingBundle) {\n    var pc = this;\n    if (usingBundle && sdpMLineIndex > 0) {\n      return this.transceivers[0].iceGatherer;\n    } else if (this._iceGatherers.length) {\n      return this._iceGatherers.shift();\n    }\n    var iceGatherer = new window.RTCIceGatherer({\n      iceServers: this._config.iceServers,\n      gatherPolicy: this._config.iceTransportPolicy\n    });\n    Object.defineProperty(iceGatherer, 'state',\n        {value: 'new', writable: true}\n    );\n\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];\n    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\n      // polyfill since RTCIceGatherer.state is not implemented in\n      // Edge 10547 yet.\n      iceGatherer.state = end ? 'completed' : 'gathering';\n      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {\n        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);\n      }\n    };\n    iceGatherer.addEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    return iceGatherer;\n  };\n\n  // start gathering from an RTCIceGatherer.\n  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {\n    var pc = this;\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer.onlocalcandidate) {\n      return;\n    }\n    var bufferedCandidateEvents =\n      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;\n    iceGatherer.removeEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    iceGatherer.onlocalcandidate = function(evt) {\n      if (pc.usingBundle && sdpMLineIndex > 0) {\n        // if we know that we use bundle we can drop candidates with\n        // dpMLineIndex > 0. If we don't do this then our state gets\n        // confused since we dispose the extra ice gatherer.\n        return;\n      }\n      var event = new Event('icecandidate');\n      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\n\n      var cand = evt.candidate;\n      // Edge emits an empty object for RTCIceCandidateComplete\n      var end = !cand || Object.keys(cand).length === 0;\n      if (end) {\n        // polyfill since RTCIceGatherer.state is not implemented in\n        // Edge 10547 yet.\n        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {\n          iceGatherer.state = 'completed';\n        }\n      } else {\n        if (iceGatherer.state === 'new') {\n          iceGatherer.state = 'gathering';\n        }\n        // RTCIceCandidate doesn't have a component, needs to be added\n        cand.component = 1;\n        // also the usernameFragment. TODO: update SDP to take both variants.\n        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;\n\n        var serializedCandidate = SDPUtils.writeCandidate(cand);\n        event.candidate = Object.assign(event.candidate,\n            SDPUtils.parseCandidate(serializedCandidate));\n\n        event.candidate.candidate = serializedCandidate;\n        event.candidate.toJSON = function() {\n          return {\n            candidate: event.candidate.candidate,\n            sdpMid: event.candidate.sdpMid,\n            sdpMLineIndex: event.candidate.sdpMLineIndex,\n            usernameFragment: event.candidate.usernameFragment\n          };\n        };\n      }\n\n      // update local description.\n      var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);\n      if (!end) {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=' + event.candidate.candidate + '\\r\\n';\n      } else {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=end-of-candidates\\r\\n';\n      }\n      pc._localDescription.sdp =\n          SDPUtils.getDescription(pc._localDescription.sdp) +\n          sections.join('');\n      var complete = pc.transceivers.every(function(transceiver) {\n        return transceiver.iceGatherer &&\n            transceiver.iceGatherer.state === 'completed';\n      });\n\n      if (pc.iceGatheringState !== 'gathering') {\n        pc.iceGatheringState = 'gathering';\n        pc._emitGatheringStateChange();\n      }\n\n      // Emit candidate. Also emit null candidate when all gatherers are\n      // complete.\n      if (!end) {\n        pc._dispatchEvent('icecandidate', event);\n      }\n      if (complete) {\n        pc._dispatchEvent('icecandidate', new Event('icecandidate'));\n        pc.iceGatheringState = 'complete';\n        pc._emitGatheringStateChange();\n      }\n    };\n\n    // emit already gathered candidates.\n    window.setTimeout(function() {\n      bufferedCandidateEvents.forEach(function(e) {\n        iceGatherer.onlocalcandidate(e);\n      });\n    }, 0);\n  };\n\n  // Create ICE transport and DTLS transport.\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {\n    var pc = this;\n    var iceTransport = new window.RTCIceTransport(null);\n    iceTransport.onicestatechange = function() {\n      pc._updateIceConnectionState();\n      pc._updateConnectionState();\n    };\n\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\n    dtlsTransport.ondtlsstatechange = function() {\n      pc._updateConnectionState();\n    };\n    dtlsTransport.onerror = function() {\n      // onerror does not set state to failed by itself.\n      Object.defineProperty(dtlsTransport, 'state',\n          {value: 'failed', writable: true});\n      pc._updateConnectionState();\n    };\n\n    return {\n      iceTransport: iceTransport,\n      dtlsTransport: dtlsTransport\n    };\n  };\n\n  // Destroy ICE gatherer, ICE transport and DTLS transport.\n  // Without triggering the callbacks.\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(\n      sdpMLineIndex) {\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer) {\n      delete iceGatherer.onlocalcandidate;\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\n    }\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\n    if (iceTransport) {\n      delete iceTransport.onicestatechange;\n      delete this.transceivers[sdpMLineIndex].iceTransport;\n    }\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\n    if (dtlsTransport) {\n      delete dtlsTransport.ondtlsstatechange;\n      delete dtlsTransport.onerror;\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\n    }\n  };\n\n  // Start the RTP Sender and Receiver for a transceiver.\n  RTCPeerConnection.prototype._transceive = function(transceiver,\n      send, recv) {\n    var params = getCommonCapabilities(transceiver.localCapabilities,\n        transceiver.remoteCapabilities);\n    if (send && transceiver.rtpSender) {\n      params.encodings = transceiver.sendEncodingParameters;\n      params.rtcp = {\n        cname: SDPUtils.localCName,\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.recvEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpSender.send(params);\n    }\n    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {\n      // remove RTX field in Edge 14942\n      if (transceiver.kind === 'video'\n          && transceiver.recvEncodingParameters\n          && edgeVersion < 15019) {\n        transceiver.recvEncodingParameters.forEach(function(p) {\n          delete p.rtx;\n        });\n      }\n      if (transceiver.recvEncodingParameters.length) {\n        params.encodings = transceiver.recvEncodingParameters;\n      } else {\n        params.encodings = [{}];\n      }\n      params.rtcp = {\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.rtcpParameters.cname) {\n        params.rtcp.cname = transceiver.rtcpParameters.cname;\n      }\n      if (transceiver.sendEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpReceiver.receive(params);\n    }\n  };\n\n  RTCPeerConnection.prototype.setLocalDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setLocalDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set local ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var sections;\n    var sessionpart;\n    if (description.type === 'offer') {\n      // VERY limited support for SDP munging. Limited to:\n      // * changing the order of codecs\n      sections = SDPUtils.splitSections(description.sdp);\n      sessionpart = sections.shift();\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var caps = SDPUtils.parseRtpParameters(mediaSection);\n        pc.transceivers[sdpMLineIndex].localCapabilities = caps;\n      });\n\n      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n        pc._gather(transceiver.mid, sdpMLineIndex);\n      });\n    } else if (description.type === 'answer') {\n      sections = SDPUtils.splitSections(pc._remoteDescription.sdp);\n      sessionpart = sections.shift();\n      var isIceLite = SDPUtils.matchPrefix(sessionpart,\n          'a=ice-lite').length > 0;\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        var iceGatherer = transceiver.iceGatherer;\n        var iceTransport = transceiver.iceTransport;\n        var dtlsTransport = transceiver.dtlsTransport;\n        var localCapabilities = transceiver.localCapabilities;\n        var remoteCapabilities = transceiver.remoteCapabilities;\n\n        // treat bundle-only as not-rejected.\n        var rejected = SDPUtils.isRejected(mediaSection) &&\n            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n\n        if (!rejected && !transceiver.rejected) {\n          var remoteIceParameters = SDPUtils.getIceParameters(\n              mediaSection, sessionpart);\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(\n              mediaSection, sessionpart);\n          if (isIceLite) {\n            remoteDtlsParameters.role = 'server';\n          }\n\n          if (!pc.usingBundle || sdpMLineIndex === 0) {\n            pc._gather(transceiver.mid, sdpMLineIndex);\n            if (iceTransport.state === 'new') {\n              iceTransport.start(iceGatherer, remoteIceParameters,\n                  isIceLite ? 'controlling' : 'controlled');\n            }\n            if (dtlsTransport.state === 'new') {\n              dtlsTransport.start(remoteDtlsParameters);\n            }\n          }\n\n          // Calculate intersection of capabilities.\n          var params = getCommonCapabilities(localCapabilities,\n              remoteCapabilities);\n\n          // Start the RTCRtpSender. The RTCRtpReceiver for this\n          // transceiver has already been started in setRemoteDescription.\n          pc._transceive(transceiver,\n              params.codecs.length > 0,\n              false);\n        }\n      });\n    }\n\n    pc._localDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-local-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.setRemoteDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setRemoteDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set remote ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var streams = {};\n    pc.remoteStreams.forEach(function(stream) {\n      streams[stream.id] = stream;\n    });\n    var receiverList = [];\n    var sections = SDPUtils.splitSections(description.sdp);\n    var sessionpart = sections.shift();\n    var isIceLite = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-lite').length > 0;\n    var usingBundle = SDPUtils.matchPrefix(sessionpart,\n        'a=group:BUNDLE ').length > 0;\n    pc.usingBundle = usingBundle;\n    var iceOptions = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-options:')[0];\n    if (iceOptions) {\n      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')\n          .indexOf('trickle') >= 0;\n    } else {\n      pc.canTrickleIceCandidates = false;\n    }\n\n    sections.forEach(function(mediaSection, sdpMLineIndex) {\n      var lines = SDPUtils.splitLines(mediaSection);\n      var kind = SDPUtils.getKind(mediaSection);\n      // treat bundle-only as not-rejected.\n      var rejected = SDPUtils.isRejected(mediaSection) &&\n          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n      var protocol = lines[0].substr(2).split(' ')[2];\n\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\n\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\n\n      // Reject datachannels which are not implemented yet.\n      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||\n          protocol === 'UDP/DTLS/SCTP'))) {\n        // TODO: this is dangerous in the case where a non-rejected m-line\n        //     becomes rejected.\n        pc.transceivers[sdpMLineIndex] = {\n          mid: mid,\n          kind: kind,\n          protocol: protocol,\n          rejected: true\n        };\n        return;\n      }\n\n      if (!rejected && pc.transceivers[sdpMLineIndex] &&\n          pc.transceivers[sdpMLineIndex].rejected) {\n        // recycle a rejected transceiver.\n        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);\n      }\n\n      var transceiver;\n      var iceGatherer;\n      var iceTransport;\n      var dtlsTransport;\n      var rtpReceiver;\n      var sendEncodingParameters;\n      var recvEncodingParameters;\n      var localCapabilities;\n\n      var track;\n      // FIXME: ensure the mediaSection has rtcp-mux set.\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n      var remoteIceParameters;\n      var remoteDtlsParameters;\n      if (!rejected) {\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters.role = 'client';\n      }\n      recvEncodingParameters =\n          SDPUtils.parseRtpEncodingParameters(mediaSection);\n\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\n\n      var isComplete = SDPUtils.matchPrefix(mediaSection,\n          'a=end-of-candidates', sessionpart).length > 0;\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n          .map(function(cand) {\n            return SDPUtils.parseCandidate(cand);\n          })\n          .filter(function(cand) {\n            return cand.component === 1;\n          });\n\n      // Check if we can use BUNDLE and dispose transports.\n      if ((description.type === 'offer' || description.type === 'answer') &&\n          !rejected && usingBundle && sdpMLineIndex > 0 &&\n          pc.transceivers[sdpMLineIndex]) {\n        pc._disposeIceAndDtlsTransports(sdpMLineIndex);\n        pc.transceivers[sdpMLineIndex].iceGatherer =\n            pc.transceivers[0].iceGatherer;\n        pc.transceivers[sdpMLineIndex].iceTransport =\n            pc.transceivers[0].iceTransport;\n        pc.transceivers[sdpMLineIndex].dtlsTransport =\n            pc.transceivers[0].dtlsTransport;\n        if (pc.transceivers[sdpMLineIndex].rtpSender) {\n          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {\n          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n      }\n      if (description.type === 'offer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex] ||\n            pc._createTransceiver(kind);\n        transceiver.mid = mid;\n\n        if (!transceiver.iceGatherer) {\n          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n              usingBundle);\n        }\n\n        if (cands.length && transceiver.iceTransport.state === 'new') {\n          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {\n            transceiver.iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);\n\n        // filter RTX until additional stuff needed for RTX is implemented\n        // in adapter.js\n        if (edgeVersion < 15019) {\n          localCapabilities.codecs = localCapabilities.codecs.filter(\n              function(codec) {\n                return codec.name !== 'rtx';\n              });\n        }\n\n        sendEncodingParameters = transceiver.sendEncodingParameters || [{\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\n        }];\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        var isNewTrack = false;\n        if (direction === 'sendrecv' || direction === 'sendonly') {\n          isNewTrack = !transceiver.rtpReceiver;\n          rtpReceiver = transceiver.rtpReceiver ||\n              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\n\n          if (isNewTrack) {\n            var stream;\n            track = rtpReceiver.track;\n            // FIXME: does not work with Plan B.\n            if (remoteMsid && remoteMsid.stream === '-') {\n              // no-op. a stream id of '-' means: no associated stream.\n            } else if (remoteMsid) {\n              if (!streams[remoteMsid.stream]) {\n                streams[remoteMsid.stream] = new window.MediaStream();\n                Object.defineProperty(streams[remoteMsid.stream], 'id', {\n                  get: function() {\n                    return remoteMsid.stream;\n                  }\n                });\n              }\n              Object.defineProperty(track, 'id', {\n                get: function() {\n                  return remoteMsid.track;\n                }\n              });\n              stream = streams[remoteMsid.stream];\n            } else {\n              if (!streams.default) {\n                streams.default = new window.MediaStream();\n              }\n              stream = streams.default;\n            }\n            if (stream) {\n              addTrackToStreamAndFireEvent(track, stream);\n              transceiver.associatedRemoteMediaStreams.push(stream);\n            }\n            receiverList.push([track, rtpReceiver, stream]);\n          }\n        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {\n          transceiver.associatedRemoteMediaStreams.forEach(function(s) {\n            var nativeTrack = s.getTracks().find(function(t) {\n              return t.id === transceiver.rtpReceiver.track.id;\n            });\n            if (nativeTrack) {\n              removeTrackFromStreamAndFireEvent(nativeTrack, s);\n            }\n          });\n          transceiver.associatedRemoteMediaStreams = [];\n        }\n\n        transceiver.localCapabilities = localCapabilities;\n        transceiver.remoteCapabilities = remoteCapabilities;\n        transceiver.rtpReceiver = rtpReceiver;\n        transceiver.rtcpParameters = rtcpParameters;\n        transceiver.sendEncodingParameters = sendEncodingParameters;\n        transceiver.recvEncodingParameters = recvEncodingParameters;\n\n        // Start the RTCRtpReceiver now. The RTPSender is started in\n        // setLocalDescription.\n        pc._transceive(pc.transceivers[sdpMLineIndex],\n            false,\n            isNewTrack);\n      } else if (description.type === 'answer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex];\n        iceGatherer = transceiver.iceGatherer;\n        iceTransport = transceiver.iceTransport;\n        dtlsTransport = transceiver.dtlsTransport;\n        rtpReceiver = transceiver.rtpReceiver;\n        sendEncodingParameters = transceiver.sendEncodingParameters;\n        localCapabilities = transceiver.localCapabilities;\n\n        pc.transceivers[sdpMLineIndex].recvEncodingParameters =\n            recvEncodingParameters;\n        pc.transceivers[sdpMLineIndex].remoteCapabilities =\n            remoteCapabilities;\n        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\n\n        if (cands.length && iceTransport.state === 'new') {\n          if ((isIceLite || isComplete) &&\n              (!usingBundle || sdpMLineIndex === 0)) {\n            iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        if (!usingBundle || sdpMLineIndex === 0) {\n          if (iceTransport.state === 'new') {\n            iceTransport.start(iceGatherer, remoteIceParameters,\n                'controlling');\n          }\n          if (dtlsTransport.state === 'new') {\n            dtlsTransport.start(remoteDtlsParameters);\n          }\n        }\n\n        // If the offer contained RTX but the answer did not,\n        // remove RTX from sendEncodingParameters.\n        var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n        var hasRtx = commonCapabilities.codecs.filter(function(c) {\n          return c.name.toLowerCase() === 'rtx';\n        }).length;\n        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n          delete transceiver.sendEncodingParameters[0].rtx;\n        }\n\n        pc._transceive(transceiver,\n            direction === 'sendrecv' || direction === 'recvonly',\n            direction === 'sendrecv' || direction === 'sendonly');\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        if (rtpReceiver &&\n            (direction === 'sendrecv' || direction === 'sendonly')) {\n          track = rtpReceiver.track;\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams.default);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        } else {\n          // FIXME: actually the receiver should be created later.\n          delete transceiver.rtpReceiver;\n        }\n      }\n    });\n\n    if (pc._dtlsRole === undefined) {\n      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';\n    }\n\n    pc._remoteDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-remote-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n    Object.keys(streams).forEach(function(sid) {\n      var stream = streams[sid];\n      if (stream.getTracks().length) {\n        if (pc.remoteStreams.indexOf(stream) === -1) {\n          pc.remoteStreams.push(stream);\n          var event = new Event('addstream');\n          event.stream = stream;\n          window.setTimeout(function() {\n            pc._dispatchEvent('addstream', event);\n          });\n        }\n\n        receiverList.forEach(function(item) {\n          var track = item[0];\n          var receiver = item[1];\n          if (stream.id !== item[2].id) {\n            return;\n          }\n          fireAddTrack(pc, track, receiver, [stream]);\n        });\n      }\n    });\n    receiverList.forEach(function(item) {\n      if (item[2]) {\n        return;\n      }\n      fireAddTrack(pc, item[0], item[1], []);\n    });\n\n    // check whether addIceCandidate({}) was called within four seconds after\n    // setRemoteDescription.\n    window.setTimeout(function() {\n      if (!(pc && pc.transceivers)) {\n        return;\n      }\n      pc.transceivers.forEach(function(transceiver) {\n        if (transceiver.iceTransport &&\n            transceiver.iceTransport.state === 'new' &&\n            transceiver.iceTransport.getRemoteCandidates().length > 0) {\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' +\n              'an end-of-candidates notification');\n          transceiver.iceTransport.addRemoteCandidate({});\n        }\n      });\n    }, 4000);\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.close = function() {\n    this.transceivers.forEach(function(transceiver) {\n      /* not yet\n      if (transceiver.iceGatherer) {\n        transceiver.iceGatherer.close();\n      }\n      */\n      if (transceiver.iceTransport) {\n        transceiver.iceTransport.stop();\n      }\n      if (transceiver.dtlsTransport) {\n        transceiver.dtlsTransport.stop();\n      }\n      if (transceiver.rtpSender) {\n        transceiver.rtpSender.stop();\n      }\n      if (transceiver.rtpReceiver) {\n        transceiver.rtpReceiver.stop();\n      }\n    });\n    // FIXME: clean up tracks, local streams, remote streams, etc\n    this._isClosed = true;\n    this._updateSignalingState('closed');\n  };\n\n  // Update the signaling state.\n  RTCPeerConnection.prototype._updateSignalingState = function(newState) {\n    this.signalingState = newState;\n    var event = new Event('signalingstatechange');\n    this._dispatchEvent('signalingstatechange', event);\n  };\n\n  // Determine whether to fire the negotiationneeded event.\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {\n    var pc = this;\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\n      return;\n    }\n    this.needNegotiation = true;\n    window.setTimeout(function() {\n      if (pc.needNegotiation) {\n        pc.needNegotiation = false;\n        var event = new Event('negotiationneeded');\n        pc._dispatchEvent('negotiationneeded', event);\n      }\n    }, 0);\n  };\n\n  // Update the ice connection state.\n  RTCPeerConnection.prototype._updateIceConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      checking: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      if (transceiver.iceTransport && !transceiver.rejected) {\n        states[transceiver.iceTransport.state]++;\n      }\n    });\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.checking > 0) {\n      newState = 'checking';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    } else if (states.completed > 0) {\n      newState = 'completed';\n    }\n\n    if (newState !== this.iceConnectionState) {\n      this.iceConnectionState = newState;\n      var event = new Event('iceconnectionstatechange');\n      this._dispatchEvent('iceconnectionstatechange', event);\n    }\n  };\n\n  // Update the connection state.\n  RTCPeerConnection.prototype._updateConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      connecting: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      if (transceiver.iceTransport && transceiver.dtlsTransport &&\n          !transceiver.rejected) {\n        states[transceiver.iceTransport.state]++;\n        states[transceiver.dtlsTransport.state]++;\n      }\n    });\n    // ICETransport.completed and connected are the same for this purpose.\n    states.connected += states.completed;\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.connecting > 0) {\n      newState = 'connecting';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    }\n\n    if (newState !== this.connectionState) {\n      this.connectionState = newState;\n      var event = new Event('connectionstatechange');\n      this._dispatchEvent('connectionstatechange', event);\n    }\n  };\n\n  RTCPeerConnection.prototype.createOffer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createOffer after close'));\n    }\n\n    var numAudioTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'audio';\n    }).length;\n    var numVideoTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'video';\n    }).length;\n\n    // Determine number of audio and video tracks we need to send/recv.\n    var offerOptions = arguments[0];\n    if (offerOptions) {\n      // Reject Chrome legacy constraints.\n      if (offerOptions.mandatory || offerOptions.optional) {\n        throw new TypeError(\n            'Legacy mandatory/optional constraints not supported.');\n      }\n      if (offerOptions.offerToReceiveAudio !== undefined) {\n        if (offerOptions.offerToReceiveAudio === true) {\n          numAudioTracks = 1;\n        } else if (offerOptions.offerToReceiveAudio === false) {\n          numAudioTracks = 0;\n        } else {\n          numAudioTracks = offerOptions.offerToReceiveAudio;\n        }\n      }\n      if (offerOptions.offerToReceiveVideo !== undefined) {\n        if (offerOptions.offerToReceiveVideo === true) {\n          numVideoTracks = 1;\n        } else if (offerOptions.offerToReceiveVideo === false) {\n          numVideoTracks = 0;\n        } else {\n          numVideoTracks = offerOptions.offerToReceiveVideo;\n        }\n      }\n    }\n\n    pc.transceivers.forEach(function(transceiver) {\n      if (transceiver.kind === 'audio') {\n        numAudioTracks--;\n        if (numAudioTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      } else if (transceiver.kind === 'video') {\n        numVideoTracks--;\n        if (numVideoTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      }\n    });\n\n    // Create M-lines for recvonly streams.\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\n      if (numAudioTracks > 0) {\n        pc._createTransceiver('audio');\n        numAudioTracks--;\n      }\n      if (numVideoTracks > 0) {\n        pc._createTransceiver('video');\n        numVideoTracks--;\n      }\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      // For each track, create an ice gatherer, ice transport,\n      // dtls transport, potentially rtpsender and rtpreceiver.\n      var track = transceiver.track;\n      var kind = transceiver.kind;\n      var mid = transceiver.mid || SDPUtils.generateIdentifier();\n      transceiver.mid = mid;\n\n      if (!transceiver.iceGatherer) {\n        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n            pc.usingBundle);\n      }\n\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\n      // filter RTX until additional stuff needed for RTX is implemented\n      // in adapter.js\n      if (edgeVersion < 15019) {\n        localCapabilities.codecs = localCapabilities.codecs.filter(\n            function(codec) {\n              return codec.name !== 'rtx';\n            });\n      }\n      localCapabilities.codecs.forEach(function(codec) {\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\n        // by adding level-asymmetry-allowed=1\n        if (codec.name === 'H264' &&\n            codec.parameters['level-asymmetry-allowed'] === undefined) {\n          codec.parameters['level-asymmetry-allowed'] = '1';\n        }\n\n        // for subsequent offers, we might have to re-use the payload\n        // type of the last offer.\n        if (transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.codecs) {\n          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {\n            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&\n                codec.clockRate === remoteCodec.clockRate) {\n              codec.preferredPayloadType = remoteCodec.payloadType;\n            }\n          });\n        }\n      });\n      localCapabilities.headerExtensions.forEach(function(hdrExt) {\n        var remoteExtensions = transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.headerExtensions || [];\n        remoteExtensions.forEach(function(rHdrExt) {\n          if (hdrExt.uri === rHdrExt.uri) {\n            hdrExt.id = rHdrExt.id;\n          }\n        });\n      });\n\n      // generate an ssrc now, to be used later in rtpSender.send\n      var sendEncodingParameters = transceiver.sendEncodingParameters || [{\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\n      }];\n      if (track) {\n        // add RTX\n        if (edgeVersion >= 15019 && kind === 'video' &&\n            !sendEncodingParameters[0].rtx) {\n          sendEncodingParameters[0].rtx = {\n            ssrc: sendEncodingParameters[0].ssrc + 1\n          };\n        }\n      }\n\n      if (transceiver.wantReceive) {\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(\n            transceiver.dtlsTransport, kind);\n      }\n\n      transceiver.localCapabilities = localCapabilities;\n      transceiver.sendEncodingParameters = sendEncodingParameters;\n    });\n\n    // always offer BUNDLE and dispose on return if not supported.\n    if (pc._config.bundlePolicy !== 'max-compat') {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,\n          'offer', transceiver.stream, pc._dtlsRole);\n      sdp += 'a=rtcp-rsize\\r\\n';\n\n      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&\n          (sdpMLineIndex === 0 || !pc.usingBundle)) {\n        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {\n          cand.component = 1;\n          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\\r\\n';\n        });\n\n        if (transceiver.iceGatherer.state === 'completed') {\n          sdp += 'a=end-of-candidates\\r\\n';\n        }\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'offer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.createAnswer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer after close'));\n    }\n\n    if (!(pc.signalingState === 'have-remote-offer' ||\n        pc.signalingState === 'have-local-pranswer')) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer in signalingState ' + pc.signalingState));\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    if (pc.usingBundle) {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    var mediaSectionsInOffer = SDPUtils.getMediaSections(\n        pc._remoteDescription.sdp).length;\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {\n        return;\n      }\n      if (transceiver.rejected) {\n        if (transceiver.kind === 'application') {\n          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt\n            sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n';\n          } else {\n            sdp += 'm=application 0 ' + transceiver.protocol +\n                ' webrtc-datachannel\\r\\n';\n          }\n        } else if (transceiver.kind === 'audio') {\n          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\n' +\n              'a=rtpmap:0 PCMU/8000\\r\\n';\n        } else if (transceiver.kind === 'video') {\n          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\\r\\n' +\n              'a=rtpmap:120 VP8/90000\\r\\n';\n        }\n        sdp += 'c=IN IP4 0.0.0.0\\r\\n' +\n            'a=inactive\\r\\n' +\n            'a=mid:' + transceiver.mid + '\\r\\n';\n        return;\n      }\n\n      // FIXME: look at direction.\n      if (transceiver.stream) {\n        var localTrack;\n        if (transceiver.kind === 'audio') {\n          localTrack = transceiver.stream.getAudioTracks()[0];\n        } else if (transceiver.kind === 'video') {\n          localTrack = transceiver.stream.getVideoTracks()[0];\n        }\n        if (localTrack) {\n          // add RTX\n          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&\n              !transceiver.sendEncodingParameters[0].rtx) {\n            transceiver.sendEncodingParameters[0].rtx = {\n              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1\n            };\n          }\n        }\n      }\n\n      // Calculate intersection of capabilities.\n      var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n      var hasRtx = commonCapabilities.codecs.filter(function(c) {\n        return c.name.toLowerCase() === 'rtx';\n      }).length;\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n        delete transceiver.sendEncodingParameters[0].rtx;\n      }\n\n      sdp += writeMediaSection(transceiver, commonCapabilities,\n          'answer', transceiver.stream, pc._dtlsRole);\n      if (transceiver.rtcpParameters &&\n          transceiver.rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'answer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\n    var pc = this;\n    var sections;\n    if (candidate && !(candidate.sdpMLineIndex !== undefined ||\n        candidate.sdpMid)) {\n      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));\n    }\n\n    // TODO: needs to go into ops queue.\n    return new Promise(function(resolve, reject) {\n      if (!pc._remoteDescription) {\n        return reject(makeError('InvalidStateError',\n            'Can not add ICE candidate without a remote description'));\n      } else if (!candidate || candidate.candidate === '') {\n        for (var j = 0; j < pc.transceivers.length; j++) {\n          if (pc.transceivers[j].rejected) {\n            continue;\n          }\n          pc.transceivers[j].iceTransport.addRemoteCandidate({});\n          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);\n          sections[j] += 'a=end-of-candidates\\r\\n';\n          pc._remoteDescription.sdp =\n              SDPUtils.getDescription(pc._remoteDescription.sdp) +\n              sections.join('');\n          if (pc.usingBundle) {\n            break;\n          }\n        }\n      } else {\n        var sdpMLineIndex = candidate.sdpMLineIndex;\n        if (candidate.sdpMid) {\n          for (var i = 0; i < pc.transceivers.length; i++) {\n            if (pc.transceivers[i].mid === candidate.sdpMid) {\n              sdpMLineIndex = i;\n              break;\n            }\n          }\n        }\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        if (transceiver) {\n          if (transceiver.rejected) {\n            return resolve();\n          }\n          var cand = Object.keys(candidate.candidate).length > 0 ?\n              SDPUtils.parseCandidate(candidate.candidate) : {};\n          // Ignore Chrome's invalid candidates since Edge does not like them.\n          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n            return resolve();\n          }\n          // Ignore RTCP candidates, we assume RTCP-MUX.\n          if (cand.component && cand.component !== 1) {\n            return resolve();\n          }\n          // when using bundle, avoid adding candidates to the wrong\n          // ice transport. And avoid adding candidates added in the SDP.\n          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&\n              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {\n            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {\n              return reject(makeError('OperationError',\n                  'Can not add ICE candidate'));\n            }\n          }\n\n          // update the remoteDescription.\n          var candidateString = candidate.candidate.trim();\n          if (candidateString.indexOf('a=') === 0) {\n            candidateString = candidateString.substr(2);\n          }\n          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);\n          sections[sdpMLineIndex] += 'a=' +\n              (cand.type ? candidateString : 'end-of-candidates')\n              + '\\r\\n';\n          pc._remoteDescription.sdp =\n              SDPUtils.getDescription(pc._remoteDescription.sdp) +\n              sections.join('');\n        } else {\n          return reject(makeError('OperationError',\n              'Can not add ICE candidate'));\n        }\n      }\n      resolve();\n    });\n  };\n\n  RTCPeerConnection.prototype.getStats = function(selector) {\n    if (selector && selector instanceof window.MediaStreamTrack) {\n      var senderOrReceiver = null;\n      this.transceivers.forEach(function(transceiver) {\n        if (transceiver.rtpSender &&\n            transceiver.rtpSender.track === selector) {\n          senderOrReceiver = transceiver.rtpSender;\n        } else if (transceiver.rtpReceiver &&\n            transceiver.rtpReceiver.track === selector) {\n          senderOrReceiver = transceiver.rtpReceiver;\n        }\n      });\n      if (!senderOrReceiver) {\n        throw makeError('InvalidAccessError', 'Invalid selector.');\n      }\n      return senderOrReceiver.getStats();\n    }\n\n    var promises = [];\n    this.transceivers.forEach(function(transceiver) {\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\n          'dtlsTransport'].forEach(function(method) {\n            if (transceiver[method]) {\n              promises.push(transceiver[method].getStats());\n            }\n          });\n    });\n    return Promise.all(promises).then(function(allStats) {\n      var results = new Map();\n      allStats.forEach(function(stats) {\n        stats.forEach(function(stat) {\n          results.set(stat.id, stat);\n        });\n      });\n      return results;\n    });\n  };\n\n  // fix low-level stat names and return Map instead of object.\n  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',\n    'RTCIceTransport', 'RTCDtlsTransport'];\n  ortcObjects.forEach(function(ortcObjectName) {\n    var obj = window[ortcObjectName];\n    if (obj && obj.prototype && obj.prototype.getStats) {\n      var nativeGetstats = obj.prototype.getStats;\n      obj.prototype.getStats = function() {\n        return nativeGetstats.apply(this)\n        .then(function(nativeStats) {\n          var mapStats = new Map();\n          Object.keys(nativeStats).forEach(function(id) {\n            nativeStats[id].type = fixStatsType(nativeStats[id]);\n            mapStats.set(id, nativeStats[id]);\n          });\n          return mapStats;\n        });\n      };\n    }\n  });\n\n  // legacy callback shims. Should be moved to adapter.js some days.\n  var methods = ['createOffer', 'createAnswer'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[0] === 'function' ||\n          typeof args[1] === 'function') { // legacy\n        return nativeMethod.apply(this, [arguments[2]])\n        .then(function(description) {\n          if (typeof args[0] === 'function') {\n            args[0].apply(null, [description]);\n          }\n        }, function(error) {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function' ||\n          typeof args[2] === 'function') { // legacy\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        }, function(error) {\n          if (typeof args[2] === 'function') {\n            args[2].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  // getStats is special. It doesn't have a spec legacy method yet we support\n  // getStats(something, cb) without error callbacks.\n  ['getStats'].forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function') {\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  return RTCPeerConnection;\n};\n","/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n /* eslint-env node */\r\n'use strict';\r\n\r\n// Expose public methods.\r\nmodule.exports = function(window) {\r\n  var navigator = window && window.navigator;\r\n\r\n  var shimError_ = function(e) {\r\n    return {\r\n      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,\r\n      message: e.message,\r\n      constraint: e.constraint,\r\n      toString: function() {\r\n        return this.name;\r\n      }\r\n    };\r\n  };\r\n\r\n  // getUserMedia error shim.\r\n  var origGetUserMedia = navigator.mediaDevices.getUserMedia.\r\n      bind(navigator.mediaDevices);\r\n  navigator.mediaDevices.getUserMedia = function(c) {\r\n    return origGetUserMedia(c).catch(function(e) {\r\n      return Promise.reject(shimError_(e));\r\n    });\r\n  };\r\n};\r\n","/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n /* eslint-env node */\r\n'use strict';\r\n\r\nvar utils = require('../utils');\r\n\r\nvar firefoxShim = {\r\n  shimOnTrack: function(window) {\r\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\r\n        window.RTCPeerConnection.prototype)) {\r\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\r\n        get: function() {\r\n          return this._ontrack;\r\n        },\r\n        set: function(f) {\r\n          if (this._ontrack) {\r\n            this.removeEventListener('track', this._ontrack);\r\n            this.removeEventListener('addstream', this._ontrackpoly);\r\n          }\r\n          this.addEventListener('track', this._ontrack = f);\r\n          this.addEventListener('addstream', this._ontrackpoly = function(e) {\r\n            e.stream.getTracks().forEach(function(track) {\r\n              var event = new Event('track');\r\n              event.track = track;\r\n              event.receiver = {track: track};\r\n              event.transceiver = {receiver: event.receiver};\r\n              event.streams = [e.stream];\r\n              this.dispatchEvent(event);\r\n            }.bind(this));\r\n          }.bind(this));\r\n        }\r\n      });\r\n    }\r\n    if (typeof window === 'object' && window.RTCTrackEvent &&\r\n        ('receiver' in window.RTCTrackEvent.prototype) &&\r\n        !('transceiver' in window.RTCTrackEvent.prototype)) {\r\n      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\r\n        get: function() {\r\n          return {receiver: this.receiver};\r\n        }\r\n      });\r\n    }\r\n  },\r\n\r\n  shimSourceObject: function(window) {\r\n    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.\r\n    if (typeof window === 'object') {\r\n      if (window.HTMLMediaElement &&\r\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\r\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\r\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\r\n          get: function() {\r\n            return this.mozSrcObject;\r\n          },\r\n          set: function(stream) {\r\n            this.mozSrcObject = stream;\r\n          }\r\n        });\r\n      }\r\n    }\r\n  },\r\n\r\n  shimPeerConnection: function(window) {\r\n    var browserDetails = utils.detectBrowser(window);\r\n\r\n    if (typeof window !== 'object' || !(window.RTCPeerConnection ||\r\n        window.mozRTCPeerConnection)) {\r\n      return; // probably media.peerconnection.enabled=false in about:config\r\n    }\r\n    // The RTCPeerConnection object.\r\n    if (!window.RTCPeerConnection) {\r\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\r\n        if (browserDetails.version < 38) {\r\n          // .urls is not supported in FF < 38.\r\n          // create RTCIceServers with a single url.\r\n          if (pcConfig && pcConfig.iceServers) {\r\n            var newIceServers = [];\r\n            for (var i = 0; i < pcConfig.iceServers.length; i++) {\r\n              var server = pcConfig.iceServers[i];\r\n              if (server.hasOwnProperty('urls')) {\r\n                for (var j = 0; j < server.urls.length; j++) {\r\n                  var newServer = {\r\n                    url: server.urls[j]\r\n                  };\r\n                  if (server.urls[j].indexOf('turn') === 0) {\r\n                    newServer.username = server.username;\r\n                    newServer.credential = server.credential;\r\n                  }\r\n                  newIceServers.push(newServer);\r\n                }\r\n              } else {\r\n                newIceServers.push(pcConfig.iceServers[i]);\r\n              }\r\n            }\r\n            pcConfig.iceServers = newIceServers;\r\n          }\r\n        }\r\n        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);\r\n      };\r\n      window.RTCPeerConnection.prototype =\r\n          window.mozRTCPeerConnection.prototype;\r\n\r\n      // wrap static methods. Currently just generateCertificate.\r\n      if (window.mozRTCPeerConnection.generateCertificate) {\r\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\r\n          get: function() {\r\n            return window.mozRTCPeerConnection.generateCertificate;\r\n          }\r\n        });\r\n      }\r\n\r\n      window.RTCSessionDescription = window.mozRTCSessionDescription;\r\n      window.RTCIceCandidate = window.mozRTCIceCandidate;\r\n    }\r\n\r\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\r\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\r\n        .forEach(function(method) {\r\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\r\n          window.RTCPeerConnection.prototype[method] = function() {\r\n            arguments[0] = new ((method === 'addIceCandidate') ?\r\n                window.RTCIceCandidate :\r\n                window.RTCSessionDescription)(arguments[0]);\r\n            return nativeMethod.apply(this, arguments);\r\n          };\r\n        });\r\n\r\n    // support for addIceCandidate(null or undefined)\r\n    var nativeAddIceCandidate =\r\n        window.RTCPeerConnection.prototype.addIceCandidate;\r\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\r\n      if (!arguments[0]) {\r\n        if (arguments[1]) {\r\n          arguments[1].apply(null);\r\n        }\r\n        return Promise.resolve();\r\n      }\r\n      return nativeAddIceCandidate.apply(this, arguments);\r\n    };\r\n\r\n    // shim getStats with maplike support\r\n    var makeMapStats = function(stats) {\r\n      var map = new Map();\r\n      Object.keys(stats).forEach(function(key) {\r\n        map.set(key, stats[key]);\r\n        map[key] = stats[key];\r\n      });\r\n      return map;\r\n    };\r\n\r\n    var modernStatsTypes = {\r\n      inboundrtp: 'inbound-rtp',\r\n      outboundrtp: 'outbound-rtp',\r\n      candidatepair: 'candidate-pair',\r\n      localcandidate: 'local-candidate',\r\n      remotecandidate: 'remote-candidate'\r\n    };\r\n\r\n    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;\r\n    window.RTCPeerConnection.prototype.getStats = function(\r\n      selector,\r\n      onSucc,\r\n      onErr\r\n    ) {\r\n      return nativeGetStats.apply(this, [selector || null])\r\n        .then(function(stats) {\r\n          if (browserDetails.version < 48) {\r\n            stats = makeMapStats(stats);\r\n          }\r\n          if (browserDetails.version < 53 && !onSucc) {\r\n            // Shim only promise getStats with spec-hyphens in type names\r\n            // Leave callback version alone; misc old uses of forEach before Map\r\n            try {\r\n              stats.forEach(function(stat) {\r\n                stat.type = modernStatsTypes[stat.type] || stat.type;\r\n              });\r\n            } catch (e) {\r\n              if (e.name !== 'TypeError') {\r\n                throw e;\r\n              }\r\n              // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\r\n              stats.forEach(function(stat, i) {\r\n                stats.set(i, Object.assign({}, stat, {\r\n                  type: modernStatsTypes[stat.type] || stat.type\r\n                }));\r\n              });\r\n            }\r\n          }\r\n          return stats;\r\n        })\r\n        .then(onSucc, onErr);\r\n    };\r\n  }\r\n};\r\n\r\n// Expose public methods.\r\nmodule.exports = {\r\n  shimOnTrack: firefoxShim.shimOnTrack,\r\n  shimSourceObject: firefoxShim.shimSourceObject,\r\n  shimPeerConnection: firefoxShim.shimPeerConnection,\r\n  shimGetUserMedia: require('./getusermedia')\r\n};\r\n","/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n /* eslint-env node */\r\n'use strict';\r\n\r\nvar utils = require('../utils');\r\nvar logging = utils.log;\r\n\r\n// Expose public methods.\r\nmodule.exports = function(window) {\r\n  var browserDetails = utils.detectBrowser(window);\r\n  var navigator = window && window.navigator;\r\n  var MediaStreamTrack = window && window.MediaStreamTrack;\r\n\r\n  var shimError_ = function(e) {\r\n    return {\r\n      name: {\r\n        InternalError: 'NotReadableError',\r\n        NotSupportedError: 'TypeError',\r\n        PermissionDeniedError: 'NotAllowedError',\r\n        SecurityError: 'NotAllowedError'\r\n      }[e.name] || e.name,\r\n      message: {\r\n        'The operation is insecure.': 'The request is not allowed by the ' +\r\n        'user agent or the platform in the current context.'\r\n      }[e.message] || e.message,\r\n      constraint: e.constraint,\r\n      toString: function() {\r\n        return this.name + (this.message && ': ') + this.message;\r\n      }\r\n    };\r\n  };\r\n\r\n  // getUserMedia constraints shim.\r\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\r\n    var constraintsToFF37_ = function(c) {\r\n      if (typeof c !== 'object' || c.require) {\r\n        return c;\r\n      }\r\n      var require = [];\r\n      Object.keys(c).forEach(function(key) {\r\n        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\r\n          return;\r\n        }\r\n        var r = c[key] = (typeof c[key] === 'object') ?\r\n            c[key] : {ideal: c[key]};\r\n        if (r.min !== undefined ||\r\n            r.max !== undefined || r.exact !== undefined) {\r\n          require.push(key);\r\n        }\r\n        if (r.exact !== undefined) {\r\n          if (typeof r.exact === 'number') {\r\n            r. min = r.max = r.exact;\r\n          } else {\r\n            c[key] = r.exact;\r\n          }\r\n          delete r.exact;\r\n        }\r\n        if (r.ideal !== undefined) {\r\n          c.advanced = c.advanced || [];\r\n          var oc = {};\r\n          if (typeof r.ideal === 'number') {\r\n            oc[key] = {min: r.ideal, max: r.ideal};\r\n          } else {\r\n            oc[key] = r.ideal;\r\n          }\r\n          c.advanced.push(oc);\r\n          delete r.ideal;\r\n          if (!Object.keys(r).length) {\r\n            delete c[key];\r\n          }\r\n        }\r\n      });\r\n      if (require.length) {\r\n        c.require = require;\r\n      }\r\n      return c;\r\n    };\r\n    constraints = JSON.parse(JSON.stringify(constraints));\r\n    if (browserDetails.version < 38) {\r\n      logging('spec: ' + JSON.stringify(constraints));\r\n      if (constraints.audio) {\r\n        constraints.audio = constraintsToFF37_(constraints.audio);\r\n      }\r\n      if (constraints.video) {\r\n        constraints.video = constraintsToFF37_(constraints.video);\r\n      }\r\n      logging('ff37: ' + JSON.stringify(constraints));\r\n    }\r\n    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {\r\n      onError(shimError_(e));\r\n    });\r\n  };\r\n\r\n  // Returns the result of getUserMedia as a Promise.\r\n  var getUserMediaPromise_ = function(constraints) {\r\n    return new Promise(function(resolve, reject) {\r\n      getUserMedia_(constraints, resolve, reject);\r\n    });\r\n  };\r\n\r\n  // Shim for mediaDevices on older versions.\r\n  if (!navigator.mediaDevices) {\r\n    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,\r\n      addEventListener: function() { },\r\n      removeEventListener: function() { }\r\n    };\r\n  }\r\n  navigator.mediaDevices.enumerateDevices =\r\n      navigator.mediaDevices.enumerateDevices || function() {\r\n        return new Promise(function(resolve) {\r\n          var infos = [\r\n            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},\r\n            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}\r\n          ];\r\n          resolve(infos);\r\n        });\r\n      };\r\n\r\n  if (browserDetails.version < 41) {\r\n    // Work around http://bugzil.la/1169665\r\n    var orgEnumerateDevices =\r\n        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);\r\n    navigator.mediaDevices.enumerateDevices = function() {\r\n      return orgEnumerateDevices().then(undefined, function(e) {\r\n        if (e.name === 'NotFoundError') {\r\n          return [];\r\n        }\r\n        throw e;\r\n      });\r\n    };\r\n  }\r\n  if (browserDetails.version < 49) {\r\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\r\n        bind(navigator.mediaDevices);\r\n    navigator.mediaDevices.getUserMedia = function(c) {\r\n      return origGetUserMedia(c).then(function(stream) {\r\n        // Work around https://bugzil.la/802326\r\n        if (c.audio && !stream.getAudioTracks().length ||\r\n            c.video && !stream.getVideoTracks().length) {\r\n          stream.getTracks().forEach(function(track) {\r\n            track.stop();\r\n          });\r\n          throw new DOMException('The object can not be found here.',\r\n                                 'NotFoundError');\r\n        }\r\n        return stream;\r\n      }, function(e) {\r\n        return Promise.reject(shimError_(e));\r\n      });\r\n    };\r\n  }\r\n  if (!(browserDetails.version > 55 &&\r\n      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\r\n    var remap = function(obj, a, b) {\r\n      if (a in obj && !(b in obj)) {\r\n        obj[b] = obj[a];\r\n        delete obj[a];\r\n      }\r\n    };\r\n\r\n    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.\r\n        bind(navigator.mediaDevices);\r\n    navigator.mediaDevices.getUserMedia = function(c) {\r\n      if (typeof c === 'object' && typeof c.audio === 'object') {\r\n        c = JSON.parse(JSON.stringify(c));\r\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\r\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\r\n      }\r\n      return nativeGetUserMedia(c);\r\n    };\r\n\r\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\r\n      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;\r\n      MediaStreamTrack.prototype.getSettings = function() {\r\n        var obj = nativeGetSettings.apply(this, arguments);\r\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\r\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\r\n        return obj;\r\n      };\r\n    }\r\n\r\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\r\n      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\r\n      MediaStreamTrack.prototype.applyConstraints = function(c) {\r\n        if (this.kind === 'audio' && typeof c === 'object') {\r\n          c = JSON.parse(JSON.stringify(c));\r\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\r\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\r\n        }\r\n        return nativeApplyConstraints.apply(this, [c]);\r\n      };\r\n    }\r\n  }\r\n  navigator.getUserMedia = function(constraints, onSuccess, onError) {\r\n    if (browserDetails.version < 44) {\r\n      return getUserMedia_(constraints, onSuccess, onError);\r\n    }\r\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\r\n    utils.deprecated('navigator.getUserMedia',\r\n        'navigator.mediaDevices.getUserMedia');\r\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\r\n  };\r\n};\r\n","/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n'use strict';\r\nvar utils = require('../utils');\r\n\r\nvar safariShim = {\r\n  // TODO: DrAlex, should be here, double check against LayoutTests\r\n\r\n  // TODO: once the back-end for the mac port is done, add.\r\n  // TODO: check for webkitGTK+\r\n  // shimPeerConnection: function() { },\r\n\r\n  shimLocalStreamsAPI: function(window) {\r\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\r\n      return;\r\n    }\r\n    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\r\n      window.RTCPeerConnection.prototype.getLocalStreams = function() {\r\n        if (!this._localStreams) {\r\n          this._localStreams = [];\r\n        }\r\n        return this._localStreams;\r\n      };\r\n    }\r\n    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {\r\n      window.RTCPeerConnection.prototype.getStreamById = function(id) {\r\n        var result = null;\r\n        if (this._localStreams) {\r\n          this._localStreams.forEach(function(stream) {\r\n            if (stream.id === id) {\r\n              result = stream;\r\n            }\r\n          });\r\n        }\r\n        if (this._remoteStreams) {\r\n          this._remoteStreams.forEach(function(stream) {\r\n            if (stream.id === id) {\r\n              result = stream;\r\n            }\r\n          });\r\n        }\r\n        return result;\r\n      };\r\n    }\r\n    if (!('addStream' in window.RTCPeerConnection.prototype)) {\r\n      var _addTrack = window.RTCPeerConnection.prototype.addTrack;\r\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\r\n        if (!this._localStreams) {\r\n          this._localStreams = [];\r\n        }\r\n        if (this._localStreams.indexOf(stream) === -1) {\r\n          this._localStreams.push(stream);\r\n        }\r\n        var self = this;\r\n        stream.getTracks().forEach(function(track) {\r\n          _addTrack.call(self, track, stream);\r\n        });\r\n      };\r\n\r\n      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\r\n        if (stream) {\r\n          if (!this._localStreams) {\r\n            this._localStreams = [stream];\r\n          } else if (this._localStreams.indexOf(stream) === -1) {\r\n            this._localStreams.push(stream);\r\n          }\r\n        }\r\n        _addTrack.call(this, track, stream);\r\n      };\r\n    }\r\n    if (!('removeStream' in window.RTCPeerConnection.prototype)) {\r\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\r\n        if (!this._localStreams) {\r\n          this._localStreams = [];\r\n        }\r\n        var index = this._localStreams.indexOf(stream);\r\n        if (index === -1) {\r\n          return;\r\n        }\r\n        this._localStreams.splice(index, 1);\r\n        var self = this;\r\n        var tracks = stream.getTracks();\r\n        this.getSenders().forEach(function(sender) {\r\n          if (tracks.indexOf(sender.track) !== -1) {\r\n            self.removeTrack(sender);\r\n          }\r\n        });\r\n      };\r\n    }\r\n  },\r\n  shimRemoteStreamsAPI: function(window) {\r\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\r\n      return;\r\n    }\r\n    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\r\n      window.RTCPeerConnection.prototype.getRemoteStreams = function() {\r\n        return this._remoteStreams ? this._remoteStreams : [];\r\n      };\r\n    }\r\n    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\r\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\r\n        get: function() {\r\n          return this._onaddstream;\r\n        },\r\n        set: function(f) {\r\n          if (this._onaddstream) {\r\n            this.removeEventListener('addstream', this._onaddstream);\r\n            this.removeEventListener('track', this._onaddstreampoly);\r\n          }\r\n          this.addEventListener('addstream', this._onaddstream = f);\r\n          this.addEventListener('track', this._onaddstreampoly = function(e) {\r\n            var stream = e.streams[0];\r\n            if (!this._remoteStreams) {\r\n              this._remoteStreams = [];\r\n            }\r\n            if (this._remoteStreams.indexOf(stream) >= 0) {\r\n              return;\r\n            }\r\n            this._remoteStreams.push(stream);\r\n            var event = new Event('addstream');\r\n            event.stream = e.streams[0];\r\n            this.dispatchEvent(event);\r\n          }.bind(this));\r\n        }\r\n      });\r\n    }\r\n  },\r\n  shimCallbacksAPI: function(window) {\r\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\r\n      return;\r\n    }\r\n    var prototype = window.RTCPeerConnection.prototype;\r\n    var createOffer = prototype.createOffer;\r\n    var createAnswer = prototype.createAnswer;\r\n    var setLocalDescription = prototype.setLocalDescription;\r\n    var setRemoteDescription = prototype.setRemoteDescription;\r\n    var addIceCandidate = prototype.addIceCandidate;\r\n\r\n    prototype.createOffer = function(successCallback, failureCallback) {\r\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\r\n      var promise = createOffer.apply(this, [options]);\r\n      if (!failureCallback) {\r\n        return promise;\r\n      }\r\n      promise.then(successCallback, failureCallback);\r\n      return Promise.resolve();\r\n    };\r\n\r\n    prototype.createAnswer = function(successCallback, failureCallback) {\r\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\r\n      var promise = createAnswer.apply(this, [options]);\r\n      if (!failureCallback) {\r\n        return promise;\r\n      }\r\n      promise.then(successCallback, failureCallback);\r\n      return Promise.resolve();\r\n    };\r\n\r\n    var withCallback = function(description, successCallback, failureCallback) {\r\n      var promise = setLocalDescription.apply(this, [description]);\r\n      if (!failureCallback) {\r\n        return promise;\r\n      }\r\n      promise.then(successCallback, failureCallback);\r\n      return Promise.resolve();\r\n    };\r\n    prototype.setLocalDescription = withCallback;\r\n\r\n    withCallback = function(description, successCallback, failureCallback) {\r\n      var promise = setRemoteDescription.apply(this, [description]);\r\n      if (!failureCallback) {\r\n        return promise;\r\n      }\r\n      promise.then(successCallback, failureCallback);\r\n      return Promise.resolve();\r\n    };\r\n    prototype.setRemoteDescription = withCallback;\r\n\r\n    withCallback = function(candidate, successCallback, failureCallback) {\r\n      var promise = addIceCandidate.apply(this, [candidate]);\r\n      if (!failureCallback) {\r\n        return promise;\r\n      }\r\n      promise.then(successCallback, failureCallback);\r\n      return Promise.resolve();\r\n    };\r\n    prototype.addIceCandidate = withCallback;\r\n  },\r\n  shimGetUserMedia: function(window) {\r\n    var navigator = window && window.navigator;\r\n\r\n    if (!navigator.getUserMedia) {\r\n      if (navigator.webkitGetUserMedia) {\r\n        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\r\n      } else if (navigator.mediaDevices &&\r\n          navigator.mediaDevices.getUserMedia) {\r\n        navigator.getUserMedia = function(constraints, cb, errcb) {\r\n          navigator.mediaDevices.getUserMedia(constraints)\r\n          .then(cb, errcb);\r\n        }.bind(navigator);\r\n      }\r\n    }\r\n  },\r\n  shimRTCIceServerUrls: function(window) {\r\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\r\n    var OrigPeerConnection = window.RTCPeerConnection;\r\n    window.RTCPeerConnection = function(pcConfig, pcConstraints) {\r\n      if (pcConfig && pcConfig.iceServers) {\r\n        var newIceServers = [];\r\n        for (var i = 0; i < pcConfig.iceServers.length; i++) {\r\n          var server = pcConfig.iceServers[i];\r\n          if (!server.hasOwnProperty('urls') &&\r\n              server.hasOwnProperty('url')) {\r\n            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\r\n            server = JSON.parse(JSON.stringify(server));\r\n            server.urls = server.url;\r\n            delete server.url;\r\n            newIceServers.push(server);\r\n          } else {\r\n            newIceServers.push(pcConfig.iceServers[i]);\r\n          }\r\n        }\r\n        pcConfig.iceServers = newIceServers;\r\n      }\r\n      return new OrigPeerConnection(pcConfig, pcConstraints);\r\n    };\r\n    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\r\n    // wrap static methods. Currently just generateCertificate.\r\n    if ('generateCertificate' in window.RTCPeerConnection) {\r\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\r\n        get: function() {\r\n          return OrigPeerConnection.generateCertificate;\r\n        }\r\n      });\r\n    }\r\n  },\r\n  shimTrackEventTransceiver: function(window) {\r\n    // Add event.transceiver member over deprecated event.receiver\r\n    if (typeof window === 'object' && window.RTCPeerConnection &&\r\n        ('receiver' in window.RTCTrackEvent.prototype) &&\r\n        // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is\r\n        // defined for some reason even when window.RTCTransceiver is not.\r\n        !window.RTCTransceiver) {\r\n      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\r\n        get: function() {\r\n          return {receiver: this.receiver};\r\n        }\r\n      });\r\n    }\r\n  },\r\n\r\n  shimCreateOfferLegacy: function(window) {\r\n    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\r\n    window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {\r\n      var pc = this;\r\n      if (offerOptions) {\r\n        var audioTransceiver = pc.getTransceivers().find(function(transceiver) {\r\n          return transceiver.sender.track &&\r\n              transceiver.sender.track.kind === 'audio';\r\n        });\r\n        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\r\n          if (audioTransceiver.direction === 'sendrecv') {\r\n            audioTransceiver.setDirection('sendonly');\r\n          } else if (audioTransceiver.direction === 'recvonly') {\r\n            audioTransceiver.setDirection('inactive');\r\n          }\r\n        } else if (offerOptions.offerToReceiveAudio === true &&\r\n            !audioTransceiver) {\r\n          pc.addTransceiver('audio');\r\n        }\r\n\r\n        var videoTransceiver = pc.getTransceivers().find(function(transceiver) {\r\n          return transceiver.sender.track &&\r\n              transceiver.sender.track.kind === 'video';\r\n        });\r\n        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\r\n          if (videoTransceiver.direction === 'sendrecv') {\r\n            videoTransceiver.setDirection('sendonly');\r\n          } else if (videoTransceiver.direction === 'recvonly') {\r\n            videoTransceiver.setDirection('inactive');\r\n          }\r\n        } else if (offerOptions.offerToReceiveVideo === true &&\r\n            !videoTransceiver) {\r\n          pc.addTransceiver('video');\r\n        }\r\n      }\r\n      return origCreateOffer.apply(pc, arguments);\r\n    };\r\n  }\r\n};\r\n\r\n// Expose public methods.\r\nmodule.exports = {\r\n  shimCallbacksAPI: safariShim.shimCallbacksAPI,\r\n  shimLocalStreamsAPI: safariShim.shimLocalStreamsAPI,\r\n  shimRemoteStreamsAPI: safariShim.shimRemoteStreamsAPI,\r\n  shimGetUserMedia: safariShim.shimGetUserMedia,\r\n  shimRTCIceServerUrls: safariShim.shimRTCIceServerUrls,\r\n  shimTrackEventTransceiver: safariShim.shimTrackEventTransceiver,\r\n  shimCreateOfferLegacy: safariShim.shimCreateOfferLegacy\r\n  // TODO\r\n  // shimPeerConnection: safariShim.shimPeerConnection\r\n};\r\n","/*\r\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n /* eslint-env node */\r\n'use strict';\r\n\r\nvar SDPUtils = require('sdp');\r\nvar utils = require('./utils');\r\n\r\n// Wraps the peerconnection event eventNameToWrap in a function\r\n// which returns the modified event object.\r\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  var proto = window.RTCPeerConnection.prototype;\r\n  var nativeAddEventListener = proto.addEventListener;\r\n  proto.addEventListener = function(nativeEventName, cb) {\r\n    if (nativeEventName !== eventNameToWrap) {\r\n      return nativeAddEventListener.apply(this, arguments);\r\n    }\r\n    var wrappedCallback = function(e) {\r\n      cb(wrapper(e));\r\n    };\r\n    this._eventMap = this._eventMap || {};\r\n    this._eventMap[cb] = wrappedCallback;\r\n    return nativeAddEventListener.apply(this, [nativeEventName,\r\n      wrappedCallback]);\r\n  };\r\n\r\n  var nativeRemoveEventListener = proto.removeEventListener;\r\n  proto.removeEventListener = function(nativeEventName, cb) {\r\n    if (nativeEventName !== eventNameToWrap || !this._eventMap\r\n        || !this._eventMap[cb]) {\r\n      return nativeRemoveEventListener.apply(this, arguments);\r\n    }\r\n    var unwrappedCb = this._eventMap[cb];\r\n    delete this._eventMap[cb];\r\n    return nativeRemoveEventListener.apply(this, [nativeEventName,\r\n      unwrappedCb]);\r\n  };\r\n\r\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\r\n    get: function() {\r\n      return this['_on' + eventNameToWrap];\r\n    },\r\n    set: function(cb) {\r\n      if (this['_on' + eventNameToWrap]) {\r\n        this.removeEventListener(eventNameToWrap,\r\n            this['_on' + eventNameToWrap]);\r\n        delete this['_on' + eventNameToWrap];\r\n      }\r\n      if (cb) {\r\n        this.addEventListener(eventNameToWrap,\r\n            this['_on' + eventNameToWrap] = cb);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  shimRTCIceCandidate: function(window) {\r\n    // foundation is arbitrarily chosen as an indicator for full support for\r\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\r\n    if (window.RTCIceCandidate && 'foundation' in\r\n        window.RTCIceCandidate.prototype) {\r\n      return;\r\n    }\r\n\r\n    var NativeRTCIceCandidate = window.RTCIceCandidate;\r\n    window.RTCIceCandidate = function(args) {\r\n      // Remove the a= which shouldn't be part of the candidate string.\r\n      if (typeof args === 'object' && args.candidate &&\r\n          args.candidate.indexOf('a=') === 0) {\r\n        args = JSON.parse(JSON.stringify(args));\r\n        args.candidate = args.candidate.substr(2);\r\n      }\r\n\r\n      // Augment the native candidate with the parsed fields.\r\n      var nativeCandidate = new NativeRTCIceCandidate(args);\r\n      var parsedCandidate = SDPUtils.parseCandidate(args.candidate);\r\n      var augmentedCandidate = Object.assign(nativeCandidate,\r\n          parsedCandidate);\r\n\r\n      // Add a serializer that does not serialize the extra attributes.\r\n      augmentedCandidate.toJSON = function() {\r\n        return {\r\n          candidate: augmentedCandidate.candidate,\r\n          sdpMid: augmentedCandidate.sdpMid,\r\n          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\r\n          usernameFragment: augmentedCandidate.usernameFragment,\r\n        };\r\n      };\r\n      return augmentedCandidate;\r\n    };\r\n\r\n    // Hook up the augmented candidate in onicecandidate and\r\n    // addEventListener('icecandidate', ...)\r\n    wrapPeerConnectionEvent(window, 'icecandidate', function(e) {\r\n      if (e.candidate) {\r\n        Object.defineProperty(e, 'candidate', {\r\n          value: new window.RTCIceCandidate(e.candidate),\r\n          writable: 'false'\r\n        });\r\n      }\r\n      return e;\r\n    });\r\n  },\r\n\r\n  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.\r\n\r\n  shimCreateObjectURL: function(window) {\r\n    var URL = window && window.URL;\r\n\r\n    if (!(typeof window === 'object' && window.HTMLMediaElement &&\r\n          'srcObject' in window.HTMLMediaElement.prototype &&\r\n        URL.createObjectURL && URL.revokeObjectURL)) {\r\n      // Only shim CreateObjectURL using srcObject if srcObject exists.\r\n      return undefined;\r\n    }\r\n\r\n    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);\r\n    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);\r\n    var streams = new Map(), newId = 0;\r\n\r\n    URL.createObjectURL = function(stream) {\r\n      if ('getTracks' in stream) {\r\n        var url = 'polyblob:' + (++newId);\r\n        streams.set(url, stream);\r\n        utils.deprecated('URL.createObjectURL(stream)',\r\n            'elem.srcObject = stream');\r\n        return url;\r\n      }\r\n      return nativeCreateObjectURL(stream);\r\n    };\r\n    URL.revokeObjectURL = function(url) {\r\n      nativeRevokeObjectURL(url);\r\n      streams.delete(url);\r\n    };\r\n\r\n    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,\r\n                                              'src');\r\n    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {\r\n      get: function() {\r\n        return dsc.get.apply(this);\r\n      },\r\n      set: function(url) {\r\n        this.srcObject = streams.get(url) || null;\r\n        return dsc.set.apply(this, [url]);\r\n      }\r\n    });\r\n\r\n    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;\r\n    window.HTMLMediaElement.prototype.setAttribute = function() {\r\n      if (arguments.length === 2 &&\r\n          ('' + arguments[0]).toLowerCase() === 'src') {\r\n        this.srcObject = streams.get(arguments[1]) || null;\r\n      }\r\n      return nativeSetAttribute.apply(this, arguments);\r\n    };\r\n  }\r\n};\r\n","var toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = require('./grammar');\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar paramReducer = function (acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  }\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/\\;\\s?/).reduce(paramReducer, {});\n};\n\n// For backward compatibility - alias will be removed in 3.0.0\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid, paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n","var grammar = require('./grammar');\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n","/* Copyright @ 2015 Atlassian Pty Ltd\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nexports.Interop = require('./interop');\r\n","/* Copyright @ 2015 Atlassian Pty Ltd\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/* global RTCSessionDescription */\r\n/* global RTCIceCandidate */\r\n/* jshint -W097 */\r\n\"use strict\";\r\n\r\nvar transform = require('./transform');\r\nvar arrayEquals = require('./array-equals');\r\n\r\n/**\r\n * Unified Plan mids may be parsed as integers\r\n */\r\nfunction midToString(line) {\r\n    if (typeof line.mid === 'number') {\r\n        line.mid = line.mid.toString();\r\n    }\r\n}\r\n\r\n\r\nfunction Interop() {\r\n\r\n    /**\r\n     * This map holds the most recent Unified Plan offer/answer SDP that was\r\n     * converted to Plan B, with the SDP type ('offer' or 'answer') as keys and\r\n     * the SDP string as values.\r\n     *\r\n     * @type {{}}\r\n     */\r\n    this.cache = {\r\n        mlB2UMap : {},\r\n        mlU2BMap : {}\r\n    };\r\n}\r\n\r\nmodule.exports = Interop;\r\n\r\n/**\r\n * Changes the candidate args to match with the related Unified Plan\r\n */\r\nInterop.prototype.candidateToUnifiedPlan = function(candidate) {\r\n    var cand = new RTCIceCandidate(candidate);\r\n\r\n    cand.sdpMLineIndex = this.cache.mlB2UMap[cand.sdpMLineIndex];\r\n    /* TODO: change sdpMid to (audio|video)-SSRC */\r\n\r\n    return cand;\r\n};\r\n\r\n/**\r\n * Changes the candidate args to match with the related Plan B\r\n */\r\nInterop.prototype.candidateToPlanB = function(candidate) {\r\n    var cand = new RTCIceCandidate(candidate);\r\n\r\n    if (cand.sdpMid.indexOf('audio') === 0) {\r\n      cand.sdpMid = 'audio';\r\n    } else if (cand.sdpMid.indexOf('video') === 0) {\r\n      cand.sdpMid = 'video';\r\n    } else {\r\n      throw new Error('candidate with ' + cand.sdpMid + ' not allowed');\r\n    }\r\n\r\n    cand.sdpMLineIndex = this.cache.mlU2BMap[cand.sdpMLineIndex];\r\n\r\n    return cand;\r\n};\r\n\r\n/**\r\n * Returns the index of the first m-line with the given media type and with a\r\n * direction which allows sending, in the last Unified Plan description with\r\n * type \"answer\" converted to Plan B. Returns {null} if there is no saved\r\n * answer, or if none of its m-lines with the given type allow sending.\r\n * @param type the media type (\"audio\" or \"video\").\r\n * @returns {*}\r\n */\r\nInterop.prototype.getFirstSendingIndexFromAnswer = function(type) {\r\n    if (!this.cache.answer) {\r\n        return null;\r\n    }\r\n\r\n    var session = transform.parse(this.cache.answer);\r\n    if (session && session.media && Array.isArray(session.media)){\r\n        for (var i = 0; i < session.media.length; i++) {\r\n            if (session.media[i].type == type &&\r\n                (!session.media[i].direction /* default to sendrecv */ ||\r\n                    session.media[i].direction === 'sendrecv' ||\r\n                    session.media[i].direction === 'sendonly')){\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * This method transforms a Unified Plan SDP to an equivalent Plan B SDP. A\r\n * PeerConnection wrapper transforms the SDP to Plan B before passing it to the\r\n * application.\r\n *\r\n * @param desc\r\n * @returns {*}\r\n */\r\nInterop.prototype.toPlanB = function(desc) {\r\n    var self = this;\r\n    //#region Preliminary input validation.\r\n\r\n    if (typeof desc !== 'object' || desc === null ||\r\n        typeof desc.sdp !== 'string') {\r\n        console.warn('An empty description was passed as an argument.');\r\n        return desc;\r\n    }\r\n\r\n    // Objectify the SDP for easier manipulation.\r\n    var session = transform.parse(desc.sdp);\r\n\r\n    // If the SDP contains no media, there's nothing to transform.\r\n    if (typeof session.media === 'undefined' ||\r\n        !Array.isArray(session.media) || session.media.length === 0) {\r\n        console.warn('The description has no media.');\r\n        return desc;\r\n    }\r\n\r\n    // Try some heuristics to \"make sure\" this is a Unified Plan SDP. Plan B\r\n    // SDP has a video, an audio and a data \"channel\" at most.\r\n    if (session.media.length <= 3 && session.media.every(function(m) {\r\n            return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;\r\n        })) {\r\n        console.warn('This description does not look like Unified Plan.');\r\n        return desc;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    // HACK https://bugzilla.mozilla.org/show_bug.cgi?id=1113443\r\n    var sdp = desc.sdp;\r\n    var rewrite = false;\r\n    for (var i = 0; i < session.media.length; i++) {\r\n        var uLine = session.media[i];\r\n        uLine.rtp.forEach(function(rtp) {\r\n            if (rtp.codec === 'NULL')\r\n            {\r\n                rewrite = true;\r\n                var offer = transform.parse(self.cache.offer);\r\n                rtp.codec = offer.media[i].rtp[0].codec;\r\n            }\r\n        });\r\n    }\r\n    if (rewrite) {\r\n        sdp = transform.write(session);\r\n    }\r\n\r\n    // Unified Plan SDP is our \"precious\". Cache it for later use in the Plan B\r\n    // -> Unified Plan transformation.\r\n    this.cache[desc.type] = sdp;\r\n\r\n    //#region Convert from Unified Plan to Plan B.\r\n\r\n    // We rebuild the session.media array.\r\n    var media = session.media;\r\n    session.media = [];\r\n\r\n    // Associative array that maps channel types to channel objects for fast\r\n    // access to channel objects by their type, e.g. type2bl['audio']->channel\r\n    // obj.\r\n    var type2bl = {};\r\n\r\n    // Used to build the group:BUNDLE value after the channels construction\r\n    // loop.\r\n    var types = [];\r\n\r\n    // Used to aggregate the directions of the m-lines.\r\n    var directionResult = {};\r\n\r\n    media.forEach(function(uLine) {\r\n        midToString(uLine);\r\n        // rtcp-mux is required in the Plan B SDP.\r\n        if ((typeof uLine.rtcpMux !== 'string' ||\r\n            uLine.rtcpMux !== 'rtcp-mux') &&\r\n            uLine.direction !== 'inactive' && uLine.type !== 'application') {\r\n            throw new Error('Cannot convert to Plan B because m-lines ' +\r\n                'without the rtcp-mux attribute were found.');\r\n        }\r\n\r\n        // If we don't have a channel for this uLine.type OR the selected is\r\n        // inactive, then select this uLine as the channel basis.\r\n        if (typeof type2bl[uLine.type] === 'undefined' ||\r\n            type2bl[uLine.type].direction === 'inactive') {\r\n            type2bl[uLine.type] = uLine;\r\n        }\r\n    });\r\n\r\n    // Implode the Unified Plan m-lines/tracks into Plan B channels.\r\n    media.forEach(function(uLine) {\r\n        var type = uLine.type;\r\n\r\n        if (type === 'application') {\r\n            uLine.mid = \"data\";\r\n            session.media.push(uLine);\r\n            types.push(uLine.mid);\r\n            return;\r\n        }\r\n\r\n        // Add sources to the channel and handle a=msid.\r\n        if (typeof uLine.sources === 'object') {\r\n            Object.keys(uLine.sources).forEach(function(ssrc) {\r\n                if (typeof type2bl[type].sources !== 'object')\r\n                    type2bl[type].sources = {};\r\n\r\n                // Assign the sources to the channel.\r\n                type2bl[type].sources[ssrc] = uLine.sources[ssrc];\r\n\r\n                if (typeof uLine.msid !== 'undefined') {\r\n                    // In Plan B the msid is an SSRC attribute. Also, we don't\r\n                    // care about the obsolete label and mslabel attributes.\r\n                    //\r\n                    // Note that it is not guaranteed that the uLine will\r\n                    // have an msid. recvonly channels in particular don't have\r\n                    // one.\r\n                    type2bl[type].sources[ssrc].msid = uLine.msid;\r\n                }\r\n                // NOTE ssrcs in ssrc groups will share msids, as\r\n                // draft-uberti-rtcweb-plan-00 mandates.\r\n            });\r\n        }\r\n\r\n        // Add ssrc groups to the channel.\r\n        if (typeof uLine.ssrcGroups !== 'undefined' &&\r\n                Array.isArray(uLine.ssrcGroups)) {\r\n\r\n            // Create the ssrcGroups array, if it's not defined.\r\n            if (typeof type2bl[type].ssrcGroups === 'undefined' ||\r\n                    !Array.isArray(type2bl[type].ssrcGroups)) {\r\n                type2bl[type].ssrcGroups = [];\r\n            }\r\n\r\n            // Different ssrc may belong to the same group\r\n            if (!arrayEquals.apply(type2bl[type].ssrcGroups,\r\n                                   [uLine.ssrcGroups])) {\r\n                type2bl[type].ssrcGroups\r\n                    = type2bl[type].ssrcGroups.concat(uLine.ssrcGroups);\r\n            }\r\n        }\r\n\r\n        var direction = uLine.direction;\r\n\r\n        directionResult[type]\r\n            = (directionResult[type] || 0 /* inactive */)\r\n                | directionMasks[direction || 'inactive'];\r\n\r\n        if (type2bl[type] === uLine) {\r\n            // Plan B mids are in ['audio', 'video', 'data']\r\n            uLine.mid = type;\r\n\r\n            // Plan B doesn't support/need the bundle-only attribute.\r\n            delete uLine.bundleOnly;\r\n\r\n            // In Plan B the msid is an SSRC attribute.\r\n            delete uLine.msid;\r\n\r\n            if (direction !== 'inactive') {\r\n              // Used to build the group:BUNDLE value after this loop.\r\n              types.push(type);\r\n            }\r\n\r\n            // Add the channel to the new media array.\r\n            session.media.push(uLine);\r\n        }\r\n    });\r\n\r\n    // We regenerate the BUNDLE group with the new mids.\r\n    session.groups.some(function(group) {\r\n        if (group.type === 'BUNDLE') {\r\n            group.mids = types.join(' ');\r\n            return true;\r\n        }\r\n    });\r\n\r\n    // msid semantic\r\n    session.msidSemantic = {\r\n        semantic: 'WMS',\r\n        token: '*'\r\n    };\r\n\r\n    var resStr = transform.write(session);\r\n\r\n    return new RTCSessionDescription({\r\n        type: desc.type,\r\n        sdp: resStr\r\n    });\r\n\r\n    //#endregion\r\n};\r\n\r\n/**\r\n * This method transforms a Plan B SDP to an equivalent Unified Plan SDP. A\r\n * PeerConnection wrapper transforms the SDP to Unified Plan before passing it\r\n * to FF.\r\n *\r\n * @param desc\r\n * @returns {*}\r\n */\r\nInterop.prototype.toUnifiedPlan = function(desc) {\r\n    var self = this;\r\n    //#region Preliminary input validation.\r\n\r\n    if (typeof desc !== 'object' || desc === null ||\r\n        typeof desc.sdp !== 'string') {\r\n        console.warn('An empty description was passed as an argument.');\r\n        return desc;\r\n    }\r\n\r\n    var session = transform.parse(desc.sdp);\r\n\r\n    // If the SDP contains no media, there's nothing to transform.\r\n    if (typeof session.media === 'undefined' ||\r\n        !Array.isArray(session.media) || session.media.length === 0) {\r\n        console.warn('The description has no media.');\r\n        return desc;\r\n    }\r\n\r\n    // Try some heuristics to \"make sure\" this is a Plan B SDP. Plan B SDP has\r\n    // a video, an audio and a data \"channel\" at most.\r\n    if (session.media.length > 3 || !session.media.every(function(m) {\r\n            return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;\r\n        })) {\r\n        console.warn('This description does not look like Plan B.');\r\n        return desc;\r\n    }\r\n\r\n    // Make sure this Plan B SDP can be converted to a Unified Plan SDP.\r\n    var mids = [];\r\n    session.media.forEach(function(m) {\r\n        mids.push(m.mid);\r\n    });\r\n\r\n    var hasBundle = false;\r\n    if (typeof session.groups !== 'undefined' &&\r\n        Array.isArray(session.groups)) {\r\n        hasBundle = session.groups.every(function(g) {\r\n            return g.type !== 'BUNDLE' ||\r\n                arrayEquals.apply(g.mids.sort(), [mids.sort()]);\r\n        });\r\n    }\r\n\r\n    if (!hasBundle) {\r\n        throw new Error(\"Cannot convert to Unified Plan because m-lines that\" +\r\n            \" are not bundled were found.\");\r\n    }\r\n\r\n    //#endregion\r\n\r\n\r\n    //#region Convert from Plan B to Unified Plan.\r\n\r\n    // Unfortunately, a Plan B offer/answer doesn't have enough information to\r\n    // rebuild an equivalent Unified Plan offer/answer.\r\n    //\r\n    // For example, if this is a local answer (in Unified Plan style) that we\r\n    // convert to Plan B prior to handing it over to the application (the\r\n    // PeerConnection wrapper called us, for instance, after a successful\r\n    // createAnswer), we want to remember the m-line at which we've seen the\r\n    // (local) SSRC. That's because when the application wants to do call the\r\n    // SLD method, forcing us to do the inverse transformation (from Plan B to\r\n    // Unified Plan), we need to know to which m-line to assign the (local)\r\n    // SSRC. We also need to know all the other m-lines that the original\r\n    // answer had and include them in the transformed answer as well.\r\n    //\r\n    // Another example is if this is a remote offer that we convert to Plan B\r\n    // prior to giving it to the application, we want to remember the mid at\r\n    // which we've seen the (remote) SSRC.\r\n    //\r\n    // In the iteration that follows, we use the cached Unified Plan (if it\r\n    // exists) to assign mids to ssrcs.\r\n\r\n    var cached;\r\n    if (typeof this.cache[desc.type] !== 'undefined') {\r\n        cached = transform.parse(this.cache[desc.type]);\r\n    }\r\n\r\n    var recvonlySsrcs = {\r\n        audio: {},\r\n        video: {}\r\n    };\r\n\r\n    // A helper map that sends mids to m-line objects. We use it later to\r\n    // rebuild the Unified Plan style session.media array.\r\n    var mid2ul = {};\r\n    var bIdx = 0;\r\n    var uIdx = 0;\r\n\r\n    session.media.forEach(function(bLine) {\r\n\r\n        if ((typeof bLine.rtcpMux !== 'string' ||\r\n            bLine.rtcpMux !== 'rtcp-mux') &&\r\n            bLine.direction !== 'inactive' && bLine.type !== 'application') {\r\n            throw new Error(\"Cannot convert to Unified Plan because m-lines \" +\r\n                \"without the rtcp-mux attribute were found.\");\r\n        }\r\n\r\n        if (bLine.type === 'application') {\r\n            var uLineData = null;\r\n            if (cached && cached.media) {\r\n                uLineData = cached.media.find(function(uLine) {\r\n                    return uLine.type === 'application';\r\n                });\r\n            }\r\n            if (uLineData) {\r\n                mid2ul[uLineData.mid] = uLineData;\r\n            } else {\r\n                mid2ul[bLine.mid] = bLine;\r\n            }\r\n            return;\r\n        }\r\n\r\n        // With rtcp-mux and bundle all the channels should have the same ICE\r\n        // stuff.\r\n        var sources = bLine.sources;\r\n        var ssrcGroups = bLine.ssrcGroups;\r\n        var candidates = bLine.candidates;\r\n        var iceUfrag = bLine.iceUfrag;\r\n        var icePwd = bLine.icePwd;\r\n        var fingerprint = bLine.fingerprint;\r\n        var port = bLine.port;\r\n\r\n        // We'll use the \"bLine\" object as a prototype for each new \"mLine\"\r\n        // that we create, but first we need to clean it up a bit.\r\n        delete bLine.sources;\r\n        delete bLine.ssrcGroups;\r\n        delete bLine.candidates;\r\n        delete bLine.iceUfrag;\r\n        delete bLine.icePwd;\r\n        delete bLine.fingerprint;\r\n        delete bLine.port;\r\n        delete bLine.mid;\r\n\r\n        // inverted ssrc group map\r\n        var ssrc2group = {};\r\n        if (typeof ssrcGroups !== 'undefined' && Array.isArray(ssrcGroups)) {\r\n            ssrcGroups.forEach(function (ssrcGroup) {\r\n\r\n                // TODO(gp) find out how to receive simulcast with FF. For the\r\n                // time being, hide it.\r\n                if (ssrcGroup.semantics === 'SIM') {\r\n                    return;\r\n                }\r\n\r\n                // XXX This might brake if an SSRC is in more than one group\r\n                // for some reason.\r\n                if (typeof ssrcGroup.ssrcs !== 'undefined' &&\r\n                    Array.isArray(ssrcGroup.ssrcs)) {\r\n                    ssrcGroup.ssrcs.forEach(function (ssrc) {\r\n                        if (typeof ssrc2group[ssrc] === 'undefined') {\r\n                            ssrc2group[ssrc] = [];\r\n                        }\r\n\r\n                        ssrc2group[ssrc].push(ssrcGroup);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        // ssrc to m-line index.\r\n        var ssrc2ml = {};\r\n\r\n        if (typeof sources === 'object') {\r\n\r\n            // Explode the Plan B channel sources with one m-line per source.\r\n            Object.keys(sources).forEach(function(ssrc) {\r\n\r\n                // The (unified) m-line for this SSRC. We either create it from\r\n                // scratch or, if it's a grouped SSRC, we re-use a related\r\n                // mline. In other words, if the source is grouped with another\r\n                // source, put the two together in the same m-line.\r\n                var uLine;\r\n\r\n                // We assume here that we are the answerer in the O/A, so any\r\n                // offers which we translate come from the remote side, while\r\n                // answers are local. So the check below is to make that we\r\n                // handle receive-only SSRCs in a special way only if they come\r\n                // from the remote side.\r\n                if (desc.type==='offer') {\r\n                    // We want to detect SSRCs which are used by a remote peer\r\n                    // in an m-line with direction=recvonly (i.e. they are\r\n                    // being used for RTCP only).\r\n                    // This information would have gotten lost if the remote\r\n                    // peer used Unified Plan and their local description was\r\n                    // translated to Plan B. So we use the lack of an MSID\r\n                    // attribute to deduce a \"receive only\" SSRC.\r\n                    if (!sources[ssrc].msid) {\r\n                        recvonlySsrcs[bLine.type][ssrc] = sources[ssrc];\r\n                        // Receive-only SSRCs must not create new m-lines. We\r\n                        // will assign them to an existing m-line later.\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                if (typeof ssrc2group[ssrc] !== 'undefined' &&\r\n                    Array.isArray(ssrc2group[ssrc])) {\r\n                    ssrc2group[ssrc].some(function (ssrcGroup) {\r\n                        // ssrcGroup.ssrcs *is* an Array, no need to check\r\n                        // again here.\r\n                        return ssrcGroup.ssrcs.some(function (related) {\r\n                            if (typeof ssrc2ml[related] === 'object') {\r\n                                uLine = ssrc2ml[related];\r\n                                return true;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n\r\n                if (typeof uLine === 'object') {\r\n                    // the m-line already exists. Just add the source.\r\n                    uLine.sources[ssrc] = sources[ssrc];\r\n                    delete sources[ssrc].msid;\r\n                } else {\r\n                    // Use the \"bLine\" as a prototype for the \"uLine\".\r\n                    uLine = Object.create(bLine);\r\n                    ssrc2ml[ssrc] = uLine;\r\n\r\n                    if (typeof sources[ssrc].msid !== 'undefined') {\r\n                        // Assign the msid of the source to the m-line. Note\r\n                        // that it is not guaranteed that the source will have\r\n                        // msid. In particular \"recvonly\" sources don't have an\r\n                        // msid. Note that \"recvonly\" is a term only defined\r\n                        // for m-lines.\r\n                        uLine.msid = sources[ssrc].msid;\r\n                        delete sources[ssrc].msid;\r\n                    }\r\n\r\n                    // We assign one SSRC per media line.\r\n                    uLine.sources = {};\r\n                    uLine.sources[ssrc] = sources[ssrc];\r\n                    uLine.ssrcGroups = ssrc2group[ssrc];\r\n\r\n                    // Use the cached Unified Plan SDP (if it exists) to assign\r\n                    // SSRCs to mids.\r\n                    if (typeof cached !== 'undefined' &&\r\n                        typeof cached.media !== 'undefined' &&\r\n                        Array.isArray(cached.media)) {\r\n\r\n                        cached.media.forEach(function (m) {\r\n                            if (typeof m.sources === 'object') {\r\n                                Object.keys(m.sources).forEach(function (s) {\r\n                                    if (s === ssrc) {\r\n                                        uLine.mid = m.mid;\r\n                                    }\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    midToString(uLine);\r\n\r\n                    if (typeof uLine.mid === 'undefined') {\r\n\r\n                        // If this is an SSRC that we see for the first time\r\n                        // assign it a new mid. This is typically the case when\r\n                        // this method is called to transform a remote\r\n                        // description for the first time or when there is a\r\n                        // new SSRC in the remote description because a new\r\n                        // peer has joined the conference. Local SSRCs should\r\n                        // have already been added to the map in the toPlanB\r\n                        // method.\r\n                        //\r\n                        // Because FF generates answers in Unified Plan style,\r\n                        // we MUST already have a cached answer with all the\r\n                        // local SSRCs mapped to some m-line/mid.\r\n\r\n                        if (desc.type === 'answer') {\r\n                            throw new Error(\"An unmapped SSRC was found.\");\r\n                        }\r\n\r\n                        uLine.mid = [bLine.type, '-', ssrc].join('');\r\n                    }\r\n\r\n                    // Include the candidates in the 1st media line.\r\n                    uLine.candidates = candidates;\r\n                    uLine.iceUfrag = iceUfrag;\r\n                    uLine.icePwd = icePwd;\r\n                    uLine.fingerprint = fingerprint;\r\n                    uLine.port = port;\r\n\r\n                    mid2ul[uLine.mid] = uLine;\r\n\r\n                    self.cache.mlU2BMap[uIdx] = bIdx;\r\n                    if (typeof self.cache.mlB2UMap[bIdx] === 'undefined') {\r\n                      self.cache.mlB2UMap[bIdx] = uIdx;\r\n                    }\r\n                    uIdx++;\r\n                }\r\n            });\r\n        }\r\n\r\n        bIdx++;\r\n    });\r\n\r\n    // Rebuild the media array in the right order and add the missing mLines\r\n    // (missing from the Plan B SDP).\r\n    session.media = [];\r\n    mids = []; // reuse\r\n\r\n    if (desc.type === 'answer') {\r\n\r\n        // The media lines in the answer must match the media lines in the\r\n        // offer. The order is important too. Here we assume that Firefox is\r\n        // the answerer, so we merely have to use the reconstructed (unified)\r\n        // answer to update the cached (unified) answer accordingly.\r\n        //\r\n        // In the general case, one would have to use the cached (unified)\r\n        // offer to find the m-lines that are missing from the reconstructed\r\n        // answer, potentially grabbing them from the cached (unified) answer.\r\n        // One has to be careful with this approach because inactive m-lines do\r\n        // not always have an mid, making it tricky (impossible?) to find where\r\n        // exactly and which m-lines are missing from the reconstructed answer.\r\n\r\n        for (var i = 0; i < cached.media.length; i++) {\r\n            var uLine = cached.media[i];\r\n            midToString(uLine);\r\n\r\n            if (typeof mid2ul[uLine.mid] === 'undefined') {\r\n\r\n                // The mid isn't in the reconstructed (unified) answer.\r\n                // This is either a (unified) m-line containing a remote\r\n                // track only, or a (unified) m-line containing a remote\r\n                // track and a local track that has been removed.\r\n                // In either case, it MUST exist in the cached\r\n                // (unified) answer.\r\n                //\r\n                // In case this is a removed local track, clean-up\r\n                // the (unified) m-line and make sure it's 'recvonly' or\r\n                // 'inactive'.\r\n\r\n                delete uLine.msid;\r\n                delete uLine.sources;\r\n                delete uLine.ssrcGroups;\r\n                if (!uLine.direction\r\n                    || uLine.direction === 'sendrecv')\r\n                    uLine.direction = 'recvonly';\r\n                else if (uLine.direction === 'sendonly')\r\n                    uLine.direction = 'inactive';\r\n            } else {\r\n                // This is an (unified) m-line/channel that contains a local\r\n                // track (sendrecv or sendonly channel) or it's a unified\r\n                // recvonly m-line/channel. In either case, since we're\r\n                // going from PlanB -> Unified Plan this m-line MUST\r\n                // exist in the cached answer.\r\n            }\r\n\r\n            session.media.push(uLine);\r\n            if (typeof uLine.mid === 'string') {\r\n                // inactive lines don't/may not have an mid.\r\n                mids.push(uLine.mid);\r\n            }\r\n        }\r\n    } else {\r\n\r\n        // SDP offer/answer (and the JSEP spec) forbids removing an m-section\r\n        // under any circumstances. If we are no longer interested in sending a\r\n        // track, we just remove the msid and ssrc attributes and set it to\r\n        // either a=recvonly (as the reofferer, we must use recvonly if the\r\n        // other side was previously sending on the m-section, but we can also\r\n        // leave the possibility open if it wasn't previously in use), or\r\n        // a=inactive.\r\n\r\n        if (typeof cached !== 'undefined' &&\r\n            typeof cached.media !== 'undefined' &&\r\n            Array.isArray(cached.media)) {\r\n            cached.media.forEach(function(uLine) {\r\n                midToString(uLine);\r\n                mids.push(uLine.mid);\r\n                if (typeof mid2ul[uLine.mid] !== 'undefined') {\r\n                    session.media.push(mid2ul[uLine.mid]);\r\n                } else {\r\n                    delete uLine.msid;\r\n                    delete uLine.sources;\r\n                    delete uLine.ssrcGroups;\r\n                    if (!uLine.direction\r\n                        || uLine.direction === 'sendrecv')\r\n                        uLine.direction = 'recvonly';\r\n                    if (!uLine.direction\r\n                        || uLine.direction === 'sendonly')\r\n                        uLine.direction = 'inactive';\r\n                    session.media.push(uLine);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Add all the remaining (new) m-lines of the transformed SDP.\r\n        Object.keys(mid2ul).forEach(function(mid) {\r\n            if (mids.indexOf(mid) === -1) {\r\n                mids.push(mid);\r\n                if (mid2ul[mid].direction === 'recvonly') {\r\n                    // This is a remote recvonly channel. Add its SSRC to the\r\n                    // appropriate sendrecv or sendonly channel.\r\n                    // TODO(gp) what if we don't have sendrecv/sendonly\r\n                    // channel?\r\n\r\n                    session.media.some(function (uLine) {\r\n                        if ((uLine.direction === 'sendrecv' ||\r\n                            uLine.direction === 'sendonly') &&\r\n                            uLine.type === mid2ul[mid].type) {\r\n\r\n                            // mid2ul[mid] shouldn't have any ssrc-groups\r\n                            Object.keys(mid2ul[mid].sources).forEach(\r\n                                function (ssrc) {\r\n                                uLine.sources[ssrc] =\r\n                                    mid2ul[mid].sources[ssrc];\r\n                            });\r\n\r\n                            return true;\r\n                        }\r\n                    });\r\n                } else {\r\n                    session.media.push(mid2ul[mid]);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    // After we have constructed the Plan Unified m-lines we can figure out\r\n    // where (in which m-line) to place the 'recvonly SSRCs'.\r\n    // Note: we assume here that we are the answerer in the O/A, so any offers\r\n    // which we translate come from the remote side, while answers are local\r\n    // (and so our last local description is cached as an 'answer').\r\n    [\"audio\", \"video\"].forEach(function (type) {\r\n        if (!session || !session.media || !Array.isArray(session.media))\r\n            return;\r\n\r\n        var idx = null;\r\n        if (Object.keys(recvonlySsrcs[type]).length > 0) {\r\n            idx = self.getFirstSendingIndexFromAnswer(type);\r\n            if (idx === null){\r\n                // If this is the first offer we receive, we don't have a\r\n                // cached answer. Assume that we will be sending media using\r\n                // the first m-line for each media type.\r\n\r\n                for (var i = 0; i < session.media.length; i++) {\r\n                    if (session.media[i].type === type) {\r\n                        idx = i;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (idx && session.media.length > idx) {\r\n            var mLine = session.media[idx];\r\n            Object.keys(recvonlySsrcs[type]).forEach(function(ssrc) {\r\n                if (mLine.sources && mLine.sources[ssrc]) {\r\n                    console.warn(\"Replacing an existing SSRC.\");\r\n                }\r\n                if (!mLine.sources) {\r\n                    mLine.sources = {};\r\n                }\r\n\r\n                mLine.sources[ssrc] = recvonlySsrcs[type][ssrc];\r\n            });\r\n        }\r\n    });\r\n\r\n    // We regenerate the BUNDLE group (since we regenerated the mids)\r\n    session.groups.some(function(group) {\r\n        if (group.type === 'BUNDLE') {\r\n            group.mids = mids.join(' ');\r\n            return true;\r\n        }\r\n    });\r\n\r\n    // msid semantic\r\n    session.msidSemantic = {\r\n        semantic: 'WMS',\r\n        token: '*'\r\n    };\r\n\r\n    var resStr = transform.write(session);\r\n\r\n    // Cache the transformed SDP (Unified Plan) for later re-use in this\r\n    // function.\r\n    this.cache[desc.type] = resStr;\r\n\r\n    return new RTCSessionDescription({\r\n        type: desc.type,\r\n        sdp: resStr\r\n    });\r\n\r\n    //#endregion\r\n};\r\n\r\n/**\r\n * Maps the direction strings to their binary representation. The binary\r\n * representation of the directions will contain only 2 bits. The least\r\n * significant bit will indicate the receiving direction and the other bit will\r\n * indicate the sending direction.\r\n *\r\n * @type {Map<string, number>}\r\n */\r\nvar directionMasks = {\r\n    'inactive': 0, // 00\r\n    'recvonly': 1, // 01\r\n    'sendonly': 2, // 10\r\n    'sendrecv': 3  // 11\r\n};\r\n\r\n/**\r\n * Parses a number into direction string.\r\n *\r\n * @param {number} direction - The number to be parsed.\r\n * @returns {string} - The parsed direction string.\r\n */\r\nfunction parseDirection(direction) { // eslint-disable-line no-unused-vars\r\n    // Filter all other bits except the 2 less significant.\r\n    var directionMask = direction & 3;\r\n\r\n    switch (directionMask) {\r\n    case 0:\r\n        return 'inactive';\r\n    case 1:\r\n        return 'recvonly';\r\n    case 2:\r\n        return 'sendonly';\r\n    case 3:\r\n        return 'sendrecv';\r\n    }\r\n}\r\n","/* Copyright @ 2015 Atlassian Pty Ltd\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nvar transform = require('sdp-transform');\r\n\r\nexports.write = function(session, opts) {\r\n\r\n  if (typeof session !== 'undefined' &&\r\n      typeof session.media !== 'undefined' &&\r\n      Array.isArray(session.media)) {\r\n\r\n    session.media.forEach(function (mLine) {\r\n      // expand sources to ssrcs\r\n      if (typeof mLine.sources !== 'undefined' &&\r\n        Object.keys(mLine.sources).length !== 0) {\r\n          mLine.ssrcs = [];\r\n          Object.keys(mLine.sources).forEach(function (ssrc) {\r\n            var source = mLine.sources[ssrc];\r\n            Object.keys(source).forEach(function (attribute) {\r\n              mLine.ssrcs.push({\r\n                id: ssrc,\r\n                attribute: attribute,\r\n                value: source[attribute]\r\n              });\r\n            });\r\n          });\r\n          delete mLine.sources;\r\n        }\r\n\r\n      // join ssrcs in ssrc groups\r\n      if (typeof mLine.ssrcGroups !== 'undefined' &&\r\n        Array.isArray(mLine.ssrcGroups)) {\r\n          mLine.ssrcGroups.forEach(function (ssrcGroup) {\r\n            if (typeof ssrcGroup.ssrcs !== 'undefined' &&\r\n                Array.isArray(ssrcGroup.ssrcs)) {\r\n              ssrcGroup.ssrcs = ssrcGroup.ssrcs.join(' ');\r\n            }\r\n          });\r\n        }\r\n    });\r\n  }\r\n\r\n  // join group mids\r\n  if (typeof session !== 'undefined' &&\r\n      typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {\r\n\r\n    session.groups.forEach(function (g) {\r\n      if (typeof g.mids !== 'undefined' && Array.isArray(g.mids)) {\r\n        g.mids = g.mids.join(' ');\r\n      }\r\n    });\r\n  }\r\n\r\n  return transform.write(session, opts);\r\n};\r\n\r\nexports.parse = function(sdp) {\r\n  var session = transform.parse(sdp);\r\n\r\n  if (typeof session !== 'undefined' && typeof session.media !== 'undefined' &&\r\n      Array.isArray(session.media)) {\r\n\r\n    session.media.forEach(function (mLine) {\r\n      // group sources attributes by ssrc\r\n      if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {\r\n        mLine.sources = {};\r\n        mLine.ssrcs.forEach(function (ssrc) {\r\n          if (!mLine.sources[ssrc.id])\r\n          mLine.sources[ssrc.id] = {};\r\n        mLine.sources[ssrc.id][ssrc.attribute] = ssrc.value;\r\n        });\r\n\r\n        delete mLine.ssrcs;\r\n      }\r\n\r\n      // split ssrcs in ssrc groups\r\n      if (typeof mLine.ssrcGroups !== 'undefined' &&\r\n        Array.isArray(mLine.ssrcGroups)) {\r\n          mLine.ssrcGroups.forEach(function (ssrcGroup) {\r\n            if (typeof ssrcGroup.ssrcs === 'string') {\r\n              ssrcGroup.ssrcs = ssrcGroup.ssrcs.split(' ');\r\n            }\r\n          });\r\n        }\r\n    });\r\n  }\r\n  // split group mids\r\n  if (typeof session !== 'undefined' &&\r\n      typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {\r\n\r\n    session.groups.forEach(function (g) {\r\n      if (typeof g.mids === 'string') {\r\n        g.mids = g.mids.split(' ');\r\n      }\r\n    });\r\n  }\r\n\r\n  return session;\r\n};\r\n\r\n","/* Copyright @ 2015 Atlassian Pty Ltd\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nmodule.exports = function arrayEquals(array) {\r\n    // if the other array is a falsy value, return\r\n    if (!array)\r\n        return false;\r\n\r\n    // compare lengths - can save a lot of time\r\n    if (this.length != array.length)\r\n        return false;\r\n\r\n    for (var i = 0, l = this.length; i < l; i++) {\r\n        // Check if we have nested arrays\r\n        if (this[i] instanceof Array && array[i] instanceof Array) {\r\n            // recurse into the nested arrays\r\n            if (!arrayEquals.apply(this[i], [array[i]]))\r\n                return false;\r\n        } else if (this[i] != array[i]) {\r\n            // Warning - two different object instances will never be equal:\r\n            // {x:20} != {x:20}\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\n","/* Copyright @ 2016 Atlassian Pty Ltd\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nvar transform = require('sdp-transform');\r\nvar transformUtils = require('./transform-utils');\r\nvar parseSsrcs = transformUtils.parseSsrcs;\r\nvar writeSsrcs = transformUtils.writeSsrcs;\r\n\r\n//region Constants\r\n\r\nvar DEFAULT_NUM_OF_LAYERS = 3;\r\n\r\n//endregion\r\n\r\nfunction getSsrcAttribute (mLine, ssrc, attributeName) {\r\n    return mLine\r\n        .ssrcs\r\n        .filter(function(ssrcInfo) { return ssrcInfo.id === ssrc; })\r\n        .filter(function(ssrcInfo) { return ssrcInfo.attribute === attributeName; })\r\n        .map(function(ssrcInfo) { return ssrcInfo.value; })[0];\r\n}\r\n\r\n//region Ctor\r\n\r\nfunction Simulcast(options) {\r\n\r\n    this.options = options ? options : {};\r\n\r\n    if (!this.options.numOfLayers) {\r\n        this.options.numOfLayers = DEFAULT_NUM_OF_LAYERS;\r\n    }\r\n    console.log(\"SdpSimulcast: using \" + this.options.numOfLayers + \" layers\");\r\n\r\n    /**\r\n     * An IN-ORDER list of the simulcast ssrcs\r\n     * @type {list<number>}\r\n     */\r\n    this.ssrcCache = [];\r\n}\r\n\r\n//endregion\r\n\r\n//region Stateless private utility functions\r\n\r\n/**\r\n * Returns a random integer between min (included) and max (excluded)\r\n * Using Math.round() gives a non-uniform distribution!\r\n * @returns {number}\r\n */\r\nfunction generateSSRC() {\r\n    var min = 0, max = 0xffffffff;\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n};\r\n\r\nfunction processVideo(session, action) {\r\n    if (session == null || !Array.isArray(session.media)) {\r\n        return;\r\n    }\r\n\r\n    session.media.forEach(function (mLine) {\r\n        if (mLine.type === 'video') {\r\n            action(mLine);\r\n        }\r\n    });\r\n};\r\n\r\nfunction validateDescription(desc)\r\n{\r\n    return desc && desc != null\r\n        && desc.type && desc.type != ''\r\n        && desc.sdp && desc.sdp != '';\r\n}\r\n\r\nfunction explodeRemoteSimulcast(mLine) {\r\n\r\n    if (!mLine || !Array.isArray(mLine.ssrcGroups)) {\r\n        return;\r\n    }\r\n\r\n    var sources = parseSsrcs(mLine);\r\n    var order = [];\r\n\r\n    // Find the SIM group and explode its sources.\r\n    var j = mLine.ssrcGroups.length;\r\n    while (j--) {\r\n\r\n        if (mLine.ssrcGroups[j].semantics !== 'SIM') {\r\n            continue;\r\n        }\r\n\r\n        var simulcastSsrcs = mLine.ssrcGroups[j].ssrcs.split(' ');\r\n\r\n        for (var i = 0; i < simulcastSsrcs.length; i++) {\r\n\r\n            var ssrc = simulcastSsrcs[i];\r\n            order.push(ssrc);\r\n\r\n            var parts = sources[ssrc].msid.split(' ');\r\n            sources[ssrc].msid = [parts[0], '/', i, ' ', parts[1], '/', i].join('');\r\n            sources[ssrc].cname = [sources[ssrc].cname, '/', i].join('');\r\n\r\n            // Remove all the groups that this SSRC participates in.\r\n            mLine.ssrcGroups.forEach(function (relatedGroup) {\r\n                if (relatedGroup.semantics === 'SIM') {\r\n                    return;\r\n                }\r\n\r\n                var relatedSsrcs = relatedGroup.ssrcs.split(' ');\r\n                if (relatedSsrcs.indexOf(ssrc) === -1) {\r\n                    return;\r\n                }\r\n\r\n                // Nuke all the related SSRCs.\r\n                relatedSsrcs.forEach(function (relatedSSRC) {\r\n                    sources[relatedSSRC].msid = sources[ssrc].msid;\r\n                    sources[relatedSSRC].cname = sources[ssrc].cname;\r\n                    if (relatedSSRC !== ssrc) {\r\n                        order.push(relatedSSRC);\r\n                    }\r\n                });\r\n\r\n                // Schedule the related group for nuking.\r\n            })\r\n        }\r\n\r\n        mLine.ssrcs = writeSsrcs(sources, order);\r\n        mLine.ssrcGroups.splice(j, 1);\r\n    };\r\n}\r\n\r\nfunction implodeRemoteSimulcast(mLine) {\r\n\r\n    if (!mLine || !Array.isArray(mLine.ssrcGroups)) {\r\n        console.info('Halt: There are no SSRC groups in the remote ' +\r\n                'description.');\r\n        return;\r\n    }\r\n\r\n    var sources = parseSsrcs(mLine);\r\n\r\n    // Find the SIM group and nuke it.\r\n    mLine.ssrcGroups.forEach(function (simulcastGroup) {\r\n        if (simulcastGroup.semantics !== 'SIM') {\r\n            return;\r\n        }\r\n\r\n        console.info(\"Imploding SIM group: \" + simulcastGroup.ssrcs);\r\n        // Schedule the SIM group for nuking.\r\n        simulcastGroup.nuke = true;\r\n\r\n        var simulcastSsrcs = simulcastGroup.ssrcs.split(' ');\r\n\r\n        // Nuke all the higher layer SSRCs.\r\n        for (var i = 1; i < simulcastSsrcs.length; i++) {\r\n\r\n            var ssrc = simulcastSsrcs[i];\r\n            delete sources[ssrc];\r\n\r\n            // Remove all the groups that this SSRC participates in.\r\n            mLine.ssrcGroups.forEach(function (relatedGroup) {\r\n                if (relatedGroup.semantics === 'SIM') {\r\n                    return;\r\n                }\r\n\r\n                var relatedSsrcs = relatedGroup.ssrcs.split(' ');\r\n                if (relatedSsrcs.indexOf(ssrc) === -1) {\r\n                    return;\r\n                }\r\n\r\n                // Nuke all the related SSRCs.\r\n                relatedSsrcs.forEach(function (relatedSSRC) {\r\n                    delete sources[relatedSSRC];\r\n                });\r\n\r\n                // Schedule the related group for nuking.\r\n                relatedGroup.nuke = true;\r\n            })\r\n        }\r\n\r\n        return;\r\n    });\r\n\r\n    mLine.ssrcs = writeSsrcs(sources);\r\n\r\n    // Nuke all the scheduled groups.\r\n    var i = mLine.ssrcGroups.length;\r\n    while (i--) {\r\n        if (mLine.ssrcGroups[i].nuke) {\r\n            mLine.ssrcGroups.splice(i, 1);\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeGoogConference(mLine) {\r\n    if (!mLine || !Array.isArray(mLine.invalid)) {\r\n        return;\r\n    }\r\n\r\n    var i = mLine.invalid.length;\r\n    while (i--) {\r\n        if (mLine.invalid[i].value == 'x-google-flag:conference') {\r\n            mLine.invalid.splice(i, 1);\r\n        }\r\n    }\r\n}\r\n\r\nfunction assertGoogConference(mLine) {\r\n    if (!mLine) {\r\n        return;\r\n    }\r\n\r\n    if (!Array.isArray(mLine.invalid)) {\r\n        mLine.invalid = [];\r\n    }\r\n\r\n    if (!mLine.invalid.some(\r\n            function (i) { return i.value === 'x-google-flag:conference' })) {\r\n        mLine.invalid.push({'value': 'x-google-flag:conference'});\r\n    }\r\n}\r\n\r\nSimulcast.prototype.clearSsrcCache = function() {\r\n    this.ssrcCache = [];\r\n}\r\n\r\n/**\r\n * When we start as video muted, all of the video\r\n *  ssrcs get generated so we can include them as part\r\n *  of the original session-accept.  That means we\r\n *  need this library to restore to those same ssrcs\r\n *  the first time we unmute, so we need the ability to\r\n *  force its cache\r\n */\r\nSimulcast.prototype.setSsrcCache = function(ssrcs) {\r\n    this.ssrcCache = ssrcs;\r\n}\r\n\r\n//endregion\r\n\r\n//region \"Private\" functions\r\n\r\n/**\r\n * Given a video mLine, return a list of the video ssrcs\r\n *  in simulcast layer order (returns a list of just\r\n *  the primary ssrc if there are no simulcast layers)\r\n */\r\nSimulcast.prototype._parseSimLayers = function (mLine) {\r\n    var simGroup = mLine.ssrcGroups &&\r\n        mLine.ssrcGroups.find(function(group) { return group.semantics === \"SIM\"; });\r\n    if (simGroup) {\r\n        return simGroup.ssrcs\r\n            .split(\" \")\r\n            .map(function(ssrcStr) { return parseInt(ssrcStr) });\r\n    } else {\r\n        return [mLine.ssrcs[0].id];\r\n    }\r\n}\r\n\r\nSimulcast.prototype._buildNewToOldSsrcMap = function (newSsrcList, oldSsrcList) {\r\n    var ssrcMap = {};\r\n    for (var i = 0; i < newSsrcList.length; ++i) {\r\n        var newSsrc = newSsrcList[i];\r\n        var oldSsrc = oldSsrcList[i] || null;\r\n        ssrcMap[newSsrc] = oldSsrc;\r\n    }\r\n    return ssrcMap;\r\n}\r\n\r\nSimulcast.prototype._fillInSourceDataFromCache = function(mLine) {\r\n    console.log(\"SdpSimulcast restoring from cache: \", this.ssrcCache);\r\n    var newSimSsrcs = this._parseSimLayers(mLine);\r\n    console.log(\"SdpSimulcast Parsed new sim ssrcs: \", newSimSsrcs);\r\n    var newMsid = getSsrcAttribute(mLine, newSimSsrcs[0], \"msid\");\r\n    var newCname = getSsrcAttribute(mLine, newSimSsrcs[0], \"cname\");\r\n    var ssrcsToReplace = this._buildNewToOldSsrcMap(newSimSsrcs, this.ssrcCache);\r\n    console.log(\"SdpSimulcast built replacement map: \", ssrcsToReplace);\r\n    // New sdp might only have 1 layer, so not every cached ssrc will have a new one\r\n    //  to replace directly\r\n    var ssrcsToAdd = this.ssrcCache\r\n        .filter(function(ssrc) { return Object.values(ssrcsToReplace).indexOf(ssrc) === -1; });\r\n    console.log(\"SdpSimulcast built ssrcs to add: \", ssrcsToAdd);\r\n\r\n    // First do the replacements\r\n    mLine.ssrcs.forEach(function(ssrc) {\r\n        if (ssrcsToReplace[ssrc.id]) {\r\n            ssrc.id = ssrcsToReplace[ssrc.id];\r\n        }\r\n    });\r\n    // Now the adds\r\n    ssrcsToAdd.forEach(function(ssrc) {\r\n        mLine.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: \"msid\",\r\n            value: newMsid\r\n        });\r\n        mLine.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: \"cname\",\r\n            value: newCname\r\n        });\r\n    });\r\n    mLine.ssrcGroups = mLine.ssrcGroups || [];\r\n    mLine.ssrcGroups.push({\r\n        semantics: \"SIM\",\r\n        ssrcs: this.ssrcCache.join(\" \")\r\n    });\r\n    return mLine;\r\n}\r\n\r\nSimulcast.prototype._generateSourceData = function(mLine, primarySsrc) {\r\n    var addAssociatedStream = function(mLine, ssrc) {\r\n        mLine.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: \"cname\",\r\n            value: primarySsrcCname\r\n        });\r\n        mLine.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: \"msid\",\r\n            value: primarySsrcMsid\r\n        });\r\n    }\r\n    var primarySsrcMsid = getSsrcAttribute(mLine, primarySsrc, \"msid\");\r\n    var primarySsrcCname = getSsrcAttribute(mLine, primarySsrc, \"cname\");\r\n\r\n    // Generate sim layers\r\n    var simSsrcs = [];\r\n    for (var i = 0; i < this.options.numOfLayers - 1; ++i) {\r\n        var simSsrc = generateSSRC();\r\n        addAssociatedStream(mLine, simSsrc);\r\n        simSsrcs.push(simSsrc);\r\n    }\r\n    mLine.ssrcGroups = mLine.ssrcGroups || [];\r\n    mLine.ssrcGroups.push({\r\n        semantics: \"SIM\",\r\n        ssrcs: primarySsrc + \" \" + simSsrcs.join(\" \")\r\n    });\r\n    return mLine;\r\n}\r\n\r\n\r\n\r\n// Assumptions:\r\n//  1) 'mLine' contains only a single primary video source\r\n//   (i.e. it will not already have simulcast streams inserted)\r\n//  2) 'mLine' MAY already contain an RTX stream for its video source\r\n//  3) 'mLine' is in sendrecv or sendonly state\r\n// Guarantees:\r\n//  1) return mLine will contain 2 additional simulcast layers\r\n//   generated\r\n//  2) if the base video ssrc in mLine has been seen before,\r\n//   then the same generated simulcast streams from before will\r\n//   be used again\r\n//  3) if rtx is enabled for the mLine, all generated simulcast\r\n//   streams will have rtx streams generated as well\r\n//  4) if rtx has been generated for a src before, we will generate\r\n//   the same rtx stream again\r\nSimulcast.prototype._restoreSimulcast = function(mLine) {\r\n    // First, find the primary video source in the given\r\n    // mLine and see if we've seen it before.\r\n    var primarySsrc;\r\n    var numSsrcs = mLine.ssrcs && mLine.ssrcs\r\n        .map(function(ssrcInfo) { return ssrcInfo.id; })\r\n        .filter(function(ssrc, index, array) {\r\n            return array.indexOf(ssrc) === index;\r\n        })\r\n        .length || 0;\r\n    var numGroups = (mLine.ssrcGroups && mLine.ssrcGroups.length) || 0;\r\n\r\n    if (numSsrcs === 0 || numSsrcs > 2) {\r\n        // Unsupported scenario\r\n        return mLine;\r\n    }\r\n    if (numSsrcs == 2 && numGroups === 0) {\r\n        // Unsupported scenario\r\n        return mLine;\r\n    }\r\n\r\n    if (numSsrcs === 1) {\r\n        primarySsrc = mLine.ssrcs[0].id;\r\n    } else {\r\n        // There must be an FID group, so parse\r\n        //  that and pull the primary ssrc from there\r\n        var fidGroup = mLine.ssrcGroups.filter(function(group) { return group.semantics === \"FID\"; })[0];\r\n        if (fidGroup) {\r\n            primarySsrc = parseInt(fidGroup.ssrcs.split(\" \")[0]);\r\n        } else {\r\n            // Unsupported scenario\r\n            return mLine;\r\n        }\r\n    }\r\n    console.log(\"SdpSimulcast: current ssrc cache: \", this.ssrcCache);\r\n    console.log(\"SdpSimulcast: parsed primary ssrc \" + primarySsrc);\r\n\r\n    var seenPrimarySsrc = this.ssrcCache.indexOf(primarySsrc) !== -1;\r\n\r\n    if (seenPrimarySsrc) {\r\n        console.log(\"SdpSimulcast: Have seen primary ssrc before, \" +\r\n            \"filling in data from cache\");\r\n        mLine = this._fillInSourceDataFromCache(mLine);\r\n    } else {\r\n        console.log(\"SdpSimulcast: Have not seen primary ssrc before, \" +\r\n            \"generating source data\");\r\n        mLine = this._generateSourceData(mLine, primarySsrc);\r\n    }\r\n    // Now update the cache to match whatever we've just put into this sdp\r\n    this.ssrcCache = this._parseSimLayers(mLine);\r\n    return mLine;\r\n}\r\n\r\n//endregion\r\n\r\n//region \"Public\" functions\r\n\r\n/**\r\n *\r\n * @param desc\r\n * @returns {RTCSessionDescription}\r\n */\r\nSimulcast.prototype.mungeRemoteDescription = function (desc) {\r\n\r\n    if (!validateDescription(desc)) {\r\n        return desc;\r\n    }\r\n\r\n    var session = transform.parse(desc.sdp);\r\n\r\n    var self = this;\r\n    processVideo(session, function (mLine) {\r\n\r\n        // Handle simulcast reception.\r\n        if (self.options.explodeRemoteSimulcast) {\r\n            explodeRemoteSimulcast(mLine);\r\n        } else {\r\n            implodeRemoteSimulcast(mLine);\r\n        }\r\n\r\n        // If native simulcast is enabled, we must append the x-goog-conference\r\n        // attribute to the SDP.\r\n        if (self.ssrcCache.length < 1) {\r\n            removeGoogConference(mLine);\r\n        } else {\r\n            assertGoogConference(mLine);\r\n        }\r\n    });\r\n\r\n    return new RTCSessionDescription({\r\n        type: desc.type,\r\n        sdp: transform.write(session)\r\n    });\r\n};\r\n\r\n/**\r\n *\r\n * NOTE this method should be called only if simulcast is supported by\r\n * the current browser, otherwise local SDP should not be munged.\r\n * @param desc\r\n * @returns {RTCSessionDescription}\r\n */\r\nSimulcast.prototype.mungeLocalDescription = function (desc) {\r\n\r\n    if (!validateDescription(desc)) {\r\n        return desc;\r\n    }\r\n\r\n    var session = transform.parse(desc.sdp);\r\n\r\n    var self = this;\r\n    processVideo(session, function (mLine) {\r\n        if (mLine.direction == 'recvonly' || mLine.direction == 'inactive')\r\n        {\r\n            return;\r\n        }\r\n        self._restoreSimulcast(mLine);\r\n    });\r\n\r\n    return new RTCSessionDescription({\r\n        type: desc.type,\r\n        sdp: transform.write(session)\r\n    });\r\n};\r\n\r\n//endregion\r\n\r\nmodule.exports = Simulcast;\r\n","/* Copyright @ 2015 Atlassian Pty Ltd\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * FIXME\r\n * @param sources FIXME\r\n * @param order An array of SSRCs which will be used to order the entries in\r\n * the returned array. Sources whose SSRC appears in 'order' will be added first,\r\n * in the specified order, and all other sources will be added afterwards (in\r\n * no specific order).\r\n * @returns {Array} FIXME\r\n */\r\nexports.writeSsrcs = function(sources, order) {\r\n  var ssrcs = [];\r\n\r\n  // expand sources to ssrcs\r\n  if (typeof sources !== 'undefined' &&\r\n      Object.keys(sources).length !== 0) {\r\n\r\n    if (!Array.isArray(order)) {\r\n      order = []\r\n    }\r\n\r\n    // Add the sources that appear in 'order' first.\r\n    for (var i = 0; i < order.length; i++) {\r\n      var ssrc = order[i];\r\n      var source = sources[ssrc];\r\n      Object.keys(source).forEach(function (attribute) {\r\n        ssrcs.push({\r\n          id: ssrc,\r\n          attribute: attribute,\r\n          value: source[attribute]\r\n        });\r\n      });\r\n    }\r\n\r\n    // Now add the rest of the sources.\r\n    Object.keys(sources).forEach(function (ssrc) {\r\n      ssrc = parseInt(ssrc); // Object.keys() returns string\r\n      if (order.indexOf(ssrc) >= 0) {\r\n        // Already added.\r\n        return;\r\n      }\r\n\r\n      var source = sources[ssrc];\r\n      Object.keys(source).forEach(function (attribute) {\r\n        ssrcs.push({\r\n          id: ssrc,\r\n          attribute: attribute,\r\n          value: source[attribute]\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  return ssrcs;\r\n};\r\n\r\nexports.parseSsrcs = function (mLine) {\r\n  var sources = {};\r\n  // group sources attributes by ssrc.\r\n  if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {\r\n    mLine.ssrcs.forEach(function (ssrc) {\r\n      if (!sources[ssrc.id])\r\n        sources[ssrc.id] = {};\r\n      sources[ssrc.id][ssrc.attribute] = ssrc.value;\r\n    });\r\n  }\r\n  return sources;\r\n};\r\n\r\n","/* eslint-disable max-params */\r\n\r\n/**\r\n * This object stores variables needed around the recording of an audio stream\r\n * and passing this recording along with additional information along to\r\n * different processes\r\n * @param blob the recording audio stream as a single blob\r\n * @param name the name of the person of the audio stream\r\n * @param startTime the time in UTC when recording of the audiostream started\r\n * @param wordArray the recorder audio stream transcribed as an array of Word\r\n *                  objects\r\n */\r\nconst RecordingResult = function(blob, name, startTime, wordArray) {\r\n    this.blob = blob;\r\n    this.name = name;\r\n    this.startTime = startTime;\r\n    this.wordArray = wordArray;\r\n};\r\n\r\n/* eslint-enable max-params */\r\n\r\nmodule.exports = RecordingResult;\r\n","/* global config */\r\n\r\nconst TranscriptionService = require('./AbstractTranscriptionService');\r\nconst Word = require('../word');\r\nconst audioRecorder = require('./../audioRecorder');\r\n\r\n/**\r\n * Implements a TranscriptionService for a Sphinx4 http server\r\n */\r\nconst SphinxService = function() {\r\n    // set the correct url\r\n    this.url = getURL();\r\n};\r\n\r\n/**\r\n * Subclass of AbstractTranscriptionService\r\n */\r\nSphinxService.prototype = Object.create(TranscriptionService.prototype);\r\n\r\n/**\r\n * Set the right constructor\r\n */\r\nSphinxService.constructor = SphinxService;\r\n\r\n/**\r\n * Overrides the sendRequest method from AbstractTranscriptionService\r\n * it will send the audio stream the a Sphinx4 server to get the transcription\r\n *\r\n * @param audioFileBlob the recorder audio stream an a single Blob\r\n * @param callback the callback function retrieving the server response\r\n */\r\nSphinxService.prototype.sendRequest = function(audioFileBlob, callback) {\r\n    console.log(`sending an audio file  to ${this.url}`);\r\n    console.log(`the audio file being sent: ${audioFileBlob}`);\r\n    const request = new XMLHttpRequest();\r\n\r\n    request.onreadystatechange = function() {\r\n        if (request.readyState === XMLHttpRequest.DONE\r\n            && request.status === 200) {\r\n            callback(request.responseText);\r\n        } else if (request.readyState === XMLHttpRequest.DONE) {\r\n            throw new Error(\r\n                `unable to accept response from sphinx server. status: ${\r\n                    request.status}`);\r\n        }\r\n\r\n        // if not ready no point to throw an error\r\n    };\r\n    request.open('POST', this.url);\r\n    request.setRequestHeader('Content-Type',\r\n        audioRecorder.determineCorrectFileType());\r\n    request.send(audioFileBlob);\r\n    console.log(`send ${audioFileBlob}`);\r\n};\r\n\r\n/**\r\n * Overrides the formatResponse method from AbstractTranscriptionService\r\n * It will parse the answer from the server in the expected format\r\n *\r\n * @param response the JSON body retrieved from the Sphinx4 server\r\n */\r\nSphinxService.prototype.formatResponse = function(response) {\r\n    const result = JSON.parse(response).objects;\r\n\r\n    // make sure to delete the session id object, which is always\r\n    // the first value in the JSON array\r\n\r\n    result.shift();\r\n    const array = [];\r\n\r\n    result.forEach(\r\n        word =>\r\n            word.filler\r\n                || array.push(new Word(word.word, word.start, word.end)));\r\n\r\n    return array;\r\n};\r\n\r\n/**\r\n * checks wether the reply is empty, or doesn't contain a correct JSON object\r\n * @param response the server response\r\n * @return {boolean} whether the response is valid\r\n */\r\nSphinxService.prototype.verify = function(response) {\r\n    console.log(`response from server:${response.toString()}`);\r\n\r\n    // test if server responded with a string object\r\n    if (typeof response !== 'string') {\r\n        return false;\r\n    }\r\n\r\n    // test if the string can be parsed into valid JSON\r\n    let json;\r\n\r\n    try {\r\n        json = JSON.parse(response);\r\n    } catch (error) {\r\n        console.log(error);\r\n\r\n        return false;\r\n    }\r\n\r\n    // check if the JSON has a \"objects\" value\r\n    if (json.objects === undefined) {\r\n        return false;\r\n    }\r\n\r\n    // get the \"objects\" value and check for a session ID\r\n    const array = json.objects;\r\n\r\n    if (!(array[0] && array[0]['session-id'])) {\r\n        return false;\r\n    }\r\n\r\n    // everything seems to be in order\r\n    return true;\r\n};\r\n\r\n/**\r\n * Gets the URL to the Sphinx4 server from the config file. If it's not there,\r\n * it will throw an error\r\n *\r\n * @returns {string} the URL to the sphinx4 server\r\n */\r\nfunction getURL() {\r\n    const message = 'config does not contain an url to a Sphinx4 https server';\r\n\r\n    if (config.sphinxURL === undefined) {\r\n        console.log(message);\r\n    } else {\r\n        const toReturn = config.sphinxURL;\r\n\r\n        if (toReturn.includes !== undefined && toReturn.includes('https://')) {\r\n            return toReturn;\r\n        }\r\n        console.log(message);\r\n\r\n    }\r\n}\r\n\r\nmodule.exports = SphinxService;\r\n","/**\r\n * Abstract class representing an interface to implement a speech-to-text\r\n * service on.\r\n */\r\nconst TranscriptionService = function() {\r\n    throw new Error('TranscriptionService is abstract and cannot be'\r\n        + 'created');\r\n};\r\n\r\n/**\r\n * This method can be used to send the recorder audio stream and\r\n * retrieve the answer from the transcription service from the callback\r\n *\r\n * @param {RecordingResult} recordingResult a recordingResult object which\r\n * includes the recorded audio stream as a blob\r\n * @param {Function} callback  which will retrieve the a RecordingResult with\r\n *        the answer as a WordArray\r\n */\r\nTranscriptionService.prototype.send = function send(recordingResult, callback) {\r\n    this.sendRequest(recordingResult.blob, response => {\r\n        if (this.verify(response)) {\r\n            recordingResult.wordArray = this.formatResponse(response);\r\n        } else {\r\n            console.log('the retrieved response from the server is not valid!');\r\n            recordingResult.wordArray = [];\r\n        }\r\n        callback(recordingResult);\r\n    });\r\n};\r\n\r\n/**\r\n * Abstract method which will rend the recorder audio stream to the implemented\r\n * transcription service and will retrieve an answer, which will be\r\n * called on the given callback method\r\n *\r\n * @param {Blob} audioBlob the recorded audio stream as a single Blob\r\n * @param {function} callback function which will retrieve the answer\r\n *                            from the service\r\n */\r\n// eslint-disable-next-line no-unused-vars\r\nTranscriptionService.prototype.sendRequest = function(audioBlob, callback) {\r\n    throw new Error('TranscriptionService.sendRequest is abstract');\r\n};\r\n\r\n/**\r\n * Abstract method which will parse the output from the implemented\r\n * transcription service to the expected format\r\n *\r\n * The transcriber class expect an array of word objects, where each word\r\n * object is one transcribed word by the service.\r\n *\r\n * The expected output of this method is an array of word objects, in\r\n * the correct order. That is, the first object in the array is the first word\r\n * being said, and the last word in the array is the last word being said\r\n *\r\n * @param response the answer from the speech-to-text server which needs to be\r\n *                 formatted\r\n * @return {Array<Word>} an array of Word objects\r\n */\r\n// eslint-disable-next-line no-unused-vars\r\nTranscriptionService.prototype.formatResponse = function(response) {\r\n    throw new Error('TranscriptionService.format is abstract');\r\n};\r\n\r\n/**\r\n * Abstract method which will verify that the response from the server is valid\r\n *\r\n * @param response the response from the server\r\n * @return {boolean} true if response is valid, false otherwise\r\n */\r\n// eslint-disable-next-line no-unused-vars\r\nTranscriptionService.prototype.verify = function(response) {\r\n    throw new Error('TranscriptionService.verify is abstract');\r\n};\r\n\r\nmodule.exports = TranscriptionService;\r\n","/**\r\n * An object representing a transcribed word, with some additional information\r\n * @param word the word\r\n * @param begin the time the word was started being uttered\r\n * @param end the time the word stopped being uttered\r\n */\r\nconst Word = function(word, begin, end) {\r\n    this.word = word;\r\n    this.begin = begin;\r\n    this.end = end;\r\n};\r\n\r\n/**\r\n * Get the string representation of the word\r\n * @returns {*} the word as a string\r\n */\r\nWord.prototype.getWord = function() {\r\n    return this.word;\r\n};\r\n\r\n/**\r\n * Get the time the word started being uttered\r\n * @returns {*} the start time as an integer\r\n */\r\nWord.prototype.getBeginTime = function() {\r\n    return this.begin;\r\n};\r\n\r\n/**\r\n * Get the time the word stopped being uttered\r\n * @returns {*} the end time as an integer\r\n */\r\nWord.prototype.getEndTime = function() {\r\n    return this.end;\r\n};\r\n\r\nmodule.exports = Word;\r\n"],"sourceRoot":""}